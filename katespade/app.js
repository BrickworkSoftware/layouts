(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

// rawAsap provides everything we need except exception management.
var rawAsap = require("./raw");
// RawTasks are recycled to reduce GC churn.
var freeTasks = [];
// We queue errors to ensure they are thrown in right order (FIFO).
// Array-as-queue is good enough here, since we are just dealing with exceptions.
var pendingErrors = [];
var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);

function throwFirstError() {
    if (pendingErrors.length) {
        throw pendingErrors.shift();
    }
}

/**
 * Calls a task as soon as possible after returning, in its own event, with priority
 * over other events like animation, reflow, and repaint. An error thrown from an
 * event will not interrupt, nor even substantially slow down the processing of
 * other events, but will be rather postponed to a lower priority event.
 * @param {{call}} task A callable object, typically a function that takes no
 * arguments.
 */
module.exports = asap;
function asap(task) {
    var rawTask;
    if (freeTasks.length) {
        rawTask = freeTasks.pop();
    } else {
        rawTask = new RawTask();
    }
    rawTask.task = task;
    rawAsap(rawTask);
}

// We wrap tasks with recyclable task objects.  A task object implements
// `call`, just like a function.
function RawTask() {
    this.task = null;
}

// The sole purpose of wrapping the task is to catch the exception and recycle
// the task object after its single use.
RawTask.prototype.call = function () {
    try {
        this.task.call();
    } catch (error) {
        if (asap.onerror) {
            // This hook exists purely for testing purposes.
            // Its name will be periodically randomized to break any code that
            // depends on its existence.
            asap.onerror(error);
        } else {
            // In a web browser, exceptions are not fatal. However, to avoid
            // slowing down the queue of pending tasks, we rethrow the error in a
            // lower priority turn.
            pendingErrors.push(error);
            requestErrorThrow();
        }
    } finally {
        this.task = null;
        freeTasks[freeTasks.length] = this;
    }
};

},{"./raw":2}],2:[function(require,module,exports){
(function (global){
"use strict";

// Use the fastest means possible to execute a task in its own turn, with
// priority over other events including IO, animation, reflow, and redraw
// events in browsers.
//
// An exception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// exception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no exceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an exception is thrown.
module.exports = rawAsap;
function rawAsap(task) {
    if (!queue.length) {
        requestFlush();
        flushing = true;
    }
    // Equivalent to push, but avoids a function call.
    queue[queue.length] = task;
}

var queue = [];
// Once a flush has been requested, no further calls to `requestFlush` are
// necessary until the next `flush` completes.
var flushing = false;
// `requestFlush` is an implementation-specific method that attempts to kick
// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
// the event queue before yielding to the browser's own event loop.
var requestFlush;
// The position of the next task to execute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an exception.
var index = 0;
// If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory exhaustion, the task queue will periodically
// truncate already-completed tasks.
var capacity = 1024;

// The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an exception.
// If a task throws an exception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// exception is thrown.
function flush() {
    while (index < queue.length) {
        var currentIndex = index;
        // Advance the index before calling the task. This ensures that we will
        // begin flushing on the next task the task throws an error.
        index = index + 1;
        queue[currentIndex].call();
        // Prevent leaking memory for long chains of recursive calls to `asap`.
        // If we call `asap` within tasks scheduled by `asap`, the queue will
        // grow, but to avoid an O(n) walk for every task we execute, we don't
        // shift tasks off the queue after they have been executed.
        // Instead, we periodically shift 1024 tasks off the queue.
        if (index > capacity) {
            // Manually shift all values starting at the index back to the
            // beginning of the queue.
            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                queue[scan] = queue[scan + index];
            }
            queue.length -= index;
            index = 0;
        }
    }
    queue.length = 0;
    index = 0;
    flushing = false;
}

// `requestFlush` is implemented using a strategy based on data collected from
// every available SauceLabs Selenium web driver worker at time of writing.
// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593

// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
// have WebKitMutationObserver but not un-prefixed MutationObserver.
// Must use `global` or `self` instead of `window` to work in both frames and web
// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.

/* globals self */
var scope = typeof global !== "undefined" ? global : self;
var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;

// MutationObservers are desirable because they have high priority and work
// reliably everywhere they are implemented.
// They are implemented in all modern browsers.
//
// - Android 4-4.3
// - Chrome 26-34
// - Firefox 14-29
// - Internet Explorer 11
// - iPad Safari 6-7.1
// - iPhone Safari 7-7.1
// - Safari 6-7
if (typeof BrowserMutationObserver === "function") {
    requestFlush = makeRequestCallFromMutationObserver(flush);

// MessageChannels are desirable because they give direct access to the HTML
// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
// 11-12, and in web workers in many engines.
// Although message channels yield to any queued rendering and IO tasks, they
// would be better than imposing the 4ms delay of timers.
// However, they do not work reliably in Internet Explorer or Safari.

// Internet Explorer 10 is the only browser that has setImmediate but does
// not have MutationObservers.
// Although setImmediate yields to the browser's renderer, it would be
// preferrable to falling back to setTimeout since it does not have
// the minimum 4ms penalty.
// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
// Desktop to a lesser extent) that renders both setImmediate and
// MessageChannel useless for the purposes of ASAP.
// https://github.com/kriskowal/q/issues/396

// Timers are implemented universally.
// We fall back to timers in workers in most engines, and in foreground
// contexts in the following browsers.
// However, note that even this simple case requires nuances to operate in a
// broad spectrum of browsers.
//
// - Firefox 3-13
// - Internet Explorer 6-9
// - iPad Safari 4.3
// - Lynx 2.8.7
} else {
    requestFlush = makeRequestCallFromTimer(flush);
}

// `requestFlush` requests that the high priority event queue be flushed as
// soon as possible.
// This is useful to prevent an error thrown in a task from stalling the event
// queue if the exception handled by Node.jsâ€™s
// `process.on("uncaughtException")` or by a domain.
rawAsap.requestFlush = requestFlush;

// To request a high priority event, we induce a mutation observer by toggling
// the text of a text node between "1" and "-1".
function makeRequestCallFromMutationObserver(callback) {
    var toggle = 1;
    var observer = new BrowserMutationObserver(callback);
    var node = document.createTextNode("");
    observer.observe(node, {characterData: true});
    return function requestCall() {
        toggle = -toggle;
        node.data = toggle;
    };
}

// The message channel technique was discovered by Malte Ubl and was the
// original foundation for this library.
// http://www.nonblocking.io/2011/06/windownexttick.html

// Safari 6.0.5 (at least) intermittently fails to create message ports on a
// page's first load. Thankfully, this version of Safari supports
// MutationObservers, so we don't need to fall back in that case.

// function makeRequestCallFromMessageChannel(callback) {
//     var channel = new MessageChannel();
//     channel.port1.onmessage = callback;
//     return function requestCall() {
//         channel.port2.postMessage(0);
//     };
// }

// For reasons explained above, we are also unable to use `setImmediate`
// under any circumstances.
// Even if we were, there is another bug in Internet Explorer 10.
// It is not sufficient to assign `setImmediate` to `requestFlush` because
// `setImmediate` must be called *by name* and therefore must be wrapped in a
// closure.
// Never forget.

// function makeRequestCallFromSetImmediate(callback) {
//     return function requestCall() {
//         setImmediate(callback);
//     };
// }

// Safari 6.0 has a problem where timers will get lost while the user is
// scrolling. This problem does not impact ASAP because Safari 6.0 supports
// mutation observers, so that implementation is used instead.
// However, if we ever elect to use timers in Safari, the prevalent work-around
// is to add a scroll event listener that calls for a flush.

// `setTimeout` does not call the passed callback if the delay is less than
// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
// even then.

function makeRequestCallFromTimer(callback) {
    return function requestCall() {
        // We dispatch a timeout with a specified delay of 0 for engines that
        // can reliably accommodate that request. This will usually be snapped
        // to a 4 milisecond delay, but once we're flushing, there's no delay
        // between events.
        var timeoutHandle = setTimeout(handleTimer, 0);
        // However, since this timer gets frequently dropped in Firefox
        // workers, we enlist an interval handle that will try to fire
        // an event 20 times per second until it succeeds.
        var intervalHandle = setInterval(handleTimer, 50);

        function handleTimer() {
            // Whichever timer succeeds will cancel both timers and
            // execute the callback.
            clearTimeout(timeoutHandle);
            clearInterval(intervalHandle);
            callback();
        }
    };
}

// This is for `asap.js` only.
// Its name will be periodically randomized to break any code that depends on
// its existence.
rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;

// ASAP was originally a nextTick shim included in Q. This was factored out
// into this ASAP package. It was later adapted to RSVP which made further
// amendments. These decisions, particularly to marginalize MessageChannel and
// to capture the MutationObserver implementation in a closure, were integrated
// back into ASAP proper.
// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],3:[function(require,module,exports){
/**
 * EvEmitter v1.1.0
 * Lil' event emitter
 * MIT License
 */

/* jshint unused: true, undef: true, strict: true */

( function( global, factory ) {
  // universal module definition
  /* jshint strict: false */ /* globals define, module, window */
  if ( typeof define == 'function' && define.amd ) {
    // AMD - RequireJS
    define( factory );
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS - Browserify, Webpack
    module.exports = factory();
  } else {
    // Browser globals
    global.EvEmitter = factory();
  }

}( typeof window != 'undefined' ? window : this, function() {

"use strict";

function EvEmitter() {}

var proto = EvEmitter.prototype;

proto.on = function( eventName, listener ) {
  if ( !eventName || !listener ) {
    return;
  }
  // set events hash
  var events = this._events = this._events || {};
  // set listeners array
  var listeners = events[ eventName ] = events[ eventName ] || [];
  // only add once
  if ( listeners.indexOf( listener ) == -1 ) {
    listeners.push( listener );
  }

  return this;
};

proto.once = function( eventName, listener ) {
  if ( !eventName || !listener ) {
    return;
  }
  // add event
  this.on( eventName, listener );
  // set once flag
  // set onceEvents hash
  var onceEvents = this._onceEvents = this._onceEvents || {};
  // set onceListeners object
  var onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};
  // set flag
  onceListeners[ listener ] = true;

  return this;
};

proto.off = function( eventName, listener ) {
  var listeners = this._events && this._events[ eventName ];
  if ( !listeners || !listeners.length ) {
    return;
  }
  var index = listeners.indexOf( listener );
  if ( index != -1 ) {
    listeners.splice( index, 1 );
  }

  return this;
};

proto.emitEvent = function( eventName, args ) {
  var listeners = this._events && this._events[ eventName ];
  if ( !listeners || !listeners.length ) {
    return;
  }
  // copy over to avoid interference if .off() in listener
  listeners = listeners.slice(0);
  args = args || [];
  // once stuff
  var onceListeners = this._onceEvents && this._onceEvents[ eventName ];

  for ( var i=0; i < listeners.length; i++ ) {
    var listener = listeners[i]
    var isOnce = onceListeners && onceListeners[ listener ];
    if ( isOnce ) {
      // remove listener
      // remove before trigger to prevent recursion
      this.off( eventName, listener );
      // unset once flag
      delete onceListeners[ listener ];
    }
    // trigger listener
    listener.apply( this, args );
  }

  return this;
};

proto.allOff = function() {
  delete this._events;
  delete this._onceEvents;
};

return EvEmitter;

}));

},{}],4:[function(require,module,exports){
/*!
 * imagesLoaded v4.1.3
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */

( function( window, factory ) { 'use strict';
  // universal module definition

  /*global define: false, module: false, require: false */

  if ( typeof define == 'function' && define.amd ) {
    // AMD
    define( [
      'ev-emitter/ev-emitter'
    ], function( EvEmitter ) {
      return factory( window, EvEmitter );
    });
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory(
      window,
      require('ev-emitter')
    );
  } else {
    // browser global
    window.imagesLoaded = factory(
      window,
      window.EvEmitter
    );
  }

})( typeof window !== 'undefined' ? window : this,

// --------------------------  factory -------------------------- //

function factory( window, EvEmitter ) {

'use strict';

var $ = window.jQuery;
var console = window.console;

// -------------------------- helpers -------------------------- //

// extend objects
function extend( a, b ) {
  for ( var prop in b ) {
    a[ prop ] = b[ prop ];
  }
  return a;
}

// turn element or nodeList into an array
function makeArray( obj ) {
  var ary = [];
  if ( Array.isArray( obj ) ) {
    // use object if already an array
    ary = obj;
  } else if ( typeof obj.length == 'number' ) {
    // convert nodeList to array
    for ( var i=0; i < obj.length; i++ ) {
      ary.push( obj[i] );
    }
  } else {
    // array of single index
    ary.push( obj );
  }
  return ary;
}

// -------------------------- imagesLoaded -------------------------- //

/**
 * @param {Array, Element, NodeList, String} elem
 * @param {Object or Function} options - if function, use as callback
 * @param {Function} onAlways - callback function
 */
function ImagesLoaded( elem, options, onAlways ) {
  // coerce ImagesLoaded() without new, to be new ImagesLoaded()
  if ( !( this instanceof ImagesLoaded ) ) {
    return new ImagesLoaded( elem, options, onAlways );
  }
  // use elem as selector string
  if ( typeof elem == 'string' ) {
    elem = document.querySelectorAll( elem );
  }

  this.elements = makeArray( elem );
  this.options = extend( {}, this.options );

  if ( typeof options == 'function' ) {
    onAlways = options;
  } else {
    extend( this.options, options );
  }

  if ( onAlways ) {
    this.on( 'always', onAlways );
  }

  this.getImages();

  if ( $ ) {
    // add jQuery Deferred object
    this.jqDeferred = new $.Deferred();
  }

  // HACK check async to allow time to bind listeners
  setTimeout( function() {
    this.check();
  }.bind( this ));
}

ImagesLoaded.prototype = Object.create( EvEmitter.prototype );

ImagesLoaded.prototype.options = {};

ImagesLoaded.prototype.getImages = function() {
  this.images = [];

  // filter & find items if we have an item selector
  this.elements.forEach( this.addElementImages, this );
};

/**
 * @param {Node} element
 */
ImagesLoaded.prototype.addElementImages = function( elem ) {
  // filter siblings
  if ( elem.nodeName == 'IMG' ) {
    this.addImage( elem );
  }
  // get background image on element
  if ( this.options.background === true ) {
    this.addElementBackgroundImages( elem );
  }

  // find children
  // no non-element nodes, #143
  var nodeType = elem.nodeType;
  if ( !nodeType || !elementNodeTypes[ nodeType ] ) {
    return;
  }
  var childImgs = elem.querySelectorAll('img');
  // concat childElems to filterFound array
  for ( var i=0; i < childImgs.length; i++ ) {
    var img = childImgs[i];
    this.addImage( img );
  }

  // get child background images
  if ( typeof this.options.background == 'string' ) {
    var children = elem.querySelectorAll( this.options.background );
    for ( i=0; i < children.length; i++ ) {
      var child = children[i];
      this.addElementBackgroundImages( child );
    }
  }
};

var elementNodeTypes = {
  1: true,
  9: true,
  11: true
};

ImagesLoaded.prototype.addElementBackgroundImages = function( elem ) {
  var style = getComputedStyle( elem );
  if ( !style ) {
    // Firefox returns null if in a hidden iframe https://bugzil.la/548397
    return;
  }
  // get url inside url("...")
  var reURL = /url\((['"])?(.*?)\1\)/gi;
  var matches = reURL.exec( style.backgroundImage );
  while ( matches !== null ) {
    var url = matches && matches[2];
    if ( url ) {
      this.addBackground( url, elem );
    }
    matches = reURL.exec( style.backgroundImage );
  }
};

/**
 * @param {Image} img
 */
ImagesLoaded.prototype.addImage = function( img ) {
  var loadingImage = new LoadingImage( img );
  this.images.push( loadingImage );
};

ImagesLoaded.prototype.addBackground = function( url, elem ) {
  var background = new Background( url, elem );
  this.images.push( background );
};

ImagesLoaded.prototype.check = function() {
  var _this = this;
  this.progressedCount = 0;
  this.hasAnyBroken = false;
  // complete if no images
  if ( !this.images.length ) {
    this.complete();
    return;
  }

  function onProgress( image, elem, message ) {
    // HACK - Chrome triggers event before object properties have changed. #83
    setTimeout( function() {
      _this.progress( image, elem, message );
    });
  }

  this.images.forEach( function( loadingImage ) {
    loadingImage.once( 'progress', onProgress );
    loadingImage.check();
  });
};

ImagesLoaded.prototype.progress = function( image, elem, message ) {
  this.progressedCount++;
  this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;
  // progress event
  this.emitEvent( 'progress', [ this, image, elem ] );
  if ( this.jqDeferred && this.jqDeferred.notify ) {
    this.jqDeferred.notify( this, image );
  }
  // check if completed
  if ( this.progressedCount == this.images.length ) {
    this.complete();
  }

  if ( this.options.debug && console ) {
    console.log( 'progress: ' + message, image, elem );
  }
};

ImagesLoaded.prototype.complete = function() {
  var eventName = this.hasAnyBroken ? 'fail' : 'done';
  this.isComplete = true;
  this.emitEvent( eventName, [ this ] );
  this.emitEvent( 'always', [ this ] );
  if ( this.jqDeferred ) {
    var jqMethod = this.hasAnyBroken ? 'reject' : 'resolve';
    this.jqDeferred[ jqMethod ]( this );
  }
};

// --------------------------  -------------------------- //

function LoadingImage( img ) {
  this.img = img;
}

LoadingImage.prototype = Object.create( EvEmitter.prototype );

LoadingImage.prototype.check = function() {
  // If complete is true and browser supports natural sizes,
  // try to check for image status manually.
  var isComplete = this.getIsImageComplete();
  if ( isComplete ) {
    // report based on naturalWidth
    this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );
    return;
  }

  // If none of the checks above matched, simulate loading on detached element.
  this.proxyImage = new Image();
  this.proxyImage.addEventListener( 'load', this );
  this.proxyImage.addEventListener( 'error', this );
  // bind to image as well for Firefox. #191
  this.img.addEventListener( 'load', this );
  this.img.addEventListener( 'error', this );
  this.proxyImage.src = this.img.src;
};

LoadingImage.prototype.getIsImageComplete = function() {
  return this.img.complete && this.img.naturalWidth !== undefined;
};

LoadingImage.prototype.confirm = function( isLoaded, message ) {
  this.isLoaded = isLoaded;
  this.emitEvent( 'progress', [ this, this.img, message ] );
};

// ----- events ----- //

// trigger specified handler for event type
LoadingImage.prototype.handleEvent = function( event ) {
  var method = 'on' + event.type;
  if ( this[ method ] ) {
    this[ method ]( event );
  }
};

LoadingImage.prototype.onload = function() {
  this.confirm( true, 'onload' );
  this.unbindEvents();
};

LoadingImage.prototype.onerror = function() {
  this.confirm( false, 'onerror' );
  this.unbindEvents();
};

LoadingImage.prototype.unbindEvents = function() {
  this.proxyImage.removeEventListener( 'load', this );
  this.proxyImage.removeEventListener( 'error', this );
  this.img.removeEventListener( 'load', this );
  this.img.removeEventListener( 'error', this );
};

// -------------------------- Background -------------------------- //

function Background( url, element ) {
  this.url = url;
  this.element = element;
  this.img = new Image();
}

// inherit LoadingImage prototype
Background.prototype = Object.create( LoadingImage.prototype );

Background.prototype.check = function() {
  this.img.addEventListener( 'load', this );
  this.img.addEventListener( 'error', this );
  this.img.src = this.url;
  // check if image is already complete
  var isComplete = this.getIsImageComplete();
  if ( isComplete ) {
    this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );
    this.unbindEvents();
  }
};

Background.prototype.unbindEvents = function() {
  this.img.removeEventListener( 'load', this );
  this.img.removeEventListener( 'error', this );
};

Background.prototype.confirm = function( isLoaded, message ) {
  this.isLoaded = isLoaded;
  this.emitEvent( 'progress', [ this, this.element, message ] );
};

// -------------------------- jQuery -------------------------- //

ImagesLoaded.makeJQueryPlugin = function( jQuery ) {
  jQuery = jQuery || window.jQuery;
  if ( !jQuery ) {
    return;
  }
  // set local variable
  $ = jQuery;
  // $().imagesLoaded()
  $.fn.imagesLoaded = function( options, callback ) {
    var instance = new ImagesLoaded( this, options, callback );
    return instance.jqDeferred.promise( $(this) );
  };
};
// try making plugin
ImagesLoaded.makeJQueryPlugin();

// --------------------------  -------------------------- //

return ImagesLoaded;

});

},{"ev-emitter":3}],5:[function(require,module,exports){
(function (global){
/**
 * @license
 * lodash 3.10.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern -d -o ./index.js`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '3.10.1';

  /** Used to compose bitmasks for wrapper metadata. */
  var BIND_FLAG = 1,
      BIND_KEY_FLAG = 2,
      CURRY_BOUND_FLAG = 4,
      CURRY_FLAG = 8,
      CURRY_RIGHT_FLAG = 16,
      PARTIAL_FLAG = 32,
      PARTIAL_RIGHT_FLAG = 64,
      ARY_FLAG = 128,
      REARG_FLAG = 256;

  /** Used as default options for `_.trunc`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect when a function becomes hot. */
  var HOT_COUNT = 150,
      HOT_SPAN = 16;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2;

  /** Used as the `TypeError` message for "Functions" methods. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
      reUnescapedHtml = /[&<>"'`]/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

  /**
   * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)
   * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).
   */
  var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
      reHasRegExpChars = RegExp(reRegExpChars.source);

  /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */
  var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect hexadecimal string values. */
  var reHasHexPrefix = /^0[xX]/;

  /** Used to detect host constructors (Safari > 5). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^\d+$/;

  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to match words to create compound words. */
  var reWords = (function() {
    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
  }());

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',
    'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
  cloneableTags[dateTag] = cloneableTags[float32Tag] =
  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[stringTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[mapTag] = cloneableTags[setTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map latin-1 supplementary letters to basic latin letters. */
  var deburredLetters = {
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '`': '&#96;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'",
    '&#96;': '`'
  };

  /** Used to determine if values are of the language type `Object`. */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used to escape characters for inclusion in compiled regexes. */
  var regexpEscapes = {
    '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',
    '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',
    'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',
    'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',
    'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Detect free variable `exports`. */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;

  /** Detect free variable `self`. */
  var freeSelf = objectTypes[typeof self] && self && self.Object && self;

  /** Detect free variable `window`. */
  var freeWindow = objectTypes[typeof window] && window && window.Object && window;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /**
   * Used as a reference to the global object.
   *
   * The `this` value is used if it's the global object to avoid Greasemonkey's
   * restricted `window` object, otherwise the `window` object is used.
   */
  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `compareAscending` which compares values and
   * sorts them in ascending order without guaranteeing a stable sort.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {number} Returns the sort order indicator for `value`.
   */
  function baseCompareAscending(value, other) {
    if (value !== other) {
      var valIsNull = value === null,
          valIsUndef = value === undefined,
          valIsReflexive = value === value;

      var othIsNull = other === null,
          othIsUndef = other === undefined,
          othIsReflexive = other === other;

      if ((value > other && !othIsNull) || !valIsReflexive ||
          (valIsNull && !othIsUndef && othIsReflexive) ||
          (valIsUndef && othIsReflexive)) {
        return 1;
      }
      if ((value < other && !valIsNull) || !othIsReflexive ||
          (othIsNull && !valIsUndef && valIsReflexive) ||
          (othIsUndef && valIsReflexive)) {
        return -1;
      }
    }
    return 0;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {Function} predicate The function invoked per iteration.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromRight) {
    var length = array.length,
        index = fromRight ? length : -1;

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without support for binary searches.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return indexOfNaN(array, fromIndex);
    }
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isFunction` without support for environments
   * with incorrect `typeof` results.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   */
  function baseIsFunction(value) {
    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
    return typeof value == 'function' || false;
  }

  /**
   * Converts `value` to a string if it's not one. An empty string is returned
   * for `null` or `undefined` values.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    return value == null ? '' : (value + '');
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the first character not found in `chars`.
   */
  function charsLeftIndex(string, chars) {
    var index = -1,
        length = string.length;

    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the last character not found in `chars`.
   */
  function charsRightIndex(string, chars) {
    var index = string.length;

    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.sortBy` to compare transformed elements of a collection and stable
   * sort them in ascending order.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareAscending(object, other) {
    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
  }

  /**
   * Used by `_.sortByOrder` to compare multiple properties of a value to another
   * and stable sort them.
   *
   * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,
   * a value is sorted in ascending order if its corresponding order is "asc", and
   * descending if "desc".
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {boolean[]} orders The order to sort by for each property.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareMultiple(object, other, orders) {
    var index = -1,
        objCriteria = object.criteria,
        othCriteria = other.criteria,
        length = objCriteria.length,
        ordersLength = orders.length;

    while (++index < length) {
      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
      if (result) {
        if (index >= ordersLength) {
          return result;
        }
        var order = orders[index];
        return result * ((order === 'asc' || order === true) ? 1 : -1);
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to provide the same value for
    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    // for more details.
    //
    // This also ensures a stable sort in V8 and other engines.
    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
    return object.index - other.index;
  }

  /**
   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  function deburrLetter(letter) {
    return deburredLetters[letter];
  }

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeHtmlChar(chr) {
    return htmlEscapes[chr];
  }

  /**
   * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @param {string} leadingChar The capture group for a leading character.
   * @param {string} whitespaceChar The capture group for a whitespace character.
   * @returns {string} Returns the escaped character.
   */
  function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
    if (leadingChar) {
      chr = regexpEscapes[chr];
    } else if (whitespaceChar) {
      chr = stringEscapes[chr];
    }
    return '\\' + chr;
  }

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the index at which the first occurrence of `NaN` is found in `array`.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
   */
  function indexOfNaN(array, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 0 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      var other = array[index];
      if (other !== other) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Checks if `value` is object-like.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   */
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  /**
   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
   * character code is whitespace.
   *
   * @private
   * @param {number} charCode The character code to inspect.
   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
   */
  function isSpace(charCode) {
    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      if (array[index] === placeholder) {
        array[index] = PLACEHOLDER;
        result[++resIndex] = index;
      }
    }
    return result;
  }

  /**
   * An implementation of `_.uniq` optimized for sorted arrays without support
   * for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee] The function invoked per iteration.
   * @returns {Array} Returns the new duplicate-value-free array.
   */
  function sortedUniq(array, iteratee) {
    var seen,
        index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value, index, array) : value;

      if (!index || seen !== computed) {
        seen = computed;
        result[++resIndex] = value;
      }
    }
    return result;
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the first non-whitespace character.
   */
  function trimmedLeftIndex(string) {
    var index = -1,
        length = string.length;

    while (++index < length && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedRightIndex(string) {
    var index = string.length;

    while (index-- && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  function unescapeHtmlChar(chr) {
    return htmlUnescapes[chr];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the given `context` object.
   *
   * @static
   * @memberOf _
   * @category Utility
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // using `context` to mock `Date#getTime` use in `_.now`
   * var mock = _.runInContext({
   *   'Date': function() {
   *     return { 'getTime': getTimeMock };
   *   }
   * });
   *
   * // or creating a suped-up `defer` in Node.js
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See https://es5.github.io/#x11.1.5 for more details.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for native method references. */
    var arrayProto = Array.prototype,
        objectProto = Object.prototype,
        stringProto = String.prototype;

    /** Used to resolve the decompiled source of functions. */
    var fnToString = Function.prototype.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objToString = objectProto.toString;

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Native method references. */
    var ArrayBuffer = context.ArrayBuffer,
        clearTimeout = context.clearTimeout,
        parseFloat = context.parseFloat,
        pow = Math.pow,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        Set = getNative(context, 'Set'),
        setTimeout = context.setTimeout,
        splice = arrayProto.splice,
        Uint8Array = context.Uint8Array,
        WeakMap = getNative(context, 'WeakMap');

    /* Native method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeCreate = getNative(Object, 'create'),
        nativeFloor = Math.floor,
        nativeIsArray = getNative(Array, 'isArray'),
        nativeIsFinite = context.isFinite,
        nativeKeys = getNative(Object, 'keys'),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = getNative(Date, 'now'),
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used as references for `-Infinity` and `Infinity`. */
    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH = 4294967295,
        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

    /**
     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
     * of an array-like value.
     */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
     * Methods that operate on and return arrays, collections, and functions can
     * be chained together. Methods that retrieve a single value or may return a
     * primitive value will automatically end the chain returning the unwrapped
     * value. Explicit chaining may be enabled using `_.chain`. The execution of
     * chained methods is lazy, that is, execution is deferred until `_#value`
     * is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
     * fusion is an optimization strategy which merge iteratee calls; this can help
     * to avoid the creation of intermediate data structures and greatly reduce the
     * number of iteratee executions.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
     * `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
     * and `where`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
     * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
     * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
     * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
     * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
     * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
     * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
     * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
     * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
     * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
     * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
     * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
     * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
     * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
     * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
     * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
     * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
     * `unescape`, `uniqueId`, `value`, and `words`
     *
     * The wrapper method `sample` will return a wrapped value when `n` is provided,
     * otherwise an unwrapped value is returned.
     *
     * @name _
     * @constructor
     * @category Chain
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(total, n) {
     *   return total + n;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(n) {
     *   return n * n;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The function whose prototype all chaining wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
     */
    function LodashWrapper(value, chainAll, actions) {
      this.__wrapped__ = value;
      this.__actions__ = actions || [];
      this.__chain__ = !!chainAll;
    }

    /**
     * An object environment feature flags.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB). Change the following template settings to use
     * alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = POSITIVE_INFINITY;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = arrayCopy(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = arrayCopy(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = arrayCopy(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
        return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a cache object to store key/value pairs.
     *
     * @private
     * @static
     * @name Cache
     * @memberOf _.memoize
     */
    function MapCache() {
      this.__data__ = {};
    }

    /**
     * Removes `key` and its value from the cache.
     *
     * @private
     * @name delete
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
     */
    function mapDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }

    /**
     * Gets the cached value for `key`.
     *
     * @private
     * @name get
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the cached value.
     */
    function mapGet(key) {
      return key == '__proto__' ? undefined : this.__data__[key];
    }

    /**
     * Checks if a cached value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapHas(key) {
      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
    }

    /**
     * Sets `value` to `key` of the cache.
     *
     * @private
     * @name set
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to cache.
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache object.
     */
    function mapSet(key, value) {
      if (key != '__proto__') {
        this.__data__[key] = value;
      }
      return this;
    }

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates a cache object to store unique values.
     *
     * @private
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var length = values ? values.length : 0;

      this.data = { 'hash': nativeCreate(null), 'set': new Set };
      while (length--) {
        this.push(values[length]);
      }
    }

    /**
     * Checks if `value` is in `cache` mimicking the return signature of
     * `_.indexOf` by returning `0` if the value is found, else `-1`.
     *
     * @private
     * @param {Object} cache The cache to search.
     * @param {*} value The value to search for.
     * @returns {number} Returns `0` if `value` is found, else `-1`.
     */
    function cacheIndexOf(cache, value) {
      var data = cache.data,
          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

      return result ? 0 : -1;
    }

    /**
     * Adds `value` to the cache.
     *
     * @private
     * @name push
     * @memberOf SetCache
     * @param {*} value The value to cache.
     */
    function cachePush(value) {
      var data = this.data;
      if (typeof value == 'string' || isObject(value)) {
        data.set.add(value);
      } else {
        data.hash[value] = true;
      }
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a new array joining `array` with `other`.
     *
     * @private
     * @param {Array} array The array to join.
     * @param {Array} other The other array to join.
     * @returns {Array} Returns the new concatenated array.
     */
    function arrayConcat(array, other) {
      var index = -1,
          length = array.length,
          othIndex = -1,
          othLength = other.length,
          result = Array(length + othLength);

      while (++index < length) {
        result[index] = array[index];
      }
      while (++othIndex < othLength) {
        result[index++] = other[othIndex];
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function arrayCopy(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.forEach` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.forEachRight` for arrays without support for
     * callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEachRight(array, iteratee) {
      var length = array.length;

      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.every` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     */
    function arrayEvery(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `baseExtremum` for arrays which invokes `iteratee`
     * with one argument: (value).
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {*} Returns the extremum value.
     */
    function arrayExtremum(array, iteratee, comparator, exValue) {
      var index = -1,
          length = array.length,
          computed = exValue,
          result = computed;

      while (++index < length) {
        var value = array[index],
            current = +iteratee(value);

        if (comparator(current, computed)) {
          computed = current;
          result = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.filter` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.map` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.reduce` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the first element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initFromArray) {
      var index = -1,
          length = array.length;

      if (initFromArray && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.reduceRight` for arrays without support for
     * callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the last element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
      var length = array.length;
      if (initFromArray && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.some` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    /**
     * A specialized version of `_.sum` for arrays without support for callback
     * shorthands and `this` binding..
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */
    function arraySum(array, iteratee) {
      var length = array.length,
          result = 0;

      while (length--) {
        result += +iteratee(array[length]) || 0;
      }
      return result;
    }

    /**
     * Used by `_.defaults` to customize its `_.assign` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignDefaults(objectValue, sourceValue) {
      return objectValue === undefined ? sourceValue : objectValue;
    }

    /**
     * Used by `_.template` to customize its `_.assign` use.
     *
     * **Note:** This function is like `assignDefaults` except that it ignores
     * inherited property values when checking if a property is `undefined`.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @param {string} key The key associated with the object and source values.
     * @param {Object} object The destination object.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignOwnDefaults(objectValue, sourceValue, key, object) {
      return (objectValue === undefined || !hasOwnProperty.call(object, key))
        ? sourceValue
        : objectValue;
    }

    /**
     * A specialized version of `_.assign` for customizing assigned values without
     * support for argument juggling, multiple sources, and `this` binding `customizer`
     * functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     */
    function assignWith(object, source, customizer) {
      var index = -1,
          props = keys(source),
          length = props.length;

      while (++index < length) {
        var key = props[index],
            value = object[key],
            result = customizer(value, source[key], key, object, source);

        if ((result === result ? (result !== value) : (value === value)) ||
            (value === undefined && !(key in object))) {
          object[key] = result;
        }
      }
      return object;
    }

    /**
     * The base implementation of `_.assign` without support for argument juggling,
     * multiple sources, and `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return source == null
        ? object
        : baseCopy(source, keys(source), object);
    }

    /**
     * The base implementation of `_.at` without support for string collections
     * and individual key arguments.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {number[]|string[]} props The property names or indexes of elements to pick.
     * @returns {Array} Returns the new array of picked elements.
     */
    function baseAt(collection, props) {
      var index = -1,
          isNil = collection == null,
          isArr = !isNil && isArrayLike(collection),
          length = isArr ? collection.length : 0,
          propsLength = props.length,
          result = Array(propsLength);

      while(++index < propsLength) {
        var key = props[index];
        if (isArr) {
          result[index] = isIndex(key, length) ? collection[key] : undefined;
        } else {
          result[index] = isNil ? undefined : collection[key];
        }
      }
      return result;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property names to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @returns {Object} Returns `object`.
     */
    function baseCopy(source, props, object) {
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];
        object[key] = source[key];
      }
      return object;
    }

    /**
     * The base implementation of `_.callback` which supports specifying the
     * number of arguments to provide to `func`.
     *
     * @private
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function baseCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (type == 'function') {
        return thisArg === undefined
          ? func
          : bindCallback(func, thisArg, argCount);
      }
      if (func == null) {
        return identity;
      }
      if (type == 'object') {
        return baseMatches(func);
      }
      return thisArg === undefined
        ? property(func)
        : baseMatchesProperty(func, thisArg);
    }

    /**
     * The base implementation of `_.clone` without support for argument juggling
     * and `this` binding `customizer` functions.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The object `value` belongs to.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return arrayCopy(value, result);
        }
      } else {
        var tag = objToString.call(value),
            isFunc = tag == funcTag;

        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return baseAssign(result, value);
          }
        } else {
          return cloneableTags[tag]
            ? initCloneByTag(value, tag, isDeep)
            : (object ? value : {});
        }
      }
      // Check for circular references and return its corresponding clone.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == value) {
          return stackB[length];
        }
      }
      // Add the source value to the stack of traversed objects and associate it with its clone.
      stackA.push(value);
      stackB.push(result);

      // Recursively populate clone (susceptible to call stack limits).
      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
      });
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(prototype) {
        if (isObject(prototype)) {
          object.prototype = prototype;
          var result = new object;
          object.prototype = undefined;
        }
        return result || {};
      };
    }());

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts an index
     * of where to slice the arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Object} args The arguments provide to `func`.
     * @returns {number} Returns the timer id.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of `_.difference` which accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values) {
      var length = array ? array.length : 0,
          result = [];

      if (!length) {
        return result;
      }
      var index = -1,
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf,
          cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
          valuesLength = values.length;

      if (cache) {
        indexOf = cacheIndexOf;
        isCommon = false;
        values = cache;
      }
      outer:
      while (++index < length) {
        var value = array[index];

        if (isCommon && value === value) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === value) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (indexOf(values, value, 0) < 0) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * Gets the extremum value of `collection` invoking `iteratee` for each value
     * in `collection` to generate the criterion by which the value is ranked.
     * The `iteratee` is invoked with three arguments: (value, index|key, collection).
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(collection, iteratee, comparator, exValue) {
      var computed = exValue,
          result = computed;

      baseEach(collection, function(value, index, collection) {
        var current = +iteratee(value, index, collection);
        if (comparator(current, computed) || (current === exValue && current === result)) {
          computed = current;
          result = value;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : (end >>> 0);
      start >>>= 0;

      while (start < length) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
     * without support for callback shorthands and `this` binding, which iterates
     * over `collection` using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function} predicate The function invoked per iteration.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @param {boolean} [retKey] Specify returning the key of the found element
     *  instead of the element itself.
     * @returns {*} Returns the found element or its key, else `undefined`.
     */
    function baseFind(collection, predicate, eachFunc, retKey) {
      var result;
      eachFunc(collection, function(value, key, collection) {
        if (predicate(value, key, collection)) {
          result = retKey ? key : value;
          return false;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with added support for restricting
     * flattening and specifying the start index.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, isDeep, isStrict, result) {
      result || (result = []);

      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index];
        if (isObjectLike(value) && isArrayLike(value) &&
            (isStrict || isArray(value) || isArguments(value))) {
          if (isDeep) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, isDeep, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForIn` and `baseForOwn` which iterates
     * over `object` properties returned by `keysFunc` invoking `iteratee` for
     * each property. Iteratee functions may exit iteration early by explicitly
     * returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forIn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForIn(object, iteratee) {
      return baseFor(object, iteratee, keysIn);
    }

    /**
     * The base implementation of `_.forOwn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from those provided.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the new array of filtered property names.
     */
    function baseFunctions(object, props) {
      var index = -1,
          length = props.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var key = props[index];
        if (isFunction(object[key])) {
          result[++resIndex] = key;
        }
      }
      return result;
    }

    /**
     * The base implementation of `get` without support for string paths
     * and default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path of the property to get.
     * @param {string} [pathKey] The key representation of path.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path, pathKey) {
      if (object == null) {
        return;
      }
      if (pathKey !== undefined && pathKey in toObject(object)) {
        path = [pathKey];
      }
      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[path[index++]];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `_.isEqual` without support for `this` binding
     * `customizer` functions.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = arrayTag,
          othTag = arrayTag;

      if (!objIsArr) {
        objTag = objToString.call(object);
        if (objTag == argsTag) {
          objTag = objectTag;
        } else if (objTag != objectTag) {
          objIsArr = isTypedArray(object);
        }
      }
      if (!othIsArr) {
        othTag = objToString.call(other);
        if (othTag == argsTag) {
          othTag = objectTag;
        } else if (othTag != objectTag) {
          othIsArr = isTypedArray(other);
        }
      }
      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && !(objIsArr || objIsObj)) {
        return equalByTag(object, other, objTag);
      }
      if (!isLoose) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
        }
      }
      if (!isSameTag) {
        return false;
      }
      // Assume cyclic values are equal.
      // For more information on detecting circular references see https://es5.github.io/#JO.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == object) {
          return stackB[length] == other;
        }
      }
      // Add `object` and `other` to the stack of traversed objects.
      stackA.push(object);
      stackB.push(other);

      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

      stackA.pop();
      stackB.pop();

      return result;
    }

    /**
     * The base implementation of `_.isMatch` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} matchData The propery names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = toObject(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var result = customizer ? customizer(objValue, srcValue, key) : undefined;
          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.map` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which does not clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        var key = matchData[0][0],
            value = matchData[0][1];

        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === value && (value !== undefined || (key in toObject(object)));
        };
      }
      return function(object) {
        return baseIsMatch(object, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to compare.
     * @returns {Function} Returns the new function.
     */
    function baseMatchesProperty(path, srcValue) {
      var isArr = isArray(path),
          isCommon = isKey(path) && isStrictComparable(srcValue),
          pathKey = (path + '');

      path = toPath(path);
      return function(object) {
        if (object == null) {
          return false;
        }
        var key = pathKey;
        object = toObject(object);
        if ((isArr || !isCommon) && !(key in object)) {
          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
          if (object == null) {
            return false;
          }
          key = last(path);
          object = toObject(object);
        }
        return object[key] === srcValue
          ? (srcValue !== undefined || (key in object))
          : baseIsEqual(srcValue, object[key], undefined, true);
      };
    }

    /**
     * The base implementation of `_.merge` without support for argument juggling,
     * multiple sources, and `this` binding `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {Object} Returns `object`.
     */
    function baseMerge(object, source, customizer, stackA, stackB) {
      if (!isObject(object)) {
        return object;
      }
      var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
          props = isSrcArr ? undefined : keys(source);

      arrayEach(props || source, function(srcValue, key) {
        if (props) {
          key = srcValue;
          srcValue = source[key];
        }
        if (isObjectLike(srcValue)) {
          stackA || (stackA = []);
          stackB || (stackB = []);
          baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
        }
        else {
          var value = object[key],
              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
              isCommon = result === undefined;

          if (isCommon) {
            result = srcValue;
          }
          if ((result !== undefined || (isSrcArr && !(key in object))) &&
              (isCommon || (result === result ? (result !== value) : (value === value)))) {
            object[key] = result;
          }
        }
      });
      return object;
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
      var length = stackA.length,
          srcValue = source[key];

      while (length--) {
        if (stackA[length] == srcValue) {
          object[key] = stackB[length];
          return;
        }
      }
      var value = object[key],
          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
          isCommon = result === undefined;

      if (isCommon) {
        result = srcValue;
        if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
          result = isArray(value)
            ? value
            : (isArrayLike(value) ? arrayCopy(value) : []);
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          result = isArguments(value)
            ? toPlainObject(value)
            : (isPlainObject(value) ? value : {});
        }
        else {
          isCommon = false;
        }
      }
      // Add the source value to the stack of traversed objects and associate
      // it with its merged value.
      stackA.push(srcValue);
      stackB.push(result);

      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
      } else if (result === result ? (result !== value) : (value === value)) {
        object[key] = result;
      }
    }

    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new function.
     */
    function basePropertyDeep(path) {
      var pathKey = (path + '');
      path = toPath(path);
      return function(object) {
        return baseGet(object, path, pathKey);
      };
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * index arguments and capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0;
      while (length--) {
        var index = indexes[length];
        if (index != previous && isIndex(index)) {
          var previous = index;
          splice.call(array, index, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for argument juggling
     * and returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns the random number.
     */
    function baseRandom(min, max) {
      return min + nativeFloor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.reduce` and `_.reduceRight` without support
     * for callback shorthands and `this` binding, which iterates over `collection`
     * using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initFromCollection Specify using the first or last element
     *  of `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */
    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
      eachFunc(collection, function(value, index, collection) {
        accumulator = initFromCollection
          ? (initFromCollection = false, value)
          : iteratee(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `setData` without support for hot loop detection.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortBy` which uses `comparer` to define
     * the sort order of `array` and replaces criteria objects with their
     * corresponding values.
     *
     * @private
     * @param {Array} array The array to sort.
     * @param {Function} comparer The function to define sort order.
     * @returns {Array} Returns `array`.
     */
    function baseSortBy(array, comparer) {
      var length = array.length;

      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }

    /**
     * The base implementation of `_.sortByOrder` without param guards.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {boolean[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseSortByOrder(collection, iteratees, orders) {
      var callback = getCallback(),
          index = -1;

      iteratees = arrayMap(iteratees, function(iteratee) { return callback(iteratee); });

      var result = baseMap(collection, function(value) {
        var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.sum` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */
    function baseSum(collection, iteratee) {
      var result = 0;
      baseEach(collection, function(value, index, collection) {
        result += +iteratee(value, index, collection) || 0;
      });
      return result;
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The function invoked per iteration.
     * @returns {Array} Returns the new duplicate-value-free array.
     */
    function baseUniq(array, iteratee) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array.length,
          isCommon = indexOf == baseIndexOf,
          isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
          seen = isLarge ? createCache() : null,
          result = [];

      if (seen) {
        indexOf = cacheIndexOf;
        isCommon = false;
      } else {
        isLarge = false;
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value, index, array) : value;

        if (isCommon && value === value) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (indexOf(seen, computed, 0) < 0) {
          if (iteratee || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
      var index = -1,
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /**
     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
     * and `_.takeWhile` without support for callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to peform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      var index = -1,
          length = actions.length;

      while (++index < length) {
        var action = actions[index];
        result = action.func.apply(action.thisArg, arrayPush([result], action.args));
      }
      return result;
    }

    /**
     * Performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndex(array, value, retHighest) {
      var low = 0,
          high = array ? array.length : low;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return binaryIndexBy(array, value, identity, retHighest);
    }

    /**
     * This function is like `binaryIndex` except that it invokes `iteratee` for
     * `value` and each element of `array` to compute their sort ranking. The
     * iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array ? array.length : 0,
          valIsNaN = value !== value,
          valIsNull = value === null,
          valIsUndef = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            isDef = computed !== undefined,
            isReflexive = computed === computed;

        if (valIsNaN) {
          var setLow = isReflexive || retHighest;
        } else if (valIsNull) {
          setLow = isReflexive && isDef && (retHighest || computed != null);
        } else if (valIsUndef) {
          setLow = isReflexive && (retHighest || isDef);
        } else if (computed == null) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * A specialized version of `baseCallback` which only supports `this` binding
     * and specifying the number of arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function bindCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      if (thisArg === undefined) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
        case 5: return function(value, other, key, object, source) {
          return func.call(thisArg, value, other, key, object, source);
        };
      }
      return function() {
        return func.apply(thisArg, arguments);
      };
    }

    /**
     * Creates a clone of the given array buffer.
     *
     * @private
     * @param {ArrayBuffer} buffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function bufferClone(buffer) {
      var result = new ArrayBuffer(buffer.byteLength),
          view = new Uint8Array(result);

      view.set(new Uint8Array(buffer));
      return result;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders) {
      var holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          leftIndex = -1,
          leftLength = partials.length,
          result = Array(leftLength + argsLength);

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        result[holders[argsIndex]] = args[argsIndex];
      }
      while (argsLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders) {
      var holdersIndex = -1,
          holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          rightIndex = -1,
          rightLength = partials.length,
          result = Array(argsLength + rightLength);

      while (++argsIndex < argsLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        result[offset + holders[holdersIndex]] = args[argsIndex++];
      }
      return result;
    }

    /**
     * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.
     *
     * @private
     * @param {Function} setter The function to set keys and values of the accumulator object.
     * @param {Function} [initializer] The function to initialize the accumulator object.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee, thisArg) {
        var result = initializer ? initializer() : {};
        iteratee = getCallback(iteratee, thisArg, 3);

        if (isArray(collection)) {
          var index = -1,
              length = collection.length;

          while (++index < length) {
            var value = collection[index];
            setter(result, value, iteratee(value, index, collection), collection);
          }
        } else {
          baseEach(collection, function(value, key, collection) {
            setter(result, value, iteratee(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return restParam(function(object, sources) {
        var index = -1,
            length = object == null ? 0 : sources.length,
            customizer = length > 2 ? sources[length - 2] : undefined,
            guard = length > 2 ? sources[2] : undefined,
            thisArg = length > 1 ? sources[length - 1] : undefined;

        if (typeof customizer == 'function') {
          customizer = bindCallback(customizer, thisArg, 5);
          length -= 2;
        } else {
          customizer = typeof thisArg == 'function' ? thisArg : undefined;
          length -= (customizer ? 1 : 0);
        }
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        var length = collection ? getLength(collection) : 0;
        if (!isLength(length)) {
          return eachFunc(collection, iteratee);
        }
        var index = fromRight ? length : -1,
            iterable = toObject(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for `_.forIn` or `_.forInRight`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var iterable = toObject(object),
            props = keysFunc(object),
            length = props.length,
            index = fromRight ? length : -1;

        while ((fromRight ? index-- : ++index < length)) {
          var key = props[index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with the `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new bound function.
     */
    function createBindWrapper(func, thisArg) {
      var Ctor = createCtorWrapper(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(thisArg, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a `Set` cache object to optimize linear searches of large arrays.
     *
     * @private
     * @param {Array} [values] The values to cache.
     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
     */
    function createCache(values) {
      return (nativeCreate && Set) ? new SetCache(values) : null;
    }

    /**
     * Creates a function that produces compound words out of the words in a
     * given string.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        var index = -1,
            array = words(deburr(string)),
            length = array.length,
            result = '';

        while (++index < length) {
          result = callback(result, array[index], index);
        }
        return result;
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtorWrapper(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors.
        // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a `_.curry` or `_.curryRight` function.
     *
     * @private
     * @param {boolean} flag The curry bit flag.
     * @returns {Function} Returns the new curry function.
     */
    function createCurry(flag) {
      function curryFunc(func, arity, guard) {
        if (guard && isIterateeCall(func, arity, guard)) {
          arity = undefined;
        }
        var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
        result.placeholder = curryFunc.placeholder;
        return result;
      }
      return curryFunc;
    }

    /**
     * Creates a `_.defaults` or `_.defaultsDeep` function.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Function} Returns the new defaults function.
     */
    function createDefaults(assigner, customizer) {
      return restParam(function(args) {
        var object = args[0];
        if (object == null) {
          return object;
        }
        args.push(customizer);
        return assigner.apply(undefined, args);
      });
    }

    /**
     * Creates a `_.max` or `_.min` function.
     *
     * @private
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {Function} Returns the new extremum function.
     */
    function createExtremum(comparator, exValue) {
      return function(collection, iteratee, thisArg) {
        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
          iteratee = undefined;
        }
        iteratee = getCallback(iteratee, thisArg, 3);
        if (iteratee.length == 1) {
          collection = isArray(collection) ? collection : toIterable(collection);
          var result = arrayExtremum(collection, iteratee, comparator, exValue);
          if (!(collection.length && result === exValue)) {
            return result;
          }
        }
        return baseExtremum(collection, iteratee, comparator, exValue);
      };
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new find function.
     */
    function createFind(eachFunc, fromRight) {
      return function(collection, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        if (isArray(collection)) {
          var index = baseFindIndex(collection, predicate, fromRight);
          return index > -1 ? collection[index] : undefined;
        }
        return baseFind(collection, predicate, eachFunc);
      };
    }

    /**
     * Creates a `_.findIndex` or `_.findLastIndex` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new find function.
     */
    function createFindIndex(fromRight) {
      return function(array, predicate, thisArg) {
        if (!(array && array.length)) {
          return -1;
        }
        predicate = getCallback(predicate, thisArg, 3);
        return baseFindIndex(array, predicate, fromRight);
      };
    }

    /**
     * Creates a `_.findKey` or `_.findLastKey` function.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new find function.
     */
    function createFindKey(objectFunc) {
      return function(object, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        return baseFind(object, predicate, objectFunc, true);
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return function() {
        var wrapper,
            length = arguments.length,
            index = fromRight ? length : -1,
            leftIndex = 0,
            funcs = Array(length);

        while ((fromRight ? index-- : ++index < length)) {
          var func = funcs[leftIndex++] = arguments[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
            wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? -1 : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      };
    }

    /**
     * Creates a function for `_.forEach` or `_.forEachRight`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over an array.
     * @param {Function} eachFunc The function to iterate over a collection.
     * @returns {Function} Returns the new each function.
     */
    function createForEach(arrayFunc, eachFunc) {
      return function(collection, iteratee, thisArg) {
        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
          ? arrayFunc(collection, iteratee)
          : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
      };
    }

    /**
     * Creates a function for `_.forIn` or `_.forInRight`.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new each function.
     */
    function createForIn(objectFunc) {
      return function(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || thisArg !== undefined) {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return objectFunc(object, iteratee, keysIn);
      };
    }

    /**
     * Creates a function for `_.forOwn` or `_.forOwnRight`.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new each function.
     */
    function createForOwn(objectFunc) {
      return function(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || thisArg !== undefined) {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return objectFunc(object, iteratee);
      };
    }

    /**
     * Creates a function for `_.mapKeys` or `_.mapValues`.
     *
     * @private
     * @param {boolean} [isMapKeys] Specify mapping keys instead of values.
     * @returns {Function} Returns the new map function.
     */
    function createObjectMapper(isMapKeys) {
      return function(object, iteratee, thisArg) {
        var result = {};
        iteratee = getCallback(iteratee, thisArg, 3);

        baseForOwn(object, function(value, key, object) {
          var mapped = iteratee(value, key, object);
          key = isMapKeys ? mapped : key;
          value = isMapKeys ? value : mapped;
          result[key] = value;
        });
        return result;
      };
    }

    /**
     * Creates a function for `_.padLeft` or `_.padRight`.
     *
     * @private
     * @param {boolean} [fromRight] Specify padding from the right.
     * @returns {Function} Returns the new pad function.
     */
    function createPadDir(fromRight) {
      return function(string, length, chars) {
        string = baseToString(string);
        return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
      };
    }

    /**
     * Creates a `_.partial` or `_.partialRight` function.
     *
     * @private
     * @param {boolean} flag The partial bit flag.
     * @returns {Function} Returns the new partial function.
     */
    function createPartial(flag) {
      var partialFunc = restParam(function(func, partials) {
        var holders = replaceHolders(partials, partialFunc.placeholder);
        return createWrapper(func, flag, undefined, partials, holders);
      });
      return partialFunc;
    }

    /**
     * Creates a function for `_.reduce` or `_.reduceRight`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over an array.
     * @param {Function} eachFunc The function to iterate over a collection.
     * @returns {Function} Returns the new each function.
     */
    function createReduce(arrayFunc, eachFunc) {
      return function(collection, iteratee, accumulator, thisArg) {
        var initFromArray = arguments.length < 3;
        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
          ? arrayFunc(collection, iteratee, accumulator, initFromArray)
          : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with optional `this`
     * binding of, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & ARY_FLAG,
          isBind = bitmask & BIND_FLAG,
          isBindKey = bitmask & BIND_KEY_FLAG,
          isCurry = bitmask & CURRY_FLAG,
          isCurryBound = bitmask & CURRY_BOUND_FLAG,
          isCurryRight = bitmask & CURRY_RIGHT_FLAG,
          Ctor = isBindKey ? undefined : createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it to other functions.
        var length = arguments.length,
            index = length,
            args = Array(length);

        while (index--) {
          args[index] = arguments[index];
        }
        if (partials) {
          args = composeArgs(args, partials, holders);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight);
        }
        if (isCurry || isCurryRight) {
          var placeholder = wrapper.placeholder,
              argsHolders = replaceHolders(args, placeholder);

          length -= argsHolders.length;
          if (length < arity) {
            var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                newArity = nativeMax(arity - length, 0),
                newsHolders = isCurry ? argsHolders : undefined,
                newHoldersRight = isCurry ? undefined : argsHolders,
                newPartials = isCurry ? args : undefined,
                newPartialsRight = isCurry ? undefined : args;

            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

            if (!isCurryBound) {
              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
            }
            var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                result = createHybridWrapper.apply(undefined, newData);

            if (isLaziable(func)) {
              setData(result, newData);
            }
            result.placeholder = placeholder;
            return result;
          }
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        if (argPos) {
          args = reorder(args, argPos);
        }
        if (isAry && ary < args.length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtorWrapper(func);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates the padding required for `string` based on the given `length`.
     * The `chars` string is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {string} string The string to create padding for.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the pad for `string`.
     */
    function createPadding(string, length, chars) {
      var strLength = string.length;
      length = +length;

      if (strLength >= length || !nativeIsFinite(length)) {
        return '';
      }
      var padLength = length - strLength;
      chars = chars == null ? ' ' : (chars + '');
      return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
    }

    /**
     * Creates a function that wraps `func` and invokes it with the optional `this`
     * binding of `thisArg` and the `partials` prepended to those provided to
     * the wrapper.
     *
     * @private
     * @param {Function} func The function to partially apply arguments to.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to the new function.
     * @returns {Function} Returns the new bound function.
     */
    function createPartialWrapper(func, bitmask, thisArg, partials) {
      var isBind = bitmask & BIND_FLAG,
          Ctor = createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it `func`.
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength);

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.ceil`, `_.floor`, or `_.round` function.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        precision = precision === undefined ? 0 : (+precision || 0);
        if (precision) {
          precision = pow(10, precision);
          return func(number * precision) / precision;
        }
        return func(number);
      };
    }

    /**
     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
     *
     * @private
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {Function} Returns the new index function.
     */
    function createSortedIndex(retHighest) {
      return function(array, value, iteratee, thisArg) {
        var callback = getCallback(iteratee);
        return (iteratee == null && callback === baseCallback)
          ? binaryIndex(array, value, retHighest)
          : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags.
     *  The bitmask may be composed of the following flags:
     *     1 - `_.bind`
     *     2 - `_.bindKey`
     *     4 - `_.curry` or `_.curryRight` of a bound function
     *     8 - `_.curry`
     *    16 - `_.curryRight`
     *    32 - `_.partial`
     *    64 - `_.partialRight`
     *   128 - `_.rearg`
     *   256 - `_.ary`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      length -= (holders ? holders.length : 0);
      if (bitmask & PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func),
          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

      if (data) {
        mergeData(newData, data);
        bitmask = newData[1];
        arity = newData[9];
      }
      newData[9] = arity == null
        ? (isBindKey ? 0 : func.length)
        : (nativeMax(arity - length, 0) || 0);

      if (bitmask == BIND_FLAG) {
        var result = createBindWrapper(newData[0], newData[2]);
      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
        result = createPartialWrapper.apply(undefined, newData);
      } else {
        result = createHybridWrapper.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setter(result, newData);
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing arrays.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var index = -1,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
        return false;
      }
      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index],
            result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

        if (result !== undefined) {
          if (result) {
            continue;
          }
          return false;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (isLoose) {
          if (!arraySome(other, function(othValue) {
                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
              })) {
            return false;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag) {
      switch (tag) {
        case boolTag:
        case dateTag:
          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
          return +object == +other;

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case numberTag:
          // Treat `NaN` vs. `NaN` as equal.
          return (object != +object)
            ? other != +other
            : object == +other;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings primitives and string
          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
          return object == (other + '');
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var objProps = keys(object),
          objLength = objProps.length,
          othProps = keys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isLoose) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var skipCtor = isLoose;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key],
            result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;

        // Recursively compare objects (susceptible to call stack limits).
        if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
          return false;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (!skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Gets the appropriate "callback" function. If the `_.callback` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseCallback` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function} Returns the chosen function or its result.
     */
    function getCallback(func, thisArg, argCount) {
      var result = lodash.callback || callback;
      result = result === callback ? baseCallback : result;
      return argCount ? result(func, thisArg, argCount) : result;
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = func.name,
          array = realNames[result],
          length = array ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseIndexOf` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function|number} Returns the chosen function or its result.
     */
    function getIndexOf(collection, target, fromIndex) {
      var result = lodash.indexOf || indexOf;
      result = result === indexOf ? baseIndexOf : result;
      return collection ? result(collection, target, fromIndex) : result;
    }

    /**
     * Gets the "length" property value of `object`.
     *
     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
     * that affects Safari on at least iOS 8.1-8.3 ARM64.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {*} Returns the "length" value.
     */
    var getLength = baseProperty('length');

    /**
     * Gets the propery names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = pairs(object),
          length = result.length;

      while (length--) {
        result[length][2] = isStrictComparable(result[length][1]);
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = object == null ? undefined : object[key];
      return isNative(value) ? value : undefined;
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add array properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      var Ctor = object.constructor;
      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
        Ctor = Object;
      }
      return new Ctor;
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return bufferClone(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          var buffer = object.buffer;
          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          var result = new Ctor(object.source, reFlags.exec(object));
          result.lastIndex = object.lastIndex;
      }
      return result;
    }

    /**
     * Invokes the method at `path` on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function invokePath(object, path, args) {
      if (object != null && !isKey(path, object)) {
        path = toPath(path);
        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
        path = last(path);
      }
      var func = object == null ? object : object[path];
      return func == null ? undefined : func.apply(object, args);
    }

    /**
     * Checks if `value` is array-like.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     */
    function isArrayLike(value) {
      return value != null && isLength(getLength(value));
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return value > -1 && value % 1 == 0 && value < length;
    }

    /**
     * Checks if the provided arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
          ? (isArrayLike(object) && isIndex(index, object.length))
          : (type == 'string' && index in object)) {
        var other = object[index];
        return value === value ? (value === other) : (other !== other);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      var type = typeof value;
      if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
        return true;
      }
      if (isArray(value)) {
        return false;
      }
      var result = !reIsDeepProp.test(value);
      return result || (object != null && value in toObject(object));
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func);
      if (!(funcName in LazyWrapper.prototype)) {
        return false;
      }
      var other = lodash[funcName];
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     */
    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers required to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
     * augment function arguments, making the order in which they are executed important,
     * preventing the merging of metadata. However, we make an exception for a safe
     * common case where curried functions have `_.ary` and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < ARY_FLAG;

      var isCombo =
        (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
        (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
        (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = arrayCopy(value);
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function mergeDefaults(objectValue, sourceValue) {
      return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
    }

    /**
     * A specialized version of `_.pick` which picks `object` properties specified
     * by `props`.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} props The property names to pick.
     * @returns {Object} Returns the new object.
     */
    function pickByArray(object, props) {
      object = toObject(object);

      var index = -1,
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        if (key in object) {
          result[key] = object[key];
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.pick` which picks `object` properties `predicate`
     * returns truthy for.
     *
     * @private
     * @param {Object} object The source object.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Object} Returns the new object.
     */
    function pickByCallback(object, predicate) {
      var result = {};
      baseForIn(object, function(value, key, object) {
        if (predicate(value, key, object)) {
          result[key] = value;
        }
      });
      return result;
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = arrayCopy(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity function
     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = (function() {
      var count = 0,
          lastCalled = 0;

      return function(key, value) {
        var stamp = now(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return key;
          }
        } else {
          count = 0;
        }
        return baseSetData(key, value);
      };
    }());

    /**
     * A fallback implementation of `Object.keys` which creates an array of the
     * own enumerable property names of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function shimKeys(object) {
      var props = keysIn(object),
          propsLength = props.length,
          length = propsLength && object.length;

      var allowIndexes = !!length && isLength(length) &&
        (isArray(object) || isArguments(object));

      var index = -1,
          result = [];

      while (++index < propsLength) {
        var key = props[index];
        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to an array-like object if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array|Object} Returns the array-like object.
     */
    function toIterable(value) {
      if (value == null) {
        return [];
      }
      if (!isArrayLike(value)) {
        return values(value);
      }
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to an object if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Object} Returns the object.
     */
    function toObject(value) {
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to property path array if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array} Returns the property path array.
     */
    function toPath(value) {
      if (isArray(value)) {
        return value;
      }
      var result = [];
      baseToString(value).replace(rePropName, function(match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      return wrapper instanceof LazyWrapper
        ? wrapper.clone()
        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `collection` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new array containing chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if (guard ? isIterateeCall(array, size, guard) : size == null) {
        size = 1;
      } else {
        size = nativeMax(nativeFloor(size) || 1, 1);
      }
      var index = 0,
          length = array ? array.length : 0,
          resIndex = -1,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[++resIndex] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * Creates an array of unique `array` values not included in the other
     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3], [4, 2]);
     * // => [1, 3]
     */
    var difference = restParam(function(array, values) {
      return (isObjectLike(array) && isArrayLike(array))
        ? baseDifference(array, baseFlatten(values, false, true))
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that match the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [1]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
     * // => ['barney']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropWhile(users, 'active', false), 'user');
     * // => ['pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8], '*', 1, 2);
     * // => [4, '*', 8]
     */
    function fill(array, value, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(chr) {
     *   return chr.user == 'barney';
     * });
     * // => 0
     *
     * // using the `_.matches` callback shorthand
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findIndex(users, 'active', false);
     * // => 0
     *
     * // using the `_.property` callback shorthand
     * _.findIndex(users, 'active');
     * // => 2
     */
    var findIndex = createFindIndex();

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(chr) {
     *   return chr.user == 'pebbles';
     * });
     * // => 2
     *
     * // using the `_.matches` callback shorthand
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastIndex(users, 'active', false);
     * // => 2
     *
     * // using the `_.property` callback shorthand
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    var findLastIndex = createFindIndex(true);

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias head
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([]);
     * // => undefined
     */
    function first(array) {
      return array ? array[0] : undefined;
    }

    /**
     * Flattens a nested array. If `isDeep` is `true` the array is recursively
     * flattened, otherwise it is only flattened a single level.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, 3, [4]]]);
     * // => [1, 2, 3, [4]]
     *
     * // using `isDeep`
     * _.flatten([1, [2, 3, [4]]], true);
     * // => [1, 2, 3, 4]
     */
    function flatten(array, isDeep, guard) {
      var length = array ? array.length : 0;
      if (guard && isIterateeCall(array, isDeep, guard)) {
        isDeep = false;
      }
      return length ? baseFlatten(array, isDeep) : [];
    }

    /**
     * Recursively flattens a nested array.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to recursively flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, 3, [4]]]);
     * // => [1, 2, 3, 4]
     */
    function flattenDeep(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, true) : [];
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
     * performs a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // using `fromIndex`
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     *
     * // performing a binary search
     * _.indexOf([1, 1, 2, 2], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      if (typeof fromIndex == 'number') {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
      } else if (fromIndex) {
        var index = binaryIndex(array, value);
        if (index < length &&
            (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
          return index;
        }
        return -1;
      }
      return baseIndexOf(array, value, fromIndex || 0);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      return dropRight(array, 1);
    }

    /**
     * Creates an array of unique values that are included in all of the provided
     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of shared values.
     * @example
     * _.intersection([1, 2], [4, 2], [2, 1]);
     * // => [2]
     */
    var intersection = restParam(function(arrays) {
      var othLength = arrays.length,
          othIndex = othLength,
          caches = Array(length),
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf,
          result = [];

      while (othIndex--) {
        var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
        caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
      }
      var array = arrays[0],
          index = -1,
          length = array ? array.length : 0,
          seen = caches[0];

      outer:
      while (++index < length) {
        value = array[index];
        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
          var othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(value);
          }
          result.push(value);
        }
      }
      return result;
    });

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array ? array.length : 0;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
     *  or `true` to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // using `fromIndex`
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     *
     * // performing a binary search
     * _.lastIndexOf([1, 1, 2, 2], 2, true);
     * // => 3
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      var index = length;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
      } else if (fromIndex) {
        index = binaryIndex(array, value, true) - 1;
        var other = array[index];
        if (value === value ? (value === other) : (other !== other)) {
          return index;
        }
        return -1;
      }
      if (value !== value) {
        return indexOfNaN(array, index, true);
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     *
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull() {
      var args = arguments,
          array = args[0];

      if (!(array && array.length)) {
        return array;
      }
      var index = 0,
          indexOf = getIndexOf(),
          length = args.length;

      while (++index < length) {
        var fromIndex = 0,
            value = args[index];

        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * Removes elements from `array` corresponding to the given indexes and returns
     * an array of the removed elements. Indexes may be specified as an array of
     * indexes or as individual arguments.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [5, 10, 15, 20];
     * var evens = _.pullAt(array, 1, 3);
     *
     * console.log(array);
     * // => [5, 15]
     *
     * console.log(evens);
     * // => [10, 20]
     */
    var pullAt = restParam(function(array, indexes) {
      indexes = baseFlatten(indexes);

      var result = baseAt(array, indexes);
      basePullAt(array, indexes.sort(baseCompareAscending));
      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is bound to
     * `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate, thisArg) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias tail
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     */
    function rest(array) {
      return drop(array, 1);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of `Array#slice` to support node
     * lists in IE < 9 and to ensure dense arrays are returned.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value` should
     * be inserted into `array` in order to maintain its sort order. If an iteratee
     * function is provided it is invoked for `value` and each element of `array`
     * to compute their sort ranking. The iteratee is bound to `thisArg` and
     * invoked with one argument; (value).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     *
     * _.sortedIndex([4, 4, 5, 5], 5);
     * // => 2
     *
     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
     *
     * // using an iteratee function
     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
     *   return this.data[word];
     * }, dict);
     * // => 1
     *
     * // using the `_.property` callback shorthand
     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 1
     */
    var sortedIndex = createSortedIndex();

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 4, 5, 5], 5);
     * // => 4
     */
    var sortedLastIndex = createSortedIndex(true);

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
     * and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [2, 3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
     * // => []
     */
    function takeRightWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is bound to
     * `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [1, 2]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false},
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeWhile(users, 'active', false), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeWhile(users, 'active'), 'user');
     * // => []
     */
    function takeWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all of the provided arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([1, 2], [4, 2], [2, 1]);
     * // => [1, 2, 4]
     */
    var union = restParam(function(arrays) {
      return baseUniq(baseFlatten(arrays, false, true));
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurence of each element
     * is kept. Providing `true` for `isSorted` performs a faster search algorithm
     * for sorted arrays. If an iteratee function is provided it is invoked for
     * each element in the array to generate the criterion by which uniqueness
     * is computed. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, array).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {boolean} [isSorted] Specify the array is sorted.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new duplicate-value-free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     *
     * // using `isSorted`
     * _.uniq([1, 1, 2], true);
     * // => [1, 2]
     *
     * // using an iteratee function
     * _.uniq([1, 2.5, 1.5, 2], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => [1, 2.5]
     *
     * // using the `_.property` callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (isSorted != null && typeof isSorted != 'boolean') {
        thisArg = iteratee;
        iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
        isSorted = false;
      }
      var callback = getCallback();
      if (!(iteratee == null && callback === baseCallback)) {
        iteratee = callback(iteratee, thisArg, 3);
      }
      return (isSorted && getIndexOf() == baseIndexOf)
        ? sortedUniq(array, iteratee)
        : baseUniq(array, iteratee);
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     *
     * _.unzip(zipped);
     * // => [['fred', 'barney'], [30, 40], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var index = -1,
          length = 0;

      array = arrayFilter(array, function(group) {
        if (isArrayLike(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      var result = Array(length);
      while (++index < length) {
        result[index] = arrayMap(array, baseProperty(index));
      }
      return result;
    }

    /**
     * This method is like `_.unzip` except that it accepts an iteratee to specify
     * how regrouped values should be combined. The `iteratee` is bound to `thisArg`
     * and invoked with four arguments: (accumulator, value, index, group).
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee] The function to combine regrouped values.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      iteratee = bindCallback(iteratee, thisArg, 4);
      return arrayMap(result, function(group) {
        return arrayReduce(group, iteratee, undefined, true);
      });
    }

    /**
     * Creates an array excluding all provided values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to filter.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 3], 1, 2);
     * // => [3]
     */
    var without = restParam(function(array, values) {
      return isArrayLike(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the provided arrays.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of values.
     * @example
     *
     * _.xor([1, 2], [4, 2]);
     * // => [1, 4]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArrayLike(array)) {
          var result = result
            ? arrayPush(baseDifference(result, array), baseDifference(array, result))
            : array;
        }
      }
      return result ? baseUniq(result) : [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second elements
     * of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    var zip = restParam(unzip);

    /**
     * The inverse of `_.pairs`; this method returns an object composed from arrays
     * of property names and values. Provide either a single two dimensional array,
     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
     * and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Array
     * @param {Array} props The property names.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject([['fred', 30], ['barney', 40]]);
     * // => { 'fred': 30, 'barney': 40 }
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(props, values) {
      var index = -1,
          length = props ? props.length : 0,
          result = {};

      if (length && !values && !isArray(props[0])) {
        values = [];
      }
      while (++index < length) {
        var key = props[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /**
     * This method is like `_.zip` except that it accepts an iteratee to specify
     * how grouped values should be combined. The `iteratee` is bound to `thisArg`
     * and invoked with four arguments: (accumulator, value, index, group).
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee] The function to combine grouped values.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], _.add);
     * // => [111, 222]
     */
    var zipWith = restParam(function(arrays) {
      var length = arrays.length,
          iteratee = length > 2 ? arrays[length - 2] : undefined,
          thisArg = length > 1 ? arrays[length - 1] : undefined;

      if (length > 2 && typeof iteratee == 'function') {
        length -= 2;
      } else {
        iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
        thisArg = undefined;
      }
      arrays.length = length;
      return unzipWith(arrays, iteratee, thisArg);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps `value` with explicit method
     * chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(users)
     *   .sortBy('age')
     *   .map(function(chr) {
     *     return chr.user + ' is ' + chr.age;
     *   })
     *   .first()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor is
     * bound to `thisArg` and invoked with one argument; (value). The purpose of
     * this method is to "tap into" a method chain in order to perform operations
     * on intermediate results within the chain.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor, thisArg) {
      interceptor.call(thisArg, value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor, thisArg) {
      return interceptor.call(thisArg, value);
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(users).first();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(users).chain()
     *   .first()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chained sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Creates a new array joining a wrapped array with any additional arrays
     * and/or values.
     *
     * @name concat
     * @memberOf _
     * @category Chain
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var wrapped = _(array).concat(2, [3], [[4]]);
     *
     * console.log(wrapped.value());
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    var wrapperConcat = restParam(function(values) {
      values = baseFlatten(values);
      return this.thru(function(array) {
        return arrayConcat(isArray(array) ? array : [toObject(array)], values);
      });
    });

    /**
     * Creates a clone of the chained sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).map(function(value) {
     *   return Math.pow(value, 2);
     * });
     *
     * var other = [3, 4];
     * var otherWrapped = wrapped.plant(other);
     *
     * otherWrapped.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * Reverses the wrapped array so the first element becomes the last, the
     * second element becomes the second to last, and so on.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;

      var interceptor = function(value) {
        return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
      };
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(interceptor);
    }

    /**
     * Produces the result of coercing the unwrapped value to a string.
     *
     * @name toString
     * @memberOf _
     * @category Chain
     * @returns {string} Returns the coerced string value.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return (this.value() + '');
    }

    /**
     * Executes the chained sequence to extract the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @alias run, toJSON, valueOf
     * @category Chain
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements corresponding to the given keys, or indexes,
     * of `collection`. Keys may be specified as individual arguments or as arrays
     * of keys.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [props] The property names
     *  or indexes of elements to pick, specified individually or in arrays.
     * @returns {Array} Returns the new array of picked elements.
     * @example
     *
     * _.at(['a', 'b', 'c'], [0, 2]);
     * // => ['a', 'c']
     *
     * _.at(['barney', 'fred', 'pebbles'], 0, 2);
     * // => ['barney', 'pebbles']
     */
    var at = restParam(function(collection, props) {
      return baseAt(collection, baseFlatten(props));
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the number of times the key was returned by `iteratee`.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * The predicate is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'active': false },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.every(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
        predicate = undefined;
      }
      if (typeof predicate != 'function' || thisArg !== undefined) {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.filter([4, 5, 6], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [4, 6]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.filter(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.filter(users, 'active'), 'user');
     * // => ['barney']
     */
    function filter(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.result(_.find(users, function(chr) {
     *   return chr.age < 40;
     * }), 'user');
     * // => 'barney'
     *
     * // using the `_.matches` callback shorthand
     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.result(_.find(users, 'active', false), 'user');
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.result(_.find(users, 'active'), 'user');
     * // => 'barney'
     */
    var find = createFind(baseEach);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(baseEachRight, true);

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning the first element that has equivalent property
     * values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
     * // => 'barney'
     *
     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
     * // => 'fred'
     */
    function findWhere(collection, source) {
      return find(collection, baseMatches(source));
    }

    /**
     * Iterates over elements of `collection` invoking `iteratee` for each element.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection). Iteratee functions may exit iteration early
     * by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length" property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEach(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from left to right and returns the array
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
     *   console.log(n, key);
     * });
     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
     */
    var forEach = createForEach(arrayEach, baseEach);

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEachRight(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from right to left and returns the array
     */
    var forEachRight = createForEach(arrayEachRight, baseEachRight);

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using the `_.property` callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        result[key] = [value];
      }
    });

    /**
     * Checks if `value` is in `collection` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
     * from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @alias contains, include
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {*} target The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.includes('pebbles', 'eb');
     * // => true
     */
    function includes(collection, target, fromIndex, guard) {
      var length = collection ? getLength(collection) : 0;
      if (!isLength(length)) {
        collection = values(collection);
        length = collection.length;
      }
      if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
        fromIndex = 0;
      } else {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
      }
      return (typeof collection == 'string' || !isArray(collection) && isString(collection))
        ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)
        : (!!length && getIndexOf(collection, target, fromIndex) > -1);
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the last element responsible for generating the key. The
     * iteratee function is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keyData = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keyData, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return String.fromCharCode(object.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return this.fromCharCode(object.code);
     * }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `methodName` is a function it is
     * invoked for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invoke = restParam(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          isProp = isKey(path),
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
        result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
      });
      return result;
    });

    /**
     * Creates an array of values by running each element in `collection` through
     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
     * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
     * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
     * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
     * `sum`, `uniq`, and `words`
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function timesThree(n) {
     *   return n * 3;
     * }
     *
     * _.map([1, 2], timesThree);
     * // => [3, 6]
     *
     * _.map({ 'a': 1, 'b': 2 }, timesThree);
     * // => [3, 6] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee, thisArg) {
      var func = isArray(collection) ? arrayMap : baseMap;
      iteratee = getCallback(iteratee, thisArg, 3);
      return func(collection, iteratee);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, while the second of which
     * contains elements `predicate` returns falsey for. The predicate is bound
     * to `thisArg` and invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * _.partition([1, 2, 3], function(n) {
     *   return n % 2;
     * });
     * // => [[1, 3], [2]]
     *
     * _.partition([1.2, 2.3, 3.4], function(n) {
     *   return this.floor(n) % 2;
     * }, Math);
     * // => [[1.2, 3.4], [2.3]]
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * var mapper = function(array) {
     *   return _.pluck(array, 'user');
     * };
     *
     * // using the `_.matches` callback shorthand
     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
     * // => [['pebbles'], ['barney', 'fred']]
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.map(_.partition(users, 'active', false), mapper);
     * // => [['barney', 'pebbles'], ['fred']]
     *
     * // using the `_.property` callback shorthand
     * _.map(_.partition(users, 'active'), mapper);
     * // => [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Gets the property value of `path` from all elements in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|string} path The path of the property to pluck.
     * @returns {Array} Returns the property values.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(users, 'user');
     * // => ['barney', 'fred']
     *
     * var userIndex = _.indexBy(users, 'user');
     * _.pluck(userIndex, 'age');
     * // => [36, 40] (iteration order is not guaranteed)
     */
    function pluck(collection, path) {
      return map(collection, property(path));
    }

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` through `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not provided the first element of `collection` is used as the initial
     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
     * and `sortByOrder`
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.reduce([1, 2], function(total, n) {
     *   return total + n;
     * });
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
     */
    var reduce = createReduce(arrayReduce, baseEach);

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    var reduceRight = createReduce(arrayReduceRight, baseEachRight);

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.reject([1, 2, 3, 4], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [1, 3]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.reject(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.reject(users, 'active'), 'user');
     * // => ['barney']
     */
    function reject(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, function(value, index, collection) {
        return !predicate(value, index, collection);
      });
    }

    /**
     * Gets a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {*} Returns the random sample(s).
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (guard ? isIterateeCall(collection, n, guard) : n == null) {
        collection = toIterable(collection);
        var length = collection.length;
        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
      }
      var index = -1,
          result = toArray(collection),
          length = result.length,
          lastIndex = length - 1;

      n = nativeMin(n < 0 ? 0 : (+n || 0), length);
      while (++index < n) {
        var rand = baseRandom(index, lastIndex),
            value = result[rand];

        result[rand] = result[index];
        result[index] = value;
      }
      result.length = n;
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      return sample(collection, POSITIVE_INFINITY);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the size of `collection`.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? getLength(collection) : 0;
      return isLength(length) ? length : keys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * The function returns as soon as it finds a passing value and does not iterate
     * over the entire collection. The predicate is bound to `thisArg` and invoked
     * with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.some(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, thisArg) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
        predicate = undefined;
      }
      if (typeof predicate != 'function' || thisArg !== undefined) {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through `iteratee`. This method performs
     * a stable sort, that is, it preserves the original sort order of equal elements.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return Math.sin(n);
     * });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return this.sin(n);
     * }, Math);
     * // => [3, 1, 2]
     *
     * var users = [
     *   { 'user': 'fred' },
     *   { 'user': 'pebbles' },
     *   { 'user': 'barney' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.sortBy(users, 'user'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function sortBy(collection, iteratee, thisArg) {
      if (collection == null) {
        return [];
      }
      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = undefined;
      }
      var index = -1;
      iteratee = getCallback(iteratee, thisArg, 3);

      var result = baseMap(collection, function(value, key, collection) {
        return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };
      });
      return baseSortBy(result, compareAscending);
    }

    /**
     * This method is like `_.sortBy` except that it can sort by multiple iteratees
     * or property names.
     *
     * If a property name is provided for an iteratee the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If an object is provided for an iteratee the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees
     *  The iteratees to sort by, specified as individual values or arrays of values.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 42 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
     * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
     *
     * _.map(_.sortByAll(users, 'user', function(chr) {
     *   return Math.floor(chr.age / 10);
     * }), _.values);
     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
     */
    var sortByAll = restParam(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var guard = iteratees[2];
      if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
        iteratees.length = 1;
      }
      return baseSortByOrder(collection, baseFlatten(iteratees), []);
    });

    /**
     * This method is like `_.sortByAll` except that it allows specifying the
     * sort orders of the iteratees to sort by. If `orders` is unspecified, all
     * values are sorted in ascending order. Otherwise, a value is sorted in
     * ascending order if its corresponding order is "asc", and descending if "desc".
     *
     * If a property name is provided for an iteratee the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If an object is provided for an iteratee the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {boolean[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 42 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // sort by `user` in ascending order and by `age` in descending order
     * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);
     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
     */
    function sortByOrder(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (guard && isIterateeCall(iteratees, orders, guard)) {
        orders = undefined;
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseSortByOrder(collection, iteratees, orders);
    }

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning an array of all elements that have equivalent
     * property values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
     * // => ['barney']
     *
     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
     * // => ['fred']
     */
    function where(collection, source) {
      return filter(collection, baseMatches(source));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Date
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => logs the number of milliseconds it took for the deferred function to be invoked
     */
    var now = nativeNow || function() {
      return new Date().getTime();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it is called `n` or more times.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'done saving!' after the two async saves have completed
     */
    function after(n, func) {
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      n = nativeIsFinite(n = +n) ? n : 0;
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that accepts up to `n` arguments ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      if (guard && isIterateeCall(func, n, guard)) {
        n = undefined;
      }
      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
      return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it is called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery('#add').on('click', _.before(5, addContactToList));
     * // => allows adding up to 4 contacts to the list
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and prepends any additional `_.bind` arguments to those provided to the
     * bound function.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind` this method does not set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var greet = function(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * };
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // using placeholders
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = restParam(function(func, thisArg, partials) {
      var bitmask = BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, bind.placeholder);
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all enumerable function
     * properties, own and inherited, of `object` are bound.
     *
     * **Note:** This method does not set the "length" property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} [methodNames] The object method names to bind,
     *  specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs' when the element is clicked
     */
    var bindAll = restParam(function(object, methodNames) {
      methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);

      var index = -1,
          length = methodNames.length;

      while (++index < length) {
        var key = methodNames[index];
        object[key] = createWrapper(object[key], BIND_FLAG, object);
      }
      return object;
    });

    /**
     * Creates a function that invokes the method at `object[key]` and prepends
     * any additional `_.bindKey` arguments to those provided to the bound function.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist.
     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // using placeholders
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = restParam(function(object, key, partials) {
      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, bindKey.placeholder);
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts one or more arguments of `func` that when
     * called either invokes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` may be specified
     * if `func.length` is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    var curry = createCurry(CURRY_FLAG);

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    var curryRight = createCurry(CURRY_RIGHT_FLAG);

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed invocations. Provide an options object to indicate that `func`
     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
     * Subsequent calls to the debounced function return the result of the last
     * `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify invoking on the leading
     *  edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
     *  delayed before it is invoked.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // ensure `batchLog` is invoked once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }));
     *
     * // cancel a debounced call
     * var todoChanges = _.debounce(batchLog, 1000);
     * Object.observe(models.todo, todoChanges);
     *
     * Object.observe(models, function(changes) {
     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
     *     todoChanges.cancel();
     *   }
     * }, ['delete']);
     *
     * // ...at some point `models.todo` is changed
     * models.todo.completed = true;
     *
     * // ...before 1 second has passed `models.todo` is deleted
     * // which cancels the debounced `todoChanges` call
     * delete models.todo;
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = wait < 0 ? 0 : (+wait || 0);
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = !!options.leading;
        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function cancel() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        if (maxTimeoutId) {
          clearTimeout(maxTimeoutId);
        }
        lastCalled = 0;
        maxTimeoutId = timeoutId = trailingCall = undefined;
      }

      function complete(isCalled, id) {
        if (id) {
          clearTimeout(id);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (isCalled) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = undefined;
          }
        }
      }

      function delayed() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0 || remaining > wait) {
          complete(trailingCall, maxTimeoutId);
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      }

      function maxDelayed() {
        complete(trailing, timeoutId);
      }

      function debounced() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0 || remaining > maxWait;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = undefined;
        }
        return result;
      }
      debounced.cancel = cancel;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    var defer = restParam(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => logs 'later' after one second
     */
    var delay = restParam(function(func, wait, args) {
      return baseDelay(func, wait, args);
    });

    /**
     * Creates a function that returns the result of invoking the provided
     * functions with the `this` binding of the created function, where each
     * successive invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow(_.add, square);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the provided functions from right to left.
     *
     * @static
     * @memberOf _
     * @alias backflow, compose
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight(square, _.add);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is coerced to a string and used as the
     * cache key. The `func` is invoked with the `this` binding of the memoized
     * function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var upperCase = _.memoize(function(string) {
     *   return string.toUpperCase();
     * });
     *
     * upperCase('fred');
     * // => 'FRED'
     *
     * // modifying the result cache
     * upperCase.cache.set('fred', 'BARNEY');
     * upperCase('fred');
     * // => 'BARNEY'
     *
     * // replacing `_.memoize.Cache`
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'barney' };
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'fred' }
     *
     * _.memoize.Cache = WeakMap;
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'barney' }
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new memoize.Cache;
      return memoized;
    }

    /**
     * Creates a function that runs each argument through a corresponding
     * transform function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms] The functions to transform
     * arguments, specified as individual functions or arrays of functions.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var modded = _.modArgs(function(x, y) {
     *   return [x, y];
     * }, square, doubled);
     *
     * modded(1, 2);
     * // => [1, 4]
     *
     * modded(5, 10);
     * // => [25, 20]
     */
    var modArgs = restParam(function(func, transforms) {
      transforms = baseFlatten(transforms);
      if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = transforms.length;
      return restParam(function(args) {
        var index = nativeMin(args.length, length);
        while (index--) {
          args[index] = transforms[index](args[index]);
        }
        return func.apply(this, args);
      });
    });

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        return !predicate.apply(this, arguments);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first call. The `func` is invoked
     * with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` invokes `createApplication` once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with `partial` arguments prepended
     * to those provided to the new function. This method is like `_.bind` except
     * it does **not** alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // using placeholders
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = createPartial(PARTIAL_FLAG);

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to those provided to the new function.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // using placeholders
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified indexes where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, 2, 0, 1);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     *
     * var map = _.rearg(_.map, [1, 0]);
     * map(function(n) {
     *   return n * 3;
     * }, [1, 2, 3]);
     * // => [3, 6, 9]
     */
    var rearg = restParam(function(func, indexes) {
      return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as an array.
     *
     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.restParam(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function restParam(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            rest = Array(length);

        while (++index < length) {
          rest[index] = args[start + index];
        }
        switch (start) {
          case 0: return func.call(this, rest);
          case 1: return func.call(this, args[0], rest);
          case 2: return func.call(this, args[0], args[1], rest);
        }
        var otherArgs = Array(start + 1);
        index = -1;
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = rest;
        return func.apply(this, otherArgs);
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the created
     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
     *
     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * // with a Promise
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function(array) {
        return func.apply(this, array);
      };
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed invocations. Provide an options object to indicate
     * that `func` should be invoked on the leading and/or trailing edge of the
     * `wait` timeout. Subsequent calls to the throttled function return the
     * result of the last `func` call.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify invoking on the leading
     *  edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     *
     * // cancel a trailing throttled call
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Any additional arguments provided to the function are
     * appended to those provided to the wrapper function. The wrapper is invoked
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      wrapper = wrapper == null ? identity : wrapper;
      return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
     * otherwise they are assigned by reference. If `customizer` is provided it is
     * invoked to produce the cloned values. If `customizer` returns `undefined`
     * cloning is handled by the method instead. The `customizer` is bound to
     * `thisArg` and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var shallow = _.clone(users);
     * shallow[0] === users[0];
     * // => true
     *
     * var deep = _.clone(users, true);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.clone(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, customizer, thisArg) {
      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
        isDeep = false;
      }
      else if (typeof isDeep == 'function') {
        thisArg = customizer;
        customizer = isDeep;
        isDeep = false;
      }
      return typeof customizer == 'function'
        ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))
        : baseClone(value, isDeep);
    }

    /**
     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
     * to produce the cloned values. If `customizer` returns `undefined` cloning
     * is handled by the method instead. The `customizer` is bound to `thisArg`
     * and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var deep = _.cloneDeep(users);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.cloneDeep(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 20
     */
    function cloneDeep(value, customizer, thisArg) {
      return typeof customizer == 'function'
        ? baseClone(value, true, bindCallback(customizer, thisArg, 1))
        : baseClone(value, true);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    function gt(value, other) {
      return value > other;
    }

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    function gte(value, other) {
      return value >= other;
    }

    /**
     * Checks if `value` is classified as an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return isObjectLike(value) && isArrayLike(value) &&
        hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
    }

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(function() { return arguments; }());
     * // => false
     */
    var isArray = nativeIsArray || function(value) {
      return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
    };

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
    }

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    function isDate(value) {
      return isObjectLike(value) && objToString.call(value) == dateTag;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
    }

    /**
     * Checks if `value` is empty. A value is considered empty unless it is an
     * `arguments` object, array, string, or jQuery-like collection with a length
     * greater than `0` or an object with own enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
          (isObjectLike(value) && isFunction(value.splice)))) {
        return !value.length;
      }
      return !keys(value).length;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent. If `customizer` is provided it is invoked to compare values.
     * If `customizer` returns `undefined` comparisons are handled by the method
     * instead. The `customizer` is bound to `thisArg` and invoked with three
     * arguments: (value, other [, index|key]).
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. Functions and DOM nodes
     * are **not** supported. Provide a customizer function to extend support
     * for comparing other values.
     *
     * @static
     * @memberOf _
     * @alias eq
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize value comparisons.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * object == other;
     * // => false
     *
     * _.isEqual(object, other);
     * // => true
     *
     * // using a customizer callback
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqual(array, other, function(value, other) {
     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
     *     return true;
     *   }
     * });
     * // => true
     */
    function isEqual(value, other, customizer, thisArg) {
      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return  result === undefined ? baseIsEqual(value, other, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(10);
     * // => true
     *
     * _.isFinite('10');
     * // => false
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite(Object(10));
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in older versions of Chrome and Safari which return 'function' for regexes
      // and Safari 8 equivalents which return 'object' for typed array constructors.
      return isObject(value) && objToString.call(value) == funcTag;
    }

    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // Avoid a V8 JIT bug in Chrome 19-20.
      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }

    /**
     * Performs a deep comparison between `object` and `source` to determine if
     * `object` contains equivalent property values. If `customizer` is provided
     * it is invoked to compare values. If `customizer` returns `undefined`
     * comparisons are handled by the method instead. The `customizer` is bound
     * to `thisArg` and invoked with three arguments: (value, other, index|key).
     *
     * **Note:** This method supports comparing properties of arrays, booleans,
     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
     * and DOM nodes are **not** supported. Provide a customizer function to extend
     * support for comparing other values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize value comparisons.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.isMatch(object, { 'age': 40 });
     * // => true
     *
     * _.isMatch(object, { 'age': 36 });
     * // => false
     *
     * // using a customizer callback
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatch(object, source, function(value, other) {
     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
     * });
     * // => true
     */
    function isMatch(object, source, customizer, thisArg) {
      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
      return baseIsMatch(object, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
     * which returns `true` for `undefined` and other non-numeric values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (value == null) {
        return false;
      }
      if (isFunction(value)) {
        return reIsNative.test(fnToString.call(value));
      }
      return isObjectLike(value) && reIsHostCtor.test(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
     * as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isNumber(8.4);
     * // => true
     *
     * _.isNumber(NaN);
     * // => true
     *
     * _.isNumber('8.4');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * **Note:** This method assumes objects created by the `Object` constructor
     * have no inherited enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      var Ctor;

      // Exit early for non `Object` objects.
      if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||
          (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
        return false;
      }
      // IE < 9 iterates inherited properties before own properties. If the first
      // iterated property is an object's own property then there are no inherited
      // enumerable properties.
      var result;
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      baseForIn(value, function(subValue, key) {
        result = key;
      });
      return result === undefined || hasOwnProperty.call(value, result);
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    function isRegExp(value) {
      return isObject(value) && objToString.call(value) == regexpTag;
    }

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    function isTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    function lt(value, other) {
      return value < other;
    }

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    function lte(value, other) {
      return value <= other;
    }

    /**
     * Converts `value` to an array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * (function() {
     *   return _.toArray(arguments).slice(1);
     * }(1, 2, 3));
     * // => [2, 3]
     */
    function toArray(value) {
      var length = value ? getLength(value) : 0;
      if (!isLength(length)) {
        return values(value);
      }
      if (!length) {
        return [];
      }
      return arrayCopy(value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable
     * properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return baseCopy(value, keysIn(value));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * overwrite property assignments of previous sources. If `customizer` is
     * provided it is invoked to produce the merged values of the destination and
     * source properties. If `customizer` returns `undefined` merging is handled
     * by the method instead. The `customizer` is bound to `thisArg` and invoked
     * with five arguments: (objectValue, sourceValue, key, object, source).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var users = {
     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
     * };
     *
     * var ages = {
     *   'data': [{ 'age': 36 }, { 'age': 40 }]
     * };
     *
     * _.merge(users, ages);
     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
     *
     * // using a customizer callback
     * var object = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var other = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(object, other, function(a, b) {
     *   if (_.isArray(a)) {
     *     return a.concat(b);
     *   }
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
     */
    var merge = createAssigner(baseMerge);

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources overwrite property assignments of previous sources.
     * If `customizer` is provided it is invoked to produce the assigned values.
     * The `customizer` is bound to `thisArg` and invoked with five arguments:
     * (objectValue, sourceValue, key, object, source).
     *
     * **Note:** This method mutates `object` and is based on
     * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
     *
     * @static
     * @memberOf _
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using a customizer callback
     * var defaults = _.partialRight(_.assign, function(value, other) {
     *   return _.isUndefined(value) ? other : value;
     * });
     *
     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var assign = createAssigner(function(object, source, customizer) {
      return customizer
        ? assignWith(object, source, customizer)
        : baseAssign(object, source);
    });

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties, guard) {
      var result = baseCreate(prototype);
      if (guard && isIterateeCall(prototype, properties, guard)) {
        properties = undefined;
      }
      return properties ? baseAssign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var defaults = createDefaults(assign, assignDefaults);

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
     * // => { 'user': { 'name': 'barney', 'age': 36 } }
     *
     */
    var defaultsDeep = createDefaults(merge, mergeDefaults);

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // using the `_.matches` callback shorthand
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    var findKey = createFindKey(baseForOwn);

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles` assuming `_.findKey` returns `barney`
     *
     * // using the `_.matches` callback shorthand
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    var findLastKey = createFindKey(baseForOwnRight);

    /**
     * Iterates over own and inherited enumerable properties of an object invoking
     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
     */
    var forIn = createForIn(baseFor);

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
     */
    var forInRight = createForIn(baseForRight);

    /**
     * Iterates over own enumerable properties of an object invoking `iteratee`
     * for each property. The `iteratee` is bound to `thisArg` and invoked with
     * three arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a' and 'b' (iteration order is not guaranteed)
     */
    var forOwn = createForOwn(baseForOwn);

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
     */
    var forOwnRight = createForOwn(baseForOwnRight);

    /**
     * Creates an array of function property names from all enumerable properties,
     * own and inherited, of `object`.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the new array of property names.
     * @example
     *
     * _.functions(_);
     * // => ['after', 'ary', 'assign', ...]
     */
    function functions(object) {
      return baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the property value at `path` of `object`. If the resolved value is
     * `undefined` the `defaultValue` is used in its place.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': { 'c': 3 } } };
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b.c');
     * // => true
     *
     * _.has(object, ['a', 'b', 'c']);
     * // => true
     */
    function has(object, path) {
      if (object == null) {
        return false;
      }
      var result = hasOwnProperty.call(object, path);
      if (!result && !isKey(path)) {
        path = toPath(path);
        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
        if (object == null) {
          return false;
        }
        path = last(path);
        result = hasOwnProperty.call(object, path);
      }
      return result || (isLength(object.length) && isIndex(path, object.length) &&
        (isArray(object) || isArguments(object)));
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite property
     * assignments of previous values unless `multiValue` is `true`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to invert.
     * @param {boolean} [multiValue] Allow multiple values per key.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     *
     * // with `multiValue`
     * _.invert(object, true);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function invert(object, multiValue, guard) {
      if (guard && isIterateeCall(object, multiValue, guard)) {
        multiValue = undefined;
      }
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index],
            value = object[key];

        if (multiValue) {
          if (hasOwnProperty.call(result, value)) {
            result[value].push(key);
          } else {
            result[value] = [key];
          }
        }
        else {
          result[value] = key;
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      var Ctor = object == null ? undefined : object.constructor;
      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
          (typeof object != 'function' && isArrayLike(object))) {
        return shimKeys(object);
      }
      return isObject(object) ? nativeKeys(object) : [];
    };

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      if (object == null) {
        return [];
      }
      if (!isObject(object)) {
        object = Object(object);
      }
      var length = object.length;
      length = (length && isLength(length) &&
        (isArray(object) || isArguments(object)) && length) || 0;

      var Ctor = object.constructor,
          index = -1,
          isProto = typeof Ctor == 'function' && Ctor.prototype === object,
          result = Array(length),
          skipIndexes = length > 0;

      while (++index < length) {
        result[index] = (index + '');
      }
      for (var key in object) {
        if (!(skipIndexes && isIndex(key, length)) &&
            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * property of `object` through `iteratee`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    var mapKeys = createObjectMapper(true);

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through `iteratee`. The
     * iteratee function is bound to `thisArg` and invoked with three arguments:
     * (value, key, object).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
     *   return n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * // using the `_.property` callback shorthand
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    var mapValues = createObjectMapper();

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable properties of `object` that are not omitted.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to omit, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.omit(object, 'age');
     * // => { 'user': 'fred' }
     *
     * _.omit(object, _.isNumber);
     * // => { 'user': 'fred' }
     */
    var omit = restParam(function(object, props) {
      if (object == null) {
        return {};
      }
      if (typeof props[0] != 'function') {
        var props = arrayMap(baseFlatten(props), String);
        return pickByArray(object, baseDifference(keysIn(object), props));
      }
      var predicate = bindCallback(props[0], props[1], 3);
      return pickByCallback(object, function(value, key, object) {
        return !predicate(value, key, object);
      });
    });

    /**
     * Creates a two dimensional array of the key-value pairs for `object`,
     * e.g. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
     */
    function pairs(object) {
      object = toObject(object);

      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates an object composed of the picked `object` properties. Property
     * names may be specified as individual arguments or as arrays of property
     * names. If `predicate` is provided it is invoked for each property of `object`
     * picking the properties `predicate` returns truthy for. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.pick(object, 'user');
     * // => { 'user': 'fred' }
     *
     * _.pick(object, _.isString);
     * // => { 'user': 'fred' }
     */
    var pick = restParam(function(object, props) {
      if (object == null) {
        return {};
      }
      return typeof props[0] == 'function'
        ? pickByCallback(object, bindCallback(props[0], props[1], 3))
        : pickByArray(object, baseFlatten(props));
    });

    /**
     * This method is like `_.get` except that if the resolved value is a function
     * it is invoked with the `this` binding of its parent object and its result
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a.b.c', 'default');
     * // => 'default'
     *
     * _.result(object, 'a.b.c', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      var result = object == null ? undefined : object[path];
      if (result === undefined) {
        if (object != null && !isKey(path, object)) {
          path = toPath(path);
          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
          result = object == null ? undefined : object[last(path)];
        }
        result = result === undefined ? defaultValue : result;
      }
      return isFunction(result) ? result.call(object) : result;
    }

    /**
     * Sets the property value of `path` on `object`. If a portion of `path`
     * does not exist it is created.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to augment.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, 'x[0].y.z', 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      if (object == null) {
        return object;
      }
      var pathKey = (path + '');
      path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = path[index];
        if (isObject(nested)) {
          if (index == lastIndex) {
            nested[key] = value;
          } else if (nested[key] == null) {
            nested[key] = isIndex(path[index + 1]) ? [] : {};
          }
        }
        nested = nested[key];
      }
      return object;
    }

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own enumerable
     * properties through `iteratee`, with each invocation potentially mutating
     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
     * with four arguments: (accumulator, value, key, object). Iteratee functions
     * may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * });
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     */
    function transform(object, iteratee, accumulator, thisArg) {
      var isArr = isArray(object) || isTypedArray(object);
      iteratee = getCallback(iteratee, thisArg, 4);

      if (accumulator == null) {
        if (isArr || isObject(object)) {
          var Ctor = object.constructor;
          if (isArr) {
            accumulator = isArray(object) ? new Ctor : [];
          } else {
            accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
          }
        } else {
          accumulator = {};
        }
      }
      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Creates an array of the own enumerable property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable property values
     * of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Checks if `n` is between `start` and up to but not including, `end`. If
     * `end` is not specified it is set to `start` with `start` then set to `0`.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} n The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     */
    function inRange(value, start, end) {
      start = +start || 0;
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      return value >= nativeMin(start, end) && value < nativeMax(start, end);
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number is returned.
     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
     * number is returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      if (floating && isIterateeCall(min, max, floating)) {
        max = floating = undefined;
      }
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (noMax && typeof min == 'boolean') {
          floating = min;
          min = 1;
        }
        else if (typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
        noMax = false;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar');
     * // => 'fooBar'
     *
     * _.camelCase('__foo_bar__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
    });

    /**
     * Capitalizes the first character of `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('fred');
     * // => 'Fred'
     */
    function capitalize(string) {
      string = baseToString(string);
      return string && (string.charAt(0).toUpperCase() + string.slice(1));
    }

    /**
     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dÃ©jÃ  vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = baseToString(string);
      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search from.
     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = baseToString(string);
      target = (target + '');

      var length = string.length;
      position = position === undefined
        ? length
        : nativeMin(position < 0 ? 0 : (+position || 0), length);

      position -= target.length;
      return position >= 0 && string.indexOf(target, position) == position;
    }

    /**
     * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
     * their corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional characters
     * use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value.
     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * Backticks are escaped because in Internet Explorer < 9, they can break out
     * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
     * for more details.
     *
     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
     * to reduce XSS vectors.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      // Reset `lastIndex` because in IE < 9 `String#replace` does not.
      string = baseToString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
     * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
     */
    function escapeRegExp(string) {
      string = baseToString(string);
      return (string && reHasRegExpChars.test(string))
        ? string.replace(reRegExpChars, escapeRegExpChar)
        : (string || '(?:)');
    }

    /**
     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__foo_bar__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = baseToString(string);
      length = +length;

      var strLength = string.length;
      if (strLength >= length || !nativeIsFinite(length)) {
        return string;
      }
      var mid = (length - strLength) / 2,
          leftLength = nativeFloor(mid),
          rightLength = nativeCeil(mid);

      chars = createPadding('', rightLength, chars);
      return chars.slice(0, leftLength) + string + chars;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padLeft('abc', 6);
     * // => '   abc'
     *
     * _.padLeft('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padLeft('abc', 3);
     * // => 'abc'
     */
    var padLeft = createPadDir();

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padRight('abc', 6);
     * // => 'abc   '
     *
     * _.padRight('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padRight('abc', 3);
     * // => 'abc'
     */
    var padRight = createPadDir(true);

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
     * in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
     * of `parseInt`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
      // Chrome fails to trim leading <BOM> whitespace characters.
      // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
      if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      string = trim(string);
      return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=0] The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n) {
      var result = '';
      string = baseToString(string);
      n = +n;
      if (n < 1 || !string || !nativeIsFinite(n)) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        string += string;
      } while (n);

      return result;
    }

    /**
     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--foo-bar');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__foo_bar__');
     * // => 'Foo Bar'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = baseToString(string);
      position = position == null
        ? 0
        : nativeMin(position < 0 ? 0 : (+position || 0), string.length);

      return string.lastIndexOf(target, position) == position;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is provided it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [options.variable] The data object variable name.
     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // using the HTML "escape" delimiter to escape data property values
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // using custom template delimiters
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using backslashes to treat delimiters as plain text
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // using the `imports` option to import `jQuery` as `jq`
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, otherOptions) {
      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (otherOptions && isIterateeCall(string, options, otherOptions)) {
        options = otherOptions = undefined;
      }
      string = baseToString(string);
      options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

      var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      var sourceURL = '//# sourceURL=' +
        ('sourceURL' in options
          ? options.sourceURL
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
      }
      chars = (chars + '');
      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimLeft('  abc  ');
     * // => 'abc  '
     *
     * _.trimLeft('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimLeft(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string));
      }
      return string.slice(charsLeftIndex(string, (chars + '')));
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimRight('  abc  ');
     * // => '  abc'
     *
     * _.trimRight('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimRight(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(0, trimmedRightIndex(string) + 1);
      }
      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object|number} [options] The options object or maximum string length.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.trunc('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', 24);
     * // => 'hi-diddly-ho there, n...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function trunc(string, options, guard) {
      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (options != null) {
        if (isObject(options)) {
          var separator = 'separator' in options ? options.separator : separator;
          length = 'length' in options ? (+options.length || 0) : length;
          omission = 'omission' in options ? baseToString(options.omission) : omission;
        } else {
          length = +options || 0;
        }
      }
      string = baseToString(string);
      if (length >= string.length) {
        return string;
      }
      var end = length - omission.length;
      if (end < 1) {
        return omission;
      }
      var result = string.slice(0, end);
      if (separator == null) {
        return result + omission;
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              newEnd,
              substring = string.slice(0, end);

          if (!separator.global) {
            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            newEnd = match.index;
          }
          result = result.slice(0, newEnd == null ? end : newEnd);
        }
      } else if (string.indexOf(separator, end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
     * corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
     * entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = baseToString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      if (guard && isIterateeCall(string, pattern, guard)) {
        pattern = undefined;
      }
      string = baseToString(string);
      return string.match(pattern || reWords) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function} func The function to attempt.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // avoid throwing errors for invalid selectors
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = restParam(function(func, args) {
      try {
        return func.apply(undefined, args);
      } catch(e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and arguments of the created function. If `func` is a property name the
     * created callback returns the property value for a given element. If `func`
     * is an object the created callback returns `true` for elements that contain
     * the equivalent object properties, otherwise it returns `false`.
     *
     * @static
     * @memberOf _
     * @alias iteratee
     * @category Utility
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
     *   if (!match) {
     *     return callback(func, thisArg);
     *   }
     *   return function(object) {
     *     return match[2] == 'gt'
     *       ? object[match[1]] > match[3]
     *       : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(users, 'age__gt36');
     * // => [{ 'user': 'fred', 'age': 40 }]
     */
    function callback(func, thisArg, guard) {
      if (guard && isIterateeCall(func, thisArg, guard)) {
        thisArg = undefined;
      }
      return isObjectLike(func)
        ? matches(func)
        : baseCallback(func, thisArg);
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var getter = _.constant(object);
     *
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that performs a deep comparison between a given object
     * and `source`, returning `true` if the given object has equivalent property
     * values, else `false`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, true));
    }

    /**
     * Creates a function that compares the property value of `path` on a given
     * object to `value`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * _.find(users, _.matchesProperty('user', 'fred'));
     * // => { 'user': 'fred' }
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, true));
    }

    /**
     * Creates a function that invokes the method at `path` on a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': { 'c': _.constant(2) } } },
     *   { 'a': { 'b': { 'c': _.constant(1) } } }
     * ];
     *
     * _.map(objects, _.method('a.b.c'));
     * // => [2, 1]
     *
     * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
     * // => [1, 2]
     */
    var method = restParam(function(path, args) {
      return function(object) {
        return invokePath(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path on `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = restParam(function(object, args) {
      return function(path) {
        return invokePath(object, path, args);
      };
    });

    /**
     * Adds all own enumerable function properties of a source object to the
     * destination object. If `object` is a function then methods are added to
     * its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added
     *  are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      if (options == null) {
        var isObj = isObject(source),
            props = isObj ? keys(source) : undefined,
            methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;

        if (!(methodNames ? methodNames.length : isObj)) {
          methodNames = false;
          options = source;
          source = object;
          object = this;
        }
      }
      if (!methodNames) {
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = true,
          index = -1,
          isFunc = isFunction(object),
          length = methodNames.length;

      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      while (++index < length) {
        var methodName = methodNames[index],
            func = source[methodName];

        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = (function(func) {
            return function() {
              var chainAll = this.__chain__;
              if (chain || chainAll) {
                var result = object(this.__wrapped__),
                    actions = result.__actions__ = arrayCopy(this.__actions__);

                actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                result.__chain__ = chainAll;
                return result;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }(func));
        }
      }
      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      root._ = oldDash;
      return this;
    }

    /**
     * A no-operation function that returns `undefined` regardless of the
     * arguments it receives.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that returns the property value at `path` on a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': { 'c': 2 } } },
     *   { 'a': { 'b': { 'c': 1 } } }
     * ];
     *
     * _.map(objects, _.property('a.b.c'));
     * // => [2, 1]
     *
     * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the property value at a given path on `object`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return baseGet(object, toPath(path), path + '');
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. If `end` is not specified it is
     * set to `start` with `start` then set to `0`. If `end` is less than `start`
     * a zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the new array of numbers.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      if (step && isIterateeCall(start, end, step)) {
        end = step = undefined;
      }
      start = +start || 0;
      step = step == null ? 1 : (+step || 0);

      if (end == null) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Invokes the iteratee function `n` times, returning an array of the results
     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
     * one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) {
     *   mage.castSpell(n);
     * });
     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`
     *
     * _.times(3, function(n) {
     *   this.cast(n);
     * }, mage);
     * // => also invokes `mage.castSpell(n)` three times
     */
    function times(n, iteratee, thisArg) {
      n = nativeFloor(n);

      // Exit early to avoid a JSC JIT bug in Safari 8
      // where `Array(0)` is treated as `Array(1)`.
      if (n < 1 || !nativeIsFinite(n)) {
        return [];
      }
      var index = -1,
          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

      iteratee = bindCallback(iteratee, thisArg, 1);
      while (++index < n) {
        if (index < MAX_ARRAY_LENGTH) {
          result[index] = iteratee(index);
        } else {
          iteratee(index);
        }
      }
      return result;
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return baseToString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} augend The first number to add.
     * @param {number} addend The second number to add.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    function add(augend, addend) {
      return (+augend || 0) + (+addend || 0);
    }

    /**
     * Calculates `n` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Calculates `n` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Gets the maximum value of `collection`. If `collection` is empty or falsey
     * `-Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => -Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.max(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using the `_.property` callback shorthand
     * _.max(users, 'age');
     * // => { 'user': 'fred', 'age': 40 }
     */
    var max = createExtremum(gt, NEGATIVE_INFINITY);

    /**
     * Gets the minimum value of `collection`. If `collection` is empty or falsey
     * `Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.min(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // using the `_.property` callback shorthand
     * _.min(users, 'age');
     * // => { 'user': 'barney', 'age': 36 }
     */
    var min = createExtremum(lt, POSITIVE_INFINITY);

    /**
     * Calculates `n` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Gets the sum of the values in `collection`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 6]);
     * // => 10
     *
     * _.sum({ 'a': 4, 'b': 6 });
     * // => 10
     *
     * var objects = [
     *   { 'n': 4 },
     *   { 'n': 6 }
     * ];
     *
     * _.sum(objects, function(object) {
     *   return object.n;
     * });
     * // => 10
     *
     * // using the `_.property` callback shorthand
     * _.sum(objects, 'n');
     * // => 10
     */
    function sum(collection, iteratee, thisArg) {
      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = undefined;
      }
      iteratee = getCallback(iteratee, thisArg, 3);
      return iteratee.length == 1
        ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)
        : baseSum(collection, iteratee);
    }

    /*------------------------------------------------------------------------*/

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    // Add functions to the `Map` cache.
    MapCache.prototype['delete'] = mapDelete;
    MapCache.prototype.get = mapGet;
    MapCache.prototype.has = mapHas;
    MapCache.prototype.set = mapSet;

    // Add functions to the `Set` cache.
    SetCache.prototype.push = cachePush;

    // Assign cache to `_.memoize`.
    memoize.Cache = MapCache;

    // Add functions that return wrapped values when chaining.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.callback = callback;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.modArgs = modArgs;
    lodash.negate = negate;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.restParam = restParam;
    lodash.set = set;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortByAll = sortByAll;
    lodash.sortByOrder = sortByOrder;
    lodash.spread = spread;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.backflow = flowRight;
    lodash.collect = map;
    lodash.compose = flowRight;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.iteratee = callback;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;

    // Add functions to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add functions that return unwrapped values when chaining.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.deburr = deburr;
    lodash.endsWith = endsWith;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.findWhere = findWhere;
    lodash.first = first;
    lodash.floor = floor;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isMatch = isMatch;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.min = min;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padLeft = padLeft;
    lodash.padRight = padRight;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.sum = sum;
    lodash.template = template;
    lodash.trim = trim;
    lodash.trimLeft = trimLeft;
    lodash.trimRight = trimRight;
    lodash.trunc = trunc;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.words = words;

    // Add aliases.
    lodash.all = every;
    lodash.any = some;
    lodash.contains = includes;
    lodash.eq = isEqual;
    lodash.detect = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.head = first;
    lodash.include = includes;
    lodash.inject = reduce;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }()), false);

    /*------------------------------------------------------------------------*/

    // Add functions capable of returning wrapped and unwrapped values when chaining.
    lodash.sample = sample;

    lodash.prototype.sample = function(n) {
      if (!this.__chain__ && n == null) {
        return sample(this.value());
      }
      return this.thru(function(value) {
        return sample(value, n);
      });
    };

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        var filtered = this.__filtered__;
        if (filtered && !index) {
          return new LazyWrapper(this);
        }
        n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);

        var result = this.clone();
        if (filtered) {
          result.__takeCount__ = nativeMin(result.__takeCount__, n);
        } else {
          result.__views__.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type != LAZY_MAP_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
        var result = this.clone();
        result.__iteratees__.push({ 'iteratee': getCallback(iteratee, thisArg, 1), 'type': type });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.first` and `_.last`.
    arrayEach(['first', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
    arrayEach(['initial', 'rest'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
    arrayEach(['pluck', 'where'], function(methodName, index) {
      var operationName = index ? 'filter' : 'map',
          createCallback = index ? baseMatches : property;

      LazyWrapper.prototype[methodName] = function(value) {
        return this[operationName](createCallback(value));
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.reject = function(predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 1);
      return this.filter(function(value) {
        return !predicate(value);
      });
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = start == null ? 0 : (+start || 0);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = (+end || 0);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
      return this.reverse().takeWhile(predicate, thisArg).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(POSITIVE_INFINITY);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
          retUnwrapped = /^(?:first|last)$/.test(methodName),
          lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var args = retUnwrapped ? [1] : arguments,
            chainAll = this.__chain__,
            value = this.__wrapped__,
            isHybrid = !!this.__actions__.length,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var interceptor = function(value) {
          return (retUnwrapped && chainAll)
            ? lodashFunc(value, 1)[0]
            : lodashFunc.apply(undefined, arrayPush([value], args));
        };

        var action = { 'func': thru, 'args': [interceptor], 'thisArg': undefined },
            onlyLazy = isLazy && !isHybrid;

        if (retUnwrapped && !chainAll) {
          if (onlyLazy) {
            value = value.clone();
            value.__actions__.push(action);
            return func.call(value);
          }
          return lodashFunc.call(undefined, this.value())[0];
        }
        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push(action);
          return new LodashWrapper(result, chainAll);
        }
        return this.thru(interceptor);
      };
    });

    // Add `Array` and `String` methods to `lodash.prototype`.
    arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
      var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          return func.apply(this.value(), args);
        }
        return this[chainName](function(value) {
          return func.apply(value, args);
        });
      };
    });

    // Map minified function names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name,
            names = realNames[key] || (realNames[key] = []);

        names.push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];

    // Add functions to the lazy wrapper.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chaining functions to the `lodash` wrapper.
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.concat = wrapperConcat;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add function aliases to the `lodash` wrapper.
    lodash.prototype.collect = lodash.prototype.map;
    lodash.prototype.head = lodash.prototype.first;
    lodash.prototype.select = lodash.prototype.filter;
    lodash.prototype.tail = lodash.prototype.rest;

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose lodash to the global object when an AMD loader is present to avoid
    // errors in cases where lodash is loaded by a script tag and not intended
    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
    // more details.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else if (freeExports && freeModule) {
    // Export for Node.js or RingoJS.
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // Export for Rhino with CommonJS support.
    else {
      freeExports._ = _;
    }
  }
  else {
    // Export for a browser or Rhino.
    root._ = _;
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],6:[function(require,module,exports){
'use strict';

module.exports = require('./lib')

},{"./lib":11}],7:[function(require,module,exports){
'use strict';

var asap = require('asap/raw');

function noop() {}

// States:
//
// 0 - pending
// 1 - fulfilled with _value
// 2 - rejected with _value
// 3 - adopted the state of another promise, _value
//
// once the state is no longer pending (0) it is immutable

// All `_` prefixed properties will be reduced to `_{random number}`
// at build time to obfuscate them and discourage their use.
// We don't use symbols or Object.defineProperty to fully hide them
// because the performance isn't good enough.


// to avoid using try/catch inside critical functions, we
// extract them to here.
var LAST_ERROR = null;
var IS_ERROR = {};
function getThen(obj) {
  try {
    return obj.then;
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}

function tryCallOne(fn, a) {
  try {
    return fn(a);
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}
function tryCallTwo(fn, a, b) {
  try {
    fn(a, b);
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}

module.exports = Promise;

function Promise(fn) {
  if (typeof this !== 'object') {
    throw new TypeError('Promises must be constructed via new');
  }
  if (typeof fn !== 'function') {
    throw new TypeError('Promise constructor\'s argument is not a function');
  }
  this._40 = 0;
  this._65 = 0;
  this._55 = null;
  this._72 = null;
  if (fn === noop) return;
  doResolve(fn, this);
}
Promise._37 = null;
Promise._87 = null;
Promise._61 = noop;

Promise.prototype.then = function(onFulfilled, onRejected) {
  if (this.constructor !== Promise) {
    return safeThen(this, onFulfilled, onRejected);
  }
  var res = new Promise(noop);
  handle(this, new Handler(onFulfilled, onRejected, res));
  return res;
};

function safeThen(self, onFulfilled, onRejected) {
  return new self.constructor(function (resolve, reject) {
    var res = new Promise(noop);
    res.then(resolve, reject);
    handle(self, new Handler(onFulfilled, onRejected, res));
  });
}
function handle(self, deferred) {
  while (self._65 === 3) {
    self = self._55;
  }
  if (Promise._37) {
    Promise._37(self);
  }
  if (self._65 === 0) {
    if (self._40 === 0) {
      self._40 = 1;
      self._72 = deferred;
      return;
    }
    if (self._40 === 1) {
      self._40 = 2;
      self._72 = [self._72, deferred];
      return;
    }
    self._72.push(deferred);
    return;
  }
  handleResolved(self, deferred);
}

function handleResolved(self, deferred) {
  asap(function() {
    var cb = self._65 === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      if (self._65 === 1) {
        resolve(deferred.promise, self._55);
      } else {
        reject(deferred.promise, self._55);
      }
      return;
    }
    var ret = tryCallOne(cb, self._55);
    if (ret === IS_ERROR) {
      reject(deferred.promise, LAST_ERROR);
    } else {
      resolve(deferred.promise, ret);
    }
  });
}
function resolve(self, newValue) {
  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
  if (newValue === self) {
    return reject(
      self,
      new TypeError('A promise cannot be resolved with itself.')
    );
  }
  if (
    newValue &&
    (typeof newValue === 'object' || typeof newValue === 'function')
  ) {
    var then = getThen(newValue);
    if (then === IS_ERROR) {
      return reject(self, LAST_ERROR);
    }
    if (
      then === self.then &&
      newValue instanceof Promise
    ) {
      self._65 = 3;
      self._55 = newValue;
      finale(self);
      return;
    } else if (typeof then === 'function') {
      doResolve(then.bind(newValue), self);
      return;
    }
  }
  self._65 = 1;
  self._55 = newValue;
  finale(self);
}

function reject(self, newValue) {
  self._65 = 2;
  self._55 = newValue;
  if (Promise._87) {
    Promise._87(self, newValue);
  }
  finale(self);
}
function finale(self) {
  if (self._40 === 1) {
    handle(self, self._72);
    self._72 = null;
  }
  if (self._40 === 2) {
    for (var i = 0; i < self._72.length; i++) {
      handle(self, self._72[i]);
    }
    self._72 = null;
  }
}

function Handler(onFulfilled, onRejected, promise){
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, promise) {
  var done = false;
  var res = tryCallTwo(fn, function (value) {
    if (done) return;
    done = true;
    resolve(promise, value);
  }, function (reason) {
    if (done) return;
    done = true;
    reject(promise, reason);
  });
  if (!done && res === IS_ERROR) {
    done = true;
    reject(promise, LAST_ERROR);
  }
}

},{"asap/raw":2}],8:[function(require,module,exports){
'use strict';

var Promise = require('./core.js');

module.exports = Promise;
Promise.prototype.done = function (onFulfilled, onRejected) {
  var self = arguments.length ? this.then.apply(this, arguments) : this;
  self.then(null, function (err) {
    setTimeout(function () {
      throw err;
    }, 0);
  });
};

},{"./core.js":7}],9:[function(require,module,exports){
'use strict';

//This file contains the ES6 extensions to the core Promises/A+ API

var Promise = require('./core.js');

module.exports = Promise;

/* Static Functions */

var TRUE = valuePromise(true);
var FALSE = valuePromise(false);
var NULL = valuePromise(null);
var UNDEFINED = valuePromise(undefined);
var ZERO = valuePromise(0);
var EMPTYSTRING = valuePromise('');

function valuePromise(value) {
  var p = new Promise(Promise._61);
  p._65 = 1;
  p._55 = value;
  return p;
}
Promise.resolve = function (value) {
  if (value instanceof Promise) return value;

  if (value === null) return NULL;
  if (value === undefined) return UNDEFINED;
  if (value === true) return TRUE;
  if (value === false) return FALSE;
  if (value === 0) return ZERO;
  if (value === '') return EMPTYSTRING;

  if (typeof value === 'object' || typeof value === 'function') {
    try {
      var then = value.then;
      if (typeof then === 'function') {
        return new Promise(then.bind(value));
      }
    } catch (ex) {
      return new Promise(function (resolve, reject) {
        reject(ex);
      });
    }
  }
  return valuePromise(value);
};

Promise.all = function (arr) {
  var args = Array.prototype.slice.call(arr);

  return new Promise(function (resolve, reject) {
    if (args.length === 0) return resolve([]);
    var remaining = args.length;
    function res(i, val) {
      if (val && (typeof val === 'object' || typeof val === 'function')) {
        if (val instanceof Promise && val.then === Promise.prototype.then) {
          while (val._65 === 3) {
            val = val._55;
          }
          if (val._65 === 1) return res(i, val._55);
          if (val._65 === 2) reject(val._55);
          val.then(function (val) {
            res(i, val);
          }, reject);
          return;
        } else {
          var then = val.then;
          if (typeof then === 'function') {
            var p = new Promise(then.bind(val));
            p.then(function (val) {
              res(i, val);
            }, reject);
            return;
          }
        }
      }
      args[i] = val;
      if (--remaining === 0) {
        resolve(args);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise.reject = function (value) {
  return new Promise(function (resolve, reject) {
    reject(value);
  });
};

Promise.race = function (values) {
  return new Promise(function (resolve, reject) {
    values.forEach(function(value){
      Promise.resolve(value).then(resolve, reject);
    });
  });
};

/* Prototype Methods */

Promise.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
};

},{"./core.js":7}],10:[function(require,module,exports){
'use strict';

var Promise = require('./core.js');

module.exports = Promise;
Promise.prototype['finally'] = function (f) {
  return this.then(function (value) {
    return Promise.resolve(f()).then(function () {
      return value;
    });
  }, function (err) {
    return Promise.resolve(f()).then(function () {
      throw err;
    });
  });
};

},{"./core.js":7}],11:[function(require,module,exports){
'use strict';

module.exports = require('./core.js');
require('./done.js');
require('./finally.js');
require('./es6-extensions.js');
require('./node-extensions.js');
require('./synchronous.js');

},{"./core.js":7,"./done.js":8,"./es6-extensions.js":9,"./finally.js":10,"./node-extensions.js":12,"./synchronous.js":13}],12:[function(require,module,exports){
'use strict';

// This file contains then/promise specific extensions that are only useful
// for node.js interop

var Promise = require('./core.js');
var asap = require('asap');

module.exports = Promise;

/* Static Functions */

Promise.denodeify = function (fn, argumentCount) {
  if (
    typeof argumentCount === 'number' && argumentCount !== Infinity
  ) {
    return denodeifyWithCount(fn, argumentCount);
  } else {
    return denodeifyWithoutCount(fn);
  }
};

var callbackFn = (
  'function (err, res) {' +
  'if (err) { rj(err); } else { rs(res); }' +
  '}'
);
function denodeifyWithCount(fn, argumentCount) {
  var args = [];
  for (var i = 0; i < argumentCount; i++) {
    args.push('a' + i);
  }
  var body = [
    'return function (' + args.join(',') + ') {',
    'var self = this;',
    'return new Promise(function (rs, rj) {',
    'var res = fn.call(',
    ['self'].concat(args).concat([callbackFn]).join(','),
    ');',
    'if (res &&',
    '(typeof res === "object" || typeof res === "function") &&',
    'typeof res.then === "function"',
    ') {rs(res);}',
    '});',
    '};'
  ].join('');
  return Function(['Promise', 'fn'], body)(Promise, fn);
}
function denodeifyWithoutCount(fn) {
  var fnLength = Math.max(fn.length - 1, 3);
  var args = [];
  for (var i = 0; i < fnLength; i++) {
    args.push('a' + i);
  }
  var body = [
    'return function (' + args.join(',') + ') {',
    'var self = this;',
    'var args;',
    'var argLength = arguments.length;',
    'if (arguments.length > ' + fnLength + ') {',
    'args = new Array(arguments.length + 1);',
    'for (var i = 0; i < arguments.length; i++) {',
    'args[i] = arguments[i];',
    '}',
    '}',
    'return new Promise(function (rs, rj) {',
    'var cb = ' + callbackFn + ';',
    'var res;',
    'switch (argLength) {',
    args.concat(['extra']).map(function (_, index) {
      return (
        'case ' + (index) + ':' +
        'res = fn.call(' + ['self'].concat(args.slice(0, index)).concat('cb').join(',') + ');' +
        'break;'
      );
    }).join(''),
    'default:',
    'args[argLength] = cb;',
    'res = fn.apply(self, args);',
    '}',
    
    'if (res &&',
    '(typeof res === "object" || typeof res === "function") &&',
    'typeof res.then === "function"',
    ') {rs(res);}',
    '});',
    '};'
  ].join('');

  return Function(
    ['Promise', 'fn'],
    body
  )(Promise, fn);
}

Promise.nodeify = function (fn) {
  return function () {
    var args = Array.prototype.slice.call(arguments);
    var callback =
      typeof args[args.length - 1] === 'function' ? args.pop() : null;
    var ctx = this;
    try {
      return fn.apply(this, arguments).nodeify(callback, ctx);
    } catch (ex) {
      if (callback === null || typeof callback == 'undefined') {
        return new Promise(function (resolve, reject) {
          reject(ex);
        });
      } else {
        asap(function () {
          callback.call(ctx, ex);
        })
      }
    }
  }
};

Promise.prototype.nodeify = function (callback, ctx) {
  if (typeof callback != 'function') return this;

  this.then(function (value) {
    asap(function () {
      callback.call(ctx, null, value);
    });
  }, function (err) {
    asap(function () {
      callback.call(ctx, err);
    });
  });
};

},{"./core.js":7,"asap":1}],13:[function(require,module,exports){
'use strict';

var Promise = require('./core.js');

module.exports = Promise;
Promise.enableSynchronous = function () {
  Promise.prototype.isPending = function() {
    return this.getState() == 0;
  };

  Promise.prototype.isFulfilled = function() {
    return this.getState() == 1;
  };

  Promise.prototype.isRejected = function() {
    return this.getState() == 2;
  };

  Promise.prototype.getValue = function () {
    if (this._65 === 3) {
      return this._55.getValue();
    }

    if (!this.isFulfilled()) {
      throw new Error('Cannot get a value of an unfulfilled promise.');
    }

    return this._55;
  };

  Promise.prototype.getReason = function () {
    if (this._65 === 3) {
      return this._55.getReason();
    }

    if (!this.isRejected()) {
      throw new Error('Cannot get a rejection reason of a non-rejected promise.');
    }

    return this._55;
  };

  Promise.prototype.getState = function () {
    if (this._65 === 3) {
      return this._55.getState();
    }
    if (this._65 === -1 || this._65 === -2) {
      return 0;
    }

    return this._65;
  };
};

Promise.disableSynchronous = function() {
  Promise.prototype.isPending = undefined;
  Promise.prototype.isFulfilled = undefined;
  Promise.prototype.isRejected = undefined;
  Promise.prototype.getValue = undefined;
  Promise.prototype.getReason = undefined;
  Promise.prototype.getState = undefined;
};

},{"./core.js":7}],14:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],15:[function(require,module,exports){
'use strict';

var replace = String.prototype.replace;
var percentTwenties = /%20/g;

module.exports = {
    'default': 'RFC3986',
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return value;
        }
    },
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

},{}],16:[function(require,module,exports){
'use strict';

var stringify = require('./stringify');
var parse = require('./parse');
var formats = require('./formats');

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};

},{"./formats":15,"./parse":17,"./stringify":18}],17:[function(require,module,exports){
'use strict';

var utils = require('./utils');

var has = Object.prototype.hasOwnProperty;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    parameterLimit: 1000,
    plainObjects: false,
    strictNullHandling: false
};

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);

    for (var i = 0; i < parts.length; ++i) {
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder);
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder);
            val = options.decoder(part.slice(pos + 1), defaults.decoder);
        }
        if (has.call(obj, key)) {
            obj[key] = [].concat(obj[key]).concat(val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function parseObjectRecursive(chain, val, options) {
    if (!chain.length) {
        return val;
    }

    var root = chain.shift();

    var obj;
    if (root === '[]') {
        obj = [];
        obj = obj.concat(parseObject(chain, val, options));
    } else {
        obj = options.plainObjects ? Object.create(null) : {};
        var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
        var index = parseInt(cleanRoot, 10);
        if (
            !isNaN(index)
            && root !== cleanRoot
            && String(index) === cleanRoot
            && index >= 0
            && (options.parseArrays && index <= options.arrayLimit)
        ) {
            obj = [];
            obj[index] = parseObject(chain, val, options);
        } else {
            obj[cleanRoot] = parseObject(chain, val, options);
        }
    }

    return obj;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys
        // that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options);
};

module.exports = function (str, opts) {
    var options = opts ? utils.assign({}, opts) : {};

    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
    options.delimiter = typeof options.delimiter === 'string' || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;
    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;
    options.parseArrays = options.parseArrays !== false;
    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;
    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;
    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;
    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;
    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;
    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};

},{"./utils":19}],18:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var formats = require('./formats');

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) { // eslint-disable-line func-name-matching
        return prefix + '[]';
    },
    indices: function indices(prefix, key) { // eslint-disable-line func-name-matching
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) { // eslint-disable-line func-name-matching
        return prefix;
    }
};

var toISO = Date.prototype.toISOString;

var defaults = {
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var stringify = function stringify( // eslint-disable-line func-name-matching
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    formatter,
    encodeValuesOnly
) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;
        }

        obj = '';
    }

    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (Array.isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        if (Array.isArray(obj)) {
            values = values.concat(stringify(
                obj[key],
                generateArrayPrefix(prefix, key),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        } else {
            values = values.concat(stringify(
                obj[key],
                prefix + (allowDots ? '.' + key : '[' + key + ']'),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        }
    }

    return values;
};

module.exports = function (object, opts) {
    var obj = object;
    var options = opts ? utils.assign({}, opts) : {};

    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;
    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;
    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;
    var encoder = typeof options.encoder === 'function' ? options.encoder : defaults.encoder;
    var sort = typeof options.sort === 'function' ? options.sort : null;
    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
    var serializeDate = typeof options.serializeDate === 'function' ? options.serializeDate : defaults.serializeDate;
    var encodeValuesOnly = typeof options.encodeValuesOnly === 'boolean' ? options.encodeValuesOnly : defaults.encodeValuesOnly;
    if (typeof options.format === 'undefined') {
        options.format = formats.default;
    } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {
        throw new TypeError('Unknown format option provided.');
    }
    var formatter = formats.formatters[options.format];
    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (Array.isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (options.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = options.arrayFormat;
    } else if ('indices' in options) {
        arrayFormat = options.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (sort) {
        objKeys.sort(sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        keys = keys.concat(stringify(
            obj[key],
            key,
            generateArrayPrefix,
            strictNullHandling,
            skipNulls,
            encode ? encoder : null,
            filter,
            sort,
            allowDots,
            serializeDate,
            formatter,
            encodeValuesOnly
        ));
    }

    var joined = keys.join(delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    return joined.length > 0 ? prefix + joined : '';
};

},{"./formats":15,"./utils":19}],19:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

exports.arrayToObject = function (source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

exports.merge = function (target, source, options) {
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (Array.isArray(target)) {
            target.push(source);
        } else if (typeof target === 'object') {
            if (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (Array.isArray(target) && !Array.isArray(source)) {
        mergeTarget = exports.arrayToObject(target, options);
    }

    if (Array.isArray(target) && Array.isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                if (target[i] && typeof target[i] === 'object') {
                    target[i] = exports.merge(target[i], item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = exports.merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

exports.assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

exports.decode = function (str) {
    try {
        return decodeURIComponent(str.replace(/\+/g, ' '));
    } catch (e) {
        return str;
    }
};

exports.encode = function (str) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = typeof str === 'string' ? str : String(str);

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D    // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

exports.compact = function (obj, references) {
    if (typeof obj !== 'object' || obj === null) {
        return obj;
    }

    var refs = references || [];
    var lookup = refs.indexOf(obj);
    if (lookup !== -1) {
        return refs[lookup];
    }

    refs.push(obj);

    if (Array.isArray(obj)) {
        var compacted = [];

        for (var i = 0; i < obj.length; ++i) {
            if (obj[i] && typeof obj[i] === 'object') {
                compacted.push(exports.compact(obj[i], refs));
            } else if (typeof obj[i] !== 'undefined') {
                compacted.push(obj[i]);
            }
        }

        return compacted;
    }

    var keys = Object.keys(obj);
    keys.forEach(function (key) {
        obj[key] = exports.compact(obj[key], refs);
    });

    return obj;
};

exports.isRegExp = function (obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

exports.isBuffer = function (obj) {
    if (obj === null || typeof obj === 'undefined') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

},{}],20:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],21:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],22:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":20,"./encode":21}],23:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":24,"punycode":14,"querystring":22}],24:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],25:[function(require,module,exports){
'use strict';
var ValidationRules = function(){};
ValidationRules.prototype.guestOrderFormRules = function() {
    var obj = {
        rules: {
            "dwfrm_guestorderhistory_orderNumber": {
                required: true,
                number: true
            },
            "dwfrm_guestorderhistory_orderEmail": {
                email: true,
                required: true
            },
            "dwfrm_guestorderhistory_postalCode": {
                required: true,
                number: true,
                minlength: 5,
                maxlength: 15
            }

        },
        messages: {
            "dwfrm_guestorderhistory_orderEmail": {
                required: Resources.VALIDATE_EMAIL,
                email: Resources.VALIDATE_EMAIL
            },
            "dwfrm_guestorderhistory_postalCode": {
                required: Resources.VALIDATE_POSTAL,
                number: Resources.VALIDATE_POSTAL,
                minlength: Resources.VALIDATE_POSTAL,
                maxlength: Resources.VALIDATE_POSTAL
            },
            "dwfrm_guestorderhistory_orderNumber": {
                required: Resources.VALIDATE_ORDERNUMBER,
                number: Resources.VALIDATE_ORDERNUMBER
            }
        },
        errorClass : 'error',
        errorElement : 'span',
        ignore: ":hidden:not(.replaced)",
        onkeyup : false,
        onfocusout : function (element) {
            if(!this.checkable(element)) {
                this.element(element);
            }
        },
        highlight : function(element, errorClass, validClass) {
            if (element.type === 'radio') {
                this.findByName(element.name).addClass(errorClass).removeClass(validClass);
            } else {
                $(element).addClass(errorClass).removeClass(validClass);
                if(element.type === 'select-one'){
                    var $element = $(element);
                    if($element.attr('id') && $element.hasClass('replaced')){
                        var selectBox = $('#' + $element.attr('id') + 'SelectBoxItContainer');
                        if(selectBox){
                            selectBox.addClass(errorClass).removeClass(validClass);
                        }
                    }
                }
            }
        },
        unhighlight : function(element, errorClass, validClass) {
            if (element.type === 'radio') {
                this.findByName(element.name).removeClass(errorClass).addClass(validClass);
            } else {
                $(element).removeClass(errorClass).addClass(validClass);
                if(element.type === 'select-one'){
                    var $element = $(element);
                    if($element.attr('id') && $element.hasClass('replaced')){
                        var selectBox = $('#' + $element.attr('id') + 'SelectBoxItContainer');
                        if(selectBox){
                            selectBox.removeClass(errorClass).addClass(validClass);
                        }
                    }
                }
            }
        },
        showErrors: function (errorMap, errorList) {
            this.defaultShowErrors();
        }
    }
    
    return obj;
}
module.exports = ValidationRules;

},{}],26:[function(require,module,exports){
'use strict';

var progress = require('./progress'),
    util = require('./util');

var currentRequests = [];

/**
 * @function
 * @description Ajax request to get json response
 * @param {Boolean} async  Asynchronous or not
 * @param {String} url URI for the request
 * @param {Object} data Name/Value pair data request
 * @param {Function} callback  Callback function to be called
 */
var getJson = function (options) {
    options.url = util.toAbsoluteUrl(options.url);
    // return if no url exists or url matches a current request
    if (!options.url || currentRequests[options.url]) {
        return;
    }

    currentRequests[options.url] = true;

    // make the server call
    $.ajax({
        dataType: 'json',
        url: options.url,
        async: (typeof options.async === 'undefined' || options.async === null) ? true : options.async,
        data: options.data || {}
    })
    // success
    .done(function (response) {
        if (options.callback) {
            options.callback(response);
        }
    })
    // failed
    .fail(function (xhr, textStatus) {
        if (textStatus === 'parsererror') {
        }
        if (options.callback) {
            options.callback(null);
        }
    })
    // executed on success or fail
    .always(function () {
        // remove current request from hash
        if (currentRequests[options.url]) {
            delete currentRequests[options.url];
        }
    });
};
/**
 * @function
 * @description ajax request to load html response in a given container
 * @param {String} url URI for the request
 * @param {Object} data Name/Value pair data request
 * @param {Function} callback  Callback function to be called
 * @param {Object} target Selector or element that will receive content
 */
var load = function (options) {
    options.url = util.toAbsoluteUrl(options.url);
    // return if no url exists or url matches a current request
    if (!options.url || currentRequests[options.url]) {
        return;
    }

    currentRequests[options.url] = true;

    // make the server call
    $.ajax({
        dataType: 'html',
        url: util.appendParamToURL(options.url, 'format', 'ajax'),
        data: options.data,
        xhrFields: {
            withCredentials: true
        }
    })
    .done(function (response) {
        // success
        if (options.target) {
            $(options.target).empty().html(response);
        }
        if (options.callback) {
            options.callback(response);
        }
    })
    .fail(function (xhr, textStatus) {
        // failed
        if (textStatus === 'parsererror') {
        }
        options.callback(null, textStatus);
    })
    .always(function () {
        progress.hide();
        // remove current request from hash
        if (currentRequests[options.url]) {
            delete currentRequests[options.url];
        }
    });
};

exports.getJson = getJson;
exports.load = load;

},{"./progress":68,"./util":82}],27:[function(require,module,exports){
/**
 *    (c) 2009-2014 Demandware Inc.
 *    Subject to standard usage terms and conditions
 *    For all details and documentation:
 *    https://bitbucket.com/demandware/sitegenesis
 */

'use strict';

// if jQuery has not been loaded, load from google cdn
if (!window.jQuery) {
    var s = document.createElement('script');
    s.setAttribute('src', 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js');
    s.setAttribute('type', 'text/javascript');
    document.getElementsByTagName('head')[0].appendChild(s);
}

require('./jquery-ext')();
require('./cookieprivacy')();
require('./captcha')();
var util = require('./util');
var ValidationRules = require('./ValidationRules');

function initializeEvents() {
    var controlKeys = ['8', '13', '46', '45', '36', '35', '38', '37', '40', '39'];

    window.addEventListener('orientationchange', function() {
	  document.getElementById('wrapper').classList.remove('menu-active')
	  document.getElementsByTagName('body')[0].classList.remove('menu-active')
	})
    
    $("body").on("click", ".dialogify, [data-dlg-options], [data-dlg-action]", app.util.setDialogify);
    $('body')
        .on('keydown', 'textarea[data-character-limit]', function (e) {
            var text = $.trim($(this).val()),
                charsLimit = $(this).data('character-limit'),
                charsUsed = text.length;

            if ((charsUsed >= charsLimit) && (controlKeys.indexOf(e.which.toString()) < 0)) {
                e.preventDefault();
            }
        }).on('click','#BVRRRatingSummaryLinkReadID', function(e){
            e.preventDefault();
            $(this).find('a').toggleClass('active').removeAttr('onclick');
            $('#BVRRDisplayContentID').toggleClass('open');

        })
        .on('change keyup mouseup', 'textarea[data-character-limit]', function () {
            var text = $.trim($(this).val()),
                charsLimit = $(this).data('character-limit'),
                charsUsed = text.length,
                charsRemain = charsLimit - charsUsed;

            if (charsRemain < 0) {
                $(this).val(text.slice(0, charsRemain));
                charsRemain = 0;
            }

            $(this).next('div.char-count').find('.char-remain-count').html(charsRemain);
        })
        .on('change', '#registry-search-container select', function (){
        	if ($(this).val()) {
        		$(this).parent().addClass('selected');
        	} else {
        		$(this).parent().removeClass('selected');
        	}
        });

    /**
     * initialize search suggestions, pending the value of the site preference(enhancedSearchSuggestions)
     * this will either init the legacy(false) or the beta versions(true) of the the search suggest feature.
     * */
    var $searchContainer = $('#navigation .header-search');
    searchsuggest.init($searchContainer, Resources.SIMPLE_SEARCH);
    var $searchContainerMobile = $('#navigation .header-search-mobile');
    var $mobileSearchInput = $searchContainerMobile.find('#q');
    var $mobileSearchInputPlaceholder = $mobileSearchInput.attr('placeholder');
    searchsuggest.init($searchContainerMobile, Resources.SIMPLE_SEARCH);
    
    $mobileSearchInput.blur(function(){
    	if($(this).attr('placeholder') == ''){
    		$(this).attr('placeholder',$mobileSearchInputPlaceholder);
    	}
	});
    
    $mobileSearchInput.focus(function(){
		$(this).attr('placeholder','');
	});
    // add show/hide navigation elements
    $('.secondary-navigation .toggle').click(function () {
        $(this).toggleClass('open').next('div').slideToggle({'duration': 200,'easing':'linear'});
    });

    $('.mobile-account-nav .secondary-navigation .nav-header').click(function (e) {
         e.preventDefault();
         $(this).toggleClass('expanded').next('ul').toggle();
     });

    $('.account-nav-asset .help-nav-header, .customer-service-mobile-nav-asset .help-nav-header').click(function (e) {
        e.preventDefault();
        if(window.innerWidth < 959){
            $(this).toggleClass('expanded').next('.account-help-nav-content').toggle();
        }
    });

    /* drawer toggle functionality */
    $('.drawer label').on('click', function(e) {
        var drawer = $(this).closest('.drawer');
        drawer.toggleClass('open');
        drawer.find('.drawer-content').slideToggle();
    });
    $('.select-shipping-method input[type="radio"]').on('change', function (e) {
    	$('.select-shipping-method .form-row').removeClass('radio-button-selected');
    	$(this).parent().addClass('radio-button-selected');
    });

    // add generic toggle functionality
    $('.toggle').next('.toggle-content').hide();
    $('.toggle').click(function (e) {
        e.preventDefault();
        if(!($(this).parent('.secondary-navigation').length)){
            e.preventDefault();
            $(this).toggleClass('expanded').next('.toggle-content').toggle();
        }
    });

    // Customer service mobile navigation
    var customerServiceActiveLink = $('.pt_customer-service .secondary-navigation a.active-link');
    var customerServicdeMobileNav = $('.pt_customer-service .customer-service-mobile-nav');
    if (customerServiceActiveLink.length) {
        var toggleLink = customerServiceActiveLink.clone();
        customerServicdeMobileNav.find('.customer-service-mobile-nav-toggle')
            .empty()
            .append(toggleLink);
        customerServiceActiveLink.parent('.content')
            .children()
            .clone()
            .appendTo(customerServicdeMobileNav.find('.customer-service-mobile-nav-items'));
    } else if (customerServicdeMobileNav.length) {
        customerServicdeMobileNav.find('.customer-service-mobile-nav-dropdown').hide();
    }

    $('.pt_customer-service .customer-service-mobile-nav-toggle').on('click', function(e) {
        e.preventDefault();
        $(this).toggleClass('expanded')
            .next('.customer-service-mobile-nav-items')
            .toggle();
    });

    // subscribe email box
    var $subscribeEmail = $('.subscribe-email');
    if ($subscribeEmail.length > 0)    {
        $subscribeEmail.focus(function () {
            var val = $(this.val());
            if (val.length > 0 && val !== Resources.SUBSCRIBE_EMAIL_DEFAULT) {
                return; // do not animate when contains non-default value
            }

            $(this).animate({color: '#999999'}, 500, 'linear', function () {
                $(this).val('').css('color', '#333333');
            });
        }).blur(function () {
            var val = $.trim($(this.val()));
            if (val.length > 0) {
                return; // do not animate when contains value
            }
            $(this).val(Resources.SUBSCRIBE_EMAIL_DEFAULT)
                .css('color', '#999999')
                .animate({color: '#333333'}, 500, 'linear');
        });
    }

    $('.privacy-policy').on('click', function (e) {
        e.preventDefault();
        var width;
        var $body = $('body');
        if ($body.width() < 960) {
            width = $body.width() - 40;
        } else {
            width = 800;
        }
        dialog.open({
            url: $(e.target).attr('href'),
            options: {
            	dialogClass: 'privacy-policy-dialog',
                height: 600,
                width: width
            }
        });
    });
    $('.header-help-span').on('click', function (e) {
        e.preventDefault();
        dialog.open({
            url: $(e.target).attr('href'),
            width: 375,
            options: {
                width: 375,
                dialogClass: 'help-widget-katespade'
            },
            callback: function(){
                $('body').on('click', '.guest-order', function(){
                    dialog.close();
                    var url = $(this).attr('data-url');
                    $.ajax({
                        url: url + '?format=ajax',
                        success: function(d){
                          app.validator.init();
                          dialog.open({
                            url: url,
                            closeOnEscape: true,
                            options: {
                                width: 668,
                                position: { my: "center", at: "center", of: window },
                                dialogClass: 'popup-guesthistory'
                            },
                            callback: function(){
                                var validationRules = new ValidationRules();
                                $('#dwfrm_guesthistory').validate(validationRules.guestOrderFormRules());
                                floatlabels.init();
                            }
                          });
                        }
                    });
                })
            }
        });
    });

    // main menu toggle
    $('.menu-toggle').on('click', function () {
        $('#wrapper').toggleClass('menu-active');
        $('body').toggleClass('menu-active');
    });
    $('.navigation-overlay').on('click', function () {
        $('#wrapper').toggleClass('menu-active');
        $('body').toggleClass('menu-active');
    });
    $('.menu-category li .menu-item-toggle').on('click', function (e) {
        e.preventDefault();
        var $parentLi = $(e.target).closest('li');
        $parentLi.siblings('li').removeClass('active').find('.menu-item-toggle').removeClass('fa-minus active').addClass('fa-chevron-right');
        $parentLi.toggleClass('active');
        $(e.target).toggleClass('fa-chevron-right fa-minus active');
    });

    // main menu mobile focus on click
    $('.menu-category.level-1 .menu-item-toggle').on('click', function () {
        // Only run when a closed menu is opened
        if ($(this).hasClass('active')) {
            // Get the element offset from body and current navigation scroll position
            var pos = $(this).offset().top + $('#navigation').scrollTop();

            $('#navigation').animate({
                scrollTop: pos
            }, 500);
        }
    });

    // Account login / signup flyout

    var customerInfoUrl = Urls.includeHeaderCustomerInfo;
    var rightHeaderLinks = $('.right-header-links');
    var mobileSignIn = $('#mobile-signin');

    // Login touch event
    $('body').on('touchend', '.right-header-links .account-link > a' ,function(e){
        e.preventDefault();
        if (!$(this).hasClass('open')){
            $(this).addClass('open')
        } else {
            window.location = $(this).attr('href');
        }
    });

    // Account Protected Links
    $('.protected').on('click', function (e) {
        e.preventDefault();
        $('#top-banner-interior .account-link-login a.user-login-hopup').click();
    });

    // Dynamically pull Account Link into header via ajax to replace remote includes on header.isml
    app.ajax.load({
        url:customerInfoUrl,
        callback: function (url){
            rightHeaderLinks.find('.search-toggle').after(url);
            mobileSignIn.append(url);
            app.hopupRegisterLogin.init();
        }
    });

    app.hopupRegisterLogin = {
        showHopup : function(hopup){
            var target = $(hopup);
            var dlg;
            var width = (window.innerWidth < 708) ? (window.innerWidth - 40).toString() : '668';
            if ((window.innerWidth > 707) && (window.innerWidth < 960))
                width = '476'
            if ((hopup == "#popup-register" || hopup == "#popup-guesthistory") && target.length > 0) {
                // Hide other instances of the dialog
                dialog.close();
                // Display the target
                target.show();
                // Wrap target in ui-dialog div
                dlg = app.dialog.create({ "target" : target, "options" : {'width' : width, 'height' : 'auto', 'dialogClass' : 'create-account'} });
                // if dialog is open, return
                if(dlg.dialog("isOpen")) {return;}
                // else, show the dialog
                dlg.dialog("open");
                var topOffset = (window.innerWidth < 708) ? 50 : ((window.innerWidth - 708) / 2) + 50;
                if (topOffset > 100) {
                    topOffset = 100;
                }
                topOffset = $(window).scrollTop() + topOffset;
                floatlabels.init();
                $('.ui-dialog').css('top', topOffset.toString() + 'px');
            }
            else {
                target.slideDown();
            }

            // None HTML5 inputs
            var form = target.find('form#dwfrm_login');
            if(form.length){
                validator.init();
                //form.find('input[placeholder]').placeholder();
                
            }

            return false;
        },
        init : function(target){
            if (typeof target == 'undefined' || !target){
                target = $('body');
            }

            if (typeof target == 'string') {
                target = $(target);
            }

            // Trigger LOGIN/REGISTER button to show hopup on click by save for later login link
            $('html body').on('click', '.saveforlater-login', function (e) {
                e.preventDefault();
                // scroll to the top on mobile devices to be consistent
                if (window.innerWidth <= 960) {
                    window.scrollTo(0, 0);
                }
                $('.header-links .js-user-login-hopup-trigger').trigger('click');
            });

            // HEADER LOGIN/REGISTER BUTTONS CLICK
            target.find('a.user-login-hopup, a.user-register-hopup').on('click', function(e){
                e.preventDefault();
            	var link = $(this);
                var popup = link.attr('href');
                var show = function() {

                    // if clicked from hamburger nav
                    if (link.closest('#mobile-signin').length) {
                        $('#wrapper').toggleClass('menu-active');
                        $('body').toggleClass('menu-active');
                    }

                    // Show the hopup
                    app.hopupRegisterLogin.showHopup(popup);
                    login.init();
                };

                if ($(popup).length == 0){
                    var d = $('<div/>');
                    if (link.hasClass('user-login-hopup')) {
                        d.addClass('login-tray');
                        if (popup === '#popup-register' || popup === "#popup-guesthistory") {
                            d.hide();
                        }

                        var header = $('.top-banner');
                        header.before(d);

                        // check if login tray needs to be sticky on initial load
                        if (header.hasClass('sticky')) {
                            d.addClass('sticky');
                        }
                    }
                    else {
                        $('body').append(d);
                    }
                    app.ajax.load({url:link.data('url'), target:d, callback:function() {
                        app.hopupRegisterLogin.init(d);
                        d.find('.login-tray-close').on('click', function(e){
                            $(popup).slideUp();
                        });

                        //push account creation to dataLayer
                        $('#dwfrm_register').on('submit',function(){
                            if (typeof dataLayer !== "undefined") {
                                dataLayer.push(app.datalayer.getEvent("event", "account-creation", "type", "Kate Spade"));
                                var test = '';
                                //dataLayer.push({"event" : "account-creation", "type" : "Kate Spade" });

                                //push email signup to dataLayer
                                if ($("#dwfrm_profile_customer_addtoemaillist").is(":checked")) {
                                    dataLayer.push(app.datalayer.getEvent("event", "email-subscribe", "subscribeType", "accountCreate"));
                                    //dataLayer.push({"event" : "email-subscribe", "subscribeType": "accountCreate"});
                                }
                            }
                        });

                        function LookUpUserName(fieldId) {
                            /*
                                LookUpUserName
                                    1. Determines if a user already exists based on the the email address provided in the current field which is the only.
                                    2. #1 occurs via an AJAX call to the pipeline Account-LoginLookup utilizing the appresources.isml URL AccountLoginCheck (app.urls.AccountLoginCheck).
                                        - This pipeline will look on the HttpParameterMap for the passed email address coming from the current form.
                                        - It then checks if the customer exists via the GetCustomer pipelet.
                                        - IF the piplet does not return an error (this means the user exists), and errorjson.isml is returned within the response.
                                        - OTHERWISE, util/successjson is returned.
                            */

                            $('body').on('blur', fieldId ,function(){

                                // Get the email address field.
                                var emailAccountLookup = $(fieldId);


                                // Determine if the email address exists and has a minumum of three characters.
                                if (emailAccountLookup.length > 0  && emailAccountLookup.val().length > 3
                                    && $(fieldId).hasClass('valid')) {

                                    // Get the email address entered by the user.
                                    var emailToLookup = emailAccountLookup.val();

                                    // Get the Id of the DOM element emailAccountLookup.
                                    var emailAccountLookupID = emailAccountLookup.attr('id');

                                    // Add the user email address to the params object.
                                    // This will be sent as a query string param in the AJAX
                                    // call to follow.
                                    var params = {email : emailToLookup};

                                    app.ajax.getJson({
                                        async: true,
                                        url: Urls.AccountLoginCheck,
                                        data: params,
                                        callback: function (data) {
                                            if(data && data.success){
                                                // There exists a user with the supplied email address / username.



                                                // Create the necessary DOM elements / attribute for jQuery Validate purposes.
                                                emailAccountLookup.removeClass('valid');
                                                emailAccountLookup.addClass('error');
                                                emailAccountLookup.siblings('span')
                                                    .removeClass('valid')
                                                    .html(Resources.INVALID_USERNAMETAKEN);

                                                if($("#dwfrm_guesthistory").validate()) {
                                                    $("#dwfrm_guesthistory").validate().settings.ignore="*";
                                                }
                                                // Add the disabled attribute on the Submit button so the user
                                                // cannot submit since this user name / emaill address already exists.
                                                $("#dwfrm_register").find(".apply-button").prop('disabled', true);
                                            }
                                            else {
                                                // There DOES NOT exist a user with the supplied email address / username.

                                                // Remove error messaging
                                                emailAccountLookup.removeClass('error');
                                                emailAccountLookup.addClass('valid');
                                                emailAccountLookup.siblings('span').addClass('valid');

                                                // Remove the disabled attribute off of the submit button.
                                                $("#dwfrm_register").find(".apply-button").prop('disabled', false);
                                            }
                                        }
                                    });
                                }
                            });
                        }

                        var dateFields = ["#dwfrm_profile_customer_birthMonth", "#dwfrm_profile_customer_birthDay", "#dwfrm_profile_customer_birthYear"];
                        $('#dwfrm_register').validate({
                            groups: {
                                date: "dwfrm_profile_customer_birthMonth dwfrm_profile_customer_birthDay dwfrm_profile_customer_birthYear"
                            },
                            rules: {
                                "dwfrm_profile_customer_birthMonth": {
                                    multidate: dateFields
                                },
                                "dwfrm_profile_customer_birthDay": {
                                    multidate: dateFields
                                },
                                "dwfrm_profile_customer_birthYear": {
                                    multidate: dateFields
                                },
                                "dwfrm_profile_customer_emailconfirm": {
                                    equalTo: "#dwfrm_profile_customer_email"
                                },
                                "dwfrm_profile_login_password": {
                                    rangelength: [7, 20]
                                },
                                "dwfrm_profile_login_passwordconfirm": {
                                    equalTo: "#dwfrm_profile_login_password"
                                }
                            },
                            messages: {
                                "dwfrm_profile_customer_firstname": {
                                    required: Resources.MISSING_FIRST_NAME
                                },
                                "dwfrm_profile_customer_lastname": {
                                    required: Resources.MISSING_LAST_NAME
                                },
                                "dwfrm_profile_customer_email": {
                                    required: Resources.MISSING_EMAIL
                                },
                                "dwfrm_profile_customer_emailconfirm": {
                                    required: Resources.MISSING_EMAILCONFIRM,
                                    equalTo: Resources.VALIDATE_INVALID_EMAILMATCH
                                },
                                "dwfrm_profile_login_password": {
                                    required: Resources.MISSING_PASSWORD,
                                    rangelength: Resources.VALIDATE_RANGELENGTH
                                },
                                "dwfrm_profile_login_passwordconfirm": {
                                    required: Resources.MISSING_PASSWORDCONFIRM,
                                    equalTo: Resources.VALIDATE_INVALID_PASSMATCH
                                },
                                "dwfrm_profile_customer_zip": {
                                    required: Resources.MISSING_POSTAL
                                },
                                "dwfrm_profile_customer_birthMonth": {
                                    multidate: Resources.BIRTHDATE_INVALID
                                },
                                "dwfrm_profile_customer_birthDay": {
                                    multidate: Resources.BIRTHDATE_INVALID
                                },
                                "dwfrm_profile_customer_birthYear": {
                                    multidate: Resources.BIRTHDATE_INVALID
                                }
                            },
                            errorClass : 'error',
                            errorElement : 'span',
                            ignore: ":hidden:not(.replaced)",
                            onkeyup : false,
                            onfocusout : function (element) {
                                if(!this.checkable(element)) {
                                    this.element(element);
                                }
                            },
                            highlight : function(element, errorClass, validClass) {
                                if (element.type === 'radio') {
                                    this.findByName(element.name).addClass(errorClass).removeClass(validClass);
                                } else {
                                    $(element).addClass(errorClass).removeClass(validClass);
                                    if(element.type === 'select-one'){
                                        var $element = $(element);
                                        if($element.attr('id') && $element.hasClass('replaced')){
                                            var selectBox = $('#' + $element.attr('id') + 'SelectBoxItContainer');
                                            if(selectBox){
                                                selectBox.addClass(errorClass).removeClass(validClass);
                                            }
                                        }
                                    }
                                }
                                if ($(element).attr('id') === "dwfrm_profile_customer_birthMonth"
                                        || $(element).attr('id') === "dwfrm_profile_customer_birthDay"
                                        || $(element).attr('id') === "dwfrm_profile_customer_birthYear") {
                                    $(dateFields[0]).removeClass(errorClass);
                                    $(dateFields[1]).removeClass(errorClass);
                                    $(dateFields[2]).removeClass(errorClass);
                                    $("#errors").empty();
                                }
                            },
                            unhighlight : function(element, errorClass, validClass) {
                                if (element.type === 'radio') {
                                    this.findByName(element.name).removeClass(errorClass).addClass(validClass);
                                } else {
                                    $(element).removeClass(errorClass).addClass(validClass);
                                    if(element.type === 'select-one'){
                                        var $element = $(element);
                                        if($element.attr('id') && $element.hasClass('replaced')){
                                            var selectBox = $('#' + $element.attr('id') + 'SelectBoxItContainer');
                                            if(selectBox){
                                                selectBox.removeClass(errorClass).addClass(validClass);
                                            }
                                        }
                                    }
                                }
                                if ($(element).attr('id') === "dwfrm_profile_customer_birthMonth"
                                        || $(element).attr('id') === "dwfrm_profile_customer_birthDay"
                                        || $(element).attr('id') === "dwfrm_profile_customer_birthYear") {
                                    $(dateFields[0]).removeClass(errorClass);
                                    $(dateFields[1]).removeClass(errorClass);
                                    $(dateFields[2]).removeClass(errorClass);
                                    $("#errors").empty();
                                }
                            },
                            showErrors: function (errorMap, errorList) {
                                this.defaultShowErrors();

                                var birthdateError = "";
                                if (errorMap.hasOwnProperty("dwfrm_profile_customer_birthMonth")) {
                                    birthdateError = errorMap["dwfrm_profile_customer_birthMonth"];
                                } else if (errorMap.hasOwnProperty("dwfrm_profile_customer_birthDay")) {
                                    birthdateError = errorMap["dwfrm_profile_customer_birthDay"];
                                } else if (errorMap.hasOwnProperty("dwfrm_profile_customer_birthYear")) {
                                    birthdateError = errorMap["dwfrm_profile_customer_birthYear"];
                                }

                                if (birthdateError != "") {
                                    $("#errors").html('<span class="error" generated="true" for="date">' + birthdateError + '</span>');
                                    $(dateFields[0]).addClass("error");
                                    $(dateFields[1]).addClass("error");
                                    $(dateFields[2]).addClass("error");
                                }
                            },
                            submitHandler: function(form) {
                                if (($(dateFields[0]).val() == "" && $(dateFields[1]).val() == "" && $(dateFields[2]).val() == "") ||
                                        ($(dateFields[0]).val() != "" && $(dateFields[1]).val() != "" && $(dateFields[2]).val() != "")) {
                                    form.submit();
                                } else {
                                    // User has put in only a partial birthdate and we should error
                                    $("#errors").html('<span class="error" generated="true" for="date">' + Resources.BIRTHDATE_INVALID + '</span>');
                                    $(dateFields[0]).addClass("error");
                                    $(dateFields[1]).addClass("error");
                                    $(dateFields[2]).addClass("error");
                                }
                            }
                        });

                        // Inititialize the look up username for the form with ID dwfrm_profile_customer_email
                        LookUpUserName("#dwfrm_profile_customer_email");

                        $('#dwfrm_guesthistory').validate({

                            rules: {
                                "dwfrm_guestorderhistory_orderNumber": {
                                    required: true,
                                    number: true
                                },
                                "dwfrm_guestorderhistory_orderEmail": {
                                    email: true,
                                    required: true
                                },
                                "dwfrm_guestorderhistory_postalCode": {
                                    required: true,
                                    minlength: 5
                                }

                            },
                            messages: {
                                "dwfrm_guestorderhistory_orderEmail": {
                                    required: Resources.VALIDATE_EMAIL,
                                    email: Resources.VALIDATE_EMAIL
                                },
                                "dwfrm_guestorderhistory_postalCode": {
                                    required: Resources.VALIDATE_POSTAL,
                                    minlength: Resources.VALIDATE_POSTAL
                                },
                                "dwfrm_guestorderhistory_orderNumber": {
                                    required: Resources.VALIDATE_ORDERNUMBER,
                                    number: Resources.VALIDATE_ORDERNUMBER
                                }
                            },
                            errorClass : 'error',
                            errorElement : 'span',
                            ignore: ":hidden:not(.replaced)",
                            onkeyup : false,
                            onfocusout : function (element) {
                                if(!this.checkable(element)) {
                                    this.element(element);
                                }
                            },
                            highlight : function(element, errorClass, validClass) {
                                if (element.type === 'radio') {
                                    this.findByName(element.name).addClass(errorClass).removeClass(validClass);
                                } else {
                                    $(element).addClass(errorClass).removeClass(validClass);
                                    if(element.type === 'select-one'){
                                        var $element = $(element);
                                        if($element.attr('id') && $element.hasClass('replaced')){
                                            var selectBox = $('#' + $element.attr('id') + 'SelectBoxItContainer');
                                            if(selectBox){
                                                selectBox.addClass(errorClass).removeClass(validClass);
                                            }
                                        }
                                    }
                                }
                            },
                            unhighlight : function(element, errorClass, validClass) {
                                if (element.type === 'radio') {
                                    this.findByName(element.name).removeClass(errorClass).addClass(validClass);
                                } else {
                                    $(element).removeClass(errorClass).addClass(validClass);
                                    if(element.type === 'select-one'){
                                        var $element = $(element);
                                        if($element.attr('id') && $element.hasClass('replaced')){
                                            var selectBox = $('#' + $element.attr('id') + 'SelectBoxItContainer');
                                            if(selectBox){
                                                selectBox.removeClass(errorClass).addClass(validClass);
                                            }
                                        }
                                    }
                                }
                            },
                            showErrors: function (errorMap, errorList) {
                                this.defaultShowErrors();
                            }
                        });
                        show();
                    }});
                        checkStaticHeader();
                }else {
                    show();
                }
            });

            // if we are on the registration failure page, we are not in a hopup and need to set up validation differently
            if ($("#registrationFailureForm").length !== 0) {
                var dateFields = ["#dwfrm_profile_customer_birthMonth", "#dwfrm_profile_customer_birthDay", "#dwfrm_profile_customer_birthYear"];
                $('#dwfrm_register').validate({
                    groups: {
                        date: "dwfrm_profile_customer_birthMonth dwfrm_profile_customer_birthDay dwfrm_profile_customer_birthYear"
                    },
                    rules: {
                        "dwfrm_profile_customer_birthMonth": {
                            multidate: dateFields
                        },
                        "dwfrm_profile_customer_birthDay": {
                            multidate: dateFields
                        },
                        "dwfrm_profile_customer_birthYear": {
                            multidate: dateFields
                        }
                    },
                    messages: {
                        "dwfrm_profile_customer_firstname": {
                            required: Resources.MISSING_FIRST_NAME
                        },
                        "dwfrm_profile_customer_lastname": {
                            required: Resources.MISSING_LAST_NAME
                        },
                        "dwfrm_profile_customer_email": {
                            required: Resources.MISSING_EMAIL
                        },
                        "dwfrm_profile_customer_emailconfirm": {
                            required: Resources.MISSING_EMAILCONFIRM
                        },
                        "dwfrm_profile_login_password": {
                            required: Resources.MISSING_PASSWORD
                        },
                        "dwfrm_profile_login_passwordconfirm": {
                            required: Resources.MISSING_PASSWORDCONFIRM
                        },
                        "dwfrm_profile_customer_zip": {
                            required: Resources.MISSING_POSTAL
                        },
                        "dwfrm_profile_customer_birthMonth": {
                            multidate: Resources.BIRTHDATE_INVALID
                        },
                        "dwfrm_profile_customer_birthDay": {
                            multidate: Resources.BIRTHDATE_INVALID
                        },
                        "dwfrm_profile_customer_birthYear": {
                            multidate: Resources.BIRTHDATE_INVALID
                        }
                    },
                    errorClass : 'error',
                    errorElement : 'span',
                    ignore: ":hidden:not(.replaced)",
                    onkeyup : false,
                    onfocusout : function (element) {
                        if(!this.checkable(element)) {
                            this.element(element);
                        }
                    },
                    highlight : function(element, errorClass, validClass) {
                        if (element.type === 'radio') {
                            this.findByName(element.name).addClass(errorClass).removeClass(validClass);
                        } else {
                            $(element).addClass(errorClass).removeClass(validClass);
                            if(element.type === 'select-one'){
                                var $element = $(element);
                                if($element.attr('id') && $element.hasClass('replaced')){
                                    var selectBox = $('#' + $element.attr('id') + 'SelectBoxItContainer');
                                    if(selectBox){
                                        selectBox.addClass(errorClass).removeClass(validClass);
                                    }
                                }
                            }
                        }
                        if ($(element).attr('id') === "dwfrm_profile_customer_birthMonth"
                                || $(element).attr('id') === "dwfrm_profile_customer_birthDay"
                                || $(element).attr('id') === "dwfrm_profile_customer_birthYear") {
                            $(dateFields[0]).removeClass(errorClass);
                            $(dateFields[1]).removeClass(errorClass);
                            $(dateFields[2]).removeClass(errorClass);
                            $("#errors").empty();
                        }
                    },
                    unhighlight : function(element, errorClass, validClass) {
                        if (element.type === 'radio') {
                            this.findByName(element.name).removeClass(errorClass).addClass(validClass);
                        } else {
                            $(element).removeClass(errorClass).addClass(validClass);
                            if(element.type === 'select-one'){
                                var $element = $(element);
                                if($element.attr('id') && $element.hasClass('replaced')){
                                    var selectBox = $('#' + $element.attr('id') + 'SelectBoxItContainer');
                                    if(selectBox){
                                        selectBox.removeClass(errorClass).addClass(validClass);
                                    }
                                }
                            }
                        }
                        if ($(element).attr('id') === "dwfrm_profile_customer_birthMonth"
                                || $(element).attr('id') === "dwfrm_profile_customer_birthDay"
                                || $(element).attr('id') === "dwfrm_profile_customer_birthYear") {
                            $(dateFields[0]).removeClass(errorClass);
                            $(dateFields[1]).removeClass(errorClass);
                            $(dateFields[2]).removeClass(errorClass);
                            $("#errors").empty();
                        }
                    },
                    showErrors: function (errorMap, errorList) {
                        this.defaultShowErrors();

                        var birthdateError = "";
                        if (errorMap.hasOwnProperty("dwfrm_profile_customer_birthMonth")) {
                            birthdateError = errorMap["dwfrm_profile_customer_birthMonth"];
                        } else if (errorMap.hasOwnProperty("dwfrm_profile_customer_birthDay")) {
                            birthdateError = errorMap["dwfrm_profile_customer_birthDay"];
                        } else if (errorMap.hasOwnProperty("dwfrm_profile_customer_birthYear")) {
                            birthdateError = errorMap["dwfrm_profile_customer_birthYear"];
                        }

                        if (birthdateError != "") {
                            $("#errors").html('<span class="error" generated="true" for="date">' + birthdateError + '</span>');
                            $(dateFields[0]).addClass("error");
                            $(dateFields[1]).addClass("error");
                            $(dateFields[2]).addClass("error");
                        }
                    },
                    submitHandler: function(form) {
                        if (($(dateFields[0]).val() == "" && $(dateFields[1]).val() == "" && $(dateFields[2]).val() == "") ||
                                ($(dateFields[0]).val() != "" && $(dateFields[1]).val() != "" && $(dateFields[2]).val() != "")) {
                            form.submit();
                        } else {
                            // User has put in only a partial birthdate and we should error
                            $("#errors").html('<span class="error" generated="true" for="date">' + Resources.BIRTHDATE_INVALID + '</span>');
                            $(dateFields[0]).addClass("error");
                            $(dateFields[1]).addClass("error");
                            $(dateFields[2]).addClass("error");
                        }
                    }
                });
            }

            // HOOK VALIDATION FOR THE HOPUP FORM
            app.util.validateHook('#popup-register .apply-button');
            app.util.validateHook('#popup-guesthistory .apply-button');
            app.util.validateHook('#popup-login .apply-button');
        }
    }

    $(window).scroll(function(){
        checkStaticHeader();
    });

    $(window).resize(function(){
        var viewportWidth = $(window).width();
        var header = $('.top-banner');

        if ($('.ui-dialog').length) {
            setTimeout(function () {
                if (!$('.ui-dialog').is('.store-pickup-dialog, .ui-dialog_quick-view')) {
                    var width = (viewportWidth < 708) ? (viewportWidth - 40).toString() : '668';
                    var topOffset = (viewportWidth < 708) ? 50 : ((viewportWidth - 708) / 2) + 50;
                }
                else if ($('.ui-dialog').is('.ui-dialog_quick-view')) {
                    var width = (viewportWidth > 960) ? '820' : '720';
                    if (viewportWidth <= 768) {
                        width = (viewportWidth < 669) ? (viewportWidth).toString() : '668';
                    }
                }
                else if (!$('.ui-dialog').is('.ui-front.create-account')) {
                    var width = (viewportWidth < 669) ? (viewportWidth).toString() : '668';
                    var topOffset = (viewportWidth < 708) ? 61 : ((viewportWidth - 708) / 2) + 61;
                }
                var left = (viewportWidth - width) / 2;

                if (topOffset > 100) {
                    topOffset = 100;
                }
                topOffset = $(window).scrollTop() + topOffset;
                $('.ui-dialog').css('width', width);
                $('.ui-dialog').css('left', left);
                $('.ui-dialog').css('top', topOffset.toString() + 'px');
            }, 500);
        }

        setTimeout(function () {
            checkStaticHeader();
            if (viewportWidth < 960) {
                moveSearch($('nav').find('.search-toggle'), $('.right-header-links').find('.search-toggle'), true);
            } else {
                if (!header.hasClass('sticky')) {
                    moveSearch($('.right-header-links').find('.search-toggle'), $('nav').find('.search-toggle'), false);
                }
            }
        }, 500);

    	alignNavContent();
    });

    $('.search-toggle').find('a').on('click', function(e) {
        e.preventDefault();
        $('.search-toggle').toggleClass('active');
        $('.header-search').toggleClass('search-hidden');
        $('.search-toggle .header-search').find('#q').focus().removeClass('error');
    });
    $('.search-toggle').find('.close-search').on('click', function() {

        $('.search-toggle').toggleClass('active');
        $('.header-search').toggleClass('search-hidden');
    });
    $('.submit-search').on('click', function() {
        var searchValue = $('.submit-search').parent.find('#q');
        if (searchValue.val() == '') {
            searchValue.addClass('empty');
        }
    });
    $('nav[role="navigation"] .menu-category.level-1 > li a.has-sub-menu').on('mouseover', function() {
        $('.search-toggle').removeClass('active');
        $('.header-search').addClass('search-hidden');
        $('.search-toggle .header-search').find('#q').blur();

        // handle sticky nav positioning
        var width = window.innerWidth;
        var subNav = $(this).next('div.level-2');
    	var offset = $('#navigation').offset();

        if (width > 960 && $('.top-banner.sticky').is(':visible')) {
        	subNav.css({
        		'width': width,
        		'left': -offset.left,
        		'text-align': 'center'
        	});
        } else {
        	subNav.removeAttr('style');
    		alignNavContent(subNav);
        }
    });
    
    /* mimic placeholder behaviour */
    $('.search-toggle .header-search').find('.search-placeholder').on('mousedown touchstart', function(e) {
        var $q = $('.search-toggle .header-search').find('#q');
    	e.preventDefault();
    	if (!$q.is(':focus')) {
    		$q.focus();
    	}
    });
    $('.search-toggle .header-search').find('#q').on('input', function(e) {
        var $this = $(this);
        if ($this.val().length > 0) {
            $('.search-toggle .header-search .search-placeholder').addClass('hide');
        } else {
            $('.search-toggle .header-search .search-placeholder').removeClass('hide');
        }
    });

    // Back to top and chat buttons on product search results page
    var offset = 50;
    var duration = 300;

    $(window).scroll(function() {
        if ($(this).scrollTop() > offset) {
            $('#back-to-top, #chat').fadeIn(duration);
            $('#back-to-top, #chat').css('display', 'block');
            $('#back-to-top, #chat').css('display', 'block');
        } else {
            $('#back-to-top, #chat').fadeOut(duration);
        }
    });

    $('#back-to-top').click(function(event) {
        event.preventDefault();
        $('html, body').animate({scrollTop: 0}, duration);
        return false;
    });

    jQuery.validator.setDefaults({
        success: "valid"
    });

    // TODO : Move all account items into account.js
    function initResetPasswordForm() {
        $('#PasswordResetForm').validate({
            rules: {
                dwfrm_requestpassword_email: {
                    required: true,
                    email: true
                }
            },
            errorClass: 'error',
            errorElement: 'span',
            onfocusout: function (element) {
                jQuery(element).valid();
            }
        });

        $('#PasswordResetForm').on('submit', function (e) {
            e.preventDefault();
            var $this = $(this);
            if (!$this.valid()) {
                return;
            }

            var url = app.util.appendParamToURL($this.attr('action'), "format", "ajax");
            var postData = $this.serializeArray();
            postData.push({name: $this.find('.apply-button').attr('name'), value: $this.find('.apply-button').attr('value')});
            $.ajax({
                type: 'POST',
                url: url,
                data: postData,
                dataType: 'html',
                success : function (data) {
                    var $data = $(data);
                    if ($data.length && $data.filter('.forgot-password-wrapper.js-confirmation-page').length) {
                        var confirmaionHTML = $data.filter('.forgot-password-wrapper.js-confirmation-page').prop('outerHTML');
                        $('.forgot-password-wrapper').html(confirmaionHTML);

                        $('.close-button').on('click', function () {
                            dialog.close();
                        });
                    } else if ($data.length) {
                        var messageHTML = $data.find('.js-message').prop('outerHTML');
                        $('.forgot-password-wrapper').find('.js-message').html(messageHTML);
                    }
                },
                failure : function (data) {
                    alert('Error');
                }
            });
        });

    }

    jQuery('body').on('click', '#password-reset', function (e) {
        e.preventDefault();
        var width = (window.innerWidth < 708) ? (window.innerWidth - 40).toString() : '500';

        dialog.open({
            url: $(e.target).attr('href'),
            options: {
                width: width,
                height: 'auto',
                open: function () {
                    floatlabels.init();
                    initResetPasswordForm();
                }
            }
        });
    });

    //True Fit
    if (typeof tfc !== 'undefined'){
        tfc.event('tfc-set-userid','render',function(e) {
            if(e.response.tfpUser.isUserAvailable === 'true') {
                // Set session for truefit variable
                app.ajax.load({url : window.Urls.TrueFitCustomerSet});
            }
        });
    }

    // Trigger UIS call when submit order is clicked.
    $('.js-order-review-btn-submit').on('click', function(){
    	triggerUISCartCheck('placeOrder');
    });
}



/**
 * @private
 * @function
 * @description Adds class ('js') to html for css targeting and loads js specific styles.
 */
function initializeDom() {

    // add class to html for css targeting
    $('html').addClass('js');
    if (SitePreferences.LISTING_INFINITE_SCROLL) {
        $('html').addClass('infinite-scroll');
    }
    // load js specific styles
    util.limitCharacters();

    checkStaticHeader();
    moveSearch($('nav').find('.search-toggle'),$('.right-header-links').find('.search-toggle'),true);

    alignNavContent();
}

function alignNavContent(els) {
	var firstMenuItemLeft = $('.menu-category.level-1').children().first().position().left;
	
	var $els = els || $('.menu-category.level-1 >li >.level-2');
    
    $els.each(function (i, e) {
    	var wrapperPadding = $(e).css('padding-left').replace('px', ''),
    		leftAlignOffset = firstMenuItemLeft - wrapperPadding,
    		$navContent = $(e).find('.nav-aligned');
    		
    	$navContent.css({
    		"left": leftAlignOffset
    	});
    });
}

function checkStaticHeader() {
    var smallViewport = (window.innerWidth <= 480);
    var mediumViewport = (window.innerWidth > 480 && window.innerWidth <= 960);
    var largeUpViewport = (window.innerWidth > 960);
    var siteTabs = $('#site-tab-bar');
    var siteTabsHeight = siteTabs.height();
    var loginTray = $('.login-tray');
    var loginTrayHeight = loginTray.height();
    var header = $('.top-banner');
    var headerHeight = header.height();
    var stickySearch = $('.right-header-links').find('.search-toggle');
    var navSearch = $('nav').find('.search-toggle');
    var header = $('.top-banner');
    var menuToggle = header.find('.menu-toggle');
    var hasFilters = ($('#filters-selected').children().length > 0);

    if (smallViewport) {
        var stickyScrollOffset = loginTray.length ? loginTrayHeight + 40 : 0;
        var stickyMarginOffset = loginTray.length ? loginTrayHeight + 91 : 0;
        if (isCheckout()) {
            var stickyScrollOffset = loginTrayHeight;
            var stickyMarginOffset = loginTrayHeight + 60;
        }
    }
    else if (mediumViewport) {
        var stickyScrollOffset = loginTrayHeight + siteTabsHeight;
        var stickyMarginOffset = loginTrayHeight + siteTabsHeight + 59;
        if (isCheckout()) {
            var stickyScrollOffset = loginTrayHeight;
            var stickyMarginOffset = loginTrayHeight + 65;
        }
    }
    else if (largeUpViewport) {
        var stickyScrollOffset = loginTrayHeight + siteTabsHeight + 65;
        var stickyMarginOffset = loginTrayHeight + siteTabsHeight + 139;
        if (isCheckout()) {
            var stickyScrollOffset = loginTrayHeight;
            var stickyMarginOffset = loginTrayHeight + 90;
        }
    }

    if ($(document).scrollTop() - 400 > stickyScrollOffset && !header.hasClass('sticky')) {
        siteTabs.css('display', 'none');
        header.addClass('sticky');
        loginTray.addClass('sticky');
        $('.nav-aligned').css("left", "");
        if(!$('.interior-account').length){
            $('#main').css('margin-top', (stickyMarginOffset + 'px'));
        }
        moveSearch(navSearch,stickySearch,false);
    } else if ($(document).scrollTop() <= 1 + loginTrayHeight && header.hasClass('sticky')) {
        siteTabs.css('display', 'block');
        header.removeClass('sticky');
        loginTray.removeClass('sticky');
        alignNavContent();
        if(!$('.interior-account').length) {
            $('#main').css('margin-top', (smallViewport && !isCheckout() ? '120px' : '0'));
        }
        moveSearch(stickySearch,navSearch,false);
    }
    $('.login-tray.sticky').css('margin-top', '0');
}

function moveSearch(currentSearch,newSearch,pageLoad){
    var menuToggle = $('.top-banner').find('.menu-toggle');
    if (pageLoad == true && menuToggle.css('display') == 'block'){
        currentSearch.find('.header-search').detach().appendTo(newSearch);
        searchsuggest.init(newSearch.find('.header-search'), Resources.SIMPLE_SEARCH);
    }else if(pageLoad == false && menuToggle.css('display') == 'none'){
        currentSearch.find('.header-search').detach().appendTo(newSearch);
        searchsuggest.init(newSearch.find('.header-search'), Resources.SIMPLE_SEARCH);
    }
}
function getCurrentAccountPage() {
    if(typeof currentAccountPage !== 'undefined'){
        var $desktopCurrentPage = $('#secondary').find("#"+currentAccountPage);
        $desktopCurrentPage.addClass('active');
        var $mobileCurrentPage = $('.mobile-account-nav ul').find("#"+currentAccountPage).detach();
        if($mobileCurrentPage.length){
            var $navHeader = $('.mobile-account-nav').find('.nav-header');
            $('.mobile-account-nav ul').prepend("<li>"+$navHeader.html()+"</li>");
            $navHeader.find('a').text($mobileCurrentPage.text());
        }
    }
}

// AJAX call to UIS; avoid multiple calls by setting app.isUISRequested.
function triggerUISCartCheck(callSource) {
    if (!app.isUISRequested) {
    	var url = app.util.appendParamToURL(Urls.cartCheck, "callSource", callSource);
        $.ajax({url: url});
        app.isUISRequested = true;
    }
}

function isCheckout() {
    return $('.pt_checkout').length > 0;
}
var pages = {
    account: require('./pages/account'),
    cart: require('./pages/cart'),
    checkout: require('./pages/checkout'),
    compare: require('./pages/compare'),
    product: require('./pages/product'),
    registry: require('./pages/registry'),
    search: require('./pages/search'),
    storefront: require('./pages/storefront'),
    wishlist: require('./pages/wishlist'),
    storelocator: require('./pages/storelocator'),
    orderconfirmation: require('./pages/checkout/orderconfirmation')
};

window.app = {
    init: function () {
        if (document.cookie.length === 0) {
            $('<div/>').addClass('browser-compatibility-alert').append($('<p/>').addClass('browser-error').html(Resources.COOKIES_DISABLED)).appendTo('#browser-check');
        }
        initializeDom();
        initializeEvents();

        getCurrentAccountPage();

        // init specific global components
        countries.init();
        tooltip.init();
        minicart.init();
        floatlabels.init();
        validator.init();
        rating.init();
        searchplaceholder.init();
        emailsubscription.init();
        // execute page specific initializations
        $.extend(page, window.pageContext);
        var ns = page.ns;
        if (ns && pages[ns] && pages[ns].init) {
            pages[ns].init();
        }

        // Check TLS status if indicated by site preference
        if (SitePreferences.CHECK_TLS === true) {
            tls.getUserAgent();
        }
    }
};

app.resources = window.Resources;

app.dialog = {
    create : function (params) {
        // options.target can be an id selector or an jquery object
        var target = $(params.target || "#dialog-container");
        var id;
        // if no element found, create one
        if(target.length === 0) {
            if(target.selector && target.selector.charAt(0) === "#") {
                id = target.selector.substr(1);
            }
            target = $("<div>").attr("id", id).addClass("dialog-content").appendTo("body");
        }

        // create the dialog
        var container=target;
        container.dialog($.extend(true, {}, app.dialog.settings, params.options || {}));
        return container;
    },

    // opens a dialog using the given url
    open : function (params) {
        if (!params.url || params.url.length===0) { return; }

        $cache.container = app.dialog.create(params);
        params.url = app.util.appendParamsToUrl(params.url, {format:"ajax"});

        // finally load the dialog
        app.ajax.load({
            target : $cache.container,
            url : params.url,
            callback : function () {
                if($cache.container.dialog("isOpen")) {	return;	}
                $cache.container.dialog("open");
            }
        });

    },
    // closes the dialog and triggers the "close" event for the dialog
    close : function () {
        if(!$cache.container) {
            return;
        }
        $cache.container.dialog("close");
    },
    // triggers the "apply" event for the dialog
    triggerApply : function () {
        $(this).trigger("dialogApplied");
    },
    // attaches the given callback function upon dialog "apply" event
    onApply : function (callback) {
        if(callback) {
            $(this).bind("dialogApplied", callback);
        }
    },
    // triggers the "delete" event for the dialog
    triggerDelete : function () {
        $(this).trigger("dialogDeleted");
    },
    // attaches the given callback function upon dialog "delete" event
    onDelete : function (callback) {
        if(callback) {
            $(this).bind("dialogDeleted", callback);
        }
    },
    // submits the dialog form with the given action
    submit : function (action) {
        var form = $cache.container.find("form:first");

        if (!form.valid()) return;

        // set the action
        $("<input/>").attr({
            name : action,
            type : "hidden"
        }).appendTo(form);

        // serialize the form and get the post url
        var post = form.serialize();
        var url = form.attr("action");

        // post the data and replace current content with response content
        $.ajax({
            type : "POST",
            url : url,
            data : post,
            dataType : "html",
            success : function (data) {
                $cache.container.html(data);
                $(".ui-dialog-content").dialog("option","closeOnEscape", true);
            },
            failure : function (data) {
                window.alert(app.resources.SERVER_ERROR);
            }
        });
    },
    settings : {
        autoOpen : false,
        resizable : false,
        bgiframe : true,
        modal : true,
        closeOnEscape : false,
        height : 'auto',
        width : '484',
        buttons : {},
        title : '',
        draggable : false,
        position: {
            my: 'center',
            at: 'center',
            of: window,
            collision: 'flipfit'
        },
        overlay : {
            opacity : 0.5,
            background : "white"
        },
        close : function (event, ui) {
            $(this).dialog("destroy");
        },
        // A fix for webkit browsers. jQuery Dialog box disables click functionality, which breaks the browser's scroll bars
        // JS-1099. 6.9.13 EthanG
        open: function(event, ui) {
            window.setTimeout(function(){
                jQuery(document).unbind('mousedown.dialog-overlay')
                .unbind('mouseup.dialog-overlay');
            }, 100);
        }
    }
};//end app.dialog
app.util = {
    // trims a prefix from a given string, this can be used to trim
    // a certain prefix from DOM element IDs for further processing on the ID
    trimPrefix : function (str, prefix) {
        return str.substring(prefix.length);
    },
    setDialogify : function (e) {
        e.preventDefault();
        var actionSource = $(this),
            dlgAction = actionSource.data("dlg-action") || {}, // url, target, isForm
            dlgCallback = (actionSource.data("dlg-callback") != null && actionSource.data("dlg-callback")) ? actionSource.data("dlg-callback") : null,
            dlgOptions = $.extend({}, app.dialog.settings, actionSource.data("dlg-options") || {}),
            customClass = (actionSource.data("dlg-customclass") != null && actionSource.data("dlg-customclass") ? actionSource.data("dlg-customclass") : null),
            validForm = ( !dlgAction.isForm || ( dlgAction.isForm && actionSource.closest("form").valid() ));
        dlgOptions.title = dlgOptions.title || actionSource.attr("title") || "";
        // If we are submitting a form, make sure it is valid first
        if(!validForm) return;
        // Else continue
        var url = dlgAction.url // url from data
                  || (dlgAction.isForm ? actionSource.closest("form").attr("action") : null) // or url from form action if isForm=true
                  || actionSource.attr("href"); // or url from href
        if (!url) return;

        // if this is a content link, update url from Page-Show to Page-Include
        if (actionSource.hasClass("attributecontentlink")) {
            var uri = app.util.getUri(url);
            url = Urls.pageInclude+uri.query;
        }
        var dlg = app.dialog.create({target:dlgAction.target, options : dlgOptions, customClass : customClass});
        // Make sure any close buttons are initiated
        dlg.on("click", ".dialog-close-button, .ui-dialog-titlebar-close", function(e){
            e.preventDefault();
            app.dialog.close();
        });

        // If we are sending a form, serialize it and send it (including the button name/value)
        var formData = dlgAction.isForm ? (actionSource.closest("form").serialize() + "&" + actionSource.attr("name") + "=" + actionSource.attr("value")) : {};
        app.ajax.load({
            url: actionSource.attr("href") || actionSource.closest("form").attr("action"),
            data : formData,
            target: dlg,
            callback: function (e) {
                dlg.dialog("open"); // open after load to ensure dialog is centered
                if (customClass){
                    dlg.closest('.ui-dialog').addClass(customClass);
                    if (dlgOptions.customClass==='size-dialog') $('#size-chart-tabs').tabs();
                }
                floatlabels.init();
                app.validator.init(); // re-init validator

                if (dlgOptions.center && dlgOptions.dialogClass) {
                    $('.' + dlgOptions.dialogClass).center();
                }

                // Call the callback function if it was set in the initial <a> tag's data-dlg-callback attribute
                if(!dlgCallback || !window.hasOwnProperty(dlgCallback)) return;
                if (typeof dlgCallback == "string"){
                    dlgCallback = eval(dlgCallback);
                    if (typeof dlgCallback == "function") {
                        dlgCallback();
                    }
                }else {
                    window[dlgCallback](e);
                }
            }
        });
    },

    setCustomRedirectURL : function(url){
        $.ajax(app.util.appendParamToURL(
                app.urls.homeSetCustomRedirectUrl,"url",url));
    },
    // Create a hook for a form that utilizes standard submit features (non-ajax), but needs additional front-end validation before submitting
    validateHook : function(target){
        $(target).on('click', function(e){
            // Prevent default action if form is not valid
            if(!$(this).closest('form').valid()) {e.preventDefault();return false;}
        });
    },
    // Clear form elements and make sure they don't have focus on load
    // @target : A jQuery object representing a form
    // @placeholder  : A boolean. true - only redo the place holders : false - do everything
    formBlur : function(target, setHolder){
        target.each(function(index){
            // Removes any characters in the input fields
            if(!setHolder) this.reset();

            // Go through the inputs and remove any error class
            $(this).find('input').each(function(i){
                var input = $(this);

                // If we only need to do the placeholders - return out of this loop and don't reset errors
                if(setHolder) {
                    // None HTML5 place holders
                    input.placeholder();
                    return true;
                }

                // make sure it isn't auto focused (hides none-html5 place holders)
                input.blur();
                // None HTML5 place holders
                //input.placeholder();
                // Remove/hide errors due to blur
                input.removeClass('error');
                input.parent().find('span.error').hide();
            });
        });
    },
    // Submit a form via ajax (only if it is valid) and allow for a call back
    formsubmit : function(form, btn, type, callback){
        // Check to see if form is valid
        if (!form.valid()) return;
        // If valid, send the form via ajax
        // Data to send to the jquery call
        var url = app.util.appendParamToURL(form.attr('action'), "format", "ajax");
        // Collect the required form fields
        var data = form.serialize();
        // Figure out what type of call this is (from the button)
        data += "&" + btn.attr("name") + "=" + btn.attr("value");
        // make the server call
        $.ajax({
            url : url,
            data : data,
            type: "POST",
            dataType: type || "html"
        })
        .done(function(e, textStatus){
            if(!callback) return;
            callback(e, textStatus);
        })
        .fail(function (e, textStatus) {
            if(textStatus === "parsererror") {
                alert(textStatus);
            }
        });
    },
    padLeft : function (str, padChar, len) {
        var digs = len || 10;
        var s = str.toString();
        var dif = digs - s.length;
        while(dif > 0) {
            s = padChar + s;
            dif--;
        }
        return s;
    },
    // appends the parameter with the given name and
    // value to the given url and returns the changed url
    appendParamToURL : function (url, name, value, encode) {
        if (typeof encode == "undefined"){
            encode = true;
        }
        var c = "?";
        if(url && url.indexOf(c) !== -1) {
            c = "&";
        }
        return url + c + name + "=" + (encode ? encodeURIComponent(value) : value);
    },
    appendParamsToUrl : function (url, params) {
        var uri = app.util.getUri(url),
            includeHash = arguments.length < 3 ? false : arguments[2];

        var qsParams = $.extend(uri.queryParams, params);
        var result = uri.path+"?"+$.param(qsParams);
        if (includeHash) {
            result+=uri.hash;
        }
        if (result.indexOf("http")<0 && result.charAt(0)!=="/") {
            result="/"+result;
        }

        return result;
    },
    removeParamFromURL : function (url, parameter) {
        var urlparts = url.split('?');
        if(urlparts.length >= 2) {
            var urlBase = urlparts.shift();
            var queryString = urlparts.join("?");
            var prefix = encodeURIComponent(parameter) + '=';
            var pars = queryString.split(/[&;]/g);
            var i=pars.length;
            while(0 < i--) {
                if(pars[i].lastIndexOf(prefix, 0) !== -1) {
                    pars.splice(i, 1);
                }
            }
            url = urlBase + '?' + pars.join('&');
        }
        return url;
    },
    staticUrl : function (path) {
        if(!path || $.trim(path).length === 0) {
            return app.urls.staticPath;
        }
        return app.urls.staticPath + (path.charAt(0) === "/" ? path.substr(1) : path );
    },
    ajaxUrl : function (path) {
        return app.util.appendParamToURL(path, "format", "ajax");
    },

    toAbsoluteUrl : function (url) {
        if (url.indexOf("http")!==0 && url.charAt(0)!=="/") {
            url = "/"+url;
        }
        return url;
    },
    loadDynamicCss : function (urls) {
        var i, len=urls.length;
        for(i=0; i < len; i++) {
            app.util.loadedCssFiles.push(app.util.loadCssFile(urls[i]));
        }
    },
    // dynamically loads a CSS file
    loadCssFile : function (url) {
        return $("<link/>").appendTo($("head")).attr({
            type : "text/css",
            rel : "stylesheet"
        }).attr("href", url); // for i.e. <9, href must be added after link has been appended to head
    },
    // array to keep track of the dynamically loaded CSS files
    loadedCssFiles : [],
    // removes all dynamically loaded CSS files
    clearDynamicCss : function () {
        var i = app.util.loadedCssFiles.length;
        while(0 > i--) {
            $(app.util.loadedCssFiles[i]).remove();
        }
        app.util.loadedCssFiles = [];
    },
    scripts : [],
    loadScript : function (url, callback, context) {
        var script =  app.util.scripts[url] || ( app.util.scripts[url] = {
            loaded    : false,
            callbacks : []
        });

        if(script.loaded && callback != undefined) {
            return callback.apply(context);
        }

        script.callbacks.push({
            fn      : callback,
            context : context
        });

        if(script.callbacks.length == 1) {
            $.ajax({
                type     : 'GET',
                url      : url,
                dataType : 'script',
                cache    : true,
                success  : function() {
                    script.loaded = true;
                    $.each(script.callbacks, function() {
                        if (this.fn != undefined) {
                            this.fn.apply(this.context);
                        }
                    });
                    script.callbacks.length = 0;
                }
            });
        }
    },
    getQueryStringParams : function (qs) {
        if(!qs || qs.length === 0) { return {}; }
        var params = {};
        // Use the String::replace method to iterate over each
        // name-value pair in the string.
        qs.replace( new RegExp( "([^?=&]+)(=([^&]*))?", "g" ),
                    function ( $0, $1, $2, $3 ) {   params[ $1 ] = $3; }
        );
        return params;
    },
    getUri : function (o) {
        var a;
        if (o.tagName && $(o).attr("href")) {
            a = o;
        }
        else if (typeof o === "string") {
            a = document.createElement("a");
            a.href = o;
        }
        else {
            return null;
        }
        var pathParts = '';
        if (a.pathname) {
            pathParts = a.pathname.split('/');
        }
        return {
            protocol : a.protocol, //http:
            host : a.host, //www.myexample.com
            hostname : a.hostname, //www.myexample.com'
            port : a.port, //:80
            path : a.pathname, // /sub1/sub2
            query : a.search, // ?param1=val1&param2=val2
            queryParams : a.search.length > 1 ? app.util.getQueryStringParams(a.search.substr(1)) : {},
            hash : a.hash, // #OU812,5150
            url : a.protocol+ "//" + a.host + a.pathname,
            urlWithQuery : a.protocol+ "//" + a.host + a.port + a.pathname + a.search,
            page : pathParts.length > 0 ? pathParts[pathParts.length-1] : '' // sub2
        };
    },
    postForm : function (args) {
        var form = $("<form>").attr({action:args.url,method:"post"}).appendTo("body");
        var p;
        for (p in args.fields) {
            $("<input>").attr({name:p,value:args.fields[p]}).appendTo(form);
        }
        form.submit();
    },
    getMessage : function (key, bundleName, callback) {
        if (!callback || !key || key.length===0) {
            return;
        }
        var params = {key:key};
        if (bundleName && bundleName.length===0) {
            params.bn = bundleName;
        }
        var url = app.util.appendParamsToUrl(app.urls.appResources, params);
        $.getJSON(url, callback);
    },

    limitCharacters : function () {
        $('form').find('textarea[data-character-limit]').each(function(){
            var characterLimit = $(this).data("character-limit");
            var charCountHtml = String.format(app.resources.CHAR_LIMIT_MSG,
                                    '<span class="char-remain-count">'+characterLimit+'</span>',
                                    '<span class="char-allowed-count">'+characterLimit+'</span>');
            var charCountContainer = $(this).next('div.char-count');
            if (charCountContainer.length===0) {
                charCountContainer = $('<div class="char-count"/>').insertAfter($(this));
            }
            charCountContainer.html(charCountHtml);
            // trigger the keydown event so that any existing character data is calculated
            $(this).change();
        });
    },

    setDeleteConfirmation : function(container, message) {
        $(container).on("click", ".delete", function(e){
            return confirm(message);
        });
    },

    scrollBrowser : function (xLocation) {
        $('html, body').animate({ scrollTop: xLocation }, 500);
    },

    noImage : function(img) {
        if(app && app.resources && app.resources.NO_IMAGE_URL){
            var $img = $(img);
            $img.attr('data-failed-src', $img.attr('src'));
            $img.attr('src', app.resources.NO_IMAGE_URL);
        }
    },

    noImageHandler : function(img, errorHandler) {
        var $img = $(img);
        $img.on('error', function(){
            if(errorHandler){
                errorHandler(this);
            }
            else{
                app.util.noImage(this);
            }
        });
        // reload image in case we missed the error event
        var src = $img.attr('src');
        //$img.attr('src', ''); // this line crashes iOS 6.0
        if(app && app.resources && app.resources.BLANK_IMAGE_URL){
            $img.attr('src', app.resources.BLANK_IMAGE_URL);
        }
        $img.attr('src', src);
    },
    setCookie : function(c_name,value,exdays){
        // http://www.w3schools.com/js/js_cookies.asp
        var exdate=new Date();
        exdate.setDate(exdate.getDate() + exdays);
        var c_value=escape(value) + ((exdays==null) ? "" : "; expires="+exdate.toUTCString()) + "; path=/";
        document.cookie=c_name + "=" + c_value;
    },
    getCookie : function(c_name){
        // http://www.w3schools.com/js/js_cookies.asp
        var c_value = document.cookie;
        var c_start = c_value.indexOf(" " + c_name + "=");
        if (c_start == -1){
            c_start = c_value.indexOf(c_name + "=");
        }
        if (c_start == -1){
            c_value = null;
        }
        else {
            c_start = c_value.indexOf("=", c_start) + 1;
            var c_end = c_value.indexOf(";", c_start);
            if (c_end == -1) {
                c_end = c_value.length;
            }
            c_value = unescape(c_value.substring(c_start,c_end));
        }
        return c_value;

    },
    showHopup: function(url) {
        var dlg = app.dialog.create({options : app.dialog.settings});
        // Make sure any close buttons are initiated
        dlg.on("click", ".dialog-close-button", function(e){
            e.preventDefault();
            app.dialog.close();
        });

        $.ajax({
            url: url,
            data : {},
            target: dlg,
            success: function (e) {
                dlg.dialog("open"); // open after load to ensure dialog is centered
            }
        });
    }

};//end app.util

app.product = {
    init : function () {

        // Initialize CloudZoom
        if(!app.quickView.isActive()) {
            CloudZoom.quickStart();
        }


        app.product.initMobilePDPCarousel();

        if (app.page.params && app.page.params.egcimg){
            var egcImgPath = decodeURIComponent(app.page.params.egcimg);
            $('.swatches a[href$="' + egcImgPath + '"]').click();
        }
    },
    get : function (options) {
        // loads a product into a given container div
        // params
        //      containerId - id of the container div, if empty then global app.containerId is used
        //      source - source string e.g. search, cart etc.
        //      label - label for the add to cart button, default is Add to Cart
        //      url - url to get the product
        //      id - id of the product to get, is optional only used when url is empty
        var target = options.target || app.quickView.init();
        var source = options.source || "";
        var productUrl = options.url || app.util.appendParamToURL(app.urls.getProductUrl, "pid", options.id);
        if(source.length > 0) {
            productUrl = app.util.appendParamToURL(productUrl, "source", source);
        }
        // show small loading image
        //app.progress.show(app.ui.primary);
        app.ajax.load({
            target : target,
            url : productUrl,
            data : options.data || "",
            // replace with callback passed in by options
            callback : options.callback || app.product.init
        });
    },
    getAvailability : function (pid, quantity, callback) {
        app.ajax.getJson({
            url: app.util.appendParamsToUrl(app.urls.getAvailability, {pid:pid, Quantity:quantity}),
            callback: callback
        });
    },
    initAddThis : function () {
        var addThisServices = ["compact","facebook","myspace","google","twitter"],
            addThisToolbox = $(".addthis_toolbox"),
            addThisLinks="";

        var i,len=addThisServices.length;
        for (i=0;i<len;i++) {
            if (addThisToolbox.find(".addthis_button_"+addThisServices[i]).length==0) {
                addThisLinks += '<a class="addthis_button_'+addThisServices[i]+'"></a>';
            }
        }
        if (addThisLinks.length===0) { return; }

        addThisToolbox.html(addThisLinks);
        if(typeof addthis != 'undefined'){
            addthis.toolbox(".addthis_toolbox");
        }
    },
    initAddToCart : function (target) {
        if (target) {
        //	target.on("click", ".add-to-cart", setAddToCartHandler);
        }
        else {
            // calling off first ensures the event is not double hooked when init is called after ajax events
            // that don't replace the add-to-cart button
        //	$(".add-to-cart").off("click", setAddToCartHandler);
        //	$(".add-to-cart").on("click", setAddToCartHandler);
        }
    },
    initAddToWaitList : function (target) {
        if (target) {
            target.on("click",".add-to-waitlist", setAddToWaitListHandler);
        }
        else {
            $cache.pdpMain.on("click",".add-to-waitlist", setAddToWaitListHandler);
        }
    },
    updateQuantity :  function(options) {
        // load the updated quantity for the pdp
        var swatch = $('#product-content .product-variations ul.swatches.Color li.selected > a.swatchanchor').first();
        // Make sure that we aren't retrieving a gift card image, which breaks in Chrome and other similar browsers
        if (swatch.closest('.gift-card-image').length != 0) return;
        // If there is a swatch object, update quantity
        if(swatch.length){
            var url = swatch.attr('href');
            if(url){
                var params = {'format':'ajax'};
                url = app.util.appendParamsToUrl(url, params);
                $.ajax({
                    url: url,
                    success : function(response){
                        if(response){
                            var $response = $(response);
                            var $newQuantity = $response.find('select.select-quantity').first();
                            if($newQuantity && $newQuantity.length){
                                // for now, as a safety check, only continue if "data-incart" is greater than zero
                                if($newQuantity.attr('data-incart') && $newQuantity.attr('data-incart') > 0){
                                    var $oldQuantity = $('#product-content select.select-quantity');
                                    $oldQuantity.next('.selectboxit-container').remove();
                                    $oldQuantity.replaceWith($newQuantity);
                                    selectBoxIt($newQuantity);
                                    if(options && options.checkPurchaseLimit == true){
                                        app.product.purchaseLimit.check($newQuantity);
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }
    },
    //TODO-MONO Replace this with app.monogram.getImage
    getMonogramImage : function(assetName, monogramText, preset) {
        assetName = assetName.split('/');
        assetName = assetName.length == 1 ? assetName[0] : assetName[1];
        assetName = assetName.replace(/_R$/,'');

        var url = app.monogramImageUrl;
        url = url.replace('{0}', assetName);
        url = url.replace('{1}', monogramText.toUpperCase());
        url = url.replace('{2}', preset);

        return url;
    },

    initMobilePDPCarousel : function () {

        // bm - siteprefs storefront - cloudzoom
        if(Resources.CLOUD_ZOOM_ENABLED){

            // setup carousel items
            var pdpImg = $('.product-imagery-container');
            var carousel = pdpImg.find('.jcarousel');
            var controls = pdpImg.find('.controls');
            var control = pdpImg.find('.control');
            var thumblink = pdpImg.find('.thumbnail-link');

            // init carousel
            carousel.jcarousel({
                scroll: 1,
                itemFallbackDimension: 100,
                itemLoadCallback: {
                    onAfterAnimation: function (e) {
                        control.removeClass('active');
                        controls.find('#control-' + e.first).addClass('active');
                    }
                }
            // mobile swipe
            }).touchwipe({
                wipeLeft: function () {
                    carousel.jcarousel('next');
                },
                wipeRight: function () {
                    carousel.jcarousel('prev');
                },
                preventDefaultEvents: false
            });

            // pagination controls
            control.click(function (e) {
                control.removeClass('active');
                $(this).addClass('active');

                // get the current items index
                var delimiter = parseInt($(this).attr('id').split('-')[1]);

                // pass index to carousel scroll
                carousel.jcarousel('scroll', delimiter);
            });
        }
    },

    purchaseLimit : {

        check : function (quantity) {

            if(!quantity){
                quantity = $('#product-content .product-add-to-cart select.select-quantity');
            }
            var $quantity = $(quantity);
            if($quantity.length){
                var options = $quantity.find('option').length;
                var inCart = $quantity.attr('data-incart');
                if(options == 0 && inCart > 0 || $quantity.data('maxlimit')){
                    app.product.purchaseLimit.show();
                }
            }
        },
        show : function () {
            // purchase limit exceeded
            var $quantity = $('#product-content .product-add-to-cart .inventory .quantity .value');
            if($quantity.length){
                //clear out the quantity select box of all options to effectively disable it
                $quantity.find('select').html('')
                selectBoxIt($('select.select-quantity'));

            }
            var $availability = $('#product-content .product-add-to-cart .availability');
            if($availability.length){
                //clear out the current availability messaging and replace it with the purchase limit message
                $availability.find('.value').empty().html('<div class="availability-msg"><p class="not-available-msg">' + Resources.PRODUCT_PURCHASE_LIMIT + '</p></div>');
            }
            var addtocart = $('#add-to-cart');
            if(addtocart.length){
                addtocart.addClass('gray-disabled');
                addtocart.attr('disabled','disabled');
            }
        }

    },
    addToInCartTotal : function() {
        var quantityElement = $('#product-content .product-add-to-cart select.select-quantity');
        var quantity = quantityElement.attr('data-incart');
        if(quantity < 5){
            quantity++;
            quantityElement.attr('data-incart',quantity);
        }else{
            app.product.purchaseLimit.show();
        }
    }
};//end app.product

app.validator = {
    init : function () {

        $("form:not(.suppress)").each(function () {
            $(this).validate(app.validator.settings);
        });

    },
    initForm : function(f) {
        $(f).validate(app.validator.settings);
    },
    initFormWSettings : function(f,s){
        $(f).validate(s);
    },
    validEmail : function(value) {
        return regex.email.test($.trim(value));
    },
    aslConfirm : function(form){
        // create asl dialog popup
        var width = window.innerWidth < 480 ? 300 : 361;

        var dlg = app.dialog.create({target:$('#asl-confirmation'), options:{
            width: width,
            autoOpen: true,
            closeOnEscape: true,
            dialogClass: 'asl-confirmation-dialog',
            open: function( event, ui ) {

            var $form = form;
            var formdata = $form.serialize();
            $('#confirmation-link').click(function(e) {

                var checkbox = dlg.find('#jsp-asl-confirm');
                if(checkbox.is(':checked')){
                    // add hidden input field stating confirmation
                    $('<input>').attr({
                        type: 'hidden',
                        name: 'antiSpamInput',
                        value: 'true'
                    }).appendTo($form);

                    // close dialog
                    dlg.dialog("close");
                    // re submit form
                    $form.submit();

                    // reset antispam after use
                    $form.find('input[name=antiSpamInput]').remove();
                }
            });
           }
        }});
    }
}; //end app.validator

app.quickView = {
    initializeButton : function (container, target) {
        // quick view button
        if(navigator.userAgent.match(/iPad/i) == null){
            $(container).on("mouseenter", target, function (e) {
                if(!$cache.qvButton) {
                    $cache.qvButton = $("<a id='quickviewbutton'/>");
                    $cache.qvButton.html(app.resources['QUICKSHOP']);
                }
                bindQvButton();

                var link = $(this).children("a:first");
                $cache.qvButton.attr({
                    "href" : link.attr("data-full-url"),
                    "title" : link.attr("title")
                }).appendTo($(this));
            });
        }
    },

    initQuickViewCarousel : function () {
    var dialogContainer = $('#quick-view-dialog');
    var productImage = dialogContainer.find($('.product-primary-image img'));

    $(".thumb a").click(function(e){
        e.preventDefault();
        var imageSrc = $(this).attr('href');
        productImage.attr('src', imageSrc)
        $(e.target).closest(".thumb .jcarousel-item li").addClass("selected").siblings().removeClass("selected");
    });

    var $list = dialogContainer.find('#thumbnail-carousel');
    var next = dialogContainer.find('#next');
    var prev = dialogContainer.find('#prev');
    var jcarouselPrev = dialogContainer.find('.jcarousel-prev');
    var jcarouselNext = dialogContainer.find('.jcarousel-next');

    var $first = $('li:first', $list),
        $last = $('li:last', $list);
        next.click(function (e) {
            var $next, $selected = dialogContainer.find((".thumb.selected"));
            $next = $selected.next('li').length ? $selected.next('li') : $first;
            $selected.removeClass("selected");
            $next.addClass('selected');
            productImage.attr('src', $next.find('a').attr("href"));
            if ($last.hasClass('selected')) {
                $(".jcarousel-next").trigger( "click" );
            }

        });

        prev.click(function () {
            var $prev, $selected = dialogContainer.find((".thumb.selected"));
            $prev = $selected.prev('li').length ? $selected.prev('li') : $last;
            $selected.removeClass("selected");
            $prev.addClass('selected');
            productImage.attr('src', $prev.find('a').attr("href"));

            if ($first.hasClass('selected')) {
                $(".jcarousel-prev").trigger( "click" );
            }

        });

        $list.jcarousel({
            auto: 0,
            vertical:true,
            scroll:1
        });

        // 1 alt image no need to display arrows
        if (dialogContainer.find('#thumbnail-carousel li').length <= 1) {
            jcarouselPrev.hide();
            jcarouselNext.hide();
            next.hide();
            prev.hide();
        }

        productImage.touchwipe({
            wipeLeft: function() { $('#next').click(); },
            wipeRight: function() { $('#prev').click(); },
            preventDefaultEvents: false
        });
        $(function() {
            var pdpMain = $('#pdpMain');
            var iscNext = pdpMain.find($('.jcarousel-next')).is(':hidden');
            var iscPrev = pdpMain.find($('.jcarousel-prev')).is(':hidden');
            var carouselClip = pdpMain.find('.jcarousel-clip');

            if(iscNext && iscPrev){
                carouselClip.css({'margin-top': '0'});
            }
        });

    },

    init : function () {
        if(app.quickView.exists()) {
            return $cache.quickView;
        }
        $cache.quickView = $("<div/>").attr("id", "quick-view-dialog").appendTo(document.body);
        return $cache.quickView;
    },
    // show quick view dialog and send request to the server to get the product
    // options.source - source of the dialog i.e. search/cart
    // options.url - product url
    show : function (options) {
        options.target = app.quickView.init();
        options.callback = function () {
            app.product.init();
            var width = 774;

            app.dialog.create({
                target : $cache.quickView,
                options : {
                    height : 'auto',
                    width : width,
                    dialogClass : 'quickview',
                    title : 'Product Quickview',
                    resizable : false,
                    position : 'center',
                    open : function () {
                        app.progress.hide();
                        if(app.resources.SESSION_CUSTOM_SITEID === 'katemobile'){
                            $('.ui-widget-overlay').bind('click', function() {
                                $('.quickview, #quick-view-dialog ').dialog('close');
                            });
                        }
                        app.tooltips.init();
                        if (typeof FB != 'undefined' && 'XFBML' in FB && 'parse' in FB.XFBML) {
                            $('fb\\:like').attr('href',options.url.replace('source=cart', 'source='));
                            FB.XFBML.parse();
                        }
                        //True Fit
                        if (typeof tfc !== 'undefined'){
                            tfc.calculate();
                        }
                    }
                }
            });

            // If the quick view is for an eGC search for the selected swatch and select it
            if (options.egcimg){
                var egcImgPath = options.egcimg;
                // make sure we have an EGC image path supplied
                if (typeof(egcImgPath) != 'undefined' && egcImgPath != ''){
                    $('.swatches a')
                        .filter(function(i,e){
                            // search for a swach with a matching image name
                            var $this = $(this);
                            var href = $this.attr('href');
                            if (typeof(href) == 'undefined' || href == ''){
                                return false;
                            }
                            var uri = app.util.getUri(href);
                            return (uri.page == egcImgPath);
                    }).click(); // 'click' swatch to select it
                }
            }
            $cache.quickView.dialog('open');
            app.quickView.initQuickViewCarousel();
        };
        app.product.get(options);
        return $cache.quickView;
    },
    // close the quick view dialog
    close : function () {
        if($cache.quickView) {
            $cache.quickView.dialog('close').empty();
            return $cache.quickView;
        }
    },
    exists : function () {
        return $cache.quickView && ($cache.quickView.length > 0);
    },
    isActive : function () {
        return $cache.quickView && ($cache.quickView.length > 0) && ($cache.quickView.children.length > 0);
    }
};//end app.quickView

app.minicart = {
    url : "", // during page loading, the Demandware URL is stored here
    // app.minicart.init: initializations
    countdownID : null,
    init : function () {

        var minicart = $("#mini-cart");
        var mcCondensed = $("#mini-cart-condensed");

        var mcTotal = minicart.find(".mini-cart-total");

        var moved = false;


        if (typeof(sr_refreshMessages) != 'undefined'){
            sr_updateMessages();
        }
        // check to see if we need to move the mini cart
        if(mcCondensed.length){

            $cache.mcCondensed = mcCondensed;

            var mcContentRegular = minicart.find(".mini-cart-content");
            var mcContentCondensed = mcCondensed.find(".mini-cart-content");
            var headerCondensed = $('#header-condensed');
            if(headerCondensed.length){
                if(headerCondensed.hasClass('visible')){
                    // use the condensed header
                    $cache.minicart = mcCondensed;
                    mcTotal = $cache.minicart.find(".mini-cart-total");
                    if(mcContentRegular && mcContentRegular.length){
                        // move mini-cart-content from regular header to condensed header
                        mcContentRegular.appendTo(mcTotal);
                        moved = true;
                    }
                    // copy count into regular header
                    $('#mini-cart .mini-cart-label').html($('#mini-cart-condensed .mini-cart-label').html());
                }
                else{
                    // use the regular header
                    $cache.minicart = minicart;
                    mcTotal = $cache.minicart.find(".mini-cart-total");
                    if(mcContentCondensed && mcContentCondensed.length){
                        // move mini-cart-content from condensed header to regular header
                        mcContentCondensed.appendTo(mcTotal);
                        moved = true;
                    }
                    // copy count into condensed header
                    $('#mini-cart-condensed .mini-cart-label').html($('#mini-cart .mini-cart-label').html());
                }
            }
        }
        else{
            $cache.minicart = minicart;
        }

        if(moved){
            $cache.mcContainer.removeClass('expanded');
        }

        $cache.mcRefresh = $cache.minicart.find(".mini-cart-refresh");
        $cache.mcTotal = $cache.minicart.find(".mini-cart-total");
        $cache.mcContent = $cache.minicart.find(".mini-cart-content");
        $cache.mcContainer = $cache.minicart.parents(".cart-link");
        $cache.mcClose = $cache.minicart.find(".mini-cart-close");
        $cache.mcProductList = $cache.minicart.find(".mini-cart-products");
        $cache.mcProducts = $cache.mcProductList.children(".mini-cart-product");
        //var collapsed = $cache.mcProductList.children().not(":first").addClass("collapsed");

        $cache.minicart.find('.mini-cart-image img').each(function(){
            app.util.noImageHandler(this);
        });

        if ($cache.mcContent.length == 0) {
            $cache.mcContainer.removeClass('expanded');
        }

        if(!initialized || moved){

            if($cache.mcContent.is(":visible")) {
                $cache.mcContainer.addClass('expanded');
            }

            if ( app.resources.SESSION_CUSTOM_SITEID != 'katemobile' )
            {
                // non-mobile event handlers

                // using click.minicart namespace to prevent duplication of events
                $cache.minicart.unbind("mouseover.minicart").unbind("mouseleave.minicart");

                // bind click event to the cart total link at the top right corner of the condensed header
                $cache.minicart.on("mouseover.minicart", ".mini-cart-link", function () {
                    if(!$cache.mcContent.is(":visible") && $(this).parents('.checkout-redesign').length == 0) {
                        // open the mini cart
                        app.minicart.slide();
                    }
                });

                $cache.minicart.on("mouseover.minicart", ".mini-cart-content", function (e) {
                    timer.clear();
                });

                $cache.minicart.on("mouseleave.minicart", ".mini-cart-total", function (e) {
                    if($cache.mcContent.is(":visible")) {
                        timer.clear();
                        timer.start(app.minicart.close,app.resources.MINICART_TIMEOUT);
                    }
                });
            }
            else
            {
                // mobile event handlers
                $cache.minicart.on("click", ".mini-cart-link", function (e) {
                    e.preventDefault();
                    if (!$cache.mcContent.is(":visible")) {
                        app.minicart.slide();
                    }
                });
            }

            $cache.minicart.on("click", ".close", function (e) {
                if($cache.mcContent.is(":visible")) {
                    app.minicart.close();
                }
            });

            //show remove button on hover
            $cache.minicart.on("mouseover", ".mini-cart-product", function(){
                $(this).find(".mini-cart-remove").show();
            })
            .on("mouseleave", ".mini-cart-product", function(){
                $(this).find(".mini-cart-remove").hide();
            });

            $cache.minicart.on("click", ".mini-cart-remove", function (e) {
                e.preventDefault();
                var uuid = $(this).parents('.mini-cart-product').data('uuid');
                if (uuid) {
                    $.ajax({
                        url : app.util.ajaxUrl(app.urls.removeProduct),
                        data : { "uuid" : uuid },
                        dataType : "html",
                        success : function (response) {
                            app.minicart.update(response);
                        }
                    });
                }
            });

            initialized = true;

        }

    },
    // reloads the mini cart, used by katespade.js for moving between the two different headers
    reload : function () {
        app.minicart.init();
        if($cache.mcContainer.hasClass('expanded')){
            app.minicart.close();
            app.minicart.slide();
        }
    },
    // shows the given content in the mini cart
    show : function (html) {
        app.minicart.update(html);
        if(!$cache.mcCondensed){
            // only scroll up to the top if we don't have a condensed version
            app.util.scrollBrowser(0);
        }
        app.minicart.slide();
        app.bonusProductsView.loadBonusOption();
        // after a time out automatically close it
        timer.start(app.minicart.close,app.resources.MINICART_TIMEOUT);
    },
    // slide down and show the contents of the mini cart
    slide : function () {
        app.minicart.init();
        if(app.minicart.suppressSlideDown && app.minicart.suppressSlideDown()) {
            return;
        }
        $cache.mcContainer.addClass('expanded');
        timer.clear();
        // show the item
        if(!$cache.mcContent.attr('style')){
            // adding this will ensure it slides the first time
            $cache.mcContent.css('display','none');
        }

        // On the mobile site, the opened search bar overlays the min-cart
        if (app.resources.SESSION_CUSTOM_SITEID === 'katemobile') {
            $('.header-search-bar').removeClass('open');
        }

        $('.mini-cart-mask').css({visibility: 'visible', opacity: '0.8'});
        $cache.mcContent.slideDown('slow', function(){
            $cache.mcContainer.addClass('expanded');
            timer.clear();
            if (app.resources.SESSION_CUSTOM_SITEID !== 'katemobile') {
                timer.start(app.minicart.close,app.resources.MINICART_TIMEOUT);
            }
        });
    },
    // closes the mini cart with given delay
    close : function (delay) {
        timer.clear();
        $('.mini-cart-mask').css({opacity: '0'});
        $cache.mcContent.slideUp('slow', function(){
            $cache.mcContainer.removeClass('expanded');
            $('.mini-cart-mask').css({visibility: 'hidden'});
            $(this).removeClass('show');
        });
    },
    // hook which can be replaced by individual pages/page types (e.g. cart)
    suppressSlideDown : function () {
        return false;
    },
    // update minicart html
    update : function (html) {
        $cache.mcRefresh.replaceWith(html);
        app.minicart.init();
    },
    // app.minicart.flyout: show flyout instead of minicart
    flyout : function (html,pdpMain,targetButton,customMessage) {

        var addtocart = (targetButton != null)? targetButton : $('#add-to-cart');

        if(addtocart.length){

            var addtocart = (targetButton != null)? targetButton : $('#add-to-cart');

            var flyout = $('#minicart-flyout');
            if(flyout.length){
                flyout.remove();
            }

            var $html = $(html);
            var $purchaseLimitMsg = $html.find('.purchase-limit-exceeded');
            if($purchaseLimitMsg.length ){ // for now only enable on kate spade and kate sale){
                app.product.purchaseLimit.show();
            }
            else{
                flyout = $('<div></div>').attr('id', 'minicart-flyout');
                flyout.html(html);
                if (customMessage != null) {
                    flyout.html('<div class="availability-msg purchase-limit-exceeded"><p>' + customMessage + '</p></div>');
                }

                if($purchaseLimitMsg.length){
                    flyout.addClass('purchase-limit');
                    addtocart.attr('disabled', 'disabled');
                }

                addtocart.after(flyout);
                if ( app.resources.SESSION_CUSTOM_SITEID === 'katemobile' ) {

                    flyout.dialog({
                        dialogClass: "minicart-flyout-dialog",
                        title: flyout.find('.mini-cart-title').remove().html(),
                        modal: true,
                        open: function(){
                            $('.ui-widget-overlay').bind('click',function(){
                                flyout.dialog('close');
                            })
                        }
                    }).find('.mini-cart-link-continue').on('click', function(e) {
                        flyout.dialog('close');
                    });

                } else {
                    timer.clear();
                    timer.start(app.minicart.closeFade,app.resources.ADDBAG_TIMEOUT);

                    flyout.on("mouseleave", function (e) {
                        timer.start(app.minicart.closeFade,app.resources.ADDBAG_TIMEOUT);
                    });

                    flyout.on("mouseover", function (e) {
                        timer.clear();
                    });

                    flyout.find('.mini-cart-image img').each(function(){
                        app.util.noImageHandler(this);
                    });
                    $('.continue-shopping-button').off('click');
                    $('.continue-shopping-button').on('click', function(e) {
                        e.preventDefault();
                        $('#minicart-flyout').hide();
                    });
                }
            }
        }

    },
    closeFade : function (){
        $('#minicart-flyout').fadeOut('slow');
    },
    cancel : function (){
        timer.clear();
    }
};//end app.minicart
var currentRequests = [];
app.ajax = {
    // ajax request to get json response
    // @param - async - boolean - asynchronous or not
    // @param - url - String - uri for the request
    // @param - data - name/value pair data request
    // @param - callback - function - callback function to be called
    getJson: function (options) {
        var currentRequests = [];
        options.url = app.util.toAbsoluteUrl(options.url);
        // return if no url exists or url matches a current request
        if(!options.url || currentRequests[options.url]) {
            return;
        }

        currentRequests[options.url] = true;
        // make the server call
        $.ajax({
            dataType : "json",
            url : options.url,
            async : (typeof options.async==="undefined" || options.async===null) ? true : options.async,
            data : options.data || {}
        })
        // success
        .done(function (response) {
            if(options.callback) {
                options.callback(response);
            }
        })
        // failed
        .fail(function (xhr, textStatus) {
            if(textStatus === "parsererror") {
                window.alert(app.resources.BAD_RESPONSE);
            }
            if(options.callback) {
                options.callback(null);
            }
        })
        // executed on success or fail
        .always(function () {
            // remove current request from hash
            if(currentRequests[options.url]) {
                delete currentRequests[options.url];
            }
        });
    },
    // ajax request to load html response in a given container
    // @param - url - String - uri for the request
    // @param - data - name/value pair data request
    // @param - callback - function - callback function to be called
    // @param - target - Object - Selector or element that will receive content
    load : function (options) {
        options.url = app.util.toAbsoluteUrl(options.url);
        // return if no url exists or url matches a current request
        if(!options.url || currentRequests[options.url]) {
            return;
        }
        currentRequests[options.url] = true;
        // make the server call
        $.ajax({
            dataType : "html",
            url : app.util.appendParamToURL(options.url, "format", "ajax"),
            data : options.data,
            type: options.type ? options.type : 'GET'
        })
        .done(function (response) {
            // success
            if(options.target) {
                $(options.target).empty().html(response);
            }
            if(options.callback) {
                options.callback(response);
            }
        })
        .fail(function (xhr, textStatus) {
            // failed
            if(textStatus === "parsererror") {
                window.alert(app.resources.BAD_RESPONSE);
            }
            if ('callback' in options) {
                options.callback(null, textStatus);
            }
        })
        .always(function () {
            app.progress.hide();
            // remove current request from hash
            if(currentRequests[options.url]) {
                delete currentRequests[options.url];
            }
        });
    }
};//end app.ajax

app.monogram = {
    init : function () {
        // First, checks if it isn't implemented yet.
        if (!String.prototype.format) {
          String.prototype.format = function() {
            var args = arguments;
            return this.replace(/{(\d+)}/g, function(match, number) {
              return typeof args[number] != 'undefined'
                ? args[number]
                : match
              ;
            });
          };
        }
    }
};

var loader;
var lastContainer;
var depth = 0;
app.progress = {
    show: function (container, navigateToLink) {
        depth++;
        if (depth > 1) return;
        var target = (!container || $(container).length===0) ? $("body") : $(container);
        var loader;
        // PCRSPADES-23: keep user from scrolling if the whole page is meant to be hidden
        if(target.is('body')) target.css('overflow', 'hidden');
        // PCRSPADES-23 - site specific loading, even on cart
        loader = $("<div/>").addClass("loader")
                .append($("<div/>").addClass(app.resources.SESSION_CUSTOM_SITEID + "-loader-indicator"), $("<div/>").addClass("loader-bg"));
        lastContainer = target;
        loader.appendTo(target).show();

        if (navigateToLink == null) return true;

        setTimeout(function() {window.location = navigateToLink;},1000);
    },
    hide: function (container) {
        depth = Math.max(depth-1,0);
        if (depth > 0) return;
        var target = container || lastContainer;
        if(target){
            // PCRSPADES-23: allow user to from scrolling if the whole page
            if(target.is('body')) target.css('overflow', 'auto');
            var loader = target.find('.loader');
            if(false){
                // fadeOut seems to prevent clicking in KateSpade in IE
                loader.hide();
            }
            else{
                loader.fadeOut('fast', function() {loader.remove();});
            }
        }
    },
    // PCRSPADES-23: Allow progress when submitting forms natively
    submitForm: function (buttons){
        buttons.each( function(index){
            var button = $(this);
            var form = button.closest('form');

            // Capture submit of the form
            button.on('click',function(e){
                // Make sure the form isn't looping its submit
                if( !$cache[form.attr('id')] ){
                    // Make sure it is valid
                    //if( form.valid()  x) {
                        // Prevent the form from submitting right away so that the progress overlay can display
                        e.preventDefault();

                        // lock the form submission
                        $cache[form.attr('id')] = true;

                        // Display progress overlay with the $('body') as the default target
                        app.progress.show();

                        // Submit the form now that the overlay has had time to populate
                        setTimeout(function(){
                            // we need to send demandware the 'save' action so the form is processed correctly
                            $("<input/>").attr({type:"hidden", name: button.attr("name")}).appendTo(form);
                            // Submit the form
                            form.submit();
                        },1000);
                    //}
                }
            });
        });
    }
};//end app.progress

app.tooltips = {
    init : function () {
        // TOOLTIP
       /***** start checkout redesign events *****/
        if ($(".page-heading.v2").length || $(".checkout-redesign").length ) {
            $('body').addClass('CRv2');
            $(".phone-tip-row .tip").on('mouseenter', function(){
                $("#tooltip").addClass('phone');
            });
            $(".form-row.phone-tip-row.cvn .tip").on('mouseenter', function(){
                $("#tooltip").addClass('cvn');
            });


            var $cvcField = $('.input-text.cvc.required');
            var $phoneField = $('.input-text.phone.required');
            var $toolTip = $('.phone-tip-row');
            /***********************************************
            * Function to hide tooltip from row
            * once the user has started typing so the error
            * and valid icons do not overlap
            ************************************************/
            $phoneField.on('keydown', function() {
                $toolTip.hide();
             });
            $cvcField.on('keydown', function() {
                $toolTip.hide();
             });
            /*************************************************
            * Function to hide tooltip from row
            * if the user clicks into the fieled then out
            * without typing so the error icon does not overlap
            **************************************************/
            $phoneField.on('focusout', function() {
                $toolTip.hide();
             });
            $cvcField.on('focusout', function() {
                $toolTip.hide();
             });

        }
        /***** end of checkout redesign events *****/

        $('.tip').on('mouseenter', function(){
            var $this = $(this);
            if(!$cache.tip) {
                $cache.tip = $('#tooltip');
                if ( app.resources.SESSION_CUSTOM_SITEID === 'katemobile' ) {
                    $cache.bg = $("<div id='tooltip-mask'></div>");
                    $cache.bg.insertBefore($cache.tip);
                    $cache.bg.on("click", function(e) {
                        tooltipClosing();
                    });
                }
            }
            var cnt = $($this.data('content'));
            var width = $this.data('width');
            var ctop = $this.offset().top;
            var cleft = $this.offset().left;
            var align = $this.data('align');
            if(!align){
                align = '';
            }
            // when the tooltip is open, this adds opacity
            if ( app.resources.SESSION_CUSTOM_SITEID === 'katemobile' ) {
                $cache.bg.css({visibility: 'visible', opacity: '0.8'});
            }
            // Populate tip with content
            $cache.tip.find('.body').html(cnt.html())
            // Adjust width
            if (width) {
                $cache.tip.css('width',width);
            }

            // Adjust position
            if (align.indexOf('right') >= 0) {
                // right align
                if (align.indexOf('innerright') < 0) {
                    // for side right, add width of element and 5 pixels for spacing
                    cleft = cleft + $this.outerWidth() + 5;
                }
            }
            else {
                // left align
                // subtract width of tip box
                cleft = cleft - $cache.tip.outerWidth();
                if (align.indexOf('innerleft') >= 0) {
                    // for inner left, subtract width of element
                    cleft = cleft + $this.outerWidth();
                }
                else {
                    // default to left outer align
                    // for outer left, subtract extra 5 pixels for spacing
                    cleft = cleft - 5;
                }
            }
            if (align.indexOf('bottom') >= 0) {
                // bottom align
                if (align.indexOf('innerbottom') < 0) {
                    // for outer bottom (aka bottom), add element height and extra 5 pixels for spacing
                    ctop = ctop + $this.outerHeight() +5;
                }
            }
            else {
                // for backwards compatiblity, default to 20 pixels up from top of element
                ctop = ctop - 20;
            }

            // Position tip
            $cache.tip.css({'left': cleft, 'top': ctop})
            $cache.tip.stop(clearQueue, jumpToEnd).show();
            mouseOnTrigger = true;
        }).on('mouseleave', function(){
            tooltipClosing();
            mouseOnTrigger = false;
        }).each(function(){
            // Disable click event on tooltip links for the mobile site
            if ( app.resources.SESSION_CUSTOM_SITEID === 'katemobile' ) {
                $(this).closest('a').on('click', function(e) {
                    e.preventDefault();
                });
            }
        });

        $(document).on('mouseenter','#tooltip', function() {
            if ( app.resources.SESSION_CUSTOM_SITEID === 'katemobile' ) {
                $('#wrapper').addClass('tooltiphelp');
            }

            mouseOnTip = true;
        }).on('mouseleave','#tooltip', function() {
            tooltipClosing();
            mouseOnTip = false;
        }).on('click', '.closeHelp', function(){
            if ( app.resources.SESSION_CUSTOM_SITEID === 'katemobile' ) {
                tooltipClosing();
                mouseOnTip = false;
                $('#wrapper').removeClass('tooltiphelp');
            }
        });
    }
};

app.triggerUISCartCheck = triggerUISCartCheck;

// general extension functions
(function () {
    String.format = function () {
        var s = arguments[0];
        var i, len = arguments.length - 1;
        for (i = 0; i < len; i++) {
            var reg = new RegExp('\\{' + i + '\\}', 'gm');
            s = s.replace(reg, arguments[i + 1]);
        }
        return s;
    };
})();

function bindQvButton() {
    $cache.qvButton.one("click", function (e) {
        e.preventDefault();
        app.quickView.show({
            url : $(this).attr("href"),
            source : "quickview"
        });
    });
}

function selectBoxIt(select) {

    var items = select.filter('select');
    if (items.length == 0) return;

    // select box replacement is disabled for certain parts of the site
    if ("page" in app && "ns" in app.page &&
            (app.page.type == 'checkout'
            || app.page.type == 'orderconfirmation'
            || app.page.type == 'GiftRegistry'
            )) {
        var item = null;

        items.each(function() {
            item = $(this);
            if (item.parent('div.select-container').length == 0){
                var label = item.next('label');
                var valid = label.next('.valid-icon');
                $('<div class="select-container" />').insertBefore(item).append(item).append(label).append(valid);
            }
        });
    }else {
        items.each(function(){
            var item = $(this);
            try {
                item.addClass('replaced');
                var sb = item.selectBoxIt().data("selectBoxIt");
                sb.refresh();
                items.bind({
                    "open": function() {
                         // Adds the Twitter Bootstrap 'dropup' class to the
                            // drop down
                        $(this).next('.selectboxit-container').addClass('open')
                    },
                    'close': function(){
                        $(this).next('.selectboxit-container').removeClass('open')
                    },
                    'focusin' : function() {
                        $(this).next('.selectboxit-container').addClass('focus');
                    },
                    'focusout' : function() {
                        $(this).next('.selectboxit-container').removeClass('focus');
                    }
               });
                // add availablity message within dropdown
                sb.dropdownContainer.find('li[data-text] a').each(function(){
                    var a = $(this);
                    var li = a.parent();
                    var dataText = li.data('text');
                    if(dataText){
                        var html = a.html();
                        if(html.indexOf(dataText) == -1){
                            li.addClass('avail');
                            a.html('<span class="size">' + html + '</span>&nbsp;<span class="msg">' + dataText + '</span>');
                        }
                    }
                });
            }catch(e){}
        });


    }
}

var countries = require('./countries'),
dialog = require('./dialog'),
datalayer = require('./datalayer'),
floatlabels = require('./float-labels'),
minicart = require('./minicart'),
page = require('./page'),
rating = require('./rating'),
searchplaceholder = require('./searchplaceholder'),
searchsuggest = require('./searchsuggest'),
tooltip = require('./tooltip'),
util = require('./util'),
validator = require('./validator'),
tls = require('./tls'),
emailsubscription = require('./emailsubscription'),
login = require('./login');


// initialize app
$(document).ready(function () {
    app.init();
});
},{"./ValidationRules":25,"./captcha":29,"./cookieprivacy":31,"./countries":32,"./datalayer":33,"./dialog":34,"./emailsubscription":35,"./float-labels":36,"./jquery-ext":41,"./login":42,"./minicart":43,"./page":44,"./pages/account":45,"./pages/cart":46,"./pages/checkout":50,"./pages/checkout/orderconfirmation":52,"./pages/compare":54,"./pages/product":58,"./pages/registry":62,"./pages/search":63,"./pages/storefront":64,"./pages/storelocator":65,"./pages/wishlist":66,"./rating":70,"./searchplaceholder":71,"./searchsuggest":72,"./tls":80,"./tooltip":81,"./util":82,"./validator":83}],28:[function(require,module,exports){
'use strict';

var dialog = require('./dialog'),
    page = require('./page'),
    util = require('./util');

var selectedList = [];
var maxItems = 1;
var bliUUID = '';

/**
 * @private
 * @function
 * description Gets a list of bonus products related to a promoted product
 */
function getBonusProducts() {
    var bonusproducts = [];

    var i, len;
    for (i = 0, len = selectedList.length; i < len; i++) {
        var p = {
            pid: selectedList[i].pid,
            qty: selectedList[i].qty,
            options: {}
        };
        var a, alen, bp = selectedList[i];
        if (bp.options) {
            for (a = 0, alen = bp.options.length; a < alen; a++) {
                var opt = bp.options[a];
                p.options = {optionName:opt.name, optionValue:opt.value};
            }
        }
        bonusproducts.push({product:p});
    }
    return {bonusproducts: bonusproducts};
}

var selectedItemTemplate = function (data) {
    var attributes = '';
    for (var attrID in data.attributes) {
        var attr = data.attributes[attrID];
        attributes += '<li data-attribute-id="' + attrID + '">\n';
        attributes += '<span class="display-name">' + attr.displayName + '</span>: ';
        attributes += '<span class="display-value">' + attr.displayValue + '</span>\n';
        attributes += '</li>';
    }
    attributes += '<li class="item-qty">\n';
    attributes += '<span class="display-name">Qty</span>: ';
    attributes += '<span class="display-value">' + data.qty + '</span>';
    return [
        '<li class="selected-bonus-item" data-uuid="' + data.uuid + '" data-pid="' + data.pid + '">',
        '<i class="remove-link fa fa-remove" title="Remove this product" href="#"></i>',
        '<div class="item-name">' + data.name + '</div>',
        '<ul class="item-attributes">',
        attributes,
        '<ul>',
        '<li>'
    ].join('\n');
};

// hide swatches that are not selected or not part of a Product Variation Group
var hideSwatches = function () {
    $('.bonus-product-item:not([data-producttype="master"]) .swatches li').not('.selected').not('.variation-group-value').hide();
    // prevent unselecting the selected variant
    $('.bonus-product-item .swatches .selected').on('click', function () {
        return false;
    });
};

/**
 * @private
 * @function
 * @description Updates the summary page with the selected bonus product
 */
function updateSummary() {
    var $bonusProductList = $('#bonus-product-list');
    if (!selectedList.length) {
        $bonusProductList.find('li.selected-bonus-item').remove();
    } else {
        var ulList = $bonusProductList.find('ul.selected-bonus-items').first();
        var i, len;
        for (i = 0, len = selectedList.length; i < len; i++) {
            var item = selectedList[i];
            var li = selectedItemTemplate(item);
            $(li).appendTo(ulList);
        }
    }

    // get remaining item count
    var remain = maxItems - selectedList.length;
    $bonusProductList.find('.bonus-items-available').text(remain);
    if (remain <= 0) {
        $bonusProductList.find('.select-bonus-item').attr('disabled', 'disabled');
    } else {
        $bonusProductList.find('.select-bonus-item').removeAttr('disabled');
    }
}

function initializeGrid () {
    var $bonusProduct = $('#bonus-product-dialog'),
        $bonusProductList = $('#bonus-product-list'),
        bliData = $bonusProductList.data('line-item-detail');
    maxItems = bliData.maxItems;
    bliUUID = bliData.uuid;

    if (bliData.itemCount >= maxItems) {
        $bonusProductList.find('.select-bonus-item').attr('disabled', 'disabled');
    }

    var cartItems = $bonusProductList.find('.selected-bonus-item');
    cartItems.each(function () {
        var ci = $(this);
        var product = {
            uuid: ci.data('uuid'),
            pid: ci.data('pid'),
            qty: ci.find('.item-qty').text(),
            name: ci.find('.item-name').html(),
            attributes: {}
        };
        var attributes = ci.find('ul.item-attributes li');
        attributes.each(function () {
            var li = $(this);
            product.attributes[li.data('attributeId')] = {
                displayName:li.children('.display-name').html(),
                displayValue:li.children('.display-value').html()
            };
        });
        selectedList.push(product);
    });

    $bonusProductList.on('click', '.bonus-product-item a[href].swatchanchor', function (e) {
        e.preventDefault();
        var url = this.href,
            $this = $(this);
        url = util.appendParamsToUrl(url, {
            'source': 'bonus',
            'format': 'ajax'
        });
        $.ajax({
            url: url,
            success: function (response) {
                $this.closest('.bonus-product-item').empty().html(response);
                hideSwatches();
            }
        });
    })
    .on('change', '.input-text', function () {
        $bonusProductList.find('.select-bonus-item').removeAttr('disabled');
        $(this).closest('.bonus-product-form').find('.quantity-error').text('');
    })
    .on('click', '.select-bonus-item', function (e) {
        e.preventDefault();
        if (selectedList.length >= maxItems) {
            $bonusProductList.find('.select-bonus-item').attr('disabled', 'disabled');
            $bonusProductList.find('.bonus-items-available').text('0');
            return;
        }

        var form = $(this).closest('.bonus-product-form'),
            detail = $(this).closest('.product-detail'),
            uuid = form.find('input[name="productUUID"]').val(),
            qtyVal = form.find('input[name="Quantity"]').val(),
            qty = (isNaN(qtyVal)) ? 1 : (+qtyVal);

        if (qty > maxItems) {
            $bonusProductList.find('.select-bonus-item').attr('disabled', 'disabled');
            form.find('.quantity-error').text(Resources.BONUS_PRODUCT_TOOMANY);
            return;
        }

        var product = {
            uuid: uuid,
            pid: form.find('input[name="pid"]').val(),
            qty: qty,
            name: detail.find('.product-name').text(),
            attributes: detail.find('.product-variations').data('attributes'),
            options: []
        };

        var optionSelects = form.find('.product-option');

        optionSelects.each(function () {
            product.options.push({
                name: this.name,
                value: $(this).val(),
                display: $(this).children(':selected').first().html()
            });
        });
        selectedList.push(product);
        updateSummary();
    })
    .on('click', '.remove-link', function (e) {
        e.preventDefault();
        var container = $(this).closest('.selected-bonus-item');
        if (!container.data('uuid')) { return; }

        var uuid = container.data('uuid');
        var i, len = selectedList.length;
        for (i = 0; i < len; i++) {
            if (selectedList[i].uuid === uuid) {
                selectedList.splice(i, 1);
                break;
            }
        }
        updateSummary();
    })
    .on('click', '.add-to-cart-bonus', function (e) {
        e.preventDefault();
        var url = util.appendParamsToUrl(Urls.addBonusProduct, {bonusDiscountLineItemUUID: bliUUID});
        var bonusProducts = getBonusProducts();
        if (bonusProducts.bonusproducts[0].product.qty > maxItems) {
            bonusProducts.bonusproducts[0].product.qty = maxItems;
        }
        // make the server call
        $.ajax({
            type: 'POST',
            dataType: 'json',
            cache: false,
            contentType: 'application/json',
            url: url,
            data: JSON.stringify(bonusProducts)
        })
        .done(function () {
            // success
            page.refresh();
        })
        .fail(function (xhr, textStatus) {
            // failed
            if (textStatus === 'parsererror') {
                window.alert(Resources.BAD_RESPONSE);
            } else {
                window.alert(Resources.SERVER_CONNECTION_ERROR);
            }
        })
        .always(function () {
            $bonusProduct.dialog('close');
        });
    })
    .on('click', '#more-bonus-products', function (e) {
        e.preventDefault();
        var uuid = $('#bonus-product-list').data().lineItemDetail.uuid;

        //get the next page of choice of bonus products
        var lineItemDetail = JSON.parse($('#bonus-product-list').attr('data-line-item-detail'));
        lineItemDetail.pageStart = lineItemDetail.pageStart + lineItemDetail.pageSize;
        $('#bonus-product-list').attr('data-line-item-detail', JSON.stringify(lineItemDetail));

        var url = util.appendParamsToUrl(Urls.getBonusProducts, {
            bonusDiscountLineItemUUID: uuid,
            format: 'ajax',
            lazyLoad: 'true',
            pageStart: lineItemDetail.pageStart,
            pageSize: $('#bonus-product-list').data().lineItemDetail.pageSize,
            bonusProductsTotal: $('#bonus-product-list').data().lineItemDetail.bpTotal
        });

        $.ajax({
            type: 'GET',
            cache: false,
            contentType: 'application/json',
            url: url
        })
        .done(function (data) {
            //add the new page to DOM and remove 'More' link if it is the last page of results
            $('#more-bonus-products').before(data);
            if ((lineItemDetail.pageStart + lineItemDetail.pageSize) >= $('#bonus-product-list').data().lineItemDetail.bpTotal) {
                $('#more-bonus-products').remove();
            }
        })
        .fail(function (xhr, textStatus) {
            if (textStatus === 'parsererror') {
                window.alert(Resources.BAD_RESPONSE);
            } else {
                window.alert(Resources.SERVER_CONNECTION_ERROR);
            }
        });
    });
}

var bonusProductsView = {
    /**
     * @function
     * @description Open the list of bonus products selection dialog
     */
    show: function (url) {
        var $bonusProduct = $('#bonus-product-dialog');
        // create the dialog
        dialog.open({
            target: $bonusProduct,
            url: url,
            options: {
                width: 795,
                title: Resources.BONUS_PRODUCTS
            },
            callback: function () {
                initializeGrid();
                hideSwatches();
            }
        });
    },
    /**
     * @function
     * @description Open bonus product promo prompt dialog
     */
    loadBonusOption: function () {
        var    self = this,
            bonusDiscountContainer = document.querySelector('.bonus-discount-container');
        if (!bonusDiscountContainer) { return; }

        // get the html from minicart, then trash it
        var bonusDiscountContainerHtml = bonusDiscountContainer.outerHTML;
        bonusDiscountContainer.parentNode.removeChild(bonusDiscountContainer);

        dialog.open({
            html: bonusDiscountContainerHtml,
            options: {
                width: 400,
                title: Resources.BONUS_PRODUCT,
                buttons: [{
                    text: Resources.SELECT_BONUS_PRODUCTS,
                    click: function () {
                        var uuid = $('.bonus-product-promo').data('lineitemid'),
                            url = util.appendParamsToUrl(Urls.getBonusProducts, {
                                bonusDiscountLineItemUUID: uuid,
                                source: 'bonus',
                                format: 'ajax',
                                lazyLoad: 'false',
                                pageStart: 0,
                                pageSize: 10,
                                bonusProductsTotal: -1
                            });
                        $(this).dialog('close');
                        self.show(url);
                    }
                }, {
                    text: Resources.NO_THANKS,
                    click: function () {
                        $(this).dialog('close');
                    }
                }]
            },
            callback: function () {
                // show hide promo details
                $('.show-promo-details').on('click', function () {
                    $('.promo-details').toggleClass('visible');
                });
            }
        });
    }
};

module.exports = bonusProductsView;

},{"./dialog":34,"./page":44,"./util":82}],29:[function(require,module,exports){
'use strict';

var dialog = require('./dialog');
var util = require('./util');
var SessionAttributes = window.SessionAttributes;

/**
 * @function captcha    Used to display/control the scrim containing the simulated captcha code
 **/
module.exports = function () {
    /**
     * if the session.privacy.ratelimited element is present then show the notification
     * NOTE: You will probably want to replace this with a call to an actual CAPTCHA system to replace the simple one here
     */
    if (SessionAttributes.SHOW_CAPTCHA) {
        dialog.open({
            html: '<h1>' + Resources.ARE_YOU_HUMAN + '</h1>',
            options: {
                closeOnEscape: false,
                dialogClass: 'no-close',
                buttons: [{
                    text: Resources.OK,
                    click: function () {
                        var url = util.appendParamsToUrl(Urls.rateLimiterReset, {format: 'ajax'});
                        $.ajax({
                            url: url
                        });
                        $(this).dialog('close');
                    }
                }]
            }
        });
    }
};

},{"./dialog":34,"./util":82}],30:[function(require,module,exports){
'use strict';

var page = require('./page'),
    util = require('./util'),
    TPromise = require('promise');

var _currentCategory = '',
    MAX_ACTIVE = 6;

/**
 * @private
 * @function
 * @description Verifies the number of elements in the compare container and updates it with sequential classes for ui targeting
 */
function refreshContainer() {
    var $compareContainer = $('.compare-items');
    var $compareItems = $compareContainer.find('.compare-item');
    var numActive = $compareItems.filter('.active').length;

    if (numActive < 2) {
        $('#compare-items-button').attr('disabled', 'disabled');
    } else {
        $('#compare-items-button').removeAttr('disabled');
    }

    $compareContainer.toggle(numActive > 0);
}
/**
 * @private
 * @function
 * @description Adds an item to the compare container and refreshes it
 */
function addToList(data) {
    // get the first compare-item not currently active
    var $item = $('.compare-items .compare-item').not('.active').first(),
        $productTile = $('#' + data.uuid);

    if ($item.length === 0) {
        if ($productTile.length > 0) {
            $productTile.find('.compare-check')[0].checked = false;
        }
        window.alert(Resources.COMPARE_ADD_FAIL);
        return;
    }

    // if already added somehow, return
    if ($('[data-uuid="' + data.uuid + '"]').length > 0) {
        return;
    }
    // set as active item
    $item.addClass('active')
        .attr('data-uuid', data.uuid)
        .attr('data-itemid', data.itemid)
        .data('uuid', data.uuid)
        .data('itemid', data.itemid)
        .append($(data.img).clone().addClass('compare-item-image'));
}
/**
 * @private
 * @function
 * description Removes an item from the compare container and refreshes it
 */
function removeFromList($item) {
    if ($item.length === 0) { return; }
    // remove class, data and id from item
    $item.removeClass('active')
        .removeAttr('data-uuid')
        .removeAttr('data-itemid')
        .data('uuid', '')
        .data('itemid', '')
        // remove the image
        .find('.compare-item-image').remove();
}

function addProductAjax(args) {
    var promise = new TPromise(function (resolve, reject) {
        $.ajax({
            url: Urls.compareAdd,
            data: {
                pid: args.itemid,
                category: _currentCategory
            },
            dataType: 'json'
        }).done(function (response) {
            if (!response || !response.success) {
                reject(new Error(Resources.COMPARE_ADD_FAIL));
            } else {
                resolve(response);
            }
        }).fail(function (jqxhr, status, err) {
            reject(new Error(err));
        });
    });
    return promise;
}

function removeProductAjax(args) {
    var promise = new TPromise(function (resolve, reject) {
        $.ajax({
            url: Urls.compareRemove,
            data: {
                pid: args.itemid,
                category: _currentCategory
            },
            dataType: 'json'
        }).done(function (response) {
            if (!response || !response.success) {
                reject(new Error(Resources.COMPARE_REMOVE_FAIL));
            } else {
                resolve(response);
            }
        }).fail(function (jqxhr, status, err) {
            reject(new Error(err));
        });
    });
    return promise;
}

function shiftImages() {
    return new TPromise(function (resolve) {
        var $items = $('.compare-items .compare-item');
        $items.each(function (i, item) {
            var $item = $(item);
            // last item
            if (i === $items.length - 1) {
                return removeFromList($item);
            }
            var $next = $items.eq(i + 1);
            if ($next.hasClass('active')) {
                // remove its own image
                $next.find('.compare-item-image').detach().appendTo($item);
                $item.addClass('active')
                    .attr('data-uuid', $next.data('uuid'))
                    .attr('data-itemid', $next.data('itemid'))
                    .data('uuid', $next.data('uuid'))
                    .data('itemid', $next.data('itemid'));
            }
        });
        resolve();
    });
}

/**
 * @function
 * @description Adds product to the compare table
 */
function addProduct(args) {
    var promise;
    var $items = $('.compare-items .compare-item');
    var $cb = $(args.cb);
    var numActive = $items.filter('.active').length;
    if (numActive === MAX_ACTIVE) {
        if (!window.confirm(Resources.COMPARE_CONFIRMATION)) {
            $cb[0].checked = false;
            return;
        }

        // remove product using id
        var $firstItem = $items.first();
        promise = removeItem($firstItem).then(function () {
            return shiftImages();
        });
    } else {
        promise = TPromise.resolve(0);
    }
    return promise.then(function () {
        return addProductAjax(args).then(function () {
            addToList(args);
            if ($cb && $cb.length > 0) { $cb[0].checked = true; }
            refreshContainer();
        });
    }).then(null, function () {
        if ($cb && $cb.length > 0) { $cb[0].checked = false; }
    });
}

/**
 * @function
 * @description Removes product from the compare table
 * @param {object} args - the arguments object should have the following properties: itemid, uuid and cb (checkbox)
 */
function removeProduct(args) {
    var $cb = args.cb ? $(args.cb) : null;
    return removeProductAjax(args).then(function () {
        var $item = $('[data-uuid="' + args.uuid + '"]');
        removeFromList($item);
        if ($cb && $cb.length > 0) { $cb[0].checked = false; }
        refreshContainer();
    }, function () {
        if ($cb && $cb.length > 0) { $cb[0].checked = true; }
    });
}

function removeItem($item) {
    var uuid = $item.data('uuid'),
        $productTile = $('#' + uuid);
    return removeProduct({
        itemid: $item.data('itemid'),
        uuid: uuid,
        cb: ($productTile.length === 0) ? null : $productTile.find('.compare-check')
    });
}

/**
 * @private
 * @function
 * @description Initializes the DOM-Object of the compare container
 */
function initializeDom() {
    var $compareContainer = $('.compare-items');
    _currentCategory = $compareContainer.data('category') || '';
    var $active = $compareContainer.find('.compare-item').filter('.active');
    $active.each(function () {
        var $productTile = $('#' +  $(this).data('uuid'));
        if ($productTile.length === 0) {return;}
        $productTile.find('.compare-check')[0].checked = true;
    });
    // set container state
    refreshContainer();
}

/**
 * @private
 * @function
 * @description Initializes the events on the compare container
 */
function initializeEvents() {
    // add event to buttons to remove products
    $('.compare-item').on('click', '.compare-item-remove', function () {
        removeItem($(this).closest('.compare-item'));
    });

    // Button to go to compare page
    $('#compare-items-button').on('click', function () {
        page.redirect(util.appendParamToURL(Urls.compareShow, 'category', _currentCategory));
    });

    // Button to clear all compared items
    // rely on refreshContainer to take care of hiding the container
    $('#clear-compared-items').on('click', function () {
        $('.compare-items .active').each(function () {
            removeItem($(this));
        });
    });
}

exports.init = function () {
    initializeDom();
    initializeEvents();
};

exports.addProduct = addProduct;
exports.removeProduct = removeProduct;

},{"./page":44,"./util":82,"promise":6}],31:[function(require,module,exports){
'use strict';

var dialog = require('./dialog');

/**
 * @function cookieprivacy    Used to display/control the scrim containing the cookie privacy code
 **/
module.exports = function () {
    /**
     * If we have not accepted cookies AND we're not on the Privacy Policy page, then show the notification
     * NOTE: You will probably want to adjust the Privacy Page test to match your site's specific privacy / cookie page
     */
    if (SitePreferences.COOKIE_HINT === true && document.cookie.indexOf('dw_cookies_accepted') < 0) {
        // check for privacy policy page
        if ($('.privacy-policy').length === 0) {
            dialog.open({
                url: Urls.cookieHint,
                options: {
                    closeOnEscape: false,
                    dialogClass: 'no-close',
                    buttons: [{
                        text: Resources.I_AGREE,
                        click: function () {
                            $(this).dialog('close');
                            enableCookies();
                        }
                    }]
                }
            });
        }
    } else {
        // Otherwise, we don't need to show the asset, just enable the cookies
        enableCookies();
    }

    function enableCookies() {
        if (document.cookie.indexOf('dw=1') < 0) {
            document.cookie = 'dw=1; path=/';
        }
        if (document.cookie.indexOf('dw_cookies_accepted') < 0) {
            document.cookie = 'dw_cookies_accepted=1; path=/';
        }
    }
};

},{"./dialog":34}],32:[function(require,module,exports){
'use strict';

exports.init = function init () {
    $('.country-selector .current-country').on('click', function () {
        $('.country-selector .selector').toggleClass('active');
        $(this).toggleClass('selector-active');
    });
    // set currency first before reload
    $('.country-selector .selector .locale').on('click', function (e) {
        e.preventDefault();
        var url = this.href;
        var currency = this.getAttribute('data-currency');
        $.ajax({
            dataType: 'json',
            url: Urls.setSessionCurrency,
            data: {
                format: 'ajax',
                currencyMnemonic: currency
            }
        })
        .done(function (response) {
            if (!response.success) {
                throw new Error('Unable to set currency');
            }
            window.location.href = url;
        });
    });
};

},{}],33:[function(require,module,exports){
'use strict';
	
app.datalayer = {
	getEvent : function(eventKey, event, typeKey, type, action, products, list) {
		return _getEvent(eventKey, event, typeKey, type, action, products, list);
	},
	getObjectExamples : function () {
		return _getObjectExamples();
	},
	objects : _getObjectExamples (),
	sendAddToCartEvent : function(){
		var isQuickView = $('#QuickViewDialog').length > 0 ? true : false;
		if (typeof dataLayer !== "undefined") {
            var transactionProducts = [];
            var dlPid, dlSku, dlProductName, dlCategoryID, dlPrice, dlVariant, dlQuantity, dlSize, dlSeasonalCollection, dlColorway, dlItemAtFullPrice, dlAvailability, dlDiscount, dlMonogramming, dlBVAverage;
            var ecomDetail = null;
            for (var i = 0; i < dataLayer.length; i++) {
                if (dataLayer[i].event == 'ecomDetail') {
                    ecomDetail = dataLayer[i];
                    break;
                }
 
            }
			var producttiles = $('.product-tile');
			var availabilityMsgContainer = $(".availability-msg");
            for(i=0;i<producttiles.length;i++){
            	console.log(producttiles.eq(i).attr('data-cgid'));
            }
            if (ecomDetail && 'ecommerce' in ecomDetail
                    && 'detail' in ecomDetail.ecommerce
                    && 'products' in ecomDetail.ecommerce.detail
                    && ecomDetail.ecommerce.detail.products.length
                    && 'category' in ecomDetail.ecommerce.detail.products[0]) {
                dlCategoryID = ecomDetail.ecommerce.detail.products[0].category;
                dlPid = ecomDetail.ecommerce.detail.products[0].id;
                dlProductName = ecomDetail.ecommerce.detail.products[0].name
            } else if (typeof cmProductName !== "undefined") {
                dlProductName = cmProductName;
                dlCategoryID = cmCategoryID;
            } else {
            	var form = $(this).closest('form');
            	if(form.length == 0 && isQuickView){
            		form = $('#QuickViewDialog');
            	}
                dlProductName = $.trim(form.find('.product-name').text());
                dlCategoryID = $.trim($('.product-tile').eq(0).attr('data-cgid'));
            }
            var form = $('.pdpForm');
            dlQuantity = parseInt($('.quantity-dropdown .selectboxit').find(':selected').text());
		    dlQuantity = dlQuantity > 0 ? dlQuantity : 1;
            if (isQuickView) {
                var qvcontainer = $('#QuickViewDialog');
                dlSku = qvcontainer.find("#pid").val();
                dlPid = dlPid || qvcontainer.find('div[data-master]').attr('data-master');
                dlProductName = $.trim(qvcontainer.find(".product-name").text());
                dlCategoryID = $.trim($('.product-tile').eq(0).attr('data-cgid'));
                dlPrice = qvcontainer.find('#gcAmount').val() || ($.trim(qvcontainer.find(".price-sales").html().trim()).replace("$",""));
                dlVariant = $.trim(qvcontainer.find(".product-variations .swatches .selected .title").text());
                dlSize = $.trim(qvcontainer.find(".product-variations .swatches.size .selected a").text());
                // dlSeasonalCollection = '';
                dlColorway = $.trim(qvcontainer.find(".product-variations .swatches.Color .selected a").attr('title'));
                dlItemAtFullPrice = $.trim(qvcontainer.find(".product-price span").html()).replace("$","");
            	if (availabilityMsgContainer.length) {
            		dlAvailability = availabilityMsgContainer.attr('data-availible');
            		if (typeof dlAvailability != 'undefined' && dlAvailability.length) {
            			dlAvailability = $.trim(dlAvailability.replace(/_|-|\./g, ' '));
            		}
            	}
            	if (typeof dlAvailability == 'undefined' || !dlAvailability.length) {
            		dlAvailability = '';
            	}
                // dlDiscount = '';
                dlMonogramming = '';
                dlBVAverage = $.trim(qvcontainer.find("#BVRRRatingOverall_ .BVRRRatingNormalOutOf").text());   
            } else {
                dlSku = $("#pid").val();
                dlPid = dlPid || $('#product-content').find('div[data-master]').attr('data-master');
                // Incase dlProductName was not set previously
                if (dlProductName == "undefined") {
                    dlProductName = $.trim($("#product-content .product-name").text());
                }
                // Incase dlCategoryID was not set previously
                if (dlCategoryID == "undefined") {
                    dlCategoryID = $('#pdpMain').attr('data-category');
                }
                dlPrice = $('#gcAmount').val() || ($.trim($(".price-sales").html().trim()).replace("$",""));
                dlVariant = $.trim($(".product-variations .swatches .selected .title").text());
                dlSize = $.trim($(".product-variations .swatches.size .selected a").text());
                // dlSeasonalCollection = '';
                dlColorway = $.trim($(".product-variations .swatches.Color .selected a").attr('title'));
                dlItemAtFullPrice = $.trim($(".product-price span").html()).replace("$","");
            	if (availabilityMsgContainer.length) {
            		dlAvailability = availabilityMsgContainer.attr('data-availible');
            		if (typeof dlAvailability != 'undefined' && dlAvailability.length) {
            			dlAvailability = $.trim(dlAvailability.replace(/_|-|\./g, ' '));
            		}
            	}
            	if (typeof dlAvailability == 'undefined' || !dlAvailability.length) {
            		dlAvailability = '';
            	}
                // dlDiscount = '';
                dlMonogramming = '';
                dlBVAverage = $.trim($("#BVRRRatingOverall_ .BVRRRatingNormalOutOf").text());
            }
            transactionProducts.push({
                "brand" : 'kate',
                "sku" : dlSku,
                "id" : dlPid,
                "name" : dlProductName,
                "category" : dlCategoryID,
                "price" : dlPrice,
                "quantity" : dlQuantity,
                "variant" : dlVariant,
                "dimension5" : dlSize, //product size
                //"dimension9" : dlSeasonalCollection, // seasonal collection the product is part of
                "dimension10" : dlColorway, //colorway
                "dimension11" : dlItemAtFullPrice, //Was the item at full price
                "dimension12" : dlAvailability, //availability of product
                //"dimension13" : dlDiscount, discount amount if applicable
                "dimension14" : dlMonogramming, //was monogramming applied
                //"dimension15" : dlGiftWrap, //was gift wrap selected
                "dimension16" : dlBVAverage //bv average star rating
            });
            dataLayer.push(app.datalayer.getEvent("event","ecomAdd", "ecommerce", " ", "add", transactionProducts));
		}
	}
};

function _getEvent(eventKey, event, typeKey, type, action, products, list) {
	
	// Event Formats
		//	app.datalayer.getEvent("eventKey","event");
		//	app.datalayer.getEvent("eventKey","event", "typeKey", "type");
		//	app.datalayer.getEvent("eventKey","event", "ecommerce", "type", "add", "products");
		//	app.datalayer.getEvent("eventKey","event", "typeKey", "type", "remove", "products");
		//	app.datalayer.getEvent("eventKey","event", "ecommerce", "type", "click", "products", "list");
	
	var object = { };
	
	if(eventKey && event && !typeKey) {
		// Handle object such as { "event" : "addToCart" } 
		//object = { eventKey : event };
		object[eventKey] = event;
	}
	else if(eventKey && event && typeKey && type && typeKey != "ecommerce") {
		// Handle object such as{ "event" : "email-subscribe", "subscribeType": "accountCreate" }
		//object = { eventKey : event, typeKey : type };
		object[eventKey] = event;
		object[typeKey] = type;
	}
	
	if(eventKey && event && typeKey && type && typeKey == "ecommerce" && products && (action == "add" || action == "remove")) {
		// Handle object such as 
		// 		{ "event" : "ecomAdd", "ecommerce" : { "add": { "products": "transactionProductsObject" } } } 
		//object = { eventKey : event, typeKey : { action : { "products": products } } };
		
		object[eventKey] = event;
		var typeObj = object[typeKey] = {};
		typeObj[action] = { "products":  products  };
		
	}
	
	if(eventKey && event && typeKey && type && typeKey == "ecommerce" && products && (action == "click")) {
		// Handle object such as 
		// 		{ "event": "ecomProductImpressionClick", "ecommerce" : { "click" : { "actionField" : {"list" : null }, "products" : null } } } 
		//object = { eventKey : event, typeKey : { action : { "actionField" : {"list" : list }, "products" : products } } } ;
		
		object[eventKey] = event;
		var typeObj2 = object[typeKey] = {};
		var typeInnerObj = typeObj2[action] = { "products": [ products ] };
		typeInnerObj["actionField"] = { "list": list };
	}
	
	return object;
};

function _getObjectExamples () { 
	
	var dataLayerObjects = [];
	
	// Event with Two Parameters 
	dataLayerObjects.push( { "event" : "addToCart" } );
	dataLayerObjects.push( { "event": "batchedEcomProdImpression" } );
	dataLayerObjects.push( { "event": "ecomProductImpressionClick" } );
	
	// Event with Four Parameters
	dataLayerObjects.push( { "event" : "email-subscribe", "subscribeType": "accountCreate" } );
	dataLayerObjects.push( { "event" : "email-subscribe", "subscribeType": "checkout" } );
	dataLayerObjects.push( { "event" : "email-subscribe", "subscribeType": "customerService" } ) ;
	dataLayerObjects.push( { "event" : "email-subscribe", "subscribeType": "lightbox" } );
	dataLayerObjects.push( { "event" : "email-subscribe", "subscribeType": "footer" } ) ;
	dataLayerObjects.push( { "event" : "account-creation", "type" : "Kate Spade" } );
	
	// Event with Ecommerce Object
	dataLayerObjects.push( { "event" : "ecomAdd", "ecommerce" : { "add": { "products": "transactionProductsObject" } } } );
	dataLayerObjects.push( { "event": "ecomProductImpressionClick", "ecommerce" : { "click" : { "actionField" : {"list" : null }, "products" : null } } } );
	dataLayerObjects.push( { "event" : "ecomRemove", "ecommerce" : { "remove" : { "products": null } } } );
	
	// Transaction Products with Two Parameters
	dataLayerObjects.push( { "transactionProducts" : "transactionProductsObject" } );
	dataLayerObjects.push( { "transactionProducts" : "ecomProductImpressionClick" } );
		
	return dataLayerObjects;
};

module.exports = app.datalayer;

},{}],34:[function(require,module,exports){
'use strict';

var ajax = require('./ajax'),
    util = require('./util'),
    _ = require('lodash'),
    imagesLoaded = require('imagesloaded');

var dialog = {
    /**
     * @function
     * @description Appends a dialog to a given container (target)
     * @param {Object} params  params.target can be an id selector or an jquery object
     */
    create: function (params) {
        var $target, id;

        if (_.isString(params.target)) {
            if (params.target.charAt(0) === '#') {
                $target = $(params.target);
            } else {
                $target = $('#' + params.target);
            }
        } else if (params.target instanceof jQuery) {
            $target = params.target;
        } else {
            $target = $('#dialog-container');
        }

        // if no element found, create one
        if ($target.length === 0) {
            if ($target.selector && $target.selector.charAt(0) === '#') {
                id = $target.selector.substr(1);
                $target = $('<div>').attr('id', id).addClass('dialog-content').appendTo('body');
            }
        }

        // create the dialog
        this.$container = $target;
        this.$container.dialog(_.merge({}, this.settings, params.options || {}));
    },
    /**
     * @function
     * @description Opens a dialog using the given url (params.url) or html (params.html)
     * @param {Object} params
     * @param {Object} params.url should contain the url
     * @param {String} params.html contains the html of the dialog content
     */
    open: function (params) {
        // close any open dialog
        //this.close();
        this.create(params);
        this.replace(params);
    },
    /**
     * @description populate the dialog with html content, then open it
     **/
    openWithContent: function (params) {
        var content, position, callback;

        if (!this.$container) { return; }
        content = params.content || params.html;
        if (!content) { return; }
        this.$container.empty().html(content);
        if (!this.$container.dialog('isOpen')) {
            this.$container.dialog('open');
        }

        if (params.options) {
            position = params.options.position;
        }
        if (!position) {
            position = this.settings.position;
        }
        imagesLoaded(this.$container).on('done', function () {
            this.$container.dialog('option', 'position', position);
        }.bind(this));
        
        if(typeof params.callback === 'function'){
        	callback = params.callback;
        }else if(typeof params.options.open === 'function'){
        	callback = params.options.open;
        }else{
        	callback = function () {};
        }
        callback();
    },
    /**
     * @description Replace the content of current dialog
     * @param {object} params
     * @param {string} params.url - If the url property is provided, an ajax call is performed to get the content to replace
     * @param {string} params.html - If no url property is provided, use html provided to replace
     */
    replace: function (params) {
        if (params.useContainer) {
            this.$container = params.useContainer;
        }
        if (!this.$container) {
            return;
        }
        if (params.url) {
            params.url = util.appendParamToURL(params.url, 'format', 'ajax');
            ajax.load({
                url: params.url,
                data: params.data,
                callback: function (response) {
                    params.content = response;
                    this.openWithContent(params);
                }.bind(this)
            });
        } else if (params.html) {
            this.openWithContent(params);
        }
    },
    /**
     * @description Replace the content of current dialog, from another handled ajax call.
     * @param {html} content to replace.
     */
    replaceContent: function(content) {
		if (!this.$container || !content) {
			return;
		}
		this.$container.empty().html(content);
	},
    /**
     * @function
     * @description Closes the dialog
     */
    close: function () {
        if (!this.$container) {
            return;
        }
        this.$container.dialog('close');
    },
    exists: function () {
        return this.$container && (this.$container.length > 0);
    },
    isActive: function () {
        return this.exists() && (this.$container.children.length > 0);
    },
    settings: {
        autoOpen: true,
        height: 'auto',
        modal: true,
        overlay: {
            opacity: 0.5,
            background: 'black'
        },
        resizable: false,
        title: '',
        width: '800',
        close: function () {
            $(this).dialog('close');
        },
        position: {
            my: 'center',
            at: 'center',
            of: window,
            collision: 'flipfit'
        }
    }
};

module.exports = dialog;

},{"./ajax":26,"./util":82,"imagesloaded":4,"lodash":5}],35:[function(require,module,exports){
'use strict';

var ajax = require('./ajax'),
    dialog = require('./dialog'),
    smallMedBreakpoint = 360;

var emailsubscription = {
    init: function () {
        // GET FORM ELEMENTS
        var form		 = this.getField();
        var emailAddress = form.find("input.email");
        var zipCode 	 = form.find("input.postalAll");
        var url 		 = Urls.emailSubscription + "?email=" + $(emailAddress).val();

        // SET BLUR EVENTS
        this.setEvent("blur", emailAddress, "email address");
        this.setEvent("blur", zipCode, "zip");

        // SET DIALOG CLOSE EVENT
        $("ui-icon-closethick").click(function () {
            $( ".ui-icon-closethick" ).dialog().close();
        });

        // SET FORM SUBMISSION EVENT
        $(form).submit(function(event) {

            // Disable the default form action.
            // This allows us to make the AJAX call once
            // this action has been disabled.
            event.preventDefault();

            // GET FORM ELEMENTS
            var form		 = emailsubscription.getField();
            var emailAddress = form.find("input.email");
            var zipCode 	 = form.find("input.postalAll");

            if($(emailAddress).val()) {

                // GET AJAX URL
                // This URL is a concatenation of the
                // pipeline, email address, and source parameters.
                var url = Urls.emailSubscription;

                // MAKE AJAX CALL VIA EMAIL SUBSCRIPTION SIGN UP FORM
                ajax.getJson({
                     url: url,
                     data: emailsubscription.getField().serialize(),
                     callback: function (data) {
                        if(data.success) {
                            var form = emailsubscription.getField();
                            var emailAddress = form.find("input.email");
                            var newsletter = $("#newsletter-popuplink").attr('href');
                            var emailErrorExists = $(emailAddress).hasClass('error');
                            var zipErrorExists = form.find("input.postalAll").hasClass('error');

                            // ONLY OPEN THE DIALOG IF THERE DOES NOT EXIST ANY ERRORS
                            if(!emailErrorExists && !zipErrorExists) {
                                 if (typeof dataLayer !== 'undefined'){
                                    dataLayer.push(app.datalayer.getEvent("event", "email-subscribe", "subscribeType", "footer"));
                                 }

                                dialog.open({
                                    url: newsletter,
                                    closeOnEscape: true,
                                    options: {
                                        width: window.innerWidth < smallMedBreakpoint ? 300 : 340,
                                        position: { my: "center", at: "center", of: window },
                                        dialogClass: 'footer-newsletter-dialog',
                                        close: function () {
                                            $(emailAddress).val('');
                                            $(zipCode).val('');
                                        }
                                    },
                                    callback: function () {
                                        // SET FORM 2 SUBMISSION EVENT
                                        $("#newsletter-popup").find("form").on('submit', function(event) {

                                            // Disable the default form action.
                                            // This allows us to make the AJAX call once
                                            // this action has been disabled.
                                            event.preventDefault();

                                            // GET AJAX URL 2
                                            // This URL is a concatenation of the
                                            // pipeline, email address, and source parameters.
                                            var url2 = Urls.emailSignupAltLists + "?et_email=" + $(emailAddress).val() + "&et_postal=" + $(zipCode).val() + "&jsp=" + $("#jsp-receiveEmail").is(":checked") + "&source=ajax";

                                            // MAKE AJAX CALL VIA EMAIL SUBSCRIPTION SIGN UP FORM 2
                                            ajax.getJson({
                                                url: url2,
                                                 callback: function (data2) {
                                                     // CLEAR EMAIL AND ZIP CODE FIELDS
                                                     $(emailAddress).val('');
                                                     $(zipCode).val('');

                                                     // CLOSE THE DIALOG MODAL
                                                     dialog.close();
                                                 }
                                             });

                                        });
                                        // SET DIALOG CLOSE EVENT 2
                                         $(".nothanks").on('click', function () {
                                             $(emailAddress).val('');
                                             $(zipCode).val('');

                                             dialog.close();
                                         });

                                        $('.footer-newsletter-dialog').center();
                                    }
                                });

                                // REMOVE THE CLASS ERROR FROM THE EMAIL FIELD
                                $(emailAddress).removeClass("error");
                            }
                         }
                         else {
                            if (data.error.showAntiSpamDialog) {
                                app.validator.aslConfirm(emailsubscription.getField());
                            } else {
                                var form = emailsubscription.getField();
                                var emailAddress = form.find("input.email");
                                $(emailAddress).val("");
                                $(emailAddress).addClass("error");
                                $(emailAddress).attr("placeholder", data.error.message);
                            }
                         }
                     }
                });
            }
        });
        //IE newsletter placeholder fix
        if(!(window.ActiveXObject) && "ActiveXObject" in window) {
            webshims.setOptions("forms", {
                overridePlaceholder: true
            });
            webshims.polyfill("forms");
            $(".newsletter input[type='submit']").on('click', function () {
                setTimeout(function () {
                    $('.placeholder-focused').blur().focus();
                },200);
            });
        }
    },
    getField: function () {
        return $("#footer-wrapper").find(".content-asset").find("#footer").find("form");
    },
    setEvent: function (type, field, phrase) {
        $(field).on(type, function () {
            if($(this).val().length == 0 ) {
                $(this).attr("placeholder", phrase + " required");
            }
        });
    }
};

module.exports = emailsubscription;
},{"./ajax":26,"./dialog":34}],36:[function(require,module,exports){
'use strict';

/**
 * @function
 * @description Initializes input float labels
 */
exports.init = function () {

    $('.form-row.has-float-label').each(function () {
        var label = $(this).find('.text-input-label'),
            input = $(this).find('input, textarea');

        // auto expand textarea inputs so text does not overlap label
        if (input.hasClass('input-textarea') && $.fn.autogrow) {
            input.css('overflow', 'hidden').autogrow({
                vertical: true,
                horizontal: false,
                flickering: false
            });
        }

        // use the label as a placeholder, this adds (optional) if not required
        if(label[0] && label[0].innerText) {
            input.attr('placeholder', label[0].innerText);
        }
        
        input.on('focus keyup', function () {
            label.addClass('float');
            input.addClass('float');
            input.css('text-transform', 'none');
            input.css('color', '#000');
        }).on('blur', function () {
            if (!input.val()) {
                label.removeClass('float');
                input.removeClass('float');
                input.css('text-transform', 'uppercase');
                input.css('color', '#8F9194');
            } else {
                label.addClass('float');
                input.addClass('float');
                input.css('text-transform', 'none');
                input.css('color', '#000');
            }
        });
        
        if(input.attr('value') && input.attr('value').length){
        	label.addClass('float');
            input.addClass('float');
            input.css('text-transform', 'none');
            input.css('color', '#000');
        }
    });
};

},{}],37:[function(require,module,exports){
'use strict';

var ajax = require('./ajax'),
	util = require('./util'),
	validator = require('./validator');

/**
 * @description Initialize event handlers on giftcard detail page
 */
function initializeEvents() {
    var $pdpMain = $('#pdpMain'),
        pdpForm = $('.pdpForm'),
        $atc = $('#add-to-cart');
    
    /*Gift Card check inputs*/
    $pdpMain.on ('focus blur', '.gift-card-attribute input, .gift-card-attribute textarea', function(e){
    	var opacity = 1;
    	var speed = 500;
    	var $this = $(this);
    	if ($this.val() || e.type == 'focusin') {
    		opacity = 0;
    		speed = 0;
    	}
    	$this.closest('.gift-card-attribute').find('label').fadeTo(speed , opacity);
    });
    if ($('.gift-card-info').length > 0) {
        $('.gift-card-attribute').each(function(){
        	var $this = $(this);
        	var _thisin = $this.find('input');
        	var _thistx = $this.find('textarea');
        	if (_thisin.val() || _thistx.val()) {
        		$this.find('label').fadeTo(0 , 0);
        	}
        })
    }
    /*Gift Card set amount*/
    $('body').on('click', '#gcAmountselect a.swatchanchor', function() {
		$('body').find('input#gcAmount').val($(this).data('value'));
    });
	$('body').on('click', '.ui-dialog #gcAmountselect a.swatchanchor', function() {
		if (!$(this).hasClass('selected')) {
			$(this).parent().addClass('selected');
			$(this).parent().siblings().removeClass('selected');
		}
	});

    if ($('input#gcAmount').length) {
    	$('#gcAmount').val($('#gcAmountselect .selected a.swatchanchor').data('value'));
    }
    
    $pdpMain.find('div.product-detail .gift-card-image a.swatchanchor').on('click', function (e) {
    	e.preventDefault();
		var $this = $(this),
			storefrontImage = $('#gcStorefrontImage'),
			$val = $this.attr('data-src'); // use data-src for gsi image
		
		if (!$val) {
			$val = $this.attr('href'); // fall back to href (which is used for pdp image)
		}
		
		$('.gift-card-image .swatches li').each(function() {
			$(this).removeClass('selected');
		});
		
		$this.parent().addClass('selected');
		
		$('.gift-card-image .swatches li.selected-value').text($this.attr('title'));
		$('#gcImage').val($val);
		
		if (storefrontImage.length){
			storefrontImage.val($this.attr('href'));
		}
		
		$pdpMain.find('.product-primary-image').html('<img class="gift-card-main-image" src="' + $this.attr('href') + '"/>');
		$pdpMain.find('.thumbnail-link:first img').attr('src', $this.attr('href'));
	});
}

/**
 * @function
 * @description Public namespace
 */
module.exports = {
	checkBalance: function (id, pin, callback) {
		/**
		 * @function
		 * @description Load details to a given gift certificate
		 * @param {String} id The ID of the gift certificate
		 * @param {Function} callback A function to called
		 */
		var url = util.appendParamToURL(Urls.giftCardCheckBalance, "giftCardNumber", id);
		url = util.appendParamToURL(url, "giftCardPin", pin);
		ajax.getJson({
			url: url,
			callback: callback
		});
	},
	/**
	 * Get the party started.
	 */
	init: function () {
		// Custom GC logic
		if ($('.gift-card').length || $('.e-gift-card').length) {
			 initializeEvents();
			 validator.initForm('form.pdpForm');
			 util.limitCharacters();
		}
	}
};

},{"./ajax":26,"./util":82,"./validator":83}],38:[function(require,module,exports){
'use strict';

var ajax = require('./ajax'),
    minicart = require('./minicart'),
    util = require('./util');

var setAddToCartHandler = function (e) {
    e.preventDefault();
    var form = $(this).closest('form');

    var options = {
        url: util.ajaxUrl(form.attr('action')),
        method: 'POST',
        cache: false,
        data: form.serialize()
    };
    $.ajax(options).done(function (response) {
        if (response.success) {
            ajax.load({
                url: Urls.minicartGC,
                data: {lineItemId: response.result.lineItemId},
                callback: function (response) {
                    minicart.show(response);
                    form.find('input,textarea').val('');
                }
            });
        } else {
            form.find('span.error').hide();
            for (var id in response.errors.FormErrors) {
                var $errorEl = $('#' + id).addClass('error').removeClass('valid').next('.error');
                if (!$errorEl || $errorEl.length === 0) {
                    $errorEl = $('<span for="' + id + '" generated="true" class="error" style=""></span>');
                    $('#' + id).after($errorEl);
                }
                $errorEl.text(response.errors.FormErrors[id].replace(/\\'/g, '\'')).show();
            }
        }
    }).fail(function (xhr, textStatus) {
        // failed
        if (textStatus === 'parsererror') {
            window.alert(Resources.BAD_RESPONSE);
        } else {
            window.alert(Resources.SERVER_CONNECTION_ERROR);
        }
    });
};

exports.init = function () {
    $('#AddToBasketButton').on('click', setAddToCartHandler);
};

},{"./ajax":26,"./minicart":43,"./util":82}],39:[function(require,module,exports){
/*! Image Map Resizer
 *  Desc: Resize HTML imageMap to scaled image.
 *  Copyright: (c) 2014-15 David J. Bradshaw - dave@bradshaw.net
 *  License: MIT
 */

(function(){
    'use strict';

    function scaleImageMap(){

        function resizeMap() {
            function resizeAreaTag(cachedAreaCoords,idx){
                function scale(coord){
                    var dimension = ( 1 === (isWidth = 1-isWidth) ? 'width' : 'height' );
                    return Math.floor(Number(coord) * scallingFactor[dimension]);
                }

                var isWidth = 0;

                areas[idx].coords = cachedAreaCoords.split(',').map(scale).join(',');
            }

            var scallingFactor = {
                width  : image.width  / image.naturalWidth,
                height : image.height / image.naturalHeight
            };

            cachedAreaCoordsArray.forEach(resizeAreaTag);
        }

        function getCoords(e){
            //Normalize coord-string to csv format without any space chars
            return e.coords.replace(/ *, */g,',').replace(/ +/g,',');
        }

        function debounce() {
            clearTimeout(timer);
            timer = setTimeout(resizeMap, 250);
        }

        function start(){
            if ((image.width !== image.naturalWidth) || (image.height !== image.naturalHeight)) {
                resizeMap();
            }
        }

        function addEventListeners(){
            image.addEventListener('load',  resizeMap, false); //Detect late image loads in IE11
            window.addEventListener('focus',  resizeMap, false); //Cope with window being resized whilst on another tab
            window.addEventListener('resize', debounce,  false);
            window.addEventListener('readystatechange', resizeMap,  false);
            document.addEventListener('fullscreenchange', resizeMap,  false);
        }

        function beenHere(){
            return ('function' === typeof map._resize);
        }

        function setup(){
            areas                 = map.getElementsByTagName('area');
            cachedAreaCoordsArray = Array.prototype.map.call(areas, getCoords);
            image                 = document.querySelector('img[usemap="#'+map.name+'"]');
            map._resize           = resizeMap; //Bind resize method to HTML map element
        }

        var
            /*jshint validthis:true */
            map   = this,
            areas = null, cachedAreaCoordsArray = null, image = null, timer = null;

        if (!beenHere()){
            setup();
            addEventListeners();
            start();
        } else {
            map._resize(); //Already setup, so just resize map
        }
    }



    function factory(){
        function chkMap(element){
            if(!element.tagName) {
                throw new TypeError('Object is not a valid DOM element');
            } else if ('MAP' !== element.tagName.toUpperCase()) {
                throw new TypeError('Expected <MAP> tag, found <'+element.tagName+'>.');
            }
        }

        function init(element){
            if (element){
                chkMap(element);
                scaleImageMap.call(element);
                maps.push(element);
            }
        }

        var maps;

        return function imageMapResizeF(target){
            maps = [];  // Only return maps from this call

            switch (typeof(target)){
                case 'undefined':
                case 'string':
                    Array.prototype.forEach.call(document.querySelectorAll(target||'map'),init);
                    break;
                case 'object':
                    init(target);
                    break;
                default:
                    throw new TypeError('Unexpected data type ('+typeof target+').');
            }

            return maps;
        };
    }


    if (typeof define === 'function' && define.amd) {
        define([],factory);
    } else if (typeof module === 'object' && typeof module.exports === 'object'){
        module.exports = factory(); //Node for browserfy
    } else {
        window.imageMapResize = factory();
    }


    if('jQuery' in window) {
        jQuery.fn.imageMapResize = function $imageMapResizeF(){
            return this.filter('map').each(scaleImageMap).end();
        };
    }

})();
},{}],40:[function(require,module,exports){
/**
 * interact.js v1.2.6
 *
 * Copyright (c) 2012-2015 Taye Adeyemi <dev@taye.me>
 * Open source under the MIT License.
 * https://raw.github.com/taye/interact.js/master/LICENSE
 */
(function (realWindow) {
    'use strict';

    // return early if there's no window to work with (eg. Node.js)
    if (!realWindow) { return; }

    var // get wrapped window if using Shadow DOM polyfill
        window = (function () {
            // create a TextNode
            var el = realWindow.document.createTextNode('');

            // check if it's wrapped by a polyfill
            if (el.ownerDocument !== realWindow.document
                && typeof realWindow.wrap === 'function'
                && realWindow.wrap(el) === el) {
                // return wrapped window
                return realWindow.wrap(realWindow);
            }

            // no Shadow DOM polyfil or native implementation
            return realWindow;
        }()),

        document           = window.document,
        DocumentFragment   = window.DocumentFragment   || blank,
        SVGElement         = window.SVGElement         || blank,
        SVGSVGElement      = window.SVGSVGElement      || blank,
        SVGElementInstance = window.SVGElementInstance || blank,
        HTMLElement        = window.HTMLElement        || window.Element,

        PointerEvent = (window.PointerEvent || window.MSPointerEvent),
        pEventTypes,

        hypot = Math.hypot || function (x, y) { return Math.sqrt(x * x + y * y); },

        tmpXY = {},     // reduce object creation in getXY()

        documents       = [],   // all documents being listened to

        interactables   = [],   // all set interactables
        interactions    = [],   // all interactions

        dynamicDrop     = false,

        // {
        //      type: {
        //          selectors: ['selector', ...],
        //          contexts : [document, ...],
        //          listeners: [[listener, useCapture], ...]
        //      }
        //  }
        delegatedEvents = {},

        defaultOptions = {
            base: {
                accept        : null,
                actionChecker : null,
                styleCursor   : true,
                preventDefault: 'auto',
                origin        : { x: 0, y: 0 },
                deltaSource   : 'page',
                allowFrom     : null,
                ignoreFrom    : null,
                _context      : document,
                dropChecker   : null
            },

            drag: {
                enabled: false,
                manualStart: true,
                max: Infinity,
                maxPerElement: 1,

                snap: null,
                restrict: null,
                inertia: null,
                autoScroll: null,

                axis: 'xy'
            },

            drop: {
                enabled: false,
                accept: null,
                overlap: 'pointer'
            },

            resize: {
                enabled: false,
                manualStart: false,
                max: Infinity,
                maxPerElement: 1,

                snap: null,
                restrict: null,
                inertia: null,
                autoScroll: null,

                square: false,
                preserveAspectRatio: false,
                axis: 'xy',

                // use default margin
                margin: NaN,

                // object with props left, right, top, bottom which are
                // true/false values to resize when the pointer is over that edge,
                // CSS selectors to match the handles for each direction
                // or the Elements for each handle
                edges: null,

                // a value of 'none' will limit the resize rect to a minimum of 0x0
                // 'negate' will alow the rect to have negative width/height
                // 'reposition' will keep the width/height positive by swapping
                // the top and bottom edges and/or swapping the left and right edges
                invert: 'none'
            },

            gesture: {
                manualStart: false,
                enabled: false,
                max: Infinity,
                maxPerElement: 1,

                restrict: null
            },

            perAction: {
                manualStart: false,
                max: Infinity,
                maxPerElement: 1,

                snap: {
                    enabled     : false,
                    endOnly     : false,
                    range       : Infinity,
                    targets     : null,
                    offsets     : null,

                    relativePoints: null
                },

                restrict: {
                    enabled: false,
                    endOnly: false
                },

                autoScroll: {
                    enabled     : false,
                    container   : null,     // the item that is scrolled (Window or HTMLElement)
                    margin      : 60,
                    speed       : 300       // the scroll speed in pixels per second
                },

                inertia: {
                    enabled          : false,
                    resistance       : 10,    // the lambda in exponential decay
                    minSpeed         : 100,   // target speed must be above this for inertia to start
                    endSpeed         : 10,    // the speed at which inertia is slow enough to stop
                    allowResume      : true,  // allow resuming an action in inertia phase
                    zeroResumeDelta  : true,  // if an action is resumed after launch, set dx/dy to 0
                    smoothEndDuration: 300    // animate to snap/restrict endOnly if there's no inertia
                }
            },

            _holdDuration: 600
        },

        // Things related to autoScroll
        autoScroll = {
            interaction: null,
            i: null,    // the handle returned by window.setInterval
            x: 0, y: 0, // Direction each pulse is to scroll in

            // scroll the window by the values in scroll.x/y
            scroll: function () {
                var options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll,
                    container = options.container || getWindow(autoScroll.interaction.element),
                    now = new Date().getTime(),
                    // change in time in seconds
                    dtx = (now - autoScroll.prevTimeX) / 1000,
                    dty = (now - autoScroll.prevTimeY) / 1000,
                    vx, vy, sx, sy;

                // displacement
                if (options.velocity) {
                  vx = options.velocity.x;
                  vy = options.velocity.y;
                }
                else {
                  vx = vy = options.speed
                }
 
                sx = vx * dtx;
                sy = vy * dty;

                if (sx >= 1 || sy >= 1) {
                    if (isWindow(container)) {
                        container.scrollBy(autoScroll.x * sx, autoScroll.y * sy);
                    }
                    else if (container) {
                        container.scrollLeft += autoScroll.x * sx;
                        container.scrollTop  += autoScroll.y * sy;
                    }

                    if (sx >=1) autoScroll.prevTimeX = now;
                    if (sy >= 1) autoScroll.prevTimeY = now;
                }

                if (autoScroll.isScrolling) {
                    cancelFrame(autoScroll.i);
                    autoScroll.i = reqFrame(autoScroll.scroll);
                }
            },

            isScrolling: false,
            prevTimeX: 0,
            prevTimeY: 0,

            start: function (interaction) {
                autoScroll.isScrolling = true;
                cancelFrame(autoScroll.i);

                autoScroll.interaction = interaction;
                autoScroll.prevTimeX = new Date().getTime();
                autoScroll.prevTimeY = new Date().getTime();
                autoScroll.i = reqFrame(autoScroll.scroll);
            },

            stop: function () {
                autoScroll.isScrolling = false;
                cancelFrame(autoScroll.i);
            }
        },

        // Does the browser support touch input?
        supportsTouch = (('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch),

        // Does the browser support PointerEvents
        supportsPointerEvent = !!PointerEvent,

        // Less Precision with touch input
        margin = supportsTouch || supportsPointerEvent? 20: 10,

        pointerMoveTolerance = 1,

        // for ignoring browser's simulated mouse events
        prevTouchTime = 0,

        // Allow this many interactions to happen simultaneously
        maxInteractions = Infinity,

        // Check if is IE9 or older
        actionCursors = (document.all && !window.atob) ? {
            drag    : 'move',
            resizex : 'e-resize',
            resizey : 's-resize',
            resizexy: 'se-resize',

            resizetop        : 'n-resize',
            resizeleft       : 'w-resize',
            resizebottom     : 's-resize',
            resizeright      : 'e-resize',
            resizetopleft    : 'se-resize',
            resizebottomright: 'se-resize',
            resizetopright   : 'ne-resize',
            resizebottomleft : 'ne-resize',

            gesture : ''
        } : {
            drag    : 'move',
            resizex : 'ew-resize',
            resizey : 'ns-resize',
            resizexy: 'nwse-resize',

            resizetop        : 'ns-resize',
            resizeleft       : 'ew-resize',
            resizebottom     : 'ns-resize',
            resizeright      : 'ew-resize',
            resizetopleft    : 'nwse-resize',
            resizebottomright: 'nwse-resize',
            resizetopright   : 'nesw-resize',
            resizebottomleft : 'nesw-resize',

            gesture : ''
        },

        actionIsEnabled = {
            drag   : true,
            resize : true,
            gesture: true
        },

        // because Webkit and Opera still use 'mousewheel' event type
        wheelEvent = 'onmousewheel' in document? 'mousewheel': 'wheel',

        eventTypes = [
            'dragstart',
            'dragmove',
            'draginertiastart',
            'dragend',
            'dragenter',
            'dragleave',
            'dropactivate',
            'dropdeactivate',
            'dropmove',
            'drop',
            'resizestart',
            'resizemove',
            'resizeinertiastart',
            'resizeend',
            'gesturestart',
            'gesturemove',
            'gestureinertiastart',
            'gestureend',

            'down',
            'move',
            'up',
            'cancel',
            'tap',
            'doubletap',
            'hold'
        ],

        globalEvents = {},

        // Opera Mobile must be handled differently
        isOperaMobile = navigator.appName == 'Opera' &&
            supportsTouch &&
            navigator.userAgent.match('Presto'),

        // scrolling doesn't change the result of getClientRects on iOS 7
        isIOS7 = (/iP(hone|od|ad)/.test(navigator.platform)
                         && /OS 7[^\d]/.test(navigator.appVersion)),

        // prefix matchesSelector
        prefixedMatchesSelector = 'matches' in Element.prototype?
                'matches': 'webkitMatchesSelector' in Element.prototype?
                    'webkitMatchesSelector': 'mozMatchesSelector' in Element.prototype?
                        'mozMatchesSelector': 'oMatchesSelector' in Element.prototype?
                            'oMatchesSelector': 'msMatchesSelector',

        // will be polyfill function if browser is IE8
        ie8MatchesSelector,

        // native requestAnimationFrame or polyfill
        reqFrame = realWindow.requestAnimationFrame,
        cancelFrame = realWindow.cancelAnimationFrame,

        // Events wrapper
        events = (function () {
            var useAttachEvent = ('attachEvent' in window) && !('addEventListener' in window),
                addEvent       = useAttachEvent?  'attachEvent': 'addEventListener',
                removeEvent    = useAttachEvent?  'detachEvent': 'removeEventListener',
                on             = useAttachEvent? 'on': '',

                elements          = [],
                targets           = [],
                attachedListeners = [];

            function add (element, type, listener, useCapture) {
                var elementIndex = indexOf(elements, element),
                    target = targets[elementIndex];

                if (!target) {
                    target = {
                        events: {},
                        typeCount: 0
                    };

                    elementIndex = elements.push(element) - 1;
                    targets.push(target);

                    attachedListeners.push((useAttachEvent ? {
                            supplied: [],
                            wrapped : [],
                            useCount: []
                        } : null));
                }

                if (!target.events[type]) {
                    target.events[type] = [];
                    target.typeCount++;
                }

                if (!contains(target.events[type], listener)) {
                    var ret;

                    if (useAttachEvent) {
                        var listeners = attachedListeners[elementIndex],
                            listenerIndex = indexOf(listeners.supplied, listener);

                        var wrapped = listeners.wrapped[listenerIndex] || function (event) {
                            if (!event.immediatePropagationStopped) {
                                event.target = event.srcElement;
                                event.currentTarget = element;

                                event.preventDefault = event.preventDefault || preventDef;
                                event.stopPropagation = event.stopPropagation || stopProp;
                                event.stopImmediatePropagation = event.stopImmediatePropagation || stopImmProp;

                                if (/mouse|click/.test(event.type)) {
                                    event.pageX = event.clientX + getWindow(element).document.documentElement.scrollLeft;
                                    event.pageY = event.clientY + getWindow(element).document.documentElement.scrollTop;
                                }

                                listener(event);
                            }
                        };

                        ret = element[addEvent](on + type, wrapped, Boolean(useCapture));

                        if (listenerIndex === -1) {
                            listeners.supplied.push(listener);
                            listeners.wrapped.push(wrapped);
                            listeners.useCount.push(1);
                        }
                        else {
                            listeners.useCount[listenerIndex]++;
                        }
                    }
                    else {
                        ret = element[addEvent](type, listener, useCapture || false);
                    }
                    target.events[type].push(listener);

                    return ret;
                }
            }

            function remove (element, type, listener, useCapture) {
                var i,
                    elementIndex = indexOf(elements, element),
                    target = targets[elementIndex],
                    listeners,
                    listenerIndex,
                    wrapped = listener;

                if (!target || !target.events) {
                    return;
                }

                if (useAttachEvent) {
                    listeners = attachedListeners[elementIndex];
                    listenerIndex = indexOf(listeners.supplied, listener);
                    wrapped = listeners.wrapped[listenerIndex];
                }

                if (type === 'all') {
                    for (type in target.events) {
                        if (target.events.hasOwnProperty(type)) {
                            remove(element, type, 'all');
                        }
                    }
                    return;
                }

                if (target.events[type]) {
                    var len = target.events[type].length;

                    if (listener === 'all') {
                        for (i = 0; i < len; i++) {
                            remove(element, type, target.events[type][i], Boolean(useCapture));
                        }
                        return;
                    } else {
                        for (i = 0; i < len; i++) {
                            if (target.events[type][i] === listener) {
                                element[removeEvent](on + type, wrapped, useCapture || false);
                                target.events[type].splice(i, 1);

                                if (useAttachEvent && listeners) {
                                    listeners.useCount[listenerIndex]--;
                                    if (listeners.useCount[listenerIndex] === 0) {
                                        listeners.supplied.splice(listenerIndex, 1);
                                        listeners.wrapped.splice(listenerIndex, 1);
                                        listeners.useCount.splice(listenerIndex, 1);
                                    }
                                }

                                break;
                            }
                        }
                    }

                    if (target.events[type] && target.events[type].length === 0) {
                        target.events[type] = null;
                        target.typeCount--;
                    }
                }

                if (!target.typeCount) {
                    targets.splice(elementIndex, 1);
                    elements.splice(elementIndex, 1);
                    attachedListeners.splice(elementIndex, 1);
                }
            }

            function preventDef () {
                this.returnValue = false;
            }

            function stopProp () {
                this.cancelBubble = true;
            }

            function stopImmProp () {
                this.cancelBubble = true;
                this.immediatePropagationStopped = true;
            }

            return {
                add: add,
                remove: remove,
                useAttachEvent: useAttachEvent,

                _elements: elements,
                _targets: targets,
                _attachedListeners: attachedListeners
            };
        }());

    function blank () {}

    function isElement (o) {
        if (!o || (typeof o !== 'object')) { return false; }

        var _window = getWindow(o) || window;

        return (/object|function/.test(typeof _window.Element)
            ? o instanceof _window.Element //DOM2
            : o.nodeType === 1 && typeof o.nodeName === "string");
    }
    function isWindow (thing) { return thing === window || !!(thing && thing.Window) && (thing instanceof thing.Window); }
    function isDocFrag (thing) { return !!thing && thing instanceof DocumentFragment; }
    function isArray (thing) {
        return isObject(thing)
                && (typeof thing.length !== undefined)
                && isFunction(thing.splice);
    }
    function isObject   (thing) { return !!thing && (typeof thing === 'object'); }
    function isFunction (thing) { return typeof thing === 'function'; }
    function isNumber   (thing) { return typeof thing === 'number'  ; }
    function isBool     (thing) { return typeof thing === 'boolean' ; }
    function isString   (thing) { return typeof thing === 'string'  ; }

    function trySelector (value) {
        if (!isString(value)) { return false; }

        // an exception will be raised if it is invalid
        document.querySelector(value);
        return true;
    }

    function extend (dest, source) {
        for (var prop in source) {
            dest[prop] = source[prop];
        }
        return dest;
    }

    var prefixedPropREs = {
      webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/
    };

    function pointerExtend (dest, source) {
        for (var prop in source) {
          var deprecated = false;

          // skip deprecated prefixed properties
          for (var vendor in prefixedPropREs) {
            if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {
              deprecated = true;
              break;
            }
          }

          if (!deprecated) {
            dest[prop] = source[prop];
          }
        }
        return dest;
    }

    function copyCoords (dest, src) {
        dest.page = dest.page || {};
        dest.page.x = src.page.x;
        dest.page.y = src.page.y;

        dest.client = dest.client || {};
        dest.client.x = src.client.x;
        dest.client.y = src.client.y;

        dest.timeStamp = src.timeStamp;
    }

    function setEventXY (targetObj, pointers, interaction) {
        var pointer = (pointers.length > 1
                       ? pointerAverage(pointers)
                       : pointers[0]);

        getPageXY(pointer, tmpXY, interaction);
        targetObj.page.x = tmpXY.x;
        targetObj.page.y = tmpXY.y;

        getClientXY(pointer, tmpXY, interaction);
        targetObj.client.x = tmpXY.x;
        targetObj.client.y = tmpXY.y;

        targetObj.timeStamp = new Date().getTime();
    }

    function setEventDeltas (targetObj, prev, cur) {
        targetObj.page.x     = cur.page.x      - prev.page.x;
        targetObj.page.y     = cur.page.y      - prev.page.y;
        targetObj.client.x   = cur.client.x    - prev.client.x;
        targetObj.client.y   = cur.client.y    - prev.client.y;
        targetObj.timeStamp = new Date().getTime() - prev.timeStamp;

        // set pointer velocity
        var dt = Math.max(targetObj.timeStamp / 1000, 0.001);
        targetObj.page.speed   = hypot(targetObj.page.x, targetObj.page.y) / dt;
        targetObj.page.vx      = targetObj.page.x / dt;
        targetObj.page.vy      = targetObj.page.y / dt;

        targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;
        targetObj.client.vx    = targetObj.client.x / dt;
        targetObj.client.vy    = targetObj.client.y / dt;
    }

    function isNativePointer (pointer) {
        return (pointer instanceof window.Event
            || (supportsTouch && window.Touch && pointer instanceof window.Touch));
    }

    // Get specified X/Y coords for mouse or event.touches[0]
    function getXY (type, pointer, xy) {
        xy = xy || {};
        type = type || 'page';

        xy.x = pointer[type + 'X'];
        xy.y = pointer[type + 'Y'];

        return xy;
    }

    function getPageXY (pointer, page) {
        page = page || {};

        // Opera Mobile handles the viewport and scrolling oddly
        if (isOperaMobile && isNativePointer(pointer)) {
            getXY('screen', pointer, page);

            page.x += window.scrollX;
            page.y += window.scrollY;
        }
        else {
            getXY('page', pointer, page);
        }

        return page;
    }

    function getClientXY (pointer, client) {
        client = client || {};

        if (isOperaMobile && isNativePointer(pointer)) {
            // Opera Mobile handles the viewport and scrolling oddly
            getXY('screen', pointer, client);
        }
        else {
          getXY('client', pointer, client);
        }

        return client;
    }

    function getScrollXY (win) {
        win = win || window;
        return {
            x: win.scrollX || win.document.documentElement.scrollLeft,
            y: win.scrollY || win.document.documentElement.scrollTop
        };
    }

    function getPointerId (pointer) {
        return isNumber(pointer.pointerId)? pointer.pointerId : pointer.identifier;
    }

    function getActualElement (element) {
        return (element instanceof SVGElementInstance
            ? element.correspondingUseElement
            : element);
    }

    function getWindow (node) {
        if (isWindow(node)) {
            return node;
        }

        var rootNode = (node.ownerDocument || node);

        return rootNode.defaultView || rootNode.parentWindow || window;
    }

    function getElementClientRect (element) {
        var clientRect = (element instanceof SVGElement
                            ? element.getBoundingClientRect()
                            : element.getClientRects()[0]);

        return clientRect && {
            left  : clientRect.left,
            right : clientRect.right,
            top   : clientRect.top,
            bottom: clientRect.bottom,
            width : clientRect.width || clientRect.right - clientRect.left,
            height: clientRect.height || clientRect.bottom - clientRect.top
        };
    }

    function getElementRect (element) {
        var clientRect = getElementClientRect(element);

        if (!isIOS7 && clientRect) {
            var scroll = getScrollXY(getWindow(element));

            clientRect.left   += scroll.x;
            clientRect.right  += scroll.x;
            clientRect.top    += scroll.y;
            clientRect.bottom += scroll.y;
        }

        return clientRect;
    }

    function getTouchPair (event) {
        var touches = [];

        // array of touches is supplied
        if (isArray(event)) {
            touches[0] = event[0];
            touches[1] = event[1];
        }
        // an event
        else {
            if (event.type === 'touchend') {
                if (event.touches.length === 1) {
                    touches[0] = event.touches[0];
                    touches[1] = event.changedTouches[0];
                }
                else if (event.touches.length === 0) {
                    touches[0] = event.changedTouches[0];
                    touches[1] = event.changedTouches[1];
                }
            }
            else {
                touches[0] = event.touches[0];
                touches[1] = event.touches[1];
            }
        }

        return touches;
    }

    function pointerAverage (pointers) {
        var average = {
            pageX  : 0,
            pageY  : 0,
            clientX: 0,
            clientY: 0,
            screenX: 0,
            screenY: 0
        };
        var prop;

        for (var i = 0; i < pointers.length; i++) {
            for (prop in average) {
                average[prop] += pointers[i][prop];
            }
        }
        for (prop in average) {
            average[prop] /= pointers.length;
        }

        return average;
    }

    function touchBBox (event) {
        if (!event.length && !(event.touches && event.touches.length > 1)) {
            return;
        }

        var touches = getTouchPair(event),
            minX = Math.min(touches[0].pageX, touches[1].pageX),
            minY = Math.min(touches[0].pageY, touches[1].pageY),
            maxX = Math.max(touches[0].pageX, touches[1].pageX),
            maxY = Math.max(touches[0].pageY, touches[1].pageY);

        return {
            x: minX,
            y: minY,
            left: minX,
            top: minY,
            width: maxX - minX,
            height: maxY - minY
        };
    }

    function touchDistance (event, deltaSource) {
        deltaSource = deltaSource || defaultOptions.deltaSource;

        var sourceX = deltaSource + 'X',
            sourceY = deltaSource + 'Y',
            touches = getTouchPair(event);


        var dx = touches[0][sourceX] - touches[1][sourceX],
            dy = touches[0][sourceY] - touches[1][sourceY];

        return hypot(dx, dy);
    }

    function touchAngle (event, prevAngle, deltaSource) {
        deltaSource = deltaSource || defaultOptions.deltaSource;

        var sourceX = deltaSource + 'X',
            sourceY = deltaSource + 'Y',
            touches = getTouchPair(event),
            dx = touches[0][sourceX] - touches[1][sourceX],
            dy = touches[0][sourceY] - touches[1][sourceY],
            angle = 180 * Math.atan(dy / dx) / Math.PI;

        if (isNumber(prevAngle)) {
            var dr = angle - prevAngle,
                drClamped = dr % 360;

            if (drClamped > 315) {
                angle -= 360 + (angle / 360)|0 * 360;
            }
            else if (drClamped > 135) {
                angle -= 180 + (angle / 360)|0 * 360;
            }
            else if (drClamped < -315) {
                angle += 360 + (angle / 360)|0 * 360;
            }
            else if (drClamped < -135) {
                angle += 180 + (angle / 360)|0 * 360;
            }
        }

        return  angle;
    }

    function getOriginXY (interactable, element) {
        var origin = interactable
                ? interactable.options.origin
                : defaultOptions.origin;

        if (origin === 'parent') {
            origin = parentElement(element);
        }
        else if (origin === 'self') {
            origin = interactable.getRect(element);
        }
        else if (trySelector(origin)) {
            origin = closest(element, origin) || { x: 0, y: 0 };
        }

        if (isFunction(origin)) {
            origin = origin(interactable && element);
        }

        if (isElement(origin))  {
            origin = getElementRect(origin);
        }

        origin.x = ('x' in origin)? origin.x : origin.left;
        origin.y = ('y' in origin)? origin.y : origin.top;

        return origin;
    }

    // http://stackoverflow.com/a/5634528/2280888
    function _getQBezierValue(t, p1, p2, p3) {
        var iT = 1 - t;
        return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;
    }

    function getQuadraticCurvePoint(startX, startY, cpX, cpY, endX, endY, position) {
        return {
            x:  _getQBezierValue(position, startX, cpX, endX),
            y:  _getQBezierValue(position, startY, cpY, endY)
        };
    }

    // http://gizma.com/easing/
    function easeOutQuad (t, b, c, d) {
        t /= d;
        return -c * t*(t-2) + b;
    }

    function nodeContains (parent, child) {
        while (child) {
            if (child === parent) {
                return true;
            }

            child = child.parentNode;
        }

        return false;
    }

    function closest (child, selector) {
        var parent = parentElement(child);

        while (isElement(parent)) {
            if (matchesSelector(parent, selector)) { return parent; }

            parent = parentElement(parent);
        }

        return null;
    }

    function parentElement (node) {
        var parent = node.parentNode;

        if (isDocFrag(parent)) {
            // skip past #shado-root fragments
            while ((parent = parent.host) && isDocFrag(parent)) {}

            return parent;
        }

        return parent;
    }

    function inContext (interactable, element) {
        return interactable._context === element.ownerDocument
                || nodeContains(interactable._context, element);
    }

    function testIgnore (interactable, interactableElement, element) {
        var ignoreFrom = interactable.options.ignoreFrom;

        if (!ignoreFrom || !isElement(element)) { return false; }

        if (isString(ignoreFrom)) {
            return matchesUpTo(element, ignoreFrom, interactableElement);
        }
        else if (isElement(ignoreFrom)) {
            return nodeContains(ignoreFrom, element);
        }

        return false;
    }

    function testAllow (interactable, interactableElement, element) {
        var allowFrom = interactable.options.allowFrom;

        if (!allowFrom) { return true; }

        if (!isElement(element)) { return false; }

        if (isString(allowFrom)) {
            return matchesUpTo(element, allowFrom, interactableElement);
        }
        else if (isElement(allowFrom)) {
            return nodeContains(allowFrom, element);
        }

        return false;
    }

    function checkAxis (axis, interactable) {
        if (!interactable) { return false; }

        var thisAxis = interactable.options.drag.axis;

        return (axis === 'xy' || thisAxis === 'xy' || thisAxis === axis);
    }

    function checkSnap (interactable, action) {
        var options = interactable.options;

        if (/^resize/.test(action)) {
            action = 'resize';
        }

        return options[action].snap && options[action].snap.enabled;
    }

    function checkRestrict (interactable, action) {
        var options = interactable.options;

        if (/^resize/.test(action)) {
            action = 'resize';
        }

        return  options[action].restrict && options[action].restrict.enabled;
    }

    function checkAutoScroll (interactable, action) {
        var options = interactable.options;

        if (/^resize/.test(action)) {
            action = 'resize';
        }

        return  options[action].autoScroll && options[action].autoScroll.enabled;
    }

    function withinInteractionLimit (interactable, element, action) {
        var options = interactable.options,
            maxActions = options[action.name].max,
            maxPerElement = options[action.name].maxPerElement,
            activeInteractions = 0,
            targetCount = 0,
            targetElementCount = 0;

        for (var i = 0, len = interactions.length; i < len; i++) {
            var interaction = interactions[i],
                otherAction = interaction.prepared.name,
                active = interaction.interacting();

            if (!active) { continue; }

            activeInteractions++;

            if (activeInteractions >= maxInteractions) {
                return false;
            }

            if (interaction.target !== interactable) { continue; }

            targetCount += (otherAction === action.name)|0;

            if (targetCount >= maxActions) {
                return false;
            }

            if (interaction.element === element) {
                targetElementCount++;

                if (otherAction !== action.name || targetElementCount >= maxPerElement) {
                    return false;
                }
            }
        }

        return maxInteractions > 0;
    }

    // Test for the element that's "above" all other qualifiers
    function indexOfDeepestElement (elements) {
        var dropzone,
            deepestZone = elements[0],
            index = deepestZone? 0: -1,
            parent,
            deepestZoneParents = [],
            dropzoneParents = [],
            child,
            i,
            n;

        for (i = 1; i < elements.length; i++) {
            dropzone = elements[i];

            // an element might belong to multiple selector dropzones
            if (!dropzone || dropzone === deepestZone) {
                continue;
            }

            if (!deepestZone) {
                deepestZone = dropzone;
                index = i;
                continue;
            }

            // check if the deepest or current are document.documentElement or document.rootElement
            // - if the current dropzone is, do nothing and continue
            if (dropzone.parentNode === dropzone.ownerDocument) {
                continue;
            }
            // - if deepest is, update with the current dropzone and continue to next
            else if (deepestZone.parentNode === dropzone.ownerDocument) {
                deepestZone = dropzone;
                index = i;
                continue;
            }

            if (!deepestZoneParents.length) {
                parent = deepestZone;
                while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {
                    deepestZoneParents.unshift(parent);
                    parent = parent.parentNode;
                }
            }

            // if this element is an svg element and the current deepest is
            // an HTMLElement
            if (deepestZone instanceof HTMLElement
                && dropzone instanceof SVGElement
                && !(dropzone instanceof SVGSVGElement)) {

                if (dropzone === deepestZone.parentNode) {
                    continue;
                }

                parent = dropzone.ownerSVGElement;
            }
            else {
                parent = dropzone;
            }

            dropzoneParents = [];

            while (parent.parentNode !== parent.ownerDocument) {
                dropzoneParents.unshift(parent);
                parent = parent.parentNode;
            }

            n = 0;

            // get (position of last common ancestor) + 1
            while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {
                n++;
            }

            var parents = [
                dropzoneParents[n - 1],
                dropzoneParents[n],
                deepestZoneParents[n]
            ];

            child = parents[0].lastChild;

            while (child) {
                if (child === parents[1]) {
                    deepestZone = dropzone;
                    index = i;
                    deepestZoneParents = [];

                    break;
                }
                else if (child === parents[2]) {
                    break;
                }

                child = child.previousSibling;
            }
        }

        return index;
    }

    function Interaction () {
        this.target          = null; // current interactable being interacted with
        this.element         = null; // the target element of the interactable
        this.dropTarget      = null; // the dropzone a drag target might be dropped into
        this.dropElement     = null; // the element at the time of checking
        this.prevDropTarget  = null; // the dropzone that was recently dragged away from
        this.prevDropElement = null; // the element at the time of checking

        this.prepared        = {     // action that's ready to be fired on next move event
            name : null,
            axis : null,
            edges: null
        };

        this.matches         = [];   // all selectors that are matched by target element
        this.matchElements   = [];   // corresponding elements

        this.inertiaStatus = {
            active       : false,
            smoothEnd    : false,
            ending       : false,

            startEvent: null,
            upCoords: {},

            xe: 0, ye: 0,
            sx: 0, sy: 0,

            t0: 0,
            vx0: 0, vys: 0,
            duration: 0,

            resumeDx: 0,
            resumeDy: 0,

            lambda_v0: 0,
            one_ve_v0: 0,
            i  : null
        };

        if (isFunction(Function.prototype.bind)) {
            this.boundInertiaFrame = this.inertiaFrame.bind(this);
            this.boundSmoothEndFrame = this.smoothEndFrame.bind(this);
        }
        else {
            var that = this;

            this.boundInertiaFrame = function () { return that.inertiaFrame(); };
            this.boundSmoothEndFrame = function () { return that.smoothEndFrame(); };
        }

        this.activeDrops = {
            dropzones: [],      // the dropzones that are mentioned below
            elements : [],      // elements of dropzones that accept the target draggable
            rects    : []       // the rects of the elements mentioned above
        };

        // keep track of added pointers
        this.pointers    = [];
        this.pointerIds  = [];
        this.downTargets = [];
        this.downTimes   = [];
        this.holdTimers  = [];

        // Previous native pointer move event coordinates
        this.prevCoords = {
            page     : { x: 0, y: 0 },
            client   : { x: 0, y: 0 },
            timeStamp: 0
        };
        // current native pointer move event coordinates
        this.curCoords = {
            page     : { x: 0, y: 0 },
            client   : { x: 0, y: 0 },
            timeStamp: 0
        };

        // Starting InteractEvent pointer coordinates
        this.startCoords = {
            page     : { x: 0, y: 0 },
            client   : { x: 0, y: 0 },
            timeStamp: 0
        };

        // Change in coordinates and time of the pointer
        this.pointerDelta = {
            page     : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },
            client   : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },
            timeStamp: 0
        };

        this.downEvent   = null;    // pointerdown/mousedown/touchstart event
        this.downPointer = {};

        this._eventTarget    = null;
        this._curEventTarget = null;

        this.prevEvent = null;      // previous action event
        this.tapTime   = 0;         // time of the most recent tap event
        this.prevTap   = null;

        this.startOffset    = { left: 0, right: 0, top: 0, bottom: 0 };
        this.restrictOffset = { left: 0, right: 0, top: 0, bottom: 0 };
        this.snapOffsets    = [];

        this.gesture = {
            start: { x: 0, y: 0 },

            startDistance: 0,   // distance between two touches of touchStart
            prevDistance : 0,
            distance     : 0,

            scale: 1,           // gesture.distance / gesture.startDistance

            startAngle: 0,      // angle of line joining two touches
            prevAngle : 0       // angle of the previous gesture event
        };

        this.snapStatus = {
            x       : 0, y       : 0,
            dx      : 0, dy      : 0,
            realX   : 0, realY   : 0,
            snappedX: 0, snappedY: 0,
            targets : [],
            locked  : false,
            changed : false
        };

        this.restrictStatus = {
            dx         : 0, dy         : 0,
            restrictedX: 0, restrictedY: 0,
            snap       : null,
            restricted : false,
            changed    : false
        };

        this.restrictStatus.snap = this.snapStatus;

        this.pointerIsDown   = false;
        this.pointerWasMoved = false;
        this.gesturing       = false;
        this.dragging        = false;
        this.resizing        = false;
        this.resizeAxes      = 'xy';

        this.mouse = false;

        interactions.push(this);
    }

    Interaction.prototype = {
        getPageXY  : function (pointer, xy) { return   getPageXY(pointer, xy, this); },
        getClientXY: function (pointer, xy) { return getClientXY(pointer, xy, this); },
        setEventXY : function (target, ptr) { return  setEventXY(target, ptr, this); },

        pointerOver: function (pointer, event, eventTarget) {
            if (this.prepared.name || !this.mouse) { return; }

            var curMatches = [],
                curMatchElements = [],
                prevTargetElement = this.element;

            this.addPointer(pointer);

            if (this.target
                && (testIgnore(this.target, this.element, eventTarget)
                    || !testAllow(this.target, this.element, eventTarget))) {
                // if the eventTarget should be ignored or shouldn't be allowed
                // clear the previous target
                this.target = null;
                this.element = null;
                this.matches = [];
                this.matchElements = [];
            }

            var elementInteractable = interactables.get(eventTarget),
                elementAction = (elementInteractable
                                 && !testIgnore(elementInteractable, eventTarget, eventTarget)
                                 && testAllow(elementInteractable, eventTarget, eventTarget)
                                 && validateAction(
                                     elementInteractable.getAction(pointer, event, this, eventTarget),
                                     elementInteractable));

            if (elementAction && !withinInteractionLimit(elementInteractable, eventTarget, elementAction)) {
                 elementAction = null;
            }

            function pushCurMatches (interactable, selector) {
                if (interactable
                    && inContext(interactable, eventTarget)
                    && !testIgnore(interactable, eventTarget, eventTarget)
                    && testAllow(interactable, eventTarget, eventTarget)
                    && matchesSelector(eventTarget, selector)) {

                    curMatches.push(interactable);
                    curMatchElements.push(eventTarget);
                }
            }

            if (elementAction) {
                this.target = elementInteractable;
                this.element = eventTarget;
                this.matches = [];
                this.matchElements = [];
            }
            else {
                interactables.forEachSelector(pushCurMatches);

                if (this.validateSelector(pointer, event, curMatches, curMatchElements)) {
                    this.matches = curMatches;
                    this.matchElements = curMatchElements;

                    this.pointerHover(pointer, event, this.matches, this.matchElements);
                    events.add(eventTarget,
                                        PointerEvent? pEventTypes.move : 'mousemove',
                                        listeners.pointerHover);
                }
                else if (this.target) {
                    if (nodeContains(prevTargetElement, eventTarget)) {
                        this.pointerHover(pointer, event, this.matches, this.matchElements);
                        events.add(this.element,
                                            PointerEvent? pEventTypes.move : 'mousemove',
                                            listeners.pointerHover);
                    }
                    else {
                        this.target = null;
                        this.element = null;
                        this.matches = [];
                        this.matchElements = [];
                    }
                }
            }
        },

        // Check what action would be performed on pointerMove target if a mouse
        // button were pressed and change the cursor accordingly
        pointerHover: function (pointer, event, eventTarget, curEventTarget, matches, matchElements) {
            var target = this.target;

            if (!this.prepared.name && this.mouse) {

                var action;

                // update pointer coords for defaultActionChecker to use
                this.setEventXY(this.curCoords, [pointer]);

                if (matches) {
                    action = this.validateSelector(pointer, event, matches, matchElements);
                }
                else if (target) {
                    action = validateAction(target.getAction(this.pointers[0], event, this, this.element), this.target);
                }

                if (target && target.options.styleCursor) {
                    if (action) {
                        target._doc.documentElement.style.cursor = getActionCursor(action);
                    }
                    else {
                        target._doc.documentElement.style.cursor = '';
                    }
                }
            }
            else if (this.prepared.name) {
                this.checkAndPreventDefault(event, target, this.element);
            }
        },

        pointerOut: function (pointer, event, eventTarget) {
            if (this.prepared.name) { return; }

            // Remove temporary event listeners for selector Interactables
            if (!interactables.get(eventTarget)) {
                events.remove(eventTarget,
                                       PointerEvent? pEventTypes.move : 'mousemove',
                                       listeners.pointerHover);
            }

            if (this.target && this.target.options.styleCursor && !this.interacting()) {
                this.target._doc.documentElement.style.cursor = '';
            }
        },

        selectorDown: function (pointer, event, eventTarget, curEventTarget) {
            var that = this,
                // copy event to be used in timeout for IE8
                eventCopy = events.useAttachEvent? extend({}, event) : event,
                element = eventTarget,
                pointerIndex = this.addPointer(pointer),
                action;

            this.holdTimers[pointerIndex] = setTimeout(function () {
                that.pointerHold(events.useAttachEvent? eventCopy : pointer, eventCopy, eventTarget, curEventTarget);
            }, defaultOptions._holdDuration);

            this.pointerIsDown = true;

            // Check if the down event hits the current inertia target
            if (this.inertiaStatus.active && this.target.selector) {
                // climb up the DOM tree from the event target
                while (isElement(element)) {

                    // if this element is the current inertia target element
                    if (element === this.element
                        // and the prospective action is the same as the ongoing one
                        && validateAction(this.target.getAction(pointer, event, this, this.element), this.target).name === this.prepared.name) {

                        // stop inertia so that the next move will be a normal one
                        cancelFrame(this.inertiaStatus.i);
                        this.inertiaStatus.active = false;

                        this.collectEventTargets(pointer, event, eventTarget, 'down');
                        return;
                    }
                    element = parentElement(element);
                }
            }

            // do nothing if interacting
            if (this.interacting()) {
                this.collectEventTargets(pointer, event, eventTarget, 'down');
                return;
            }

            function pushMatches (interactable, selector, context) {
                var elements = ie8MatchesSelector
                    ? context.querySelectorAll(selector)
                    : undefined;

                if (inContext(interactable, element)
                    && !testIgnore(interactable, element, eventTarget)
                    && testAllow(interactable, element, eventTarget)
                    && matchesSelector(element, selector, elements)) {

                    that.matches.push(interactable);
                    that.matchElements.push(element);
                }
            }

            // update pointer coords for defaultActionChecker to use
            this.setEventXY(this.curCoords, [pointer]);
            this.downEvent = event;

            while (isElement(element) && !action) {
                this.matches = [];
                this.matchElements = [];

                interactables.forEachSelector(pushMatches);

                action = this.validateSelector(pointer, event, this.matches, this.matchElements);
                element = parentElement(element);
            }

            if (action) {
                this.prepared.name  = action.name;
                this.prepared.axis  = action.axis;
                this.prepared.edges = action.edges;

                this.collectEventTargets(pointer, event, eventTarget, 'down');

                return this.pointerDown(pointer, event, eventTarget, curEventTarget, action);
            }
            else {
                // do these now since pointerDown isn't being called from here
                this.downTimes[pointerIndex] = new Date().getTime();
                this.downTargets[pointerIndex] = eventTarget;
                pointerExtend(this.downPointer, pointer);

                copyCoords(this.prevCoords, this.curCoords);
                this.pointerWasMoved = false;
            }

            this.collectEventTargets(pointer, event, eventTarget, 'down');
        },

        // Determine action to be performed on next pointerMove and add appropriate
        // style and event Listeners
        pointerDown: function (pointer, event, eventTarget, curEventTarget, forceAction) {
            if (!forceAction && !this.inertiaStatus.active && this.pointerWasMoved && this.prepared.name) {
                this.checkAndPreventDefault(event, this.target, this.element);

                return;
            }

            this.pointerIsDown = true;
            this.downEvent = event;

            var pointerIndex = this.addPointer(pointer),
                action;

            // If it is the second touch of a multi-touch gesture, keep the
            // target the same and get a new action if a target was set by the
            // first touch
            if (this.pointerIds.length > 1 && this.target._element === this.element) {
                var newAction = validateAction(forceAction || this.target.getAction(pointer, event, this, this.element), this.target);

                if (withinInteractionLimit(this.target, this.element, newAction)) {
                    action = newAction;
                }

                this.prepared.name = null;
            }
            // Otherwise, set the target if there is no action prepared
            else if (!this.prepared.name) {
                var interactable = interactables.get(curEventTarget);

                if (interactable
                    && !testIgnore(interactable, curEventTarget, eventTarget)
                    && testAllow(interactable, curEventTarget, eventTarget)
                    && (action = validateAction(forceAction || interactable.getAction(pointer, event, this, curEventTarget), interactable, eventTarget))
                    && withinInteractionLimit(interactable, curEventTarget, action)) {
                    this.target = interactable;
                    this.element = curEventTarget;
                }
            }

            var target = this.target,
                options = target && target.options;

            if (target && (forceAction || !this.prepared.name)) {
                action = action || validateAction(forceAction || target.getAction(pointer, event, this, curEventTarget), target, this.element);

                this.setEventXY(this.startCoords, this.pointers);

                if (!action) { return; }

                if (options.styleCursor) {
                    target._doc.documentElement.style.cursor = getActionCursor(action);
                }

                this.resizeAxes = action.name === 'resize'? action.axis : null;

                if (action === 'gesture' && this.pointerIds.length < 2) {
                    action = null;
                }

                this.prepared.name  = action.name;
                this.prepared.axis  = action.axis;
                this.prepared.edges = action.edges;

                this.snapStatus.snappedX = this.snapStatus.snappedY =
                    this.restrictStatus.restrictedX = this.restrictStatus.restrictedY = NaN;

                this.downTimes[pointerIndex] = new Date().getTime();
                this.downTargets[pointerIndex] = eventTarget;
                pointerExtend(this.downPointer, pointer);

                copyCoords(this.prevCoords, this.startCoords);
                this.pointerWasMoved = false;

                this.checkAndPreventDefault(event, target, this.element);
            }
            // if inertia is active try to resume action
            else if (this.inertiaStatus.active
                && curEventTarget === this.element
                && validateAction(target.getAction(pointer, event, this, this.element), target).name === this.prepared.name) {

                cancelFrame(this.inertiaStatus.i);
                this.inertiaStatus.active = false;

                this.checkAndPreventDefault(event, target, this.element);
            }
        },

        setModifications: function (coords, preEnd) {
            var target         = this.target,
                shouldMove     = true,
                shouldSnap     = checkSnap(target, this.prepared.name)     && (!target.options[this.prepared.name].snap.endOnly     || preEnd),
                shouldRestrict = checkRestrict(target, this.prepared.name) && (!target.options[this.prepared.name].restrict.endOnly || preEnd);

            if (shouldSnap    ) { this.setSnapping   (coords); } else { this.snapStatus    .locked     = false; }
            if (shouldRestrict) { this.setRestriction(coords); } else { this.restrictStatus.restricted = false; }

            if (shouldSnap && this.snapStatus.locked && !this.snapStatus.changed) {
                shouldMove = shouldRestrict && this.restrictStatus.restricted && this.restrictStatus.changed;
            }
            else if (shouldRestrict && this.restrictStatus.restricted && !this.restrictStatus.changed) {
                shouldMove = false;
            }

            return shouldMove;
        },

        setStartOffsets: function (action, interactable, element) {
            var rect = interactable.getRect(element),
                origin = getOriginXY(interactable, element),
                snap = interactable.options[this.prepared.name].snap,
                restrict = interactable.options[this.prepared.name].restrict,
                width, height;

            if (rect) {
                this.startOffset.left = this.startCoords.page.x - rect.left;
                this.startOffset.top  = this.startCoords.page.y - rect.top;

                this.startOffset.right  = rect.right  - this.startCoords.page.x;
                this.startOffset.bottom = rect.bottom - this.startCoords.page.y;

                if ('width' in rect) { width = rect.width; }
                else { width = rect.right - rect.left; }
                if ('height' in rect) { height = rect.height; }
                else { height = rect.bottom - rect.top; }
            }
            else {
                this.startOffset.left = this.startOffset.top = this.startOffset.right = this.startOffset.bottom = 0;
            }

            this.snapOffsets.splice(0);

            var snapOffset = snap && snap.offset === 'startCoords'
                                ? {
                                    x: this.startCoords.page.x - origin.x,
                                    y: this.startCoords.page.y - origin.y
                                }
                                : snap && snap.offset || { x: 0, y: 0 };

            if (rect && snap && snap.relativePoints && snap.relativePoints.length) {
                for (var i = 0; i < snap.relativePoints.length; i++) {
                    this.snapOffsets.push({
                        x: this.startOffset.left - (width  * snap.relativePoints[i].x) + snapOffset.x,
                        y: this.startOffset.top  - (height * snap.relativePoints[i].y) + snapOffset.y
                    });
                }
            }
            else {
                this.snapOffsets.push(snapOffset);
            }

            if (rect && restrict.elementRect) {
                this.restrictOffset.left = this.startOffset.left - (width  * restrict.elementRect.left);
                this.restrictOffset.top  = this.startOffset.top  - (height * restrict.elementRect.top);

                this.restrictOffset.right  = this.startOffset.right  - (width  * (1 - restrict.elementRect.right));
                this.restrictOffset.bottom = this.startOffset.bottom - (height * (1 - restrict.elementRect.bottom));
            }
            else {
                this.restrictOffset.left = this.restrictOffset.top = this.restrictOffset.right = this.restrictOffset.bottom = 0;
            }
        },

        /*\
         * Interaction.start
         [ method ]
         *
         * Start an action with the given Interactable and Element as tartgets. The
         * action must be enabled for the target Interactable and an appropriate number
         * of pointers must be held down â€“ 1 for drag/resize, 2 for gesture.
         *
         * Use it with `interactable.<action>able({ manualStart: false })` to always
         * [start actions manually](https://github.com/taye/interact.js/issues/114)
         *
         - action       (object)  The action to be performed - drag, resize, etc.
         - interactable (Interactable) The Interactable to target
         - element      (Element) The DOM Element to target
         = (object) interact
         **
         | interact(target)
         |   .draggable({
         |     // disable the default drag start by down->move
         |     manualStart: true
         |   })
         |   // start dragging after the user holds the pointer down
         |   .on('hold', function (event) {
         |     var interaction = event.interaction;
         |
         |     if (!interaction.interacting()) {
         |       interaction.start({ name: 'drag' },
         |                         event.interactable,
         |                         event.currentTarget);
         |     }
         | });
        \*/
        start: function (action, interactable, element) {
            if (this.interacting()
                || !this.pointerIsDown
                || this.pointerIds.length < (action.name === 'gesture'? 2 : 1)) {
                return;
            }

            // if this interaction had been removed after stopping
            // add it back
            if (indexOf(interactions, this) === -1) {
                interactions.push(this);
            }

            // set the startCoords if there was no prepared action
            if (!this.prepared.name) {
                this.setEventXY(this.startCoords);
            }

            this.prepared.name  = action.name;
            this.prepared.axis  = action.axis;
            this.prepared.edges = action.edges;
            this.target         = interactable;
            this.element        = element;

            this.setStartOffsets(action.name, interactable, element);
            this.setModifications(this.startCoords.page);

            this.prevEvent = this[this.prepared.name + 'Start'](this.downEvent);
        },

        pointerMove: function (pointer, event, eventTarget, curEventTarget, preEnd) {
            if (this.inertiaStatus.active) {
                var pageUp   = this.inertiaStatus.upCoords.page;
                var clientUp = this.inertiaStatus.upCoords.client;

                var inertiaPosition = {
                    pageX  : pageUp.x   + this.inertiaStatus.sx,
                    pageY  : pageUp.y   + this.inertiaStatus.sy,
                    clientX: clientUp.x + this.inertiaStatus.sx,
                    clientY: clientUp.y + this.inertiaStatus.sy
                };

                this.setEventXY(this.curCoords, [inertiaPosition]);
            }
            else {
                this.recordPointer(pointer);
                this.setEventXY(this.curCoords, this.pointers);
            }

            var duplicateMove = (this.curCoords.page.x === this.prevCoords.page.x
                                 && this.curCoords.page.y === this.prevCoords.page.y
                                 && this.curCoords.client.x === this.prevCoords.client.x
                                 && this.curCoords.client.y === this.prevCoords.client.y);

            var dx, dy,
                pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));

            // register movement greater than pointerMoveTolerance
            if (this.pointerIsDown && !this.pointerWasMoved) {
                dx = this.curCoords.client.x - this.startCoords.client.x;
                dy = this.curCoords.client.y - this.startCoords.client.y;

                this.pointerWasMoved = hypot(dx, dy) > pointerMoveTolerance;
            }

            if (!duplicateMove && (!this.pointerIsDown || this.pointerWasMoved)) {
                if (this.pointerIsDown) {
                    clearTimeout(this.holdTimers[pointerIndex]);
                }

                this.collectEventTargets(pointer, event, eventTarget, 'move');
            }

            if (!this.pointerIsDown) { return; }

            if (duplicateMove && this.pointerWasMoved && !preEnd) {
                this.checkAndPreventDefault(event, this.target, this.element);
                return;
            }

            // set pointer coordinate, time changes and speeds
            setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);

            if (!this.prepared.name) { return; }

            if (this.pointerWasMoved
                // ignore movement while inertia is active
                && (!this.inertiaStatus.active || (pointer instanceof InteractEvent && /inertiastart/.test(pointer.type)))) {

                // if just starting an action, calculate the pointer speed now
                if (!this.interacting()) {
                    setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);

                    // check if a drag is in the correct axis
                    if (this.prepared.name === 'drag') {
                        var absX = Math.abs(dx),
                            absY = Math.abs(dy),
                            targetAxis = this.target.options.drag.axis,
                            axis = (absX > absY ? 'x' : absX < absY ? 'y' : 'xy');

                        // if the movement isn't in the axis of the interactable
                        if (axis !== 'xy' && targetAxis !== 'xy' && targetAxis !== axis) {
                            // cancel the prepared action
                            this.prepared.name = null;

                            // then try to get a drag from another ineractable

                            var element = eventTarget;

                            // check element interactables
                            while (isElement(element)) {
                                var elementInteractable = interactables.get(element);

                                if (elementInteractable
                                    && elementInteractable !== this.target
                                    && !elementInteractable.options.drag.manualStart
                                    && elementInteractable.getAction(this.downPointer, this.downEvent, this, element).name === 'drag'
                                    && checkAxis(axis, elementInteractable)) {

                                    this.prepared.name = 'drag';
                                    this.target = elementInteractable;
                                    this.element = element;
                                    break;
                                }

                                element = parentElement(element);
                            }

                            // if there's no drag from element interactables,
                            // check the selector interactables
                            if (!this.prepared.name) {
                                var thisInteraction = this;

                                var getDraggable = function (interactable, selector, context) {
                                    var elements = ie8MatchesSelector
                                        ? context.querySelectorAll(selector)
                                        : undefined;

                                    if (interactable === thisInteraction.target) { return; }

                                    if (inContext(interactable, eventTarget)
                                        && !interactable.options.drag.manualStart
                                        && !testIgnore(interactable, element, eventTarget)
                                        && testAllow(interactable, element, eventTarget)
                                        && matchesSelector(element, selector, elements)
                                        && interactable.getAction(thisInteraction.downPointer, thisInteraction.downEvent, thisInteraction, element).name === 'drag'
                                        && checkAxis(axis, interactable)
                                        && withinInteractionLimit(interactable, element, 'drag')) {

                                        return interactable;
                                    }
                                };

                                element = eventTarget;

                                while (isElement(element)) {
                                    var selectorInteractable = interactables.forEachSelector(getDraggable);

                                    if (selectorInteractable) {
                                        this.prepared.name = 'drag';
                                        this.target = selectorInteractable;
                                        this.element = element;
                                        break;
                                    }

                                    element = parentElement(element);
                                }
                            }
                        }
                    }
                }

                var starting = !!this.prepared.name && !this.interacting();

                if (starting
                    && (this.target.options[this.prepared.name].manualStart
                        || !withinInteractionLimit(this.target, this.element, this.prepared))) {
                    this.stop(event);
                    return;
                }

                if (this.prepared.name && this.target) {
                    if (starting) {
                        this.start(this.prepared, this.target, this.element);
                    }

                    var shouldMove = this.setModifications(this.curCoords.page, preEnd);

                    // move if snapping or restriction doesn't prevent it
                    if (shouldMove || starting) {
                        this.prevEvent = this[this.prepared.name + 'Move'](event);
                    }

                    this.checkAndPreventDefault(event, this.target, this.element);
                }
            }

            copyCoords(this.prevCoords, this.curCoords);

            if (this.dragging || this.resizing) {
                this.autoScrollMove(pointer);
            }
        },

        dragStart: function (event) {
            var dragEvent = new InteractEvent(this, event, 'drag', 'start', this.element);

            this.dragging = true;
            this.target.fire(dragEvent);

            // reset active dropzones
            this.activeDrops.dropzones = [];
            this.activeDrops.elements  = [];
            this.activeDrops.rects     = [];

            if (!this.dynamicDrop) {
                this.setActiveDrops(this.element);
            }

            var dropEvents = this.getDropEvents(event, dragEvent);

            if (dropEvents.activate) {
                this.fireActiveDrops(dropEvents.activate);
            }

            return dragEvent;
        },

        dragMove: function (event) {
            var target = this.target,
                dragEvent  = new InteractEvent(this, event, 'drag', 'move', this.element),
                draggableElement = this.element,
                drop = this.getDrop(dragEvent, event, draggableElement);

            this.dropTarget = drop.dropzone;
            this.dropElement = drop.element;

            var dropEvents = this.getDropEvents(event, dragEvent);

            target.fire(dragEvent);

            if (dropEvents.leave) { this.prevDropTarget.fire(dropEvents.leave); }
            if (dropEvents.enter) {     this.dropTarget.fire(dropEvents.enter); }
            if (dropEvents.move ) {     this.dropTarget.fire(dropEvents.move ); }

            this.prevDropTarget  = this.dropTarget;
            this.prevDropElement = this.dropElement;

            return dragEvent;
        },

        resizeStart: function (event) {
            var resizeEvent = new InteractEvent(this, event, 'resize', 'start', this.element);

            if (this.prepared.edges) {
                var startRect = this.target.getRect(this.element);

                /*
                 * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge
                 * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make
                 * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend
                 * on the active edges and the edge being interacted with.
                 */
                if (this.target.options.resize.square || this.target.options.resize.preserveAspectRatio) {
                    var linkedEdges = extend({}, this.prepared.edges);

                    linkedEdges.top    = linkedEdges.top    || (linkedEdges.left   && !linkedEdges.bottom);
                    linkedEdges.left   = linkedEdges.left   || (linkedEdges.top    && !linkedEdges.right );
                    linkedEdges.bottom = linkedEdges.bottom || (linkedEdges.right  && !linkedEdges.top   );
                    linkedEdges.right  = linkedEdges.right  || (linkedEdges.bottom && !linkedEdges.left  );

                    this.prepared._linkedEdges = linkedEdges;
                }
                else {
                    this.prepared._linkedEdges = null;
                }

                // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize
                if (this.target.options.resize.preserveAspectRatio) {
                    this.resizeStartAspectRatio = startRect.width / startRect.height;
                }

                this.resizeRects = {
                    start     : startRect,
                    current   : extend({}, startRect),
                    restricted: extend({}, startRect),
                    previous  : extend({}, startRect),
                    delta     : {
                        left: 0, right : 0, width : 0,
                        top : 0, bottom: 0, height: 0
                    }
                };

                resizeEvent.rect = this.resizeRects.restricted;
                resizeEvent.deltaRect = this.resizeRects.delta;
            }

            this.target.fire(resizeEvent);

            this.resizing = true;

            return resizeEvent;
        },

        resizeMove: function (event) {
            var resizeEvent = new InteractEvent(this, event, 'resize', 'move', this.element);

            var edges = this.prepared.edges,
                invert = this.target.options.resize.invert,
                invertible = invert === 'reposition' || invert === 'negate';

            if (edges) {
                var dx = resizeEvent.dx,
                    dy = resizeEvent.dy,

                    start      = this.resizeRects.start,
                    current    = this.resizeRects.current,
                    restricted = this.resizeRects.restricted,
                    delta      = this.resizeRects.delta,
                    previous   = extend(this.resizeRects.previous, restricted),

                    originalEdges = edges;

                // `resize.preserveAspectRatio` takes precedence over `resize.square`
                if (this.target.options.resize.preserveAspectRatio) {
                    var resizeStartAspectRatio = this.resizeStartAspectRatio;

                    edges = this.prepared._linkedEdges;

                    if ((originalEdges.left && originalEdges.bottom)
                        || (originalEdges.right && originalEdges.top)) {
                        dy = -dx / resizeStartAspectRatio;
                    }
                    else if (originalEdges.left || originalEdges.right) { dy = dx / resizeStartAspectRatio; }
                    else if (originalEdges.top || originalEdges.bottom) { dx = dy * resizeStartAspectRatio; }
                }
                else if (this.target.options.resize.square) {
                    edges = this.prepared._linkedEdges;

                    if ((originalEdges.left && originalEdges.bottom)
                        || (originalEdges.right && originalEdges.top)) {
                        dy = -dx;
                    }
                    else if (originalEdges.left || originalEdges.right) { dy = dx; }
                    else if (originalEdges.top || originalEdges.bottom) { dx = dy; }
                }

                // update the 'current' rect without modifications
                if (edges.top   ) { current.top    += dy; }
                if (edges.bottom) { current.bottom += dy; }
                if (edges.left  ) { current.left   += dx; }
                if (edges.right ) { current.right  += dx; }

                if (invertible) {
                    // if invertible, copy the current rect
                    extend(restricted, current);

                    if (invert === 'reposition') {
                        // swap edge values if necessary to keep width/height positive
                        var swap;

                        if (restricted.top > restricted.bottom) {
                            swap = restricted.top;

                            restricted.top = restricted.bottom;
                            restricted.bottom = swap;
                        }
                        if (restricted.left > restricted.right) {
                            swap = restricted.left;

                            restricted.left = restricted.right;
                            restricted.right = swap;
                        }
                    }
                }
                else {
                    // if not invertible, restrict to minimum of 0x0 rect
                    restricted.top    = Math.min(current.top, start.bottom);
                    restricted.bottom = Math.max(current.bottom, start.top);
                    restricted.left   = Math.min(current.left, start.right);
                    restricted.right  = Math.max(current.right, start.left);
                }

                restricted.width  = restricted.right  - restricted.left;
                restricted.height = restricted.bottom - restricted.top ;

                for (var edge in restricted) {
                    delta[edge] = restricted[edge] - previous[edge];
                }

                resizeEvent.edges = this.prepared.edges;
                resizeEvent.rect = restricted;
                resizeEvent.deltaRect = delta;
            }

            this.target.fire(resizeEvent);

            return resizeEvent;
        },

        gestureStart: function (event) {
            var gestureEvent = new InteractEvent(this, event, 'gesture', 'start', this.element);

            gestureEvent.ds = 0;

            this.gesture.startDistance = this.gesture.prevDistance = gestureEvent.distance;
            this.gesture.startAngle = this.gesture.prevAngle = gestureEvent.angle;
            this.gesture.scale = 1;

            this.gesturing = true;

            this.target.fire(gestureEvent);

            return gestureEvent;
        },

        gestureMove: function (event) {
            if (!this.pointerIds.length) {
                return this.prevEvent;
            }

            var gestureEvent;

            gestureEvent = new InteractEvent(this, event, 'gesture', 'move', this.element);
            gestureEvent.ds = gestureEvent.scale - this.gesture.scale;

            this.target.fire(gestureEvent);

            this.gesture.prevAngle = gestureEvent.angle;
            this.gesture.prevDistance = gestureEvent.distance;

            if (gestureEvent.scale !== Infinity &&
                gestureEvent.scale !== null &&
                gestureEvent.scale !== undefined  &&
                !isNaN(gestureEvent.scale)) {

                this.gesture.scale = gestureEvent.scale;
            }

            return gestureEvent;
        },

        pointerHold: function (pointer, event, eventTarget) {
            this.collectEventTargets(pointer, event, eventTarget, 'hold');
        },

        pointerUp: function (pointer, event, eventTarget, curEventTarget) {
            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));

            clearTimeout(this.holdTimers[pointerIndex]);

            this.collectEventTargets(pointer, event, eventTarget, 'up' );
            this.collectEventTargets(pointer, event, eventTarget, 'tap');

            this.pointerEnd(pointer, event, eventTarget, curEventTarget);

            this.removePointer(pointer);
        },

        pointerCancel: function (pointer, event, eventTarget, curEventTarget) {
            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));

            clearTimeout(this.holdTimers[pointerIndex]);

            this.collectEventTargets(pointer, event, eventTarget, 'cancel');
            this.pointerEnd(pointer, event, eventTarget, curEventTarget);

            this.removePointer(pointer);
        },

        // http://www.quirksmode.org/dom/events/click.html
        // >Events leading to dblclick
        //
        // IE8 doesn't fire down event before dblclick.
        // This workaround tries to fire a tap and doubletap after dblclick
        ie8Dblclick: function (pointer, event, eventTarget) {
            if (this.prevTap
                && event.clientX === this.prevTap.clientX
                && event.clientY === this.prevTap.clientY
                && eventTarget   === this.prevTap.target) {

                this.downTargets[0] = eventTarget;
                this.downTimes[0] = new Date().getTime();
                this.collectEventTargets(pointer, event, eventTarget, 'tap');
            }
        },

        // End interact move events and stop auto-scroll unless inertia is enabled
        pointerEnd: function (pointer, event, eventTarget, curEventTarget) {
            var endEvent,
                target = this.target,
                options = target && target.options,
                inertiaOptions = options && this.prepared.name && options[this.prepared.name].inertia,
                inertiaStatus = this.inertiaStatus;

            if (this.interacting()) {

                if (inertiaStatus.active && !inertiaStatus.ending) { return; }

                var pointerSpeed,
                    now = new Date().getTime(),
                    inertiaPossible = false,
                    inertia = false,
                    smoothEnd = false,
                    endSnap = checkSnap(target, this.prepared.name) && options[this.prepared.name].snap.endOnly,
                    endRestrict = checkRestrict(target, this.prepared.name) && options[this.prepared.name].restrict.endOnly,
                    dx = 0,
                    dy = 0,
                    startEvent;

                if (this.dragging) {
                    if      (options.drag.axis === 'x' ) { pointerSpeed = Math.abs(this.pointerDelta.client.vx); }
                    else if (options.drag.axis === 'y' ) { pointerSpeed = Math.abs(this.pointerDelta.client.vy); }
                    else   /*options.drag.axis === 'xy'*/{ pointerSpeed = this.pointerDelta.client.speed; }
                }
                else {
                    pointerSpeed = this.pointerDelta.client.speed;
                }

                // check if inertia should be started
                inertiaPossible = (inertiaOptions && inertiaOptions.enabled
                                   && this.prepared.name !== 'gesture'
                                   && event !== inertiaStatus.startEvent);

                inertia = (inertiaPossible
                           && (now - this.curCoords.timeStamp) < 50
                           && pointerSpeed > inertiaOptions.minSpeed
                           && pointerSpeed > inertiaOptions.endSpeed);

                if (inertiaPossible && !inertia && (endSnap || endRestrict)) {

                    var snapRestrict = {};

                    snapRestrict.snap = snapRestrict.restrict = snapRestrict;

                    if (endSnap) {
                        this.setSnapping(this.curCoords.page, snapRestrict);
                        if (snapRestrict.locked) {
                            dx += snapRestrict.dx;
                            dy += snapRestrict.dy;
                        }
                    }

                    if (endRestrict) {
                        this.setRestriction(this.curCoords.page, snapRestrict);
                        if (snapRestrict.restricted) {
                            dx += snapRestrict.dx;
                            dy += snapRestrict.dy;
                        }
                    }

                    if (dx || dy) {
                        smoothEnd = true;
                    }
                }

                if (inertia || smoothEnd) {
                    copyCoords(inertiaStatus.upCoords, this.curCoords);

                    this.pointers[0] = inertiaStatus.startEvent = startEvent =
                        new InteractEvent(this, event, this.prepared.name, 'inertiastart', this.element);

                    inertiaStatus.t0 = now;

                    target.fire(inertiaStatus.startEvent);

                    if (inertia) {
                        inertiaStatus.vx0 = this.pointerDelta.client.vx;
                        inertiaStatus.vy0 = this.pointerDelta.client.vy;
                        inertiaStatus.v0 = pointerSpeed;

                        this.calcInertia(inertiaStatus);

                        var page = extend({}, this.curCoords.page),
                            origin = getOriginXY(target, this.element),
                            statusObject;

                        page.x = page.x + inertiaStatus.xe - origin.x;
                        page.y = page.y + inertiaStatus.ye - origin.y;

                        statusObject = {
                            useStatusXY: true,
                            x: page.x,
                            y: page.y,
                            dx: 0,
                            dy: 0,
                            snap: null
                        };

                        statusObject.snap = statusObject;

                        dx = dy = 0;

                        if (endSnap) {
                            var snap = this.setSnapping(this.curCoords.page, statusObject);

                            if (snap.locked) {
                                dx += snap.dx;
                                dy += snap.dy;
                            }
                        }

                        if (endRestrict) {
                            var restrict = this.setRestriction(this.curCoords.page, statusObject);

                            if (restrict.restricted) {
                                dx += restrict.dx;
                                dy += restrict.dy;
                            }
                        }

                        inertiaStatus.modifiedXe += dx;
                        inertiaStatus.modifiedYe += dy;

                        inertiaStatus.i = reqFrame(this.boundInertiaFrame);
                    }
                    else {
                        inertiaStatus.smoothEnd = true;
                        inertiaStatus.xe = dx;
                        inertiaStatus.ye = dy;

                        inertiaStatus.sx = inertiaStatus.sy = 0;

                        inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);
                    }

                    inertiaStatus.active = true;
                    return;
                }

                if (endSnap || endRestrict) {
                    // fire a move event at the snapped coordinates
                    this.pointerMove(pointer, event, eventTarget, curEventTarget, true);
                }
            }

            if (this.dragging) {
                endEvent = new InteractEvent(this, event, 'drag', 'end', this.element);

                var draggableElement = this.element,
                    drop = this.getDrop(endEvent, event, draggableElement);

                this.dropTarget = drop.dropzone;
                this.dropElement = drop.element;

                var dropEvents = this.getDropEvents(event, endEvent);

                if (dropEvents.leave) { this.prevDropTarget.fire(dropEvents.leave); }
                if (dropEvents.enter) {     this.dropTarget.fire(dropEvents.enter); }
                if (dropEvents.drop ) {     this.dropTarget.fire(dropEvents.drop ); }
                if (dropEvents.deactivate) {
                    this.fireActiveDrops(dropEvents.deactivate);
                }

                target.fire(endEvent);
            }
            else if (this.resizing) {
                endEvent = new InteractEvent(this, event, 'resize', 'end', this.element);
                target.fire(endEvent);
            }
            else if (this.gesturing) {
                endEvent = new InteractEvent(this, event, 'gesture', 'end', this.element);
                target.fire(endEvent);
            }

            this.stop(event);
        },

        collectDrops: function (element) {
            var drops = [],
                elements = [],
                i;

            element = element || this.element;

            // collect all dropzones and their elements which qualify for a drop
            for (i = 0; i < interactables.length; i++) {
                if (!interactables[i].options.drop.enabled) { continue; }

                var current = interactables[i],
                    accept = current.options.drop.accept;

                // test the draggable element against the dropzone's accept setting
                if ((isElement(accept) && accept !== element)
                    || (isString(accept)
                        && !matchesSelector(element, accept))) {

                    continue;
                }

                // query for new elements if necessary
                var dropElements = current.selector? current._context.querySelectorAll(current.selector) : [current._element];

                for (var j = 0, len = dropElements.length; j < len; j++) {
                    var currentElement = dropElements[j];

                    if (currentElement === element) {
                        continue;
                    }

                    drops.push(current);
                    elements.push(currentElement);
                }
            }

            return {
                dropzones: drops,
                elements: elements
            };
        },

        fireActiveDrops: function (event) {
            var i,
                current,
                currentElement,
                prevElement;

            // loop through all active dropzones and trigger event
            for (i = 0; i < this.activeDrops.dropzones.length; i++) {
                current = this.activeDrops.dropzones[i];
                currentElement = this.activeDrops.elements [i];

                // prevent trigger of duplicate events on same element
                if (currentElement !== prevElement) {
                    // set current element as event target
                    event.target = currentElement;
                    current.fire(event);
                }
                prevElement = currentElement;
            }
        },

        // Collect a new set of possible drops and save them in activeDrops.
        // setActiveDrops should always be called when a drag has just started or a
        // drag event happens while dynamicDrop is true
        setActiveDrops: function (dragElement) {
            // get dropzones and their elements that could receive the draggable
            var possibleDrops = this.collectDrops(dragElement, true);

            this.activeDrops.dropzones = possibleDrops.dropzones;
            this.activeDrops.elements  = possibleDrops.elements;
            this.activeDrops.rects     = [];

            for (var i = 0; i < this.activeDrops.dropzones.length; i++) {
                this.activeDrops.rects[i] = this.activeDrops.dropzones[i].getRect(this.activeDrops.elements[i]);
            }
        },

        getDrop: function (dragEvent, event, dragElement) {
            var validDrops = [];

            if (dynamicDrop) {
                this.setActiveDrops(dragElement);
            }

            // collect all dropzones and their elements which qualify for a drop
            for (var j = 0; j < this.activeDrops.dropzones.length; j++) {
                var current        = this.activeDrops.dropzones[j],
                    currentElement = this.activeDrops.elements [j],
                    rect           = this.activeDrops.rects    [j];

                validDrops.push(current.dropCheck(dragEvent, event, this.target, dragElement, currentElement, rect)
                                ? currentElement
                                : null);
            }

            // get the most appropriate dropzone based on DOM depth and order
            var dropIndex = indexOfDeepestElement(validDrops),
                dropzone  = this.activeDrops.dropzones[dropIndex] || null,
                element   = this.activeDrops.elements [dropIndex] || null;

            return {
                dropzone: dropzone,
                element: element
            };
        },

        getDropEvents: function (pointerEvent, dragEvent) {
            var dropEvents = {
                enter     : null,
                leave     : null,
                activate  : null,
                deactivate: null,
                move      : null,
                drop      : null
            };

            if (this.dropElement !== this.prevDropElement) {
                // if there was a prevDropTarget, create a dragleave event
                if (this.prevDropTarget) {
                    dropEvents.leave = {
                        target       : this.prevDropElement,
                        dropzone     : this.prevDropTarget,
                        relatedTarget: dragEvent.target,
                        draggable    : dragEvent.interactable,
                        dragEvent    : dragEvent,
                        interaction  : this,
                        timeStamp    : dragEvent.timeStamp,
                        type         : 'dragleave'
                    };

                    dragEvent.dragLeave = this.prevDropElement;
                    dragEvent.prevDropzone = this.prevDropTarget;
                }
                // if the dropTarget is not null, create a dragenter event
                if (this.dropTarget) {
                    dropEvents.enter = {
                        target       : this.dropElement,
                        dropzone     : this.dropTarget,
                        relatedTarget: dragEvent.target,
                        draggable    : dragEvent.interactable,
                        dragEvent    : dragEvent,
                        interaction  : this,
                        timeStamp    : dragEvent.timeStamp,
                        type         : 'dragenter'
                    };

                    dragEvent.dragEnter = this.dropElement;
                    dragEvent.dropzone = this.dropTarget;
                }
            }

            if (dragEvent.type === 'dragend' && this.dropTarget) {
                dropEvents.drop = {
                    target       : this.dropElement,
                    dropzone     : this.dropTarget,
                    relatedTarget: dragEvent.target,
                    draggable    : dragEvent.interactable,
                    dragEvent    : dragEvent,
                    interaction  : this,
                    timeStamp    : dragEvent.timeStamp,
                    type         : 'drop'
                };

                dragEvent.dropzone = this.dropTarget;
            }
            if (dragEvent.type === 'dragstart') {
                dropEvents.activate = {
                    target       : null,
                    dropzone     : null,
                    relatedTarget: dragEvent.target,
                    draggable    : dragEvent.interactable,
                    dragEvent    : dragEvent,
                    interaction  : this,
                    timeStamp    : dragEvent.timeStamp,
                    type         : 'dropactivate'
                };
            }
            if (dragEvent.type === 'dragend') {
                dropEvents.deactivate = {
                    target       : null,
                    dropzone     : null,
                    relatedTarget: dragEvent.target,
                    draggable    : dragEvent.interactable,
                    dragEvent    : dragEvent,
                    interaction  : this,
                    timeStamp    : dragEvent.timeStamp,
                    type         : 'dropdeactivate'
                };
            }
            if (dragEvent.type === 'dragmove' && this.dropTarget) {
                dropEvents.move = {
                    target       : this.dropElement,
                    dropzone     : this.dropTarget,
                    relatedTarget: dragEvent.target,
                    draggable    : dragEvent.interactable,
                    dragEvent    : dragEvent,
                    interaction  : this,
                    dragmove     : dragEvent,
                    timeStamp    : dragEvent.timeStamp,
                    type         : 'dropmove'
                };
                dragEvent.dropzone = this.dropTarget;
            }

            return dropEvents;
        },

        currentAction: function () {
            return (this.dragging && 'drag') || (this.resizing && 'resize') || (this.gesturing && 'gesture') || null;
        },

        interacting: function () {
            return this.dragging || this.resizing || this.gesturing;
        },

        clearTargets: function () {
            this.target = this.element = null;

            this.dropTarget = this.dropElement = this.prevDropTarget = this.prevDropElement = null;
        },

        stop: function (event) {
            if (this.interacting()) {
                autoScroll.stop();
                this.matches = [];
                this.matchElements = [];

                var target = this.target;

                if (target.options.styleCursor) {
                    target._doc.documentElement.style.cursor = '';
                }

                // prevent Default only if were previously interacting
                if (event && isFunction(event.preventDefault)) {
                    this.checkAndPreventDefault(event, target, this.element);
                }

                if (this.dragging) {
                    this.activeDrops.dropzones = this.activeDrops.elements = this.activeDrops.rects = null;
                }
            }

            this.clearTargets();

            this.pointerIsDown = this.snapStatus.locked = this.dragging = this.resizing = this.gesturing = false;
            this.prepared.name = this.prevEvent = null;
            this.inertiaStatus.resumeDx = this.inertiaStatus.resumeDy = 0;

            // remove pointers if their ID isn't in this.pointerIds
            for (var i = 0; i < this.pointers.length; i++) {
                if (indexOf(this.pointerIds, getPointerId(this.pointers[i])) === -1) {
                    this.pointers.splice(i, 1);
                }
            }
        },

        inertiaFrame: function () {
            var inertiaStatus = this.inertiaStatus,
                options = this.target.options[this.prepared.name].inertia,
                lambda = options.resistance,
                t = new Date().getTime() / 1000 - inertiaStatus.t0;

            if (t < inertiaStatus.te) {

                var progress =  1 - (Math.exp(-lambda * t) - inertiaStatus.lambda_v0) / inertiaStatus.one_ve_v0;

                if (inertiaStatus.modifiedXe === inertiaStatus.xe && inertiaStatus.modifiedYe === inertiaStatus.ye) {
                    inertiaStatus.sx = inertiaStatus.xe * progress;
                    inertiaStatus.sy = inertiaStatus.ye * progress;
                }
                else {
                    var quadPoint = getQuadraticCurvePoint(
                            0, 0,
                            inertiaStatus.xe, inertiaStatus.ye,
                            inertiaStatus.modifiedXe, inertiaStatus.modifiedYe,
                            progress);

                    inertiaStatus.sx = quadPoint.x;
                    inertiaStatus.sy = quadPoint.y;
                }

                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);

                inertiaStatus.i = reqFrame(this.boundInertiaFrame);
            }
            else {
                inertiaStatus.ending = true;

                inertiaStatus.sx = inertiaStatus.modifiedXe;
                inertiaStatus.sy = inertiaStatus.modifiedYe;

                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);
                this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);

                inertiaStatus.active = inertiaStatus.ending = false;
            }
        },

        smoothEndFrame: function () {
            var inertiaStatus = this.inertiaStatus,
                t = new Date().getTime() - inertiaStatus.t0,
                duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;

            if (t < duration) {
                inertiaStatus.sx = easeOutQuad(t, 0, inertiaStatus.xe, duration);
                inertiaStatus.sy = easeOutQuad(t, 0, inertiaStatus.ye, duration);

                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);

                inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);
            }
            else {
                inertiaStatus.ending = true;

                inertiaStatus.sx = inertiaStatus.xe;
                inertiaStatus.sy = inertiaStatus.ye;

                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);
                this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);

                inertiaStatus.smoothEnd =
                  inertiaStatus.active = inertiaStatus.ending = false;
            }
        },

        addPointer: function (pointer) {
            var id = getPointerId(pointer),
                index = this.mouse? 0 : indexOf(this.pointerIds, id);

            if (index === -1) {
                index = this.pointerIds.length;
            }

            this.pointerIds[index] = id;
            this.pointers[index] = pointer;

            return index;
        },

        removePointer: function (pointer) {
            var id = getPointerId(pointer),
                index = this.mouse? 0 : indexOf(this.pointerIds, id);

            if (index === -1) { return; }

            this.pointers   .splice(index, 1);
            this.pointerIds .splice(index, 1);
            this.downTargets.splice(index, 1);
            this.downTimes  .splice(index, 1);
            this.holdTimers .splice(index, 1);
        },

        recordPointer: function (pointer) {
            var index = this.mouse? 0: indexOf(this.pointerIds, getPointerId(pointer));

            if (index === -1) { return; }

            this.pointers[index] = pointer;
        },

        collectEventTargets: function (pointer, event, eventTarget, eventType) {
            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));

            // do not fire a tap event if the pointer was moved before being lifted
            if (eventType === 'tap' && (this.pointerWasMoved
                // or if the pointerup target is different to the pointerdown target
                || !(this.downTargets[pointerIndex] && this.downTargets[pointerIndex] === eventTarget))) {
                return;
            }

            var targets = [],
                elements = [],
                element = eventTarget;

            function collectSelectors (interactable, selector, context) {
                var els = ie8MatchesSelector
                        ? context.querySelectorAll(selector)
                        : undefined;

                if (interactable._iEvents[eventType]
                    && isElement(element)
                    && inContext(interactable, element)
                    && !testIgnore(interactable, element, eventTarget)
                    && testAllow(interactable, element, eventTarget)
                    && matchesSelector(element, selector, els)) {

                    targets.push(interactable);
                    elements.push(element);
                }
            }

            while (element) {
                if (interact.isSet(element) && interact(element)._iEvents[eventType]) {
                    targets.push(interact(element));
                    elements.push(element);
                }

                interactables.forEachSelector(collectSelectors);

                element = parentElement(element);
            }

            // create the tap event even if there are no listeners so that
            // doubletap can still be created and fired
            if (targets.length || eventType === 'tap') {
                this.firePointers(pointer, event, eventTarget, targets, elements, eventType);
            }
        },

        firePointers: function (pointer, event, eventTarget, targets, elements, eventType) {
            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer)),
                pointerEvent = {},
                i,
                // for tap events
                interval, createNewDoubleTap;

            // if it's a doubletap then the event properties would have been
            // copied from the tap event and provided as the pointer argument
            if (eventType === 'doubletap') {
                pointerEvent = pointer;
            }
            else {
                pointerExtend(pointerEvent, event);
                if (event !== pointer) {
                    pointerExtend(pointerEvent, pointer);
                }

                pointerEvent.preventDefault           = preventOriginalDefault;
                pointerEvent.stopPropagation          = InteractEvent.prototype.stopPropagation;
                pointerEvent.stopImmediatePropagation = InteractEvent.prototype.stopImmediatePropagation;
                pointerEvent.interaction              = this;

                pointerEvent.timeStamp       = new Date().getTime();
                pointerEvent.originalEvent   = event;
                pointerEvent.originalPointer = pointer;
                pointerEvent.type            = eventType;
                pointerEvent.pointerId       = getPointerId(pointer);
                pointerEvent.pointerType     = this.mouse? 'mouse' : !supportsPointerEvent? 'touch'
                                                    : isString(pointer.pointerType)
                                                        ? pointer.pointerType
                                                        : [,,'touch', 'pen', 'mouse'][pointer.pointerType];
            }

            if (eventType === 'tap') {
                pointerEvent.dt = pointerEvent.timeStamp - this.downTimes[pointerIndex];

                interval = pointerEvent.timeStamp - this.tapTime;
                createNewDoubleTap = !!(this.prevTap && this.prevTap.type !== 'doubletap'
                       && this.prevTap.target === pointerEvent.target
                       && interval < 500);

                pointerEvent.double = createNewDoubleTap;

                this.tapTime = pointerEvent.timeStamp;
            }

            for (i = 0; i < targets.length; i++) {
                pointerEvent.currentTarget = elements[i];
                pointerEvent.interactable = targets[i];
                targets[i].fire(pointerEvent);

                if (pointerEvent.immediatePropagationStopped
                    ||(pointerEvent.propagationStopped && elements[i + 1] !== pointerEvent.currentTarget)) {
                    break;
                }
            }

            if (createNewDoubleTap) {
                var doubleTap = {};

                extend(doubleTap, pointerEvent);

                doubleTap.dt   = interval;
                doubleTap.type = 'doubletap';

                this.collectEventTargets(doubleTap, event, eventTarget, 'doubletap');

                this.prevTap = doubleTap;
            }
            else if (eventType === 'tap') {
                this.prevTap = pointerEvent;
            }
        },

        validateSelector: function (pointer, event, matches, matchElements) {
            for (var i = 0, len = matches.length; i < len; i++) {
                var match = matches[i],
                    matchElement = matchElements[i],
                    action = validateAction(match.getAction(pointer, event, this, matchElement), match);

                if (action && withinInteractionLimit(match, matchElement, action)) {
                    this.target = match;
                    this.element = matchElement;

                    return action;
                }
            }
        },

        setSnapping: function (pageCoords, status) {
            var snap = this.target.options[this.prepared.name].snap,
                targets = [],
                target,
                page,
                i;

            status = status || this.snapStatus;

            if (status.useStatusXY) {
                page = { x: status.x, y: status.y };
            }
            else {
                var origin = getOriginXY(this.target, this.element);

                page = extend({}, pageCoords);

                page.x -= origin.x;
                page.y -= origin.y;
            }

            status.realX = page.x;
            status.realY = page.y;

            page.x = page.x - this.inertiaStatus.resumeDx;
            page.y = page.y - this.inertiaStatus.resumeDy;

            var len = snap.targets? snap.targets.length : 0;

            for (var relIndex = 0; relIndex < this.snapOffsets.length; relIndex++) {
                var relative = {
                    x: page.x - this.snapOffsets[relIndex].x,
                    y: page.y - this.snapOffsets[relIndex].y
                };

                for (i = 0; i < len; i++) {
                    if (isFunction(snap.targets[i])) {
                        target = snap.targets[i](relative.x, relative.y, this);
                    }
                    else {
                        target = snap.targets[i];
                    }

                    if (!target) { continue; }

                    targets.push({
                        x: isNumber(target.x) ? (target.x + this.snapOffsets[relIndex].x) : relative.x,
                        y: isNumber(target.y) ? (target.y + this.snapOffsets[relIndex].y) : relative.y,

                        range: isNumber(target.range)? target.range: snap.range
                    });
                }
            }

            var closest = {
                    target: null,
                    inRange: false,
                    distance: 0,
                    range: 0,
                    dx: 0,
                    dy: 0
                };

            for (i = 0, len = targets.length; i < len; i++) {
                target = targets[i];

                var range = target.range,
                    dx = target.x - page.x,
                    dy = target.y - page.y,
                    distance = hypot(dx, dy),
                    inRange = distance <= range;

                // Infinite targets count as being out of range
                // compared to non infinite ones that are in range
                if (range === Infinity && closest.inRange && closest.range !== Infinity) {
                    inRange = false;
                }

                if (!closest.target || (inRange
                    // is the closest target in range?
                    ? (closest.inRange && range !== Infinity
                        // the pointer is relatively deeper in this target
                        ? distance / range < closest.distance / closest.range
                        // this target has Infinite range and the closest doesn't
                        : (range === Infinity && closest.range !== Infinity)
                            // OR this target is closer that the previous closest
                            || distance < closest.distance)
                    // The other is not in range and the pointer is closer to this target
                    : (!closest.inRange && distance < closest.distance))) {

                    if (range === Infinity) {
                        inRange = true;
                    }

                    closest.target = target;
                    closest.distance = distance;
                    closest.range = range;
                    closest.inRange = inRange;
                    closest.dx = dx;
                    closest.dy = dy;

                    status.range = range;
                }
            }

            var snapChanged;

            if (closest.target) {
                snapChanged = (status.snappedX !== closest.target.x || status.snappedY !== closest.target.y);

                status.snappedX = closest.target.x;
                status.snappedY = closest.target.y;
            }
            else {
                snapChanged = true;

                status.snappedX = NaN;
                status.snappedY = NaN;
            }

            status.dx = closest.dx;
            status.dy = closest.dy;

            status.changed = (snapChanged || (closest.inRange && !status.locked));
            status.locked = closest.inRange;

            return status;
        },

        setRestriction: function (pageCoords, status) {
            var target = this.target,
                restrict = target && target.options[this.prepared.name].restrict,
                restriction = restrict && restrict.restriction,
                page;

            if (!restriction) {
                return status;
            }

            status = status || this.restrictStatus;

            page = status.useStatusXY
                    ? page = { x: status.x, y: status.y }
                    : page = extend({}, pageCoords);

            if (status.snap && status.snap.locked) {
                page.x += status.snap.dx || 0;
                page.y += status.snap.dy || 0;
            }

            page.x -= this.inertiaStatus.resumeDx;
            page.y -= this.inertiaStatus.resumeDy;

            status.dx = 0;
            status.dy = 0;
            status.restricted = false;

            var rect, restrictedX, restrictedY;

            if (isString(restriction)) {
                if (restriction === 'parent') {
                    restriction = parentElement(this.element);
                }
                else if (restriction === 'self') {
                    restriction = target.getRect(this.element);
                }
                else {
                    restriction = closest(this.element, restriction);
                }

                if (!restriction) { return status; }
            }

            if (isFunction(restriction)) {
                restriction = restriction(page.x, page.y, this.element);
            }

            if (isElement(restriction)) {
                restriction = getElementRect(restriction);
            }

            rect = restriction;

            if (!restriction) {
                restrictedX = page.x;
                restrictedY = page.y;
            }
            // object is assumed to have
            // x, y, width, height or
            // left, top, right, bottom
            else if ('x' in restriction && 'y' in restriction) {
                restrictedX = Math.max(Math.min(rect.x + rect.width  - this.restrictOffset.right , page.x), rect.x + this.restrictOffset.left);
                restrictedY = Math.max(Math.min(rect.y + rect.height - this.restrictOffset.bottom, page.y), rect.y + this.restrictOffset.top );
            }
            else {
                restrictedX = Math.max(Math.min(rect.right  - this.restrictOffset.right , page.x), rect.left + this.restrictOffset.left);
                restrictedY = Math.max(Math.min(rect.bottom - this.restrictOffset.bottom, page.y), rect.top  + this.restrictOffset.top );
            }

            status.dx = restrictedX - page.x;
            status.dy = restrictedY - page.y;

            status.changed = status.restrictedX !== restrictedX || status.restrictedY !== restrictedY;
            status.restricted = !!(status.dx || status.dy);

            status.restrictedX = restrictedX;
            status.restrictedY = restrictedY;

            return status;
        },

        checkAndPreventDefault: function (event, interactable, element) {
            if (!(interactable = interactable || this.target)) { return; }

            var options = interactable.options,
                prevent = options.preventDefault;

            if (prevent === 'auto' && element && !/^(input|select|textarea)$/i.test(event.target.nodeName)) {
                // do not preventDefault on pointerdown if the prepared action is a drag
                // and dragging can only start from a certain direction - this allows
                // a touch to pan the viewport if a drag isn't in the right direction
                if (/down|start/i.test(event.type)
                    && this.prepared.name === 'drag' && options.drag.axis !== 'xy') {

                    return;
                }

                // with manualStart, only preventDefault while interacting
                if (options[this.prepared.name] && options[this.prepared.name].manualStart
                    && !this.interacting()) {
                    return;
                }

                event.preventDefault();
                return;
            }

            if (prevent === 'always') {
                event.preventDefault();
                return;
            }
        },

        calcInertia: function (status) {
            var inertiaOptions = this.target.options[this.prepared.name].inertia,
                lambda = inertiaOptions.resistance,
                inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;

            status.x0 = this.prevEvent.pageX;
            status.y0 = this.prevEvent.pageY;
            status.t0 = status.startEvent.timeStamp / 1000;
            status.sx = status.sy = 0;

            status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;
            status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;
            status.te = inertiaDur;

            status.lambda_v0 = lambda / status.v0;
            status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;
        },

        autoScrollMove: function (pointer) {
            if (!(this.interacting()
                && checkAutoScroll(this.target, this.prepared.name))) {
                return;
            }

            if (this.inertiaStatus.active) {
                autoScroll.x = autoScroll.y = 0;
                return;
            }

            var top,
                right,
                bottom,
                left,
                options = this.target.options[this.prepared.name].autoScroll,
                container = options.container || getWindow(this.element);

            if (isWindow(container)) {
                left   = pointer.clientX < autoScroll.margin;
                top    = pointer.clientY < autoScroll.margin;
                right  = pointer.clientX > container.innerWidth  - autoScroll.margin;
                bottom = pointer.clientY > container.innerHeight - autoScroll.margin;
            }
            else {
                var rect = getElementClientRect(container);

                left   = pointer.clientX < rect.left   + autoScroll.margin;
                top    = pointer.clientY < rect.top    + autoScroll.margin;
                right  = pointer.clientX > rect.right  - autoScroll.margin;
                bottom = pointer.clientY > rect.bottom - autoScroll.margin;
            }

            autoScroll.x = (right ? 1: left? -1: 0);
            autoScroll.y = (bottom? 1:  top? -1: 0);

            if (!autoScroll.isScrolling) {
                // set the autoScroll properties to those of the target
                autoScroll.margin = options.margin;
                autoScroll.speed  = options.speed;

                autoScroll.start(this);
            }
        },

        _updateEventTargets: function (target, currentTarget) {
            this._eventTarget    = target;
            this._curEventTarget = currentTarget;
        }

    };

    function getInteractionFromPointer (pointer, eventType, eventTarget) {
        var i = 0, len = interactions.length,
            mouseEvent = (/mouse/i.test(pointer.pointerType || eventType)
                          // MSPointerEvent.MSPOINTER_TYPE_MOUSE
                          || pointer.pointerType === 4),
            interaction;

        var id = getPointerId(pointer);

        // try to resume inertia with a new pointer
        if (/down|start/i.test(eventType)) {
            for (i = 0; i < len; i++) {
                interaction = interactions[i];

                var element = eventTarget;

                if (interaction.inertiaStatus.active && interaction.target.options[interaction.prepared.name].inertia.allowResume
                    && (interaction.mouse === mouseEvent)) {
                    while (element) {
                        // if the element is the interaction element
                        if (element === interaction.element) {
                            return interaction;
                        }
                        element = parentElement(element);
                    }
                }
            }
        }

        // if it's a mouse interaction
        if (mouseEvent || !(supportsTouch || supportsPointerEvent)) {

            // find a mouse interaction that's not in inertia phase
            for (i = 0; i < len; i++) {
                if (interactions[i].mouse && !interactions[i].inertiaStatus.active) {
                    return interactions[i];
                }
            }

            // find any interaction specifically for mouse.
            // if the eventType is a mousedown, and inertia is active
            // ignore the interaction
            for (i = 0; i < len; i++) {
                if (interactions[i].mouse && !(/down/.test(eventType) && interactions[i].inertiaStatus.active)) {
                    return interaction;
                }
            }

            // create a new interaction for mouse
            interaction = new Interaction();
            interaction.mouse = true;

            return interaction;
        }

        // get interaction that has this pointer
        for (i = 0; i < len; i++) {
            if (contains(interactions[i].pointerIds, id)) {
                return interactions[i];
            }
        }

        // at this stage, a pointerUp should not return an interaction
        if (/up|end|out/i.test(eventType)) {
            return null;
        }

        // get first idle interaction
        for (i = 0; i < len; i++) {
            interaction = interactions[i];

            if ((!interaction.prepared.name || (interaction.target.options.gesture.enabled))
                && !interaction.interacting()
                && !(!mouseEvent && interaction.mouse)) {

                return interaction;
            }
        }

        return new Interaction();
    }

    function doOnInteractions (method) {
        return (function (event) {
            var interaction,
                eventTarget = getActualElement(event.path
                                               ? event.path[0]
                                               : event.target),
                curEventTarget = getActualElement(event.currentTarget),
                i;

            if (supportsTouch && /touch/.test(event.type)) {
                prevTouchTime = new Date().getTime();

                for (i = 0; i < event.changedTouches.length; i++) {
                    var pointer = event.changedTouches[i];

                    interaction = getInteractionFromPointer(pointer, event.type, eventTarget);

                    if (!interaction) { continue; }

                    interaction._updateEventTargets(eventTarget, curEventTarget);

                    interaction[method](pointer, event, eventTarget, curEventTarget);
                }
            }
            else {
                if (!supportsPointerEvent && /mouse/.test(event.type)) {
                    // ignore mouse events while touch interactions are active
                    for (i = 0; i < interactions.length; i++) {
                        if (!interactions[i].mouse && interactions[i].pointerIsDown) {
                            return;
                        }
                    }

                    // try to ignore mouse events that are simulated by the browser
                    // after a touch event
                    if (new Date().getTime() - prevTouchTime < 500) {
                        return;
                    }
                }

                interaction = getInteractionFromPointer(event, event.type, eventTarget);

                if (!interaction) { return; }

                interaction._updateEventTargets(eventTarget, curEventTarget);

                interaction[method](event, event, eventTarget, curEventTarget);
            }
        });
    }

    function InteractEvent (interaction, event, action, phase, element, related) {
        var client,
            page,
            target      = interaction.target,
            snapStatus  = interaction.snapStatus,
            restrictStatus  = interaction.restrictStatus,
            pointers    = interaction.pointers,
            deltaSource = (target && target.options || defaultOptions).deltaSource,
            sourceX     = deltaSource + 'X',
            sourceY     = deltaSource + 'Y',
            options     = target? target.options: defaultOptions,
            origin      = getOriginXY(target, element),
            starting    = phase === 'start',
            ending      = phase === 'end',
            coords      = starting? interaction.startCoords : interaction.curCoords;

        element = element || interaction.element;

        page   = extend({}, coords.page);
        client = extend({}, coords.client);

        page.x -= origin.x;
        page.y -= origin.y;

        client.x -= origin.x;
        client.y -= origin.y;

        var relativePoints = options[action].snap && options[action].snap.relativePoints ;

        if (checkSnap(target, action) && !(starting && relativePoints && relativePoints.length)) {
            this.snap = {
                range  : snapStatus.range,
                locked : snapStatus.locked,
                x      : snapStatus.snappedX,
                y      : snapStatus.snappedY,
                realX  : snapStatus.realX,
                realY  : snapStatus.realY,
                dx     : snapStatus.dx,
                dy     : snapStatus.dy
            };

            if (snapStatus.locked) {
                page.x += snapStatus.dx;
                page.y += snapStatus.dy;
                client.x += snapStatus.dx;
                client.y += snapStatus.dy;
            }
        }

        if (checkRestrict(target, action) && !(starting && options[action].restrict.elementRect) && restrictStatus.restricted) {
            page.x += restrictStatus.dx;
            page.y += restrictStatus.dy;
            client.x += restrictStatus.dx;
            client.y += restrictStatus.dy;

            this.restrict = {
                dx: restrictStatus.dx,
                dy: restrictStatus.dy
            };
        }

        this.pageX     = page.x;
        this.pageY     = page.y;
        this.clientX   = client.x;
        this.clientY   = client.y;

        this.x0        = interaction.startCoords.page.x - origin.x;
        this.y0        = interaction.startCoords.page.y - origin.y;
        this.clientX0  = interaction.startCoords.client.x - origin.x;
        this.clientY0  = interaction.startCoords.client.y - origin.y;
        this.ctrlKey   = event.ctrlKey;
        this.altKey    = event.altKey;
        this.shiftKey  = event.shiftKey;
        this.metaKey   = event.metaKey;
        this.button    = event.button;
        this.buttons   = event.buttons;
        this.target    = element;
        this.t0        = interaction.downTimes[0];
        this.type      = action + (phase || '');

        this.interaction = interaction;
        this.interactable = target;

        var inertiaStatus = interaction.inertiaStatus;

        if (inertiaStatus.active) {
            this.detail = 'inertia';
        }

        if (related) {
            this.relatedTarget = related;
        }

        // end event dx, dy is difference between start and end points
        if (ending) {
            if (deltaSource === 'client') {
                this.dx = client.x - interaction.startCoords.client.x;
                this.dy = client.y - interaction.startCoords.client.y;
            }
            else {
                this.dx = page.x - interaction.startCoords.page.x;
                this.dy = page.y - interaction.startCoords.page.y;
            }
        }
        else if (starting) {
            this.dx = 0;
            this.dy = 0;
        }
        // copy properties from previousmove if starting inertia
        else if (phase === 'inertiastart') {
            this.dx = interaction.prevEvent.dx;
            this.dy = interaction.prevEvent.dy;
        }
        else {
            if (deltaSource === 'client') {
                this.dx = client.x - interaction.prevEvent.clientX;
                this.dy = client.y - interaction.prevEvent.clientY;
            }
            else {
                this.dx = page.x - interaction.prevEvent.pageX;
                this.dy = page.y - interaction.prevEvent.pageY;
            }
        }
        if (interaction.prevEvent && interaction.prevEvent.detail === 'inertia'
            && !inertiaStatus.active
            && options[action].inertia && options[action].inertia.zeroResumeDelta) {

            inertiaStatus.resumeDx += this.dx;
            inertiaStatus.resumeDy += this.dy;

            this.dx = this.dy = 0;
        }

        if (action === 'resize' && interaction.resizeAxes) {
            if (options.resize.square) {
                if (interaction.resizeAxes === 'y') {
                    this.dx = this.dy;
                }
                else {
                    this.dy = this.dx;
                }
                this.axes = 'xy';
            }
            else {
                this.axes = interaction.resizeAxes;

                if (interaction.resizeAxes === 'x') {
                    this.dy = 0;
                }
                else if (interaction.resizeAxes === 'y') {
                    this.dx = 0;
                }
            }
        }
        else if (action === 'gesture') {
            this.touches = [pointers[0], pointers[1]];

            if (starting) {
                this.distance = touchDistance(pointers, deltaSource);
                this.box      = touchBBox(pointers);
                this.scale    = 1;
                this.ds       = 0;
                this.angle    = touchAngle(pointers, undefined, deltaSource);
                this.da       = 0;
            }
            else if (ending || event instanceof InteractEvent) {
                this.distance = interaction.prevEvent.distance;
                this.box      = interaction.prevEvent.box;
                this.scale    = interaction.prevEvent.scale;
                this.ds       = this.scale - 1;
                this.angle    = interaction.prevEvent.angle;
                this.da       = this.angle - interaction.gesture.startAngle;
            }
            else {
                this.distance = touchDistance(pointers, deltaSource);
                this.box      = touchBBox(pointers);
                this.scale    = this.distance / interaction.gesture.startDistance;
                this.angle    = touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);

                this.ds = this.scale - interaction.gesture.prevScale;
                this.da = this.angle - interaction.gesture.prevAngle;
            }
        }

        if (starting) {
            this.timeStamp = interaction.downTimes[0];
            this.dt        = 0;
            this.duration  = 0;
            this.speed     = 0;
            this.velocityX = 0;
            this.velocityY = 0;
        }
        else if (phase === 'inertiastart') {
            this.timeStamp = interaction.prevEvent.timeStamp;
            this.dt        = interaction.prevEvent.dt;
            this.duration  = interaction.prevEvent.duration;
            this.speed     = interaction.prevEvent.speed;
            this.velocityX = interaction.prevEvent.velocityX;
            this.velocityY = interaction.prevEvent.velocityY;
        }
        else {
            this.timeStamp = new Date().getTime();
            this.dt        = this.timeStamp - interaction.prevEvent.timeStamp;
            this.duration  = this.timeStamp - interaction.downTimes[0];

            if (event instanceof InteractEvent) {
                var dx = this[sourceX] - interaction.prevEvent[sourceX],
                    dy = this[sourceY] - interaction.prevEvent[sourceY],
                    dt = this.dt / 1000;

                this.speed = hypot(dx, dy) / dt;
                this.velocityX = dx / dt;
                this.velocityY = dy / dt;
            }
            // if normal move or end event, use previous user event coords
            else {
                // speed and velocity in pixels per second
                this.speed = interaction.pointerDelta[deltaSource].speed;
                this.velocityX = interaction.pointerDelta[deltaSource].vx;
                this.velocityY = interaction.pointerDelta[deltaSource].vy;
            }
        }

        if ((ending || phase === 'inertiastart')
            && interaction.prevEvent.speed > 600 && this.timeStamp - interaction.prevEvent.timeStamp < 150) {

            var angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI,
                overlap = 22.5;

            if (angle < 0) {
                angle += 360;
            }

            var left = 135 - overlap <= angle && angle < 225 + overlap,
                up   = 225 - overlap <= angle && angle < 315 + overlap,

                right = !left && (315 - overlap <= angle || angle <  45 + overlap),
                down  = !up   &&   45 - overlap <= angle && angle < 135 + overlap;

            this.swipe = {
                up   : up,
                down : down,
                left : left,
                right: right,
                angle: angle,
                speed: interaction.prevEvent.speed,
                velocity: {
                    x: interaction.prevEvent.velocityX,
                    y: interaction.prevEvent.velocityY
                }
            };
        }
    }

    InteractEvent.prototype = {
        preventDefault: blank,
        stopImmediatePropagation: function () {
            this.immediatePropagationStopped = this.propagationStopped = true;
        },
        stopPropagation: function () {
            this.propagationStopped = true;
        }
    };

    function preventOriginalDefault () {
        this.originalEvent.preventDefault();
    }

    function getActionCursor (action) {
        var cursor = '';

        if (action.name === 'drag') {
            cursor =  actionCursors.drag;
        }
        if (action.name === 'resize') {
            if (action.axis) {
                cursor =  actionCursors[action.name + action.axis];
            }
            else if (action.edges) {
                var cursorKey = 'resize',
                    edgeNames = ['top', 'bottom', 'left', 'right'];

                for (var i = 0; i < 4; i++) {
                    if (action.edges[edgeNames[i]]) {
                        cursorKey += edgeNames[i];
                    }
                }

                cursor = actionCursors[cursorKey];
            }
        }

        return cursor;
    }

    function checkResizeEdge (name, value, page, element, interactableElement, rect, margin) {
        // false, '', undefined, null
        if (!value) { return false; }

        // true value, use pointer coords and element rect
        if (value === true) {
            // if dimensions are negative, "switch" edges
            var width = isNumber(rect.width)? rect.width : rect.right - rect.left,
                height = isNumber(rect.height)? rect.height : rect.bottom - rect.top;

            if (width < 0) {
                if      (name === 'left' ) { name = 'right'; }
                else if (name === 'right') { name = 'left' ; }
            }
            if (height < 0) {
                if      (name === 'top'   ) { name = 'bottom'; }
                else if (name === 'bottom') { name = 'top'   ; }
            }

            if (name === 'left'  ) { return page.x < ((width  >= 0? rect.left: rect.right ) + margin); }
            if (name === 'top'   ) { return page.y < ((height >= 0? rect.top : rect.bottom) + margin); }

            if (name === 'right' ) { return page.x > ((width  >= 0? rect.right : rect.left) - margin); }
            if (name === 'bottom') { return page.y > ((height >= 0? rect.bottom: rect.top ) - margin); }
        }

        // the remaining checks require an element
        if (!isElement(element)) { return false; }

        return isElement(value)
                    // the value is an element to use as a resize handle
                    ? value === element
                    // otherwise check if element matches value as selector
                    : matchesUpTo(element, value, interactableElement);
    }

    function defaultActionChecker (pointer, interaction, element) {
        var rect = this.getRect(element),
            shouldResize = false,
            action = null,
            resizeAxes = null,
            resizeEdges,
            page = extend({}, interaction.curCoords.page),
            options = this.options;

        if (!rect) { return null; }

        if (actionIsEnabled.resize && options.resize.enabled) {
            var resizeOptions = options.resize;

            resizeEdges = {
                left: false, right: false, top: false, bottom: false
            };

            // if using resize.edges
            if (isObject(resizeOptions.edges)) {
                for (var edge in resizeEdges) {
                    resizeEdges[edge] = checkResizeEdge(edge,
                                                        resizeOptions.edges[edge],
                                                        page,
                                                        interaction._eventTarget,
                                                        element,
                                                        rect,
                                                        resizeOptions.margin || margin);
                }

                resizeEdges.left = resizeEdges.left && !resizeEdges.right;
                resizeEdges.top  = resizeEdges.top  && !resizeEdges.bottom;

                shouldResize = resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom;
            }
            else {
                var right  = options.resize.axis !== 'y' && page.x > (rect.right  - margin),
                    bottom = options.resize.axis !== 'x' && page.y > (rect.bottom - margin);

                shouldResize = right || bottom;
                resizeAxes = (right? 'x' : '') + (bottom? 'y' : '');
            }
        }

        action = shouldResize
            ? 'resize'
            : actionIsEnabled.drag && options.drag.enabled
                ? 'drag'
                : null;

        if (actionIsEnabled.gesture
            && interaction.pointerIds.length >=2
            && !(interaction.dragging || interaction.resizing)) {
            action = 'gesture';
        }

        if (action) {
            return {
                name: action,
                axis: resizeAxes,
                edges: resizeEdges
            };
        }

        return null;
    }

    // Check if action is enabled globally and the current target supports it
    // If so, return the validated action. Otherwise, return null
    function validateAction (action, interactable) {
        if (!isObject(action)) { return null; }

        var actionName = action.name,
            options = interactable.options;

        if ((  (actionName  === 'resize'   && options.resize.enabled )
            || (actionName      === 'drag'     && options.drag.enabled  )
            || (actionName      === 'gesture'  && options.gesture.enabled))
            && actionIsEnabled[actionName]) {

            if (actionName === 'resize' || actionName === 'resizeyx') {
                actionName = 'resizexy';
            }

            return action;
        }
        return null;
    }

    var listeners = {},
        interactionListeners = [
            'dragStart', 'dragMove', 'resizeStart', 'resizeMove', 'gestureStart', 'gestureMove',
            'pointerOver', 'pointerOut', 'pointerHover', 'selectorDown',
            'pointerDown', 'pointerMove', 'pointerUp', 'pointerCancel', 'pointerEnd',
            'addPointer', 'removePointer', 'recordPointer', 'autoScrollMove'
        ];

    for (var i = 0, len = interactionListeners.length; i < len; i++) {
        var name = interactionListeners[i];

        listeners[name] = doOnInteractions(name);
    }

    // bound to the interactable context when a DOM event
    // listener is added to a selector interactable
    function delegateListener (event, useCapture) {
        var fakeEvent = {},
            delegated = delegatedEvents[event.type],
            eventTarget = getActualElement(event.path
                                           ? event.path[0]
                                           : event.target),
            element = eventTarget;

        useCapture = useCapture? true: false;

        // duplicate the event so that currentTarget can be changed
        for (var prop in event) {
            fakeEvent[prop] = event[prop];
        }

        fakeEvent.originalEvent = event;
        fakeEvent.preventDefault = preventOriginalDefault;

        // climb up document tree looking for selector matches
        while (isElement(element)) {
            for (var i = 0; i < delegated.selectors.length; i++) {
                var selector = delegated.selectors[i],
                    context = delegated.contexts[i];

                if (matchesSelector(element, selector)
                    && nodeContains(context, eventTarget)
                    && nodeContains(context, element)) {

                    var listeners = delegated.listeners[i];

                    fakeEvent.currentTarget = element;

                    for (var j = 0; j < listeners.length; j++) {
                        if (listeners[j][1] === useCapture) {
                            listeners[j][0](fakeEvent);
                        }
                    }
                }
            }

            element = parentElement(element);
        }
    }

    function delegateUseCapture (event) {
        return delegateListener.call(this, event, true);
    }

    interactables.indexOfElement = function indexOfElement (element, context) {
        context = context || document;

        for (var i = 0; i < this.length; i++) {
            var interactable = this[i];

            if ((interactable.selector === element
                && (interactable._context === context))
                || (!interactable.selector && interactable._element === element)) {

                return i;
            }
        }
        return -1;
    };

    interactables.get = function interactableGet (element, options) {
        return this[this.indexOfElement(element, options && options.context)];
    };

    interactables.forEachSelector = function (callback) {
        for (var i = 0; i < this.length; i++) {
            var interactable = this[i];

            if (!interactable.selector) {
                continue;
            }

            var ret = callback(interactable, interactable.selector, interactable._context, i, this);

            if (ret !== undefined) {
                return ret;
            }
        }
    };

    /*\
     * interact
     [ method ]
     *
     * The methods of this variable can be used to set elements as
     * interactables and also to change various default settings.
     *
     * Calling it as a function and passing an element or a valid CSS selector
     * string returns an Interactable object which has various methods to
     * configure it.
     *
     - element (Element | string) The HTML or SVG Element to interact with or CSS selector
     = (object) An @Interactable
     *
     > Usage
     | interact(document.getElementById('draggable')).draggable(true);
     |
     | var rectables = interact('rect');
     | rectables
     |     .gesturable(true)
     |     .on('gesturemove', function (event) {
     |         // something cool...
     |     })
     |     .autoScroll(true);
    \*/
    function interact (element, options) {
        return interactables.get(element, options) || new Interactable(element, options);
    }

    /*\
     * Interactable
     [ property ]
     **
     * Object type returned by @interact
    \*/
    function Interactable (element, options) {
        this._element = element;
        this._iEvents = this._iEvents || {};

        var _window;

        if (trySelector(element)) {
            this.selector = element;

            var context = options && options.context;

            _window = context? getWindow(context) : window;

            if (context && (_window.Node
                    ? context instanceof _window.Node
                    : (isElement(context) || context === _window.document))) {

                this._context = context;
            }
        }
        else {
            _window = getWindow(element);

            if (isElement(element, _window)) {

                if (PointerEvent) {
                    events.add(this._element, pEventTypes.down, listeners.pointerDown );
                    events.add(this._element, pEventTypes.move, listeners.pointerHover);
                }
                else {
                    events.add(this._element, 'mousedown' , listeners.pointerDown );
                    events.add(this._element, 'mousemove' , listeners.pointerHover);
                    events.add(this._element, 'touchstart', listeners.pointerDown );
                    events.add(this._element, 'touchmove' , listeners.pointerHover);
                }
            }
        }

        this._doc = _window.document;

        if (!contains(documents, this._doc)) {
            listenToDocument(this._doc);
        }

        interactables.push(this);

        this.set(options);
    }

    Interactable.prototype = {
        setOnEvents: function (action, phases) {
            if (action === 'drop') {
                if (isFunction(phases.ondrop)          ) { this.ondrop           = phases.ondrop          ; }
                if (isFunction(phases.ondropactivate)  ) { this.ondropactivate   = phases.ondropactivate  ; }
                if (isFunction(phases.ondropdeactivate)) { this.ondropdeactivate = phases.ondropdeactivate; }
                if (isFunction(phases.ondragenter)     ) { this.ondragenter      = phases.ondragenter     ; }
                if (isFunction(phases.ondragleave)     ) { this.ondragleave      = phases.ondragleave     ; }
                if (isFunction(phases.ondropmove)      ) { this.ondropmove       = phases.ondropmove      ; }
            }
            else {
                action = 'on' + action;

                if (isFunction(phases.onstart)       ) { this[action + 'start'         ] = phases.onstart         ; }
                if (isFunction(phases.onmove)        ) { this[action + 'move'          ] = phases.onmove          ; }
                if (isFunction(phases.onend)         ) { this[action + 'end'           ] = phases.onend           ; }
                if (isFunction(phases.oninertiastart)) { this[action + 'inertiastart'  ] = phases.oninertiastart  ; }
            }

            return this;
        },

        /*\
         * Interactable.draggable
         [ method ]
         *
         * Gets or sets whether drag actions can be performed on the
         * Interactable
         *
         = (boolean) Indicates if this can be the target of drag events
         | var isDraggable = interact('ul li').draggable();
         * or
         - options (boolean | object) #optional true/false or An object with event listeners to be fired on drag events (object makes the Interactable draggable)
         = (object) This Interactable
         | interact(element).draggable({
         |     onstart: function (event) {},
         |     onmove : function (event) {},
         |     onend  : function (event) {},
         |
         |     // the axis in which the first movement must be
         |     // for the drag sequence to start
         |     // 'xy' by default - any direction
         |     axis: 'x' || 'y' || 'xy',
         |
         |     // max number of drags that can happen concurrently
         |     // with elements of this Interactable. Infinity by default
         |     max: Infinity,
         |
         |     // max number of drags that can target the same element+Interactable
         |     // 1 by default
         |     maxPerElement: 2
         | });
        \*/
        draggable: function (options) {
            if (isObject(options)) {
                this.options.drag.enabled = options.enabled === false? false: true;
                this.setPerAction('drag', options);
                this.setOnEvents('drag', options);

                if (/^x$|^y$|^xy$/.test(options.axis)) {
                    this.options.drag.axis = options.axis;
                }
                else if (options.axis === null) {
                    delete this.options.drag.axis;
                }

                return this;
            }

            if (isBool(options)) {
                this.options.drag.enabled = options;

                return this;
            }

            return this.options.drag;
        },

        setPerAction: function (action, options) {
            // for all the default per-action options
            for (var option in options) {
                // if this option exists for this action
                if (option in defaultOptions[action]) {
                    // if the option in the options arg is an object value
                    if (isObject(options[option])) {
                        // duplicate the object
                        this.options[action][option] = extend(this.options[action][option] || {}, options[option]);

                        if (isObject(defaultOptions.perAction[option]) && 'enabled' in defaultOptions.perAction[option]) {
                            this.options[action][option].enabled = options[option].enabled === false? false : true;
                        }
                    }
                    else if (isBool(options[option]) && isObject(defaultOptions.perAction[option])) {
                        this.options[action][option].enabled = options[option];
                    }
                    else if (options[option] !== undefined) {
                        // or if it's not undefined, do a plain assignment
                        this.options[action][option] = options[option];
                    }
                }
            }
        },

        /*\
         * Interactable.dropzone
         [ method ]
         *
         * Returns or sets whether elements can be dropped onto this
         * Interactable to trigger drop events
         *
         * Dropzones can receive the following events:
         *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends
         *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone
         *  - `dragmove` when a draggable that has entered the dropzone is moved
         *  - `drop` when a draggable is dropped into this dropzone
         *
         *  Use the `accept` option to allow only elements that match the given CSS selector or element.
         *
         *  Use the `overlap` option to set how drops are checked for. The allowed values are:
         *   - `'pointer'`, the pointer must be over the dropzone (default)
         *   - `'center'`, the draggable element's center must be over the dropzone
         *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.
         *       e.g. `0.5` for drop to happen when half of the area of the
         *       draggable is over the dropzone
         *
         - options (boolean | object | null) #optional The new value to be set.
         | interact('.drop').dropzone({
         |   accept: '.can-drop' || document.getElementById('single-drop'),
         |   overlap: 'pointer' || 'center' || zeroToOne
         | }
         = (boolean | object) The current setting or this Interactable
        \*/
        dropzone: function (options) {
            if (isObject(options)) {
                this.options.drop.enabled = options.enabled === false? false: true;
                this.setOnEvents('drop', options);

                if (/^(pointer|center)$/.test(options.overlap)) {
                    this.options.drop.overlap = options.overlap;
                }
                else if (isNumber(options.overlap)) {
                    this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);
                }
                if ('accept' in options) {
                  this.options.drop.accept = options.accept;
                }
                if ('checker' in options) {
                  this.options.drop.checker = options.checker;
                }

                return this;
            }

            if (isBool(options)) {
                this.options.drop.enabled = options;

                return this;
            }

            return this.options.drop;
        },

        dropCheck: function (dragEvent, event, draggable, draggableElement, dropElement, rect) {
            var dropped = false;

            // if the dropzone has no rect (eg. display: none)
            // call the custom dropChecker or just return false
            if (!(rect = rect || this.getRect(dropElement))) {
                return (this.options.drop.checker
                    ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement)
                    : false);
            }

            var dropOverlap = this.options.drop.overlap;

            if (dropOverlap === 'pointer') {
                var page = getPageXY(dragEvent),
                    origin = getOriginXY(draggable, draggableElement),
                    horizontal,
                    vertical;

                page.x += origin.x;
                page.y += origin.y;

                horizontal = (page.x > rect.left) && (page.x < rect.right);
                vertical   = (page.y > rect.top ) && (page.y < rect.bottom);

                dropped = horizontal && vertical;
            }

            var dragRect = draggable.getRect(draggableElement);

            if (dropOverlap === 'center') {
                var cx = dragRect.left + dragRect.width  / 2,
                    cy = dragRect.top  + dragRect.height / 2;

                dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;
            }

            if (isNumber(dropOverlap)) {
                var overlapArea  = (Math.max(0, Math.min(rect.right , dragRect.right ) - Math.max(rect.left, dragRect.left))
                                  * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top , dragRect.top ))),
                    overlapRatio = overlapArea / (dragRect.width * dragRect.height);

                dropped = overlapRatio >= dropOverlap;
            }

            if (this.options.drop.checker) {
                dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);
            }

            return dropped;
        },

        /*\
         * Interactable.dropChecker
         [ method ]
         *
         * DEPRECATED. Use interactable.dropzone({ checker: function... }) instead.
         *
         * Gets or sets the function used to check if a dragged element is
         * over this Interactable.
         *
         - checker (function) #optional The function that will be called when checking for a drop
         = (Function | Interactable) The checker function or this Interactable
         *
         * The checker function takes the following arguments:
         *
         - dragEvent (InteractEvent) The related dragmove or dragend event
         - event (TouchEvent | PointerEvent | MouseEvent) The user move/up/end Event related to the dragEvent
         - dropped (boolean) The value from the default drop checker
         - dropzone (Interactable) The dropzone interactable
         - dropElement (Element) The dropzone element
         - draggable (Interactable) The Interactable being dragged
         - draggableElement (Element) The actual element that's being dragged
         *
         > Usage:
         | interact(target)
         | .dropChecker(function(dragEvent,         // related dragmove or dragend event
         |                       event,             // TouchEvent/PointerEvent/MouseEvent
         |                       dropped,           // bool result of the default checker
         |                       dropzone,          // dropzone Interactable
         |                       dropElement,       // dropzone elemnt
         |                       draggable,         // draggable Interactable
         |                       draggableElement) {// draggable element
         |
         |   return dropped && event.target.hasAttribute('allow-drop');
         | }
        \*/
        dropChecker: function (checker) {
            if (isFunction(checker)) {
                this.options.drop.checker = checker;

                return this;
            }
            if (checker === null) {
                delete this.options.getRect;

                return this;
            }

            return this.options.drop.checker;
        },

        /*\
         * Interactable.accept
         [ method ]
         *
         * Deprecated. add an `accept` property to the options object passed to
         * @Interactable.dropzone instead.
         *
         * Gets or sets the Element or CSS selector match that this
         * Interactable accepts if it is a dropzone.
         *
         - newValue (Element | string | null) #optional
         * If it is an Element, then only that element can be dropped into this dropzone.
         * If it is a string, the element being dragged must match it as a selector.
         * If it is null, the accept options is cleared - it accepts any element.
         *
         = (string | Element | null | Interactable) The current accept option if given `undefined` or this Interactable
        \*/
        accept: function (newValue) {
            if (isElement(newValue)) {
                this.options.drop.accept = newValue;

                return this;
            }

            // test if it is a valid CSS selector
            if (trySelector(newValue)) {
                this.options.drop.accept = newValue;

                return this;
            }

            if (newValue === null) {
                delete this.options.drop.accept;

                return this;
            }

            return this.options.drop.accept;
        },

        /*\
         * Interactable.resizable
         [ method ]
         *
         * Gets or sets whether resize actions can be performed on the
         * Interactable
         *
         = (boolean) Indicates if this can be the target of resize elements
         | var isResizeable = interact('input[type=text]').resizable();
         * or
         - options (boolean | object) #optional true/false or An object with event listeners to be fired on resize events (object makes the Interactable resizable)
         = (object) This Interactable
         | interact(element).resizable({
         |     onstart: function (event) {},
         |     onmove : function (event) {},
         |     onend  : function (event) {},
         |
         |     edges: {
         |       top   : true,       // Use pointer coords to check for resize.
         |       left  : false,      // Disable resizing from left edge.
         |       bottom: '.resize-s',// Resize if pointer target matches selector
         |       right : handleEl    // Resize if pointer target is the given Element
         |     },
         |
         |     // Width and height can be adjusted independently. When `true`, width and
         |     // height are adjusted at a 1:1 ratio.
         |     square: false,
         |
         |     // Width and height can be adjusted independently. When `true`, width and
         |     // height maintain the aspect ratio they had when resizing started.
         |     preserveAspectRatio: false,
         |
         |     // a value of 'none' will limit the resize rect to a minimum of 0x0
         |     // 'negate' will allow the rect to have negative width/height
         |     // 'reposition' will keep the width/height positive by swapping
         |     // the top and bottom edges and/or swapping the left and right edges
         |     invert: 'none' || 'negate' || 'reposition'
         |
         |     // limit multiple resizes.
         |     // See the explanation in the @Interactable.draggable example
         |     max: Infinity,
         |     maxPerElement: 1,
         | });
        \*/
        resizable: function (options) {
            if (isObject(options)) {
                this.options.resize.enabled = options.enabled === false? false: true;
                this.setPerAction('resize', options);
                this.setOnEvents('resize', options);

                if (/^x$|^y$|^xy$/.test(options.axis)) {
                    this.options.resize.axis = options.axis;
                }
                else if (options.axis === null) {
                    this.options.resize.axis = defaultOptions.resize.axis;
                }

                if (isBool(options.preserveAspectRatio)) {
                    this.options.resize.preserveAspectRatio = options.preserveAspectRatio;
                }
                else if (isBool(options.square)) {
                    this.options.resize.square = options.square;
                }

                return this;
            }
            if (isBool(options)) {
                this.options.resize.enabled = options;

                return this;
            }
            return this.options.resize;
        },

        /*\
         * Interactable.squareResize
         [ method ]
         *
         * Deprecated. Add a `square: true || false` property to @Interactable.resizable instead
         *
         * Gets or sets whether resizing is forced 1:1 aspect
         *
         = (boolean) Current setting
         *
         * or
         *
         - newValue (boolean) #optional
         = (object) this Interactable
        \*/
        squareResize: function (newValue) {
            if (isBool(newValue)) {
                this.options.resize.square = newValue;

                return this;
            }

            if (newValue === null) {
                delete this.options.resize.square;

                return this;
            }

            return this.options.resize.square;
        },

        /*\
         * Interactable.gesturable
         [ method ]
         *
         * Gets or sets whether multitouch gestures can be performed on the
         * Interactable's element
         *
         = (boolean) Indicates if this can be the target of gesture events
         | var isGestureable = interact(element).gesturable();
         * or
         - options (boolean | object) #optional true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)
         = (object) this Interactable
         | interact(element).gesturable({
         |     onstart: function (event) {},
         |     onmove : function (event) {},
         |     onend  : function (event) {},
         |
         |     // limit multiple gestures.
         |     // See the explanation in @Interactable.draggable example
         |     max: Infinity,
         |     maxPerElement: 1,
         | });
        \*/
        gesturable: function (options) {
            if (isObject(options)) {
                this.options.gesture.enabled = options.enabled === false? false: true;
                this.setPerAction('gesture', options);
                this.setOnEvents('gesture', options);

                return this;
            }

            if (isBool(options)) {
                this.options.gesture.enabled = options;

                return this;
            }

            return this.options.gesture;
        },

        /*\
         * Interactable.autoScroll
         [ method ]
         **
         * Deprecated. Add an `autoscroll` property to the options object
         * passed to @Interactable.draggable or @Interactable.resizable instead.
         *
         * Returns or sets whether dragging and resizing near the edges of the
         * window/container trigger autoScroll for this Interactable
         *
         = (object) Object with autoScroll properties
         *
         * or
         *
         - options (object | boolean) #optional
         * options can be:
         * - an object with margin, distance and interval properties,
         * - true or false to enable or disable autoScroll or
         = (Interactable) this Interactable
        \*/
        autoScroll: function (options) {
            if (isObject(options)) {
                options = extend({ actions: ['drag', 'resize']}, options);
            }
            else if (isBool(options)) {
                options = { actions: ['drag', 'resize'], enabled: options };
            }

            return this.setOptions('autoScroll', options);
        },

        /*\
         * Interactable.snap
         [ method ]
         **
         * Deprecated. Add a `snap` property to the options object passed
         * to @Interactable.draggable or @Interactable.resizable instead.
         *
         * Returns or sets if and how action coordinates are snapped. By
         * default, snapping is relative to the pointer coordinates. You can
         * change this by setting the
         * [`elementOrigin`](https://github.com/taye/interact.js/pull/72).
         **
         = (boolean | object) `false` if snap is disabled; object with snap properties if snap is enabled
         **
         * or
         **
         - options (object | boolean | null) #optional
         = (Interactable) this Interactable
         > Usage
         | interact(document.querySelector('#thing')).snap({
         |     targets: [
         |         // snap to this specific point
         |         {
         |             x: 100,
         |             y: 100,
         |             range: 25
         |         },
         |         // give this function the x and y page coords and snap to the object returned
         |         function (x, y) {
         |             return {
         |                 x: x,
         |                 y: (75 + 50 * Math.sin(x * 0.04)),
         |                 range: 40
         |             };
         |         },
         |         // create a function that snaps to a grid
         |         interact.createSnapGrid({
         |             x: 50,
         |             y: 50,
         |             range: 10,              // optional
         |             offset: { x: 5, y: 10 } // optional
         |         })
         |     ],
         |     // do not snap during normal movement.
         |     // Instead, trigger only one snapped move event
         |     // immediately before the end event.
         |     endOnly: true,
         |
         |     relativePoints: [
         |         { x: 0, y: 0 },  // snap relative to the top left of the element
         |         { x: 1, y: 1 },  // and also to the bottom right
         |     ],  
         |
         |     // offset the snap target coordinates
         |     // can be an object with x/y or 'startCoords'
         |     offset: { x: 50, y: 50 }
         |   }
         | });
        \*/
        snap: function (options) {
            var ret = this.setOptions('snap', options);

            if (ret === this) { return this; }

            return ret.drag;
        },

        setOptions: function (option, options) {
            var actions = options && isArray(options.actions)
                    ? options.actions
                    : ['drag'];

            var i;

            if (isObject(options) || isBool(options)) {
                for (i = 0; i < actions.length; i++) {
                    var action = /resize/.test(actions[i])? 'resize' : actions[i];

                    if (!isObject(this.options[action])) { continue; }

                    var thisOption = this.options[action][option];

                    if (isObject(options)) {
                        extend(thisOption, options);
                        thisOption.enabled = options.enabled === false? false: true;

                        if (option === 'snap') {
                            if (thisOption.mode === 'grid') {
                                thisOption.targets = [
                                    interact.createSnapGrid(extend({
                                        offset: thisOption.gridOffset || { x: 0, y: 0 }
                                    }, thisOption.grid || {}))
                                ];
                            }
                            else if (thisOption.mode === 'anchor') {
                                thisOption.targets = thisOption.anchors;
                            }
                            else if (thisOption.mode === 'path') {
                                thisOption.targets = thisOption.paths;
                            }

                            if ('elementOrigin' in options) {
                                thisOption.relativePoints = [options.elementOrigin];
                            }
                        }
                    }
                    else if (isBool(options)) {
                        thisOption.enabled = options;
                    }
                }

                return this;
            }

            var ret = {},
                allActions = ['drag', 'resize', 'gesture'];

            for (i = 0; i < allActions.length; i++) {
                if (option in defaultOptions[allActions[i]]) {
                    ret[allActions[i]] = this.options[allActions[i]][option];
                }
            }

            return ret;
        },


        /*\
         * Interactable.inertia
         [ method ]
         **
         * Deprecated. Add an `inertia` property to the options object passed
         * to @Interactable.draggable or @Interactable.resizable instead.
         *
         * Returns or sets if and how events continue to run after the pointer is released
         **
         = (boolean | object) `false` if inertia is disabled; `object` with inertia properties if inertia is enabled
         **
         * or
         **
         - options (object | boolean | null) #optional
         = (Interactable) this Interactable
         > Usage
         | // enable and use default settings
         | interact(element).inertia(true);
         |
         | // enable and use custom settings
         | interact(element).inertia({
         |     // value greater than 0
         |     // high values slow the object down more quickly
         |     resistance     : 16,
         |
         |     // the minimum launch speed (pixels per second) that results in inertia start
         |     minSpeed       : 200,
         |
         |     // inertia will stop when the object slows down to this speed
         |     endSpeed       : 20,
         |
         |     // boolean; should actions be resumed when the pointer goes down during inertia
         |     allowResume    : true,
         |
         |     // boolean; should the jump when resuming from inertia be ignored in event.dx/dy
         |     zeroResumeDelta: false,
         |
         |     // if snap/restrict are set to be endOnly and inertia is enabled, releasing
         |     // the pointer without triggering inertia will animate from the release
         |     // point to the snaped/restricted point in the given amount of time (ms)
         |     smoothEndDuration: 300,
         |
         |     // an array of action types that can have inertia (no gesture)
         |     actions        : ['drag', 'resize']
         | });
         |
         | // reset custom settings and use all defaults
         | interact(element).inertia(null);
        \*/
        inertia: function (options) {
            var ret = this.setOptions('inertia', options);

            if (ret === this) { return this; }

            return ret.drag;
        },

        getAction: function (pointer, event, interaction, element) {
            var action = this.defaultActionChecker(pointer, interaction, element);

            if (this.options.actionChecker) {
                return this.options.actionChecker(pointer, event, action, this, element, interaction);
            }

            return action;
        },

        defaultActionChecker: defaultActionChecker,

        /*\
         * Interactable.actionChecker
         [ method ]
         *
         * Gets or sets the function used to check action to be performed on
         * pointerDown
         *
         - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.
         = (Function | Interactable) The checker function or this Interactable
         *
         | interact('.resize-drag')
         |   .resizable(true)
         |   .draggable(true)
         |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {
         |
         |   if (interact.matchesSelector(event.target, '.drag-handle') {
         |     // force drag with handle target
         |     action.name = drag;
         |   }
         |   else {
         |     // resize from the top and right edges
         |     action.name  = 'resize';
         |     action.edges = { top: true, right: true };
         |   }
         |
         |   return action;
         | });
        \*/
        actionChecker: function (checker) {
            if (isFunction(checker)) {
                this.options.actionChecker = checker;

                return this;
            }

            if (checker === null) {
                delete this.options.actionChecker;

                return this;
            }

            return this.options.actionChecker;
        },

        /*\
         * Interactable.getRect
         [ method ]
         *
         * The default function to get an Interactables bounding rect. Can be
         * overridden using @Interactable.rectChecker.
         *
         - element (Element) #optional The element to measure.
         = (object) The object's bounding rectangle.
         o {
         o     top   : 0,
         o     left  : 0,
         o     bottom: 0,
         o     right : 0,
         o     width : 0,
         o     height: 0
         o }
        \*/
        getRect: function rectCheck (element) {
            element = element || this._element;

            if (this.selector && !(isElement(element))) {
                element = this._context.querySelector(this.selector);
            }

            return getElementRect(element);
        },

        /*\
         * Interactable.rectChecker
         [ method ]
         *
         * Returns or sets the function used to calculate the interactable's
         * element's rectangle
         *
         - checker (function) #optional A function which returns this Interactable's bounding rectangle. See @Interactable.getRect
         = (function | object) The checker function or this Interactable
        \*/
        rectChecker: function (checker) {
            if (isFunction(checker)) {
                this.getRect = checker;

                return this;
            }

            if (checker === null) {
                delete this.options.getRect;

                return this;
            }

            return this.getRect;
        },

        /*\
         * Interactable.styleCursor
         [ method ]
         *
         * Returns or sets whether the action that would be performed when the
         * mouse on the element are checked on `mousemove` so that the cursor
         * may be styled appropriately
         *
         - newValue (boolean) #optional
         = (boolean | Interactable) The current setting or this Interactable
        \*/
        styleCursor: function (newValue) {
            if (isBool(newValue)) {
                this.options.styleCursor = newValue;

                return this;
            }

            if (newValue === null) {
                delete this.options.styleCursor;

                return this;
            }

            return this.options.styleCursor;
        },

        /*\
         * Interactable.preventDefault
         [ method ]
         *
         * Returns or sets whether to prevent the browser's default behaviour
         * in response to pointer events. Can be set to:
         *  - `'always'` to always prevent
         *  - `'never'` to never prevent
         *  - `'auto'` to let interact.js try to determine what would be best
         *
         - newValue (string) #optional `true`, `false` or `'auto'`
         = (string | Interactable) The current setting or this Interactable
        \*/
        preventDefault: function (newValue) {
            if (/^(always|never|auto)$/.test(newValue)) {
                this.options.preventDefault = newValue;
                return this;
            }

            if (isBool(newValue)) {
                this.options.preventDefault = newValue? 'always' : 'never';
                return this;
            }

            return this.options.preventDefault;
        },

        /*\
         * Interactable.origin
         [ method ]
         *
         * Gets or sets the origin of the Interactable's element.  The x and y
         * of the origin will be subtracted from action event coordinates.
         *
         - origin (object | string) #optional An object eg. { x: 0, y: 0 } or string 'parent', 'self' or any CSS selector
         * OR
         - origin (Element) #optional An HTML or SVG Element whose rect will be used
         **
         = (object) The current origin or this Interactable
        \*/
        origin: function (newValue) {
            if (trySelector(newValue)) {
                this.options.origin = newValue;
                return this;
            }
            else if (isObject(newValue)) {
                this.options.origin = newValue;
                return this;
            }

            return this.options.origin;
        },

        /*\
         * Interactable.deltaSource
         [ method ]
         *
         * Returns or sets the mouse coordinate types used to calculate the
         * movement of the pointer.
         *
         - newValue (string) #optional Use 'client' if you will be scrolling while interacting; Use 'page' if you want autoScroll to work
         = (string | object) The current deltaSource or this Interactable
        \*/
        deltaSource: function (newValue) {
            if (newValue === 'page' || newValue === 'client') {
                this.options.deltaSource = newValue;

                return this;
            }

            return this.options.deltaSource;
        },

        /*\
         * Interactable.restrict
         [ method ]
         **
         * Deprecated. Add a `restrict` property to the options object passed to
         * @Interactable.draggable, @Interactable.resizable or @Interactable.gesturable instead.
         *
         * Returns or sets the rectangles within which actions on this
         * interactable (after snap calculations) are restricted. By default,
         * restricting is relative to the pointer coordinates. You can change
         * this by setting the
         * [`elementRect`](https://github.com/taye/interact.js/pull/72).
         **
         - options (object) #optional an object with keys drag, resize, and/or gesture whose values are rects, Elements, CSS selectors, or 'parent' or 'self'
         = (object) The current restrictions object or this Interactable
         **
         | interact(element).restrict({
         |     // the rect will be `interact.getElementRect(element.parentNode)`
         |     drag: element.parentNode,
         |
         |     // x and y are relative to the the interactable's origin
         |     resize: { x: 100, y: 100, width: 200, height: 200 }
         | })
         |
         | interact('.draggable').restrict({
         |     // the rect will be the selected element's parent
         |     drag: 'parent',
         |
         |     // do not restrict during normal movement.
         |     // Instead, trigger only one restricted move event
         |     // immediately before the end event.
         |     endOnly: true,
         |
         |     // https://github.com/taye/interact.js/pull/72#issue-41813493
         |     elementRect: { top: 0, left: 0, bottom: 1, right: 1 }
         | });
        \*/
        restrict: function (options) {
            if (!isObject(options)) {
                return this.setOptions('restrict', options);
            }

            var actions = ['drag', 'resize', 'gesture'],
                ret;

            for (var i = 0; i < actions.length; i++) {
                var action = actions[i];

                if (action in options) {
                    var perAction = extend({
                            actions: [action],
                            restriction: options[action]
                        }, options);

                    ret = this.setOptions('restrict', perAction);
                }
            }

            return ret;
        },

        /*\
         * Interactable.context
         [ method ]
         *
         * Gets the selector context Node of the Interactable. The default is `window.document`.
         *
         = (Node) The context Node of this Interactable
         **
        \*/
        context: function () {
            return this._context;
        },

        _context: document,

        /*\
         * Interactable.ignoreFrom
         [ method ]
         *
         * If the target of the `mousedown`, `pointerdown` or `touchstart`
         * event or any of it's parents match the given CSS selector or
         * Element, no drag/resize/gesture is started.
         *
         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to not ignore any elements
         = (string | Element | object) The current ignoreFrom value or this Interactable
         **
         | interact(element, { ignoreFrom: document.getElementById('no-action') });
         | // or
         | interact(element).ignoreFrom('input, textarea, a');
        \*/
        ignoreFrom: function (newValue) {
            if (trySelector(newValue)) {            // CSS selector to match event.target
                this.options.ignoreFrom = newValue;
                return this;
            }

            if (isElement(newValue)) {              // specific element
                this.options.ignoreFrom = newValue;
                return this;
            }

            return this.options.ignoreFrom;
        },

        /*\
         * Interactable.allowFrom
         [ method ]
         *
         * A drag/resize/gesture is started only If the target of the
         * `mousedown`, `pointerdown` or `touchstart` event or any of it's
         * parents match the given CSS selector or Element.
         *
         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to allow from any element
         = (string | Element | object) The current allowFrom value or this Interactable
         **
         | interact(element, { allowFrom: document.getElementById('drag-handle') });
         | // or
         | interact(element).allowFrom('.handle');
        \*/
        allowFrom: function (newValue) {
            if (trySelector(newValue)) {            // CSS selector to match event.target
                this.options.allowFrom = newValue;
                return this;
            }

            if (isElement(newValue)) {              // specific element
                this.options.allowFrom = newValue;
                return this;
            }

            return this.options.allowFrom;
        },

        /*\
         * Interactable.element
         [ method ]
         *
         * If this is not a selector Interactable, it returns the element this
         * interactable represents
         *
         = (Element) HTML / SVG Element
        \*/
        element: function () {
            return this._element;
        },

        /*\
         * Interactable.fire
         [ method ]
         *
         * Calls listeners for the given InteractEvent type bound globally
         * and directly to this Interactable
         *
         - iEvent (InteractEvent) The InteractEvent object to be fired on this Interactable
         = (Interactable) this Interactable
        \*/
        fire: function (iEvent) {
            if (!(iEvent && iEvent.type) || !contains(eventTypes, iEvent.type)) {
                return this;
            }

            var listeners,
                i,
                len,
                onEvent = 'on' + iEvent.type,
                funcName = '';

            // Interactable#on() listeners
            if (iEvent.type in this._iEvents) {
                listeners = this._iEvents[iEvent.type];

                for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {
                    funcName = listeners[i].name;
                    listeners[i](iEvent);
                }
            }

            // interactable.onevent listener
            if (isFunction(this[onEvent])) {
                funcName = this[onEvent].name;
                this[onEvent](iEvent);
            }

            // interact.on() listeners
            if (iEvent.type in globalEvents && (listeners = globalEvents[iEvent.type]))  {

                for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {
                    funcName = listeners[i].name;
                    listeners[i](iEvent);
                }
            }

            return this;
        },

        /*\
         * Interactable.on
         [ method ]
         *
         * Binds a listener for an InteractEvent or DOM event.
         *
         - eventType  (string | array | object) The types of events to listen for
         - listener   (function) The function to be called on the given event(s)
         - useCapture (boolean) #optional useCapture flag for addEventListener
         = (object) This Interactable
        \*/
        on: function (eventType, listener, useCapture) {
            var i;

            if (isString(eventType) && eventType.search(' ') !== -1) {
                eventType = eventType.trim().split(/ +/);
            }

            if (isArray(eventType)) {
                for (i = 0; i < eventType.length; i++) {
                    this.on(eventType[i], listener, useCapture);
                }

                return this;
            }

            if (isObject(eventType)) {
                for (var prop in eventType) {
                    this.on(prop, eventType[prop], listener);
                }

                return this;
            }

            if (eventType === 'wheel') {
                eventType = wheelEvent;
            }

            // convert to boolean
            useCapture = useCapture? true: false;

            if (contains(eventTypes, eventType)) {
                // if this type of event was never bound to this Interactable
                if (!(eventType in this._iEvents)) {
                    this._iEvents[eventType] = [listener];
                }
                else {
                    this._iEvents[eventType].push(listener);
                }
            }
            // delegated event for selector
            else if (this.selector) {
                if (!delegatedEvents[eventType]) {
                    delegatedEvents[eventType] = {
                        selectors: [],
                        contexts : [],
                        listeners: []
                    };

                    // add delegate listener functions
                    for (i = 0; i < documents.length; i++) {
                        events.add(documents[i], eventType, delegateListener);
                        events.add(documents[i], eventType, delegateUseCapture, true);
                    }
                }

                var delegated = delegatedEvents[eventType],
                    index;

                for (index = delegated.selectors.length - 1; index >= 0; index--) {
                    if (delegated.selectors[index] === this.selector
                        && delegated.contexts[index] === this._context) {
                        break;
                    }
                }

                if (index === -1) {
                    index = delegated.selectors.length;

                    delegated.selectors.push(this.selector);
                    delegated.contexts .push(this._context);
                    delegated.listeners.push([]);
                }

                // keep listener and useCapture flag
                delegated.listeners[index].push([listener, useCapture]);
            }
            else {
                events.add(this._element, eventType, listener, useCapture);
            }

            return this;
        },

        /*\
         * Interactable.off
         [ method ]
         *
         * Removes an InteractEvent or DOM event listener
         *
         - eventType  (string | array | object) The types of events that were listened for
         - listener   (function) The listener function to be removed
         - useCapture (boolean) #optional useCapture flag for removeEventListener
         = (object) This Interactable
        \*/
        off: function (eventType, listener, useCapture) {
            var i;

            if (isString(eventType) && eventType.search(' ') !== -1) {
                eventType = eventType.trim().split(/ +/);
            }

            if (isArray(eventType)) {
                for (i = 0; i < eventType.length; i++) {
                    this.off(eventType[i], listener, useCapture);
                }

                return this;
            }

            if (isObject(eventType)) {
                for (var prop in eventType) {
                    this.off(prop, eventType[prop], listener);
                }

                return this;
            }

            var eventList,
                index = -1;

            // convert to boolean
            useCapture = useCapture? true: false;

            if (eventType === 'wheel') {
                eventType = wheelEvent;
            }

            // if it is an action event type
            if (contains(eventTypes, eventType)) {
                eventList = this._iEvents[eventType];

                if (eventList && (index = indexOf(eventList, listener)) !== -1) {
                    this._iEvents[eventType].splice(index, 1);
                }
            }
            // delegated event
            else if (this.selector) {
                var delegated = delegatedEvents[eventType],
                    matchFound = false;

                if (!delegated) { return this; }

                // count from last index of delegated to 0
                for (index = delegated.selectors.length - 1; index >= 0; index--) {
                    // look for matching selector and context Node
                    if (delegated.selectors[index] === this.selector
                        && delegated.contexts[index] === this._context) {

                        var listeners = delegated.listeners[index];

                        // each item of the listeners array is an array: [function, useCaptureFlag]
                        for (i = listeners.length - 1; i >= 0; i--) {
                            var fn = listeners[i][0],
                                useCap = listeners[i][1];

                            // check if the listener functions and useCapture flags match
                            if (fn === listener && useCap === useCapture) {
                                // remove the listener from the array of listeners
                                listeners.splice(i, 1);

                                // if all listeners for this interactable have been removed
                                // remove the interactable from the delegated arrays
                                if (!listeners.length) {
                                    delegated.selectors.splice(index, 1);
                                    delegated.contexts .splice(index, 1);
                                    delegated.listeners.splice(index, 1);

                                    // remove delegate function from context
                                    events.remove(this._context, eventType, delegateListener);
                                    events.remove(this._context, eventType, delegateUseCapture, true);

                                    // remove the arrays if they are empty
                                    if (!delegated.selectors.length) {
                                        delegatedEvents[eventType] = null;
                                    }
                                }

                                // only remove one listener
                                matchFound = true;
                                break;
                            }
                        }

                        if (matchFound) { break; }
                    }
                }
            }
            // remove listener from this Interatable's element
            else {
                events.remove(this._element, eventType, listener, useCapture);
            }

            return this;
        },

        /*\
         * Interactable.set
         [ method ]
         *
         * Reset the options of this Interactable
         - options (object) The new settings to apply
         = (object) This Interactable
        \*/
        set: function (options) {
            if (!isObject(options)) {
                options = {};
            }

            this.options = extend({}, defaultOptions.base);

            var i,
                actions = ['drag', 'drop', 'resize', 'gesture'],
                methods = ['draggable', 'dropzone', 'resizable', 'gesturable'],
                perActions = extend(extend({}, defaultOptions.perAction), options[action] || {});

            for (i = 0; i < actions.length; i++) {
                var action = actions[i];

                this.options[action] = extend({}, defaultOptions[action]);

                this.setPerAction(action, perActions);

                this[methods[i]](options[action]);
            }

            var settings = [
                    'accept', 'actionChecker', 'allowFrom', 'deltaSource',
                    'dropChecker', 'ignoreFrom', 'origin', 'preventDefault',
                    'rectChecker', 'styleCursor'
                ];

            for (i = 0, len = settings.length; i < len; i++) {
                var setting = settings[i];

                this.options[setting] = defaultOptions.base[setting];

                if (setting in options) {
                    this[setting](options[setting]);
                }
            }

            return this;
        },

        /*\
         * Interactable.unset
         [ method ]
         *
         * Remove this interactable from the list of interactables and remove
         * it's drag, drop, resize and gesture capabilities
         *
         = (object) @interact
        \*/
        unset: function () {
            events.remove(this._element, 'all');

            if (!isString(this.selector)) {
                events.remove(this, 'all');
                if (this.options.styleCursor) {
                    this._element.style.cursor = '';
                }
            }
            else {
                // remove delegated events
                for (var type in delegatedEvents) {
                    var delegated = delegatedEvents[type];

                    for (var i = 0; i < delegated.selectors.length; i++) {
                        if (delegated.selectors[i] === this.selector
                            && delegated.contexts[i] === this._context) {

                            delegated.selectors.splice(i, 1);
                            delegated.contexts .splice(i, 1);
                            delegated.listeners.splice(i, 1);

                            // remove the arrays if they are empty
                            if (!delegated.selectors.length) {
                                delegatedEvents[type] = null;
                            }
                        }

                        events.remove(this._context, type, delegateListener);
                        events.remove(this._context, type, delegateUseCapture, true);

                        break;
                    }
                }
            }

            this.dropzone(false);

            interactables.splice(indexOf(interactables, this), 1);

            return interact;
        }
    };

    function warnOnce (method, message) {
        var warned = false;

        return function () {
            if (!warned) {
                window.console.warn(message);
                warned = true;
            }

            return method.apply(this, arguments);
        };
    }

    Interactable.prototype.snap = warnOnce(Interactable.prototype.snap,
         'Interactable#snap is deprecated. See the new documentation for snapping at http://interactjs.io/docs/snapping');
    Interactable.prototype.restrict = warnOnce(Interactable.prototype.restrict,
         'Interactable#restrict is deprecated. See the new documentation for resticting at http://interactjs.io/docs/restriction');
    Interactable.prototype.inertia = warnOnce(Interactable.prototype.inertia,
         'Interactable#inertia is deprecated. See the new documentation for inertia at http://interactjs.io/docs/inertia');
    Interactable.prototype.autoScroll = warnOnce(Interactable.prototype.autoScroll,
         'Interactable#autoScroll is deprecated. See the new documentation for autoScroll at http://interactjs.io/docs/#autoscroll');
    Interactable.prototype.squareResize = warnOnce(Interactable.prototype.squareResize,
         'Interactable#squareResize is deprecated. See http://interactjs.io/docs/#resize-square');

    Interactable.prototype.accept = warnOnce(Interactable.prototype.accept,
         'Interactable#accept is deprecated. use Interactable#dropzone({ accept: target }) instead');
    Interactable.prototype.dropChecker = warnOnce(Interactable.prototype.dropChecker,
         'Interactable#dropChecker is deprecated. use Interactable#dropzone({ dropChecker: checkerFunction }) instead');
    Interactable.prototype.context = warnOnce(Interactable.prototype.context,
         'Interactable#context as a method is deprecated. It will soon be a DOM Node instead');

    /*\
     * interact.isSet
     [ method ]
     *
     * Check if an element has been set
     - element (Element) The Element being searched for
     = (boolean) Indicates if the element or CSS selector was previously passed to interact
    \*/
    interact.isSet = function(element, options) {
        return interactables.indexOfElement(element, options && options.context) !== -1;
    };

    /*\
     * interact.on
     [ method ]
     *
     * Adds a global listener for an InteractEvent or adds a DOM event to
     * `document`
     *
     - type       (string | array | object) The types of events to listen for
     - listener   (function) The function to be called on the given event(s)
     - useCapture (boolean) #optional useCapture flag for addEventListener
     = (object) interact
    \*/
    interact.on = function (type, listener, useCapture) {
        if (isString(type) && type.search(' ') !== -1) {
            type = type.trim().split(/ +/);
        }

        if (isArray(type)) {
            for (var i = 0; i < type.length; i++) {
                interact.on(type[i], listener, useCapture);
            }

            return interact;
        }

        if (isObject(type)) {
            for (var prop in type) {
                interact.on(prop, type[prop], listener);
            }

            return interact;
        }

        // if it is an InteractEvent type, add listener to globalEvents
        if (contains(eventTypes, type)) {
            // if this type of event was never bound
            if (!globalEvents[type]) {
                globalEvents[type] = [listener];
            }
            else {
                globalEvents[type].push(listener);
            }
        }
        // If non InteractEvent type, addEventListener to document
        else {
            events.add(document, type, listener, useCapture);
        }

        return interact;
    };

    /*\
     * interact.off
     [ method ]
     *
     * Removes a global InteractEvent listener or DOM event from `document`
     *
     - type       (string | array | object) The types of events that were listened for
     - listener   (function) The listener function to be removed
     - useCapture (boolean) #optional useCapture flag for removeEventListener
     = (object) interact
     \*/
    interact.off = function (type, listener, useCapture) {
        if (isString(type) && type.search(' ') !== -1) {
            type = type.trim().split(/ +/);
        }

        if (isArray(type)) {
            for (var i = 0; i < type.length; i++) {
                interact.off(type[i], listener, useCapture);
            }

            return interact;
        }

        if (isObject(type)) {
            for (var prop in type) {
                interact.off(prop, type[prop], listener);
            }

            return interact;
        }

        if (!contains(eventTypes, type)) {
            events.remove(document, type, listener, useCapture);
        }
        else {
            var index;

            if (type in globalEvents
                && (index = indexOf(globalEvents[type], listener)) !== -1) {
                globalEvents[type].splice(index, 1);
            }
        }

        return interact;
    };

    /*\
     * interact.enableDragging
     [ method ]
     *
     * Deprecated.
     *
     * Returns or sets whether dragging is enabled for any Interactables
     *
     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables
     = (boolean | object) The current setting or interact
    \*/
    interact.enableDragging = warnOnce(function (newValue) {
        if (newValue !== null && newValue !== undefined) {
            actionIsEnabled.drag = newValue;

            return interact;
        }
        return actionIsEnabled.drag;
    }, 'interact.enableDragging is deprecated and will soon be removed.');

    /*\
     * interact.enableResizing
     [ method ]
     *
     * Deprecated.
     *
     * Returns or sets whether resizing is enabled for any Interactables
     *
     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables
     = (boolean | object) The current setting or interact
    \*/
    interact.enableResizing = warnOnce(function (newValue) {
        if (newValue !== null && newValue !== undefined) {
            actionIsEnabled.resize = newValue;

            return interact;
        }
        return actionIsEnabled.resize;
    }, 'interact.enableResizing is deprecated and will soon be removed.');

    /*\
     * interact.enableGesturing
     [ method ]
     *
     * Deprecated.
     *
     * Returns or sets whether gesturing is enabled for any Interactables
     *
     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables
     = (boolean | object) The current setting or interact
    \*/
    interact.enableGesturing = warnOnce(function (newValue) {
        if (newValue !== null && newValue !== undefined) {
            actionIsEnabled.gesture = newValue;

            return interact;
        }
        return actionIsEnabled.gesture;
    }, 'interact.enableGesturing is deprecated and will soon be removed.');

    interact.eventTypes = eventTypes;

    /*\
     * interact.debug
     [ method ]
     *
     * Returns debugging data
     = (object) An object with properties that outline the current state and expose internal functions and variables
    \*/
    interact.debug = function () {
        var interaction = interactions[0] || new Interaction();

        return {
            interactions          : interactions,
            target                : interaction.target,
            dragging              : interaction.dragging,
            resizing              : interaction.resizing,
            gesturing             : interaction.gesturing,
            prepared              : interaction.prepared,
            matches               : interaction.matches,
            matchElements         : interaction.matchElements,

            prevCoords            : interaction.prevCoords,
            startCoords           : interaction.startCoords,

            pointerIds            : interaction.pointerIds,
            pointers              : interaction.pointers,
            addPointer            : listeners.addPointer,
            removePointer         : listeners.removePointer,
            recordPointer        : listeners.recordPointer,

            snap                  : interaction.snapStatus,
            restrict              : interaction.restrictStatus,
            inertia               : interaction.inertiaStatus,

            downTime              : interaction.downTimes[0],
            downEvent             : interaction.downEvent,
            downPointer           : interaction.downPointer,
            prevEvent             : interaction.prevEvent,

            Interactable          : Interactable,
            interactables         : interactables,
            pointerIsDown         : interaction.pointerIsDown,
            defaultOptions        : defaultOptions,
            defaultActionChecker  : defaultActionChecker,

            actionCursors         : actionCursors,
            dragMove              : listeners.dragMove,
            resizeMove            : listeners.resizeMove,
            gestureMove           : listeners.gestureMove,
            pointerUp             : listeners.pointerUp,
            pointerDown           : listeners.pointerDown,
            pointerMove           : listeners.pointerMove,
            pointerHover          : listeners.pointerHover,

            eventTypes            : eventTypes,

            events                : events,
            globalEvents          : globalEvents,
            delegatedEvents       : delegatedEvents,

            prefixedPropREs       : prefixedPropREs
        };
    };

    // expose the functions used to calculate multi-touch properties
    interact.getPointerAverage = pointerAverage;
    interact.getTouchBBox     = touchBBox;
    interact.getTouchDistance = touchDistance;
    interact.getTouchAngle    = touchAngle;

    interact.getElementRect         = getElementRect;
    interact.getElementClientRect   = getElementClientRect;
    interact.matchesSelector        = matchesSelector;
    interact.closest                = closest;

    /*\
     * interact.margin
     [ method ]
     *
     * Deprecated. Use `interact(target).resizable({ margin: number });` instead.
     * Returns or sets the margin for autocheck resizing used in
     * @Interactable.getAction. That is the distance from the bottom and right
     * edges of an element clicking in which will start resizing
     *
     - newValue (number) #optional
     = (number | interact) The current margin value or interact
    \*/
    interact.margin = warnOnce(function (newvalue) {
        if (isNumber(newvalue)) {
            margin = newvalue;

            return interact;
        }
        return margin;
    },
    'interact.margin is deprecated. Use interact(target).resizable({ margin: number }); instead.') ;

    /*\
     * interact.supportsTouch
     [ method ]
     *
     = (boolean) Whether or not the browser supports touch input
    \*/
    interact.supportsTouch = function () {
        return supportsTouch;
    };

    /*\
     * interact.supportsPointerEvent
     [ method ]
     *
     = (boolean) Whether or not the browser supports PointerEvents
    \*/
    interact.supportsPointerEvent = function () {
        return supportsPointerEvent;
    };

    /*\
     * interact.stop
     [ method ]
     *
     * Cancels all interactions (end events are not fired)
     *
     - event (Event) An event on which to call preventDefault()
     = (object) interact
    \*/
    interact.stop = function (event) {
        for (var i = interactions.length - 1; i >= 0; i--) {
            interactions[i].stop(event);
        }

        return interact;
    };

    /*\
     * interact.dynamicDrop
     [ method ]
     *
     * Returns or sets whether the dimensions of dropzone elements are
     * calculated on every dragmove or only on dragstart for the default
     * dropChecker
     *
     - newValue (boolean) #optional True to check on each move. False to check only before start
     = (boolean | interact) The current setting or interact
    \*/
    interact.dynamicDrop = function (newValue) {
        if (isBool(newValue)) {
            //if (dragging && dynamicDrop !== newValue && !newValue) {
                //calcRects(dropzones);
            //}

            dynamicDrop = newValue;

            return interact;
        }
        return dynamicDrop;
    };

    /*\
     * interact.pointerMoveTolerance
     [ method ]
     * Returns or sets the distance the pointer must be moved before an action
     * sequence occurs. This also affects tolerance for tap events.
     *
     - newValue (number) #optional The movement from the start position must be greater than this value
     = (number | Interactable) The current setting or interact
    \*/
    interact.pointerMoveTolerance = function (newValue) {
        if (isNumber(newValue)) {
            pointerMoveTolerance = newValue;

            return this;
        }

        return pointerMoveTolerance;
    };

    /*\
     * interact.maxInteractions
     [ method ]
     **
     * Returns or sets the maximum number of concurrent interactions allowed.
     * By default only 1 interaction is allowed at a time (for backwards
     * compatibility). To allow multiple interactions on the same Interactables
     * and elements, you need to enable it in the draggable, resizable and
     * gesturable `'max'` and `'maxPerElement'` options.
     **
     - newValue (number) #optional Any number. newValue <= 0 means no interactions.
    \*/
    interact.maxInteractions = function (newValue) {
        if (isNumber(newValue)) {
            maxInteractions = newValue;

            return this;
        }

        return maxInteractions;
    };

    interact.createSnapGrid = function (grid) {
        return function (x, y) {
            var offsetX = 0,
                offsetY = 0;

            if (isObject(grid.offset)) {
                offsetX = grid.offset.x;
                offsetY = grid.offset.y;
            }

            var gridx = Math.round((x - offsetX) / grid.x),
                gridy = Math.round((y - offsetY) / grid.y),

                newX = gridx * grid.x + offsetX,
                newY = gridy * grid.y + offsetY;

            return {
                x: newX,
                y: newY,
                range: grid.range
            };
        };
    };

    function endAllInteractions (event) {
        for (var i = 0; i < interactions.length; i++) {
            interactions[i].pointerEnd(event, event);
        }
    }

    function listenToDocument (doc) {
        if (contains(documents, doc)) { return; }

        var win = doc.defaultView || doc.parentWindow;

        // add delegate event listener
        for (var eventType in delegatedEvents) {
            events.add(doc, eventType, delegateListener);
            events.add(doc, eventType, delegateUseCapture, true);
        }

        if (PointerEvent) {
            if (PointerEvent === win.MSPointerEvent) {
                pEventTypes = {
                    up: 'MSPointerUp', down: 'MSPointerDown', over: 'mouseover',
                    out: 'mouseout', move: 'MSPointerMove', cancel: 'MSPointerCancel' };
            }
            else {
                pEventTypes = {
                    up: 'pointerup', down: 'pointerdown', over: 'pointerover',
                    out: 'pointerout', move: 'pointermove', cancel: 'pointercancel' };
            }

            events.add(doc, pEventTypes.down  , listeners.selectorDown );
            events.add(doc, pEventTypes.move  , listeners.pointerMove  );
            events.add(doc, pEventTypes.over  , listeners.pointerOver  );
            events.add(doc, pEventTypes.out   , listeners.pointerOut   );
            events.add(doc, pEventTypes.up    , listeners.pointerUp    );
            events.add(doc, pEventTypes.cancel, listeners.pointerCancel);

            // autoscroll
            events.add(doc, pEventTypes.move, listeners.autoScrollMove);
        }
        else {
            events.add(doc, 'mousedown', listeners.selectorDown);
            events.add(doc, 'mousemove', listeners.pointerMove );
            events.add(doc, 'mouseup'  , listeners.pointerUp   );
            events.add(doc, 'mouseover', listeners.pointerOver );
            events.add(doc, 'mouseout' , listeners.pointerOut  );

            events.add(doc, 'touchstart' , listeners.selectorDown );
            events.add(doc, 'touchmove'  , listeners.pointerMove  );
            events.add(doc, 'touchend'   , listeners.pointerUp    );
            events.add(doc, 'touchcancel', listeners.pointerCancel);

            // autoscroll
            events.add(doc, 'mousemove', listeners.autoScrollMove);
            events.add(doc, 'touchmove', listeners.autoScrollMove);
        }

        events.add(win, 'blur', endAllInteractions);

        try {
            if (win.frameElement) {
                var parentDoc = win.frameElement.ownerDocument,
                    parentWindow = parentDoc.defaultView;

                events.add(parentDoc   , 'mouseup'      , listeners.pointerEnd);
                events.add(parentDoc   , 'touchend'     , listeners.pointerEnd);
                events.add(parentDoc   , 'touchcancel'  , listeners.pointerEnd);
                events.add(parentDoc   , 'pointerup'    , listeners.pointerEnd);
                events.add(parentDoc   , 'MSPointerUp'  , listeners.pointerEnd);
                events.add(parentWindow, 'blur'         , endAllInteractions );
            }
        }
        catch (error) {
            interact.windowParentError = error;
        }

        // prevent native HTML5 drag on interact.js target elements
        events.add(doc, 'dragstart', function (event) {
            for (var i = 0; i < interactions.length; i++) {
                var interaction = interactions[i];

                if (interaction.element
                    && (interaction.element === event.target
                        || nodeContains(interaction.element, event.target))) {

                    interaction.checkAndPreventDefault(event, interaction.target, interaction.element);
                    return;
                }
            }
        });

        if (events.useAttachEvent) {
            // For IE's lack of Event#preventDefault
            events.add(doc, 'selectstart', function (event) {
                var interaction = interactions[0];

                if (interaction.currentAction()) {
                    interaction.checkAndPreventDefault(event);
                }
            });

            // For IE's bad dblclick event sequence
            events.add(doc, 'dblclick', doOnInteractions('ie8Dblclick'));
        }

        documents.push(doc);
    }

    listenToDocument(document);

    function indexOf (array, target) {
        for (var i = 0, len = array.length; i < len; i++) {
            if (array[i] === target) {
                return i;
            }
        }

        return -1;
    }

    function contains (array, target) {
        return indexOf(array, target) !== -1;
    }

    function matchesSelector (element, selector, nodeList) {
        if (ie8MatchesSelector) {
            return ie8MatchesSelector(element, selector, nodeList);
        }

        // remove /deep/ from selectors if shadowDOM polyfill is used
        if (window !== realWindow) {
            selector = selector.replace(/\/deep\//g, ' ');
        }

        return element[prefixedMatchesSelector](selector);
    }

    function matchesUpTo (element, selector, limit) {
        while (isElement(element)) {
            if (matchesSelector(element, selector)) {
                return true;
            }

            element = parentElement(element);

            if (element === limit) {
                return matchesSelector(element, selector);
            }
        }

        return false;
    }

    // For IE8's lack of an Element#matchesSelector
    // taken from http://tanalin.com/en/blog/2012/12/matches-selector-ie8/ and modified
    if (!(prefixedMatchesSelector in Element.prototype) || !isFunction(Element.prototype[prefixedMatchesSelector])) {
        ie8MatchesSelector = function (element, selector, elems) {
            elems = elems || element.parentNode.querySelectorAll(selector);

            for (var i = 0, len = elems.length; i < len; i++) {
                if (elems[i] === element) {
                    return true;
                }
            }

            return false;
        };
    }

    // requestAnimationFrame polyfill
    (function() {
        var lastTime = 0,
            vendors = ['ms', 'moz', 'webkit', 'o'];

        for(var x = 0; x < vendors.length && !realWindow.requestAnimationFrame; ++x) {
            reqFrame = realWindow[vendors[x]+'RequestAnimationFrame'];
            cancelFrame = realWindow[vendors[x]+'CancelAnimationFrame'] || realWindow[vendors[x]+'CancelRequestAnimationFrame'];
        }

        if (!reqFrame) {
            reqFrame = function(callback) {
                var currTime = new Date().getTime(),
                    timeToCall = Math.max(0, 16 - (currTime - lastTime)),
                    id = setTimeout(function() { callback(currTime + timeToCall); },
                  timeToCall);
                lastTime = currTime + timeToCall;
                return id;
            };
        }

        if (!cancelFrame) {
            cancelFrame = function(id) {
                clearTimeout(id);
            };
        }
    }());

    /* global exports: true, module, define */

    // http://documentcloud.github.io/underscore/docs/underscore.html#section-11
    if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = interact;
        }
        exports.interact = interact;
    }
    // AMD
    else if (typeof define === 'function' && define.amd) {
        define('interact', function() {
            return interact;
        });
    }
    else {
        realWindow.interact = interact;
    }

} (typeof window === 'undefined'? undefined : window));

},{}],41:[function(require,module,exports){
'use strict';
// jQuery extensions

module.exports = function () {
    // params
    // toggleClass - required
    // triggerSelector - optional. the selector for the element that triggers the event handler. defaults to the child elements of the list.
    // eventName - optional. defaults to 'click'
    $.fn.toggledList = function (options) {
        if (!options.toggleClass) { return this; }
        var list = this;
        return list.on(options.eventName || 'click', options.triggerSelector || list.children(), function (e) {
            e.preventDefault();
            var classTarget = options.triggerSelector ? $(this).parent() : $(this);
            classTarget.toggleClass(options.toggleClass);
            // execute callback if exists
            if (options.callback) {options.callback();}
        });
    };

    $.fn.syncHeight = function () {
        var arr = $.makeArray(this);
        arr.sort(function (a, b) {
            return $(a).height() - $(b).height();
        });
        return this.height($(arr[arr.length - 1]).height());
    };

    $.fn.center = function(loaded, eventNameSpace) {
        var elements = this;
        var body_width = parseInt($(window).width());
        var body_height = parseInt($(window).height());

        elements.each(function() {
            var $el = $(this);
            var block_width = parseInt($el.width());
            var block_height = parseInt($el.height());
            var stopCentering = false;

            var left_position = parseInt((body_width / 2) - (block_width / 2)  + $(window).scrollLeft());
            if (body_width < block_width) {
                left_position = 0
            }
            var top_position = parseInt((body_height / 2) - (block_height / 2) + $(window).scrollTop());
            if (body_height < block_height) {
                stopCentering = true;
            }

            if(!loaded) {
                $el.css({ 'position': 'absolute' });
                $el.css({ 'left': left_position, 'top': top_position });
                $el.center(true);

                var resizeEvent = eventNameSpace ? 'resize.' + eventNameSpace : 'resize';
                var scrollEvent = eventNameSpace ? 'scroll.' + eventNameSpace : 'scroll';

                if (eventNameSpace) {
                    $(window).off(resizeEvent);
                    $(window).off(scrollEvent);
                }

                $(window).on(resizeEvent, function() {
                    $el.center(true);
                });

                $(window).on(scrollEvent, function() {
                    $el.center(true);
                });

            } else {
                if (!stopCentering) {
                    $el.stop();
                    $el.css({'position': 'absolute'});
                    $el.animate({'left': left_position, 'top': top_position}, 200, 'linear');
                }
            }
        });
    }
};

},{}],42:[function(require,module,exports){
'use strict';

var dialog = require('./dialog'),
    page = require('./page'),
    validator = require('./validator'),
    floatLabel = require('./float-labels');

var login = {
    /**
     * @private
     * @function
     * @description init events for the loginPage
     */
    init: function () {
        //o-auth binding for which icon is clicked
        $('.oAuthIcon').off('click').on('click', function (e) {
            $('.OAuthProvider').val(this.id);
        });
    

        //toggle the value of the rememberme checkbox
        $('#dwfrm_login_rememberme').bind('change', function () {
            if ($('#dwfrm_login_rememberme').attr('checked')) {
                $('#rememberme').val('true');
            } else {
                $('#rememberme').val('false');
            }
        });
        
        $('#password-reset').on('click', function (e) {
            e.preventDefault();

            dialog.open({
                url: $(e.target).attr('href'),
                options: {
                    open: function () {
                        validator.init();
                        var $requestPasswordForm = $('[name$="_requestpassword"]');
                        var $submit = $requestPasswordForm.find('[name$="_requestpassword_send"]');

                        $($submit).on('click', function (e) {
                            if (!$requestPasswordForm.valid()) {
                                return;
                            }
                            e.preventDefault();
                            var data = $requestPasswordForm.serialize();
                            // add form action to data
                            data += '&' + $submit.attr('name') + '=';
                            // make sure the server knows this is an ajax request
                            if (data.indexOf('ajax') === -1) {
                                data += '&format=ajax';
                            }
                            $.ajax({
                                type: 'POST',
                                url: $requestPasswordForm.attr('action'),
                                data: data,
                                success: function (response) {
                                    if (typeof response === 'object' &&
                                            !response.success &&
                                            response.error === 'CSRF Token Mismatch') {
                                        page.redirect(Urls.csrffailed);
                                    } else if (typeof response === 'string') {
                                        dialog.$container.html(response);
                                        $('.close-button').on('click', function () {
                                            dialog.close();
                                        });
                                    }
                                },
                                failure: function () {
                                    dialog.$container.html('<h1>' + Resources.SERVER_ERROR + '</h1>');
                                }
                            });
                        });
                    }
                }
            });
        });
        
        var $twitterError = $('.twitter-oauth-error').detach();
        $('.social-login').after($twitterError);
        $twitterError.show();
    }
};

module.exports = login;

},{"./dialog":34,"./float-labels":36,"./page":44,"./validator":83}],43:[function(require,module,exports){
'use strict';

var util = require('./util'),
    bonusProductsView = require('./bonus-products-view');

var miniCartDelay = 5000;

var timer = {
    id: null,
    clear: function () {
        if (this.id) {
            window.clearTimeout(this.id);
            delete this.id;
        }
    },
    start: function (duration, callback) {
        this.id = setTimeout(callback, duration);
    }
};

var minicart = {
    init: function () {
        this.$el = $('#mini-cart');
        this.$content = this.$el.find('.mini-cart-content');
        this.$cartLink = this.$el.find('.mini-cart-link');
        this.$viewBagLink = this.$el.find('.mini-cart-link-cart');

        this.whileScrolling = function() {
            timer.clear();
        }

        this.scrollComplete = function() {
            timer.clear();
            timer.start(miniCartDelay, this.close.bind(this));
        }

        $('.mini-cart-products').mCustomScrollbar({
            callbacks:{
                whileScrolling:this.whileScrolling.bind(this),
                onScroll:this.scrollComplete.bind(this)
            }
        });

        $('.mini-cart-product').eq(0).find('.mini-cart-toggle').addClass('fa-caret-down');
        $('.mini-cart-product').not(':first').addClass('collapsed')
            .find('.mini-cart-toggle').addClass('fa-caret-right');

        $('.mini-cart-toggle').on('click', function () {
            $(this).toggleClass('fa-caret-down fa-caret-right');
            $(this).closest('.mini-cart-product').toggleClass('collapsed');
        });

        this.$cartLink.on('mouseenter touchstart', function () {
            if (this.$content.not(':visible')) {
                this.slide();
            }
        }.bind(this));

        this.$cartLink.on('click', function(e) {
            if ($(this).hasClass('mini-cart-empty')) {
                e.preventDefault();
                location.href = $(this).attr('rel');
            }
        });

        this.$viewBagLink.on('click', function() {
            app.triggerUISCartCheck('cart');
        });

        this.$content.find('.mini-cart-close').on('click', function(e) {
            this.close();
        }.bind(this));

        this.$content.on('mouseover', function () {
            timer.clear();
        }.bind(this));

        this.$content.on('mouseleave', function() {
            timer.clear();
            timer.start(miniCartDelay, this.close.bind(this));
        }.bind(this));
    },
    /**
     * @function
     * @description Shows the given content in the mini cart
     * @param {String} A HTML string with the content which will be shown
     */
    show: function (html) {
        this.$el.html(html);
        util.scrollBrowser(0);
        this.init();
        this.slide();
        bonusProductsView.loadBonusOption();
    },
    /**
     * @function
     * @description Slides down and show the contents of the mini cart
     */
    slide: function () {
        timer.clear();
        // show the item
        this.$content.slideDown('slow');
        // after a time out automatically close it
        timer.start(miniCartDelay, this.close.bind(this));
    },
    /**
     * @function
     * @description Closes the mini cart with given delay
     * @param {Number} delay The delay in milliseconds
     */
    close: function (delay) {
        timer.clear();
        this.$content.slideUp(delay);
    }
};

module.exports = minicart;

},{"./bonus-products-view":28,"./util":82}],44:[function(require,module,exports){
'use strict';

var util = require('./util');

var page = {
    title: '',
    type: '',
    params: util.getQueryStringParams(window.location.search.substr(1)),
    redirect: function (newURL) {
        setTimeout(function () {
            window.location.href = newURL;
        }, 0);
    },
    refresh: function () {
        setTimeout(function () {
            window.location.assign(window.location.href);
        }, 500);
    }
};

module.exports = page;

},{"./util":82}],45:[function(require,module,exports){
'use strict';

var giftcert = require('../giftcert'),
    tooltip = require('../tooltip'),
    util = require('../util'),
    dialog = require('../dialog'),
    page = require('../page'),
    login = require('../login'),
    validator = require('../validator'),
    floatlabels = require('../float-labels'),
    TPromise = require('promise'),
    _ = require('lodash');

/**
 * @function
 * @description Initializes the events on the address form (apply, cancel, delete)
 * @param {Element} form The form which will be initialized
 */
function initializeAddressForm(validate) {
    var $form = $('#edit-address-form');
    var validate = (typeof validate === 'boolean') ? validate : false;

    $form.find('input[name="format"]').remove();
    tooltip.init();

    var $img = $('.tooltip-image-normal');
	var $hoverImg = $('.tooltip-image-hover');
    $form.find('.form-field-tooltip').each(function () {
    	var $tooltip = $(this).find('.tooltip');
    	if(!$tooltip.find('.tooltip-image').length){
	    	var $children = $tooltip.children().detach();
	    	$tooltip.empty();
	    	$tooltip.append($img);
	    	$tooltip.append($hoverImg);
	    	$tooltip.append($children);
    	}
    	$tooltip.on('click', function (e) {
        	e.preventDefault();
        });
    });

    //$("<input/>").attr({type:"hidden", name:"format", value:"ajax"}).appendTo(form);

    $form.on('click', '.apply-button', function (e) {
        e.preventDefault();
        if (!$form.valid()) {
            return false;
        }
        var url = util.appendParamToURL($form.attr('action'), 'format', 'ajax');
        var applyName = $form.find('.apply-button').attr('name');
        var options = {
            url: url,
            data: $form.serialize() + '&' + $(this).attr('name') + '=x',
            type: 'POST',
            dateType: "html"
        };

        $.ajax(options).done(function (data) {
            if (data == "success") {
                dialog.close();
                page.refresh();
            } else {
            	$('#dialog-container').html(data);
            	initializeAddressForm(true);
            }
        });

    })
    .on('click', '.cancel-button, .close-button', function (e) {
        e.preventDefault();
        dialog.close();
    })
    .on('click', '.delete-button', function (e) {
        e.preventDefault();
        if (window.confirm(String.format(Resources.CONFIRM_DELETE, Resources.TITLE_ADDRESS))) {
            var url = util.appendParamsToUrl(Urls.deleteAddress, {
                AddressID: $form.find('#addressid').val(),
                format: 'ajax'
            });
            $.ajax({
                url: url,
                method: 'POST',
                dataType: 'json'
            }).done(function (data) {
                if (data.status.toLowerCase() === 'ok') {
                    dialog.close();
                    page.refresh();
                } else if (data.message.length > 0) {
                    window.alert(data.message);
                    return false;
                } else {
                    dialog.close();
                    page.refresh();
                }
            });
        }
    })
    .on('change', '.input-text.phone', validator.formatter.phone);
    $('.input-text.phone').trigger('change');

    var $stateEmptyOptionEl = $form.find('.state-field-container select option:first-child');
    var stateEmptyOptionHtml = $('<div>').append($stateEmptyOptionEl.clone())
        .html();
    $form.on('change', 'select.country', function() {
        util.changeStateField($(this).val(), $form, stateEmptyOptionHtml);
    });
    $form.find('select.country').trigger('change');

    validator.init();
    floatlabels.init();
    util.initZipService($form);

    $('.ui-dialog-titlebar-close').blur();

    if (validate) {
    	$form.valid();
    }
}
/**
 * @private
 * @function
 * @description Toggles the list of Orders
 */
function toggleFullOrder () {
    $('.order-items')
        .find('li.hidden:first')
        .prev('li')
        .append('<a class="toggle">View All</a>')
        .children('.toggle')
        .click(function () {
            $(this).parent().siblings('li.hidden').show();
            $(this).remove();
        });
}
/**
 * @private
 * @function
 * @description Binds the events on the address form (edit, create, delete)
 */
function initAddressEvents() {
    var addresses = $('#addresses');
    if (addresses.length === 0) {
    	return;
    }

    addresses.on('click', '.address-edit, .address-create', function (e) {
    	var $form = $('#edit-address-form');
    	$form.find("input, textarea, select").val("");
        e.preventDefault();
        var width = (window.innerWidth < 708) ? (window.innerWidth - 40).toString() : '668';
        dialog.open({
            url: this.getAttribute('popup-href'),
            options: {
            	'width': width,
                open: initializeAddressForm,
                dialogClass: "addressbook-modal"
            }
        });

    }).on('click', '.delete', function (e) {
        e.preventDefault();
        if (window.confirm(String.format(Resources.CONFIRM_DELETE, Resources.TITLE_ADDRESS))) {
            $.ajax({
                url: util.appendParamToURL($(this).attr('href'), 'format', 'ajax'),
                dataType: 'json'
            }).done(function (data) {
                if (data.status.toLowerCase() === 'ok') {
                    page.redirect(Urls.addressesList);
                } else if (data.message.length > 0) {
                    window.alert(data.message);
                } else {
                    page.refresh();
                }
            });
        }
    });
}
/**
 * @private
 * @function
 * @description Binds the events of the payment methods list (delete card)
 */
function initPaymentEvents() {
    $('.add-card').on('click', function (e) {
        e.preventDefault();
        var width = 668;
        if(window.innerWidth < 768){
        	width = window.innerWidth - 57;
        }
        dialog.open({
            url: $(e.target).attr('href'),
            options: {
                open: initializePaymentForm,
                close: function(){
                	$('#current-card-type-img').remove();
                	$('#CreditCardForm').find('#dwfrm_paymentinstruments_creditcards_newcreditcard_expirationdate').parent().find('div.error').remove();
                },
                dialogClass: "paymentinstruments-modal",
                'width': width
            }
        });
    });

    var paymentList = $('.payment-list');
    if (paymentList.length === 0) { return; }

    util.setDeleteConfirmation(paymentList, String.format(Resources.CONFIRM_DELETE, Resources.TITLE_CREDITCARD));

    $('form[name="payment-remove"]').on('submit', function (e) {
        e.preventDefault();
        // override form submission in order to prevent refresh issues
        var button = $(this).find('.delete');
        $('<input/>').attr({
            type: 'hidden',
            name: button.attr('name'),
            value: button.attr('value') || 'delete card'
        }).appendTo($(this));
        var data = $(this).serialize();
        $.ajax({
            type: 'POST',
            url: $(this).attr('action'),
            data: data
        })
        .done(function () {
            page.redirect(Urls.paymentsList);
        });
    });
}
//function RemovePaymentImg() {}
function initializePaymentForm() {
	var $form = $('#CreditCardForm');
	var $expdate = $('#dwfrm_paymentinstruments_creditcards_newcreditcard_expirationdate');
	var $hiddenmonth = $('#dwfrm_paymentinstruments_creditcards_newcreditcard_month');
	var $hiddenyear = $('#dwfrm_paymentinstruments_creditcards_newcreditcard_year');
	$form.on('click', '#applyBtn', function (e) {
    	e.preventDefault();
    	if (!$form.valid()) {
            return false;
        }
        var ccInput = $form.find('.form-row:nth-child(3) input');
    	ccInput.val(ccInput.val().replace(/\s/g, ''));
        var url = util.appendParamToURL($form.attr('action'), 'format', 'ajax');
        var applyName = $form.find('#applyBtn').attr('name');

        // take data from single expiration field and populate hidden fields for validation and payment instrument creation
        $hiddenmonth.val($expdate.val().split(' / ')[0].replace('0', ''));
        $hiddenyear.val('20' + $expdate.val().split(' / ')[1]);

        var options = {
            url: url,
            data: $form.serialize() + '&' + $(this).attr('name') + '=x',
            type: 'POST',
            dateType: "html"
        };

        $.ajax(options).done(function (data) {
            if (data == "success") {
                dialog.close();
                page.refresh();
            } else {
            	//page.redirect(Urls.csrffailed);
            	if (data.error == "CREDITCARD_INVALID_EXPIRATION_DATE") {
            		showFormError($('.form-row:nth-child(6)'));
            		showFormError($('.form-row:nth-child(7)'));
            	}
            	if (data.error == "CREDITCARD_INVALID_CARD_NUMBER") {
            		showFormError($('.form-row:nth-child(3)'));
            	}
            }
        });
    }).on('click', '.cancel-button', function (e) {
        e.preventDefault();
        dialog.close();
    });


	$('.form-row input').blur(function(){
		$(this).valid();
	});

    function selectHiddenCreditCardYear($selectFieldYear, year) {
    	if(year > 2026) {
    		$selectFieldYear.val(2014);
    	}
    	else {
    		$selectFieldYear.val(year);
    	}
    }

    function selectHiddenCreditCardMonth($selectFieldMonth, month) {
    	if(month > 12) {
    		$selectFieldMonth.val(1);
    	}
    	else {
    		$selectFieldMonth.val(month);
    	}
    }

    function getMonth($textBoxExpirationDate) {
    	var month = 1;

    	if($textBoxExpirationDate && $textBoxExpirationDate.val().length > 1) {
    		month = parseInt($textBoxExpirationDate.val().substring(0, 2));
    	}

    	return month;
    }

    function getYear($textBoxExpirationDate) {
    	var year = 2014;

    	if($textBoxExpirationDate && $textBoxExpirationDate.val().length == 7)
    		year = parseInt("20" + $textBoxExpirationDate.val().substring(5, 7));

    	return year;
    }

    function selectHiddenCreditCardOption ($selectField, creditCardType) {
    	$selectField.val(creditCardType);
    }

    function getCreditCardType(creditCardNumber) {
    	// Default credit card type to Visa.
    	var creditCardType = "";

    	// Ensure credit card number has a minimum of three digits.
    	// Default to Visa again just in case it was never set.
    	if(creditCardNumber.length > 3) {

    		if (/^(5[1-5]|2[2-7][0-9])/.test(creditCardNumber))
    			creditCardType = "Master";
    		else if (/^4/.test(creditCardNumber))
    			creditCardType = "Visa";
    		else if (/^3[47]/.test(creditCardNumber))
    			creditCardType = "Amex";
    		else if (/^(6011|622(12[6-9]|1[3-9][0-9]|[2-8][0-9]{2}|9[0-1][0-9]|92[0-5]|64[4-9])|65)/.test(creditCardNumber))
    			creditCardType = "Discover";
    		else
    			creditCardType = "Visa"
    	} else {
    		creditCardType = "";
    	}

    	// Return the credit card type.
    	return creditCardType;
    }

    function getCreditCardNumber($textBox) {
    	return $textBox.val();
    }

    function allowOnlyIntegersOn($textBox) {
    	$textBox.keydown(function (e) {
    		// Return true if key stroke is a number.
    		// Otherwise, return false.
            var isNumber = (e.shiftKey || (e.keyCode >= 48 && e.keyCode <=57) || (e.keyCode >= 96 && e.keyCode <=105));

    		// Return true if key stroke is a backspace, delete, tab, escape, and/or enter
    		// Otherwise, return false.
    		var allowedKey1 = $.inArray(e.keyCode, [46, 8, 9, 27, 13, 110, 190]) !== -1;

    		// Return true if key stroke is Ctrl+A or Command+A
    		// Otherwise, return false.
    		var allowedKey2 = (e.keyCode === 65 && (e.ctrlKey === true || e.metaKey === true));

    		// Return true if key stroke is home, end, left, right, down, or up.
    		// Otherwise, return false.
    		var allowedKey3 = (e.keyCode >= 35 && e.keyCode <= 40);

            // Do not do anything if the current key stroke is one of the
    		// allowed keys.
            if (allowedKey1 || allowedKey2 || allowedKey3)
    			return;

    		// Do not allow key press if the user input is not a number.
            if (!isNumber)
    			e.preventDefault();
        });
    }

    // credit card form type auto-detect and expiration date format
    var creditCardNumber = "";
	var $textBox = $(".form-row:nth-child(3) .input-text");
	var $selectField = $('#dwfrm_paymentinstruments_creditcards_newcreditcard_type');
	var $textBoxExpirationDate = $("#dwfrm_paymentinstruments_creditcards_newcreditcard_expirationdate");
	var $selectFieldMonth = $("#dwfrm_paymentinstruments_creditcards_newcreditcard_month");
	var $selectFieldYear = $("#dwfrm_paymentinstruments_creditcards_newcreditcard_year");

	// Only allow integers on the credit card number
	// text box field.
	allowOnlyIntegersOn($textBox);

	var $currentCardType = $('#current-card-type').detach();
	$('.form-row:nth-child(3)').append($currentCardType);
	$currentCardType.append("<img id='current-card-type-img'/>");
	var $cardImg = $('#current-card-type-img');

	// Key Up Event for the Credit Card Number Text Box Field
	$textBox.on('keyup blur', function (e) {
		var creditCardNumber = getCreditCardNumber($textBox);
		var creditCardType = getCreditCardType(creditCardNumber);
		selectHiddenCreditCardOption($selectField, creditCardType);

		var selectedTypeURL = $cardImg.attr("src");
		var selectedTypeAlt = $cardImg.attr("alt");

		if(creditCardType == "Visa"){
			selectedTypeURL = visaURL;
			selectedTypeAlt = creditCardType;
		}else if(creditCardType == "Master"){
			selectedTypeURL = mastercardURL;
			selectedTypeAlt = "MasterCard";
		}else if(creditCardType == "Amex"){
			selectedTypeURL = americanexpressURL;
			selectedTypeAlt = "American Express";
		}else if(creditCardType == "Discover"){
			selectedTypeURL = discoverURL;
			selectedTypeAlt = "Discover";
		}
		if($(this).val() && creditCardType != '') {
			$cardImg.attr("src", selectedTypeURL, "alt", selectedTypeAlt);
		} else {
			$cardImg.attr("src", '', "alt", '');
		}
	});

	$textBox.mask("0000  0000  0000  0000", { watchInputs: true });


	// Only allow integers on the credit card number
	// text box field.
	allowOnlyIntegersOn($textBoxExpirationDate);


	// Key Up Event for the Credit Card's Expiration Date
	$textBoxExpirationDate.on('keyup blur', function (e) {
            // Get year from input field
        var yearData =  $textBoxExpirationDate.val().substr(4, 3);
            // Get Month from input field
        var monthData = $textBoxExpirationDate.val().substr(0, 2);
            // Get current year
        var currentYear =  new Date().getFullYear();
            // Get current month
        var currentMonth = new Date().getMonth();
            // Get allowed year range
        var allowYear = currentYear + 9;
            // Create year
        yearData = '20'+parseInt(yearData);
            // Assign selected month and year to hidden month/year fields
        selectHiddenCreditCardMonth($selectFieldMonth, monthData);
        selectHiddenCreditCardYear($selectFieldYear, yearData);

            // Make sure user has entered in date
        if (yearData.length == 4 && parseInt(monthData) > 0 && parseInt(monthData) < 13) {
                // Make sure credit card date isn't expired

        	if ( (yearData == currentYear && monthData >= currentMonth) || (yearData <= allowYear && yearData > currentYear) ) {
                $textBoxExpirationDate.addClass('valid').next('.error').text('');
            } else {
                $textBoxExpirationDate.removeClass('valid').next('.error').removeClass('valid').text(Resources.INVALID_EXPIRATION);
            }
        } else {
            $textBoxExpirationDate.removeClass('valid').next('.error').removeClass('valid').text(Resources.MISSING_EXPIRATION);
        }

	});

	// Mask the Credit Card's Expiration Date
	$textBoxExpirationDate.mask("00 / 00", { watchInputs: true });

	$('.form-row:has(select)').hide();

	floatlabels.init();
	validator.init();
}

function preferredStoreTemplate(store) {
    var newLine = '\n';

    return [
        '<li>',
        '    <div class="store">',
        '        <div class="store-information">',
        '            <div class="store-name">' + store.name + '</div>',
        '            <div class="store-address">',
        '                <div>' + store.address1 + '</div>',
        '                <div>' + store.city + ((store.stateCode) ? ', ' + store.stateCode : ''),
        '                     ' + store.postalCode,
        '                </div>',
        '                <div>' + store.countryCode + '</div>',
                         ((store.phone) ? '<div class="store-phone">' + store.phone + '</div>' : ''),
        '            </div>',
        '        </div>',
        '    </div>',
        '</li>'
    ].join(newLine);
}

function storeTemplate(store, preferredStoreID) {
    var newLine = '\n';

    // Remove all HTML after two <br> elements from store hours
    var storeHoursOnly = store.storeHours.split(/<br\s*\/*>\s*<br\s*\/*>/)[0];

    var storeHoursParts = storeHoursOnly.split(/<br\s*\/*>/);
    var storeHoursStacked = storeHoursParts.join('<br/>');
    var storeHoursLong = storeHoursParts.join(', \u00A0');

    return [
        '<li class="store-tile store-tile-id-' + store.storeId + (store.storeId === preferredStoreID ? ' selected' : '') + '"' +
            ' data-store-id="' + store.storeId + '">',
            ((store.storeId === preferredStoreID) ? '<span class="preferred-shop-msg">' + 'your preferred shop' + '</span>' : ''),
        '    <button class="select-store-radio" data-store-id="' + store.storeId + '"' +'>',
        '    </button>',
        '    <div class="store-primary-info">',
        '        <p class="store-name">',
        '            ' + store.name + '<br/>',
        '        </p>',
        '        <p class="store-address">',
        '            ' + store.address1 + '<br/>',
        '            ' + store.city + ', ' + store.stateCode + ' ' + store.postalCode,
        '        </p>',
        '    </div>',
        '    <div class="store-secondary-info">',
        '        <p class="store-hours-stacked">' + storeHoursStacked + '</p>',
        '        <p class="store-hours-long">' + storeHoursLong + '</p>',
        '    </div>',
        '    <a class="store-map-toggle">' + 'MAP' + '</a>',
        '    <div class="store-map-container">',
        '       <div class="store-map"></div>',
        '    </div>',
        '</li>'
    ].join(newLine);
}

function validateZipCode(zipCode) {
    var regexes = {
            canada: /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJKLMNPRSTVWXYZ]( )?\d[ABCEGHJKLMNPRSTVWXYZ]\d$/i,
            usa: /^\d{5}(-\d{4})?$/
        };
    var valid = false;
    if (!zipCode) { return false; }

    _.each(regexes, function(re) {
        var regexp = new RegExp(re);
        valid = regexp.test(zipCode);
    });

    return valid;
}

var nearestStore = {
    DISPLAY_STORES_COUNT: 3,
    $cache: {},

    init: function() {
        var $container = $('#search-stores-container');
        this.$cache = {
            container: $container,
            storeList: $container.find('.store-list'),
            storeCounter: $container.find('.store-counter'),
            zipInput: $container.find('.zip-input'),
            distanceInput: $container.find('.distance-input'),
            distanceLabel: $container.find('.distance-input-label'),
            preferredStores: $('.js-preferred-store-list')
        };

        this.initEvents();
        this.updateDistanceLabel();
    },

    openDialog: function() {
        var self = this;

        TPromise.resolve(
            $.ajax({
                url: Urls.accountSearchStores,
                dataType : 'json'
            })
        ).then(function(response) {
            self.updateDialog(response);
            var dialogWidth = (window.innerWidth < 708) ? (window.innerWidth).toString() : '668';

            dialog.open({
                target: $('#search-stores-container'),
                options: {
                    buttons: [{
                        text: Resources.UPDATE_MY_STORE,
                        click: function () {
                            self.setStore();
                        }
                    }],
                    dialogClass: 'account-search-stores-dialog',
                    width: dialogWidth
                }
            });
        });
    },

    updateDialog: function (data) {
        var self = this;

        // Update store list
        var stores = data.kateStores.slice(0, this.DISPLAY_STORES_COUNT);
        var storeListHTML = _.map(stores, function(store) {
            return storeTemplate(store, data.preferredStoreID);
        });
        this.$cache.storeList.empty()
            .html(storeListHTML);

        // Bind full stores data to DOM elements
        _.each(stores, function(store) {
            self.$cache.storeList.find('.store-tile-id-' + store.storeId)
                .data('sourceObj', store);
        });


        // Update stores counter
        var storeCount = stores.length;
        this.$cache.storeCounter.text(storeCount);

        // Update zip code value if needed
        if (data.defaultZip) {
            this.$cache.zipInput.val(data.defaultZip);
        }
    },

    initEvents: function() {
        var self = this;
        var $container = this.$cache.container;

        $('.js-account-setup-preferred-store').on('click', function() {
            self.openDialog();
        });

        $container.on('click', '.select-store-radio', function(e) {
            e.preventDefault();

            var $storeTile = $(this).closest('.store-tile');
            if (!$storeTile.hasClass('selected')) {
                self.$cache.storeList.find('.store-tile.selected').removeClass('selected');
                $storeTile.addClass('selected');
            }
        });

        $container.on('click', '.store-map-toggle', function(e) {
            e.preventDefault();

            var $this = $(this);
            var $storeTile = $this.closest('.store-tile');
            var $mapContainer = $storeTile.find('.store-map');

            $mapContainer.toggle();
            $this.toggleClass('visible');
            $storeTile.find('.store-map-container')
                .toggleClass('visible');

            if ($mapContainer.children().length === 0) {
                var map = new google.maps.Map($mapContainer[0], {
                    zoom: 8
                });

                var geocoder = new google.maps.Geocoder();
                var address = $storeTile.find('.store-address')[0].innerText;
                geocoder.geocode({'address': address}, function(results, status) {
                    if (status === 'OK') {
                        map.setCenter(results[0].geometry.location);
                        var marker = new google.maps.Marker({
                            map: map,
                            position: results[0].geometry.location
                        });
                    } else {
                        console.error('Geocode was not successful for the following reason: ' + status);
                    }
                });
            }
        });

        $container.on('submit', '#showStoresForm', function(e) {
            e.preventDefault();
            self.updateStores();
        });

        this.$cache.distanceInput.on('change', function() {
            self.updateDistanceLabel();
            self.updateStores();
        });
    },

    updateStores: function() {
        var self = this;

        var zipCode = this.$cache.zipInput.val();
        var maxDistance = this.$cache.distanceInput.val();
        if (!validateZipCode(zipCode)) {
            return;
        }

        var url = util.appendParamsToUrl(Urls.accountSearchStores, {
            zip: zipCode,
            distance: maxDistance
        });

        TPromise.resolve($.ajax({
            dataType: 'json',
            url: url
        })).then(function(response) {
            self.updateDialog(response);
        });
    },

    updateDistanceLabel: function() {
        var value = this.$cache.distanceInput.find('option:selected').attr('value');
        this.$cache.distanceLabel.text('Radius: ' + value + ' miles');
    },

    setStore: function() {
        var self = this;

        var $selectedStore = this.$cache.storeList.find('.store-tile.selected');
        if ($selectedStore.length) {
            var storeId = $selectedStore.data('store-id');
            var url = util.appendParamsToUrl(Urls.setNearestStore, {
                storeId: storeId
            });

            TPromise.resolve(
                $.ajax({
                    url: url,
                    dataType : 'json'
                })
            ).then(function(response) {
                if (response.success) {
                    self.updatePreferredStore($selectedStore.data('sourceObj'));
                    $('.unselected-nearest-store-header').html(Resources.NEAREST_STORE_SELECTED_HEADER).removeClass('unselected-nearest-store-header');
                    $('.unselected-nearest-store-button').html(Resources.NEAREST_STORE_EDIT).removeClass('unselected-nearest-store-button');
                    dialog.close();
                }
            })
        }
    },

    updatePreferredStore: function(store) {
        var storeHtml = preferredStoreTemplate(store);
        this.$cache.preferredStores.html(storeHtml);
    }
};

function initPersonalEvents() {
	$('#account-personaldata .edit-link').on("click", function(e){
		e.preventDefault();
		dialog.open({
			url: this.getAttribute('popup-href'),
			callback: function() {
				initializeInfoForm();
				initializePasswordForm();
			},
			options: {
				'width' : window.innerWidth < 768 ? window.innerWidth - 40 : 668,
				'height' : 'auto',
				'dialogClass': "personaldata-modal"
			}
		});
	});
}

//functions for order history
function initOrderHistory(){
	$('.order-details-linkback').click(function(e){
		e.preventDefault();
		window.history.go(-1);
	});
}

//ACCOUNT EDIT INFO - PERSONAL INFO FORM LOADED VIA AJAX
function initializeInfoForm() {
	var form = $("#personalEditInfo");
	var dateFields = ["#dwfrm_profile_customer_birthMonth", "#dwfrm_profile_customer_birthDay", "#dwfrm_profile_customer_birthYear"];

	// Clear form of errors and focus
	app.util.formBlur(form);
	$('#dwfrm_profile_customer_newemail').attr('value', customerEmailAddress);
	$('#dwfrm_profile_customer_newemailconfirm').attr('value', customerEmailAddress);
	floatlabels.init();

	form.validate({
		groups: {
			date: "dwfrm_profile_customer_birthMonth dwfrm_profile_customer_birthDay dwfrm_profile_customer_birthYear"
		},
		rules: {
			"dwfrm_profile_customer_birthMonth": {
				multidate: dateFields
			},
			"dwfrm_profile_customer_birthDay": {
				multidate: dateFields
			},
			"dwfrm_profile_customer_birthYear": {
				multidate: dateFields
			}
		},
		messages: {
			"dwfrm_profile_customer_firstname": {
				required: app.resources.MISSING_FIRST_NAME
			},
			"dwfrm_profile_customer_lastname": {
				required: app.resources.MISSING_LAST_NAME
			},
			"dwfrm_profile_customer_email": {
				required: app.resources.MISSING_EMAIL
			},
			"dwfrm_profile_customer_emailconfirm": {
				required: app.resources.MISSING_EMAILCONFIRM
			},
			"dwfrm_profile_login_password": {
				required: app.resources.MISSING_PASSWORD
			},
			"dwfrm_profile_login_passwordconfirm": {
				required: app.resources.MISSING_PASSWORDCONFIRM
			},
			"dwfrm_profile_customer_zip": {
				required: app.resources.MISSING_POSTAL
			},
			"dwfrm_profile_customer_birthMonth": {
				multidate: app.resources.BIRTHDATE_INVALID
			},
			"dwfrm_profile_customer_birthDay": {
				multidate: app.resources.BIRTHDATE_INVALID
			},
			"dwfrm_profile_customer_birthYear": {
				multidate: app.resources.BIRTHDATE_INVALID
			}
		},
		errorClass : 'error',
		errorElement : 'span',
		ignore: ":hidden:not(.replaced)",
		onkeyup : false,
		onfocusout : function (element) {
			if(!this.checkable(element)) {
				this.element(element);
			}
		},
		highlight : function(element, errorClass, validClass) {
			if (element.type === 'radio') {
				this.findByName(element.name).addClass(errorClass).removeClass(validClass);
			} else {
				$(element).addClass(errorClass).removeClass(validClass);
				if(element.type === 'select-one'){
					var $element = $(element);
					if($element.attr('id') && $element.hasClass('replaced')){
						var selectBox = $('#' + $element.attr('id') + 'SelectBoxItContainer');
						if(selectBox){
							selectBox.addClass(errorClass).removeClass(validClass);
						}
					}
				}
			}
			if ($(element).attr('id') === "dwfrm_profile_customer_birthMonth"
					|| $(element).attr('id') === "dwfrm_profile_customer_birthDay"
					|| $(element).attr('id') === "dwfrm_profile_customer_birthYear") {
				$(dateFields[0]).removeClass(errorClass);
				$(dateFields[1]).removeClass(errorClass);
				$(dateFields[2]).removeClass(errorClass);
				$("#errors").empty();
			}
		},
		unhighlight : function(element, errorClass, validClass) {
			if (element.type === 'radio') {
				this.findByName(element.name).removeClass(errorClass).addClass(validClass);
			} else {
				$(element).removeClass(errorClass).addClass(validClass);
				if(element.type === 'select-one'){
					var $element = $(element);
					if($element.attr('id') && $element.hasClass('replaced')){
						var selectBox = $('#' + $element.attr('id') + 'SelectBoxItContainer');
						if(selectBox){
							selectBox.removeClass(errorClass).addClass(validClass);
						}
					}
				}
			}
			if ($(element).attr('id') === "dwfrm_profile_customer_birthMonth"
					|| $(element).attr('id') === "dwfrm_profile_customer_birthDay"
					|| $(element).attr('id') === "dwfrm_profile_customer_birthYear") {
				$(dateFields[0]).removeClass(errorClass);
				$(dateFields[1]).removeClass(errorClass);
				$(dateFields[2]).removeClass(errorClass);
				$("#errors").empty();
			}
		},
		showErrors: function (errorMap, errorList) {
			this.defaultShowErrors();

			var birthdateError = "";
			if (errorMap.hasOwnProperty("dwfrm_profile_customer_birthMonth")) {
				birthdateError = errorMap["dwfrm_profile_customer_birthMonth"];
			} else if (errorMap.hasOwnProperty("dwfrm_profile_customer_birthDay")) {
				birthdateError = errorMap["dwfrm_profile_customer_birthDay"];
			} else if (errorMap.hasOwnProperty("dwfrm_profile_customer_birthYear")) {
				birthdateError = errorMap["dwfrm_profile_customer_birthYear"];
			}

			if (birthdateError != "") {
				$("#errors").html('<span class="error" generated="true" for="date">' + birthdateError + '</span>');
				$(dateFields[0]).addClass("error");
				$(dateFields[1]).addClass("error");
				$(dateFields[2]).addClass("error");
			}
		}
	});

	validator.initForm(form);

	form.on("click", ".apply-button", function(e) {
		// Stop the form from submitting (which causes the pipeline to redirect elsewhere)
		e.preventDefault();

		if($('#dwfrm_profile_customer_newemail').val() != "" && $('#dwfrm_profile_customer_newemailconfirm').val() == ""){
			$('#dwfrm_profile_customer_newemailconfirm').val(customerEmailAddress);
			$('#dwfrm_profile_login_currentpassword__newemail').val($('#dwfrm_profile_login_currentpassword__newpassword').val());
		}

		if (!(($(dateFields[0]).val() == "" && $(dateFields[1]).val() == "" && $(dateFields[2]).val() == "") ||
				($(dateFields[0]).val() != "" && $(dateFields[1]).val() != "" && $(dateFields[2]).val() != ""))) {
			// User has put in only a partial birthdate and we should error
			$("#errors").html('<span class="error" generated="true" for="date">' + app.resources.BIRTHDATE_INVALID + '</span>');
			$(dateFields[0]).addClass("error");
			$(dateFields[1]).addClass("error");
			$(dateFields[2]).addClass("error");
			return false;
		}

		validator.initForm(form);
		if (!form.valid()) {
			return;
		}
		app.util.formsubmit(form, jQuery(this), "html", function(response) {
			// success
			if($.trim(response.toString()) == 'success') page.refresh();
			// Failure
			else {
				$('#personaldata-edit-info').empty().html(response);
				initializeInfoForm();
			}
		});
	});
};

//ACCOUNT EDIT INFO - PERSONAL INFO FORM LOADED VIA AJAX
function initializePasswordForm() {
	var form = $("#personalEditPassword");
	// Clear form of errors and focus
	app.util.formBlur(form);
	floatlabels.init();

	validator.initForm("#personalEditPassword", {
        rules: {
            "dwfrm_profile_login_newpassword": {
            	rangelength: [7, 20]
            },
            "dwfrm_profile_login_newpasswordconfirm": {
            	rangelength: [7, 20],
            	equalTo: "#dwfrm_profile_login_newpassword"
            }
        },
        messages: {
            "dwfrm_profile_login_newpassword": {
                required: Resources.MISSING_PASSWORD,
                rangelength: Resources.VALIDATE_RANGELENGTH,
                equalTo: Resources.VALIDATE_INVALID_PASSMATCH
            }
        },
        errorClass : 'error',
        errorElement : 'span',
        ignore: ":hidden:not(.replaced)",
        onkeyup : false,
        onfocusout : function (element) {
            if(!this.checkable(element)) {
                this.element(element);
            }
        }
    });

	form.on("click", ".apply-button", function(e) {
		// Stop the form from submitting (which causes the pipeline to redirect elsewhere)
		e.preventDefault();
		util.formsubmit(form, jQuery(this), "html", function(response) {
			// success
			if($.trim(response.toString()) == 'success') page.refresh();
			// Failure
			else {
				$('#personaldata-edit-password').empty().html(response);
				initializePasswordForm();
			}
		});
	})
	.on('click', '.cancel-button', function(e){
		e.preventDefault();
		dialog.close();
	});
}

function showFormError($row){
	var $input  = $row.find('input');
	var span = "<span class='error invalid-form-icon'></span>";
	$input.addClass('error');
	$input.after(span);
	$input.blur(function(){
		$row.find('.invalid-form-icon').remove();
	});
}

/**
 * @private
 * @function
 * @description Binds the events of the order, address and payment pages
 */
function initializeEvents() {
    toggleFullOrder();
    initAddressEvents();
    initPaymentEvents();
    initPersonalEvents();
    initOrderHistory();
    login.init();
}

var account = {
    init: function () {
        initializeEvents();
        giftcert.init();
        nearestStore.init();
    },
    initCartLogin: function () {
        login.init();
    }
};

module.exports = account;

},{"../dialog":34,"../float-labels":36,"../giftcert":38,"../login":42,"../page":44,"../tooltip":81,"../util":82,"../validator":83,"lodash":5,"promise":6}],46:[function(require,module,exports){
'use strict';

var account = require('./account'),
    bonusProductsView = require('../bonus-products-view'),
    quickview = require('../quickview'),
    selectBoxIt = require('../selectboxit'),
    cartStoreInventory = require('../storeinventory/cart'),
    util = require('../util'),
    $cache = {},
    SFL_PAGE_SIZE = 5;

/**
 * @private
 * @function
 * @description Binds events to the cart page (edit item's details, bonus item's actions, coupon code entry)
 */
function initializeEvents() {
    $('#cart-table').on('click', '.item-edit-details a', function (e) {
        e.preventDefault();
        var isGC = $(e.target).hasClass('giftCard') ? 'giftCard' : '';
        //Very specific case for making inputs outside of dialog available
        $.widget( "ui.dialog", $.ui.dialog, {
            _allowInteraction: function( event ) {
                return !!$( event.target ).is( "input" ) || this._super( event );
            }
        });
        quickview.show({
            url: e.target.href,
            source: 'cart',
            customClass: 'ui-dialog_update-item ' + isGC,
            callback: function () {
                var price = $('.e-gift-card .product-price').text().trim();
                $('.e-gift-card .swatches li').each(function () {
                   var currentPrice = $(this).find('a').data('combined');
                   if(currentPrice == price) {
                       $('.e-gift-card .swatches li').removeClass('selected');
                       $(this).addClass('selected');
                   }
                });
                $('.e-gift-card').on('click', '.swatches.Color li', function () {
                    $('.product-options-gift-card #gcAmountselect .selected a').trigger('click');
                });
             }
        });
    })
    .on('click', '.bonus-item-actions a, .item-details .bonusproducts a', function (e) {
        e.preventDefault();
        bonusProductsView.show(this.href);
    });

    //render White Glove Block
    var $targetBlock = $('.white-glove-block .tooltip > .tooltip-content');
    var targetContent = $targetBlock.find('.tooltip-content').html();
    $targetBlock.empty();
    $targetBlock.html(targetContent);

    // override enter key for coupon code entry
    $('form input[name$="_couponCode"]').on('keydown', function (e) {
        if (e.which === 13 && $(this).val().length === 0) { return false; }
    });

    //to prevent multiple submissions of the form when removing a product from the cart
    var removeItemEvent = false;
    $('button[name$="deleteProduct"]').on('click', function (e) {
    	var productID = $(this).data('pid');
    	
        if (removeItemEvent) {
            e.preventDefault();
        } else {
            removeItemEvent = true;
        }
        if (dataLayer) {
            var ecommerce = null;
            for (var i = 0; i < dataLayer.length; i++) {
                if ('ecommerce' in dataLayer[i]) {
                    ecommerce = dataLayer[i].ecommerce;
                    break;
                }
            }
            if (ecommerce != undefined && 'checkout' in ecommerce && 'products' in ecommerce.checkout) {
                var p;
                for (var i = 0; i < ecommerce.checkout.products.length; i++) {
                    p = ecommerce.checkout.products[i];
                    if (p.id == productID){

                        dataLayer.push(app.datalayer.getEvent("event","ecomRemove", "ecommerce", " ", "remove", [p]));
                        break;
                    }
                }
            }
        }
    });
    /*Script for unusial position of control button on Shopping Cart page*/
    if ($('.item-edit-details').length && $('.item-user-actions').length) {
        $('.cart-row').each( function (){
            var current = $(this).find('.item-edit-details');
            var place = $(this).find('.item-user-actions');
            var actionbox = $(this).find('.action-box');
            var mobileheader = $(this).find('.mobile-header');
            current.prependTo(place);
            place.clone().prependTo(actionbox);
            $(this).find('.sku').clone().prependTo(mobileheader);
            $(this).find('.name').clone().prependTo(mobileheader);
        });
    }
    /**/
    $('.item-details button').on('click', function (e){
         var xOffset = 24;
         var yOffset = 24;
         var elemnt = $(this);
         $(this).fadeOut('fast');
         var bgTop = 0;
         var frames = 5;
         var frameSize = 32;
         var frameRate = 100;
         for(i=1;i<frames;i++) {
             bgTop -= frameSize;
             var f = function (i) {
                setTimeout(function () {
                        poof.css('background-position','0 -' + i*frameSize + 'px');
                }, i*frameRate);
            }

            f(i);
         }

        setTimeout(function () {
            elemnt.closest('.cart-row').hide();
            elemnt.closest('.cart-row').next('.final-sale-row').hide();
        }, frames * frameRate);
    });

    // Save for later lazy loading
    $cache.sfl = {
        footerEl: $('#footer-wrapper #footer')[0],
        tableEl: $('.js-sfl-table'),
        loaderEl: $('.savedforlater-wrapper .sfl-loader'),
        responseContainer: $('<div>'),
        isRequestPending: false
    };
    

    function loadAllSflItems() {
        var totalQty = Number($cache.sfl.tableEl.attr('data-sfl-total-qty')),
            showItemsQty = Number($cache.sfl.tableEl.attr('data-sfl-show-items-qty')),
            requestUrl = $cache.sfl.tableEl.attr('data-sfl-load-url');

        if (totalQty > showItemsQty) {
            var startIdx = showItemsQty;
            var endIdx = startIdx + SFL_PAGE_SIZE - 1;
            if (endIdx >= totalQty || $('body').width() < 768) {
                endIdx = totalQty - 1;
            }

            $cache.sfl.isRequestPending = true;
            $cache.sfl.loaderEl.addClass('sfl-loader-visible');
            loadSflItems({
                startIdx: startIdx,
                endIdx: endIdx,
                requestUrl: requestUrl,
                showItemsQty: showItemsQty
            });
            $('#sfl-mobile-loader').css('display', 'none');
        }
    }

    $(window).on('scroll.sflLazyLoad', function() {
            var isFooterVisible = $cache.sfl.footerEl && util.elementInViewport($cache.sfl.footerEl);

            if (isFooterVisible && !$cache.sfl.isRequestPending && $cache.sfl.tableEl.length > 0 && $('body').width() > 767) {
                loadAllSflItems();
            }
    });
    $('body').on('click', '#sfl-mobile-loader', function () {
        loadAllSflItems();
    });

    // Fixed cart summary
    $cache.fixedTotals = {
        totalsEl: $('#cart-items-form .cart-footer'),
        header: $('.pt_cart > .top-banner'),
        placeholder: $('#cart-items-form .cart-footer-placeholder'),
        isFixed: false,
        isInitialized: false
    };

    function initCartTotals() {
        if ($cache.fixedTotals.totalsEl.length === 0) return;

        var windowWidth = $(window).width();

        if (windowWidth > 960) {
            makeTotalsStatic();
            calcTotalsPosition();
            removeTotalsEvenListeners();
            addTotalsEvenListeners();
            $cache.fixedTotals.isInitialized = true;
        } else {
            if ($cache.fixedTotals.isInitialized) {
                makeTotalsStatic();
                removeTotalsEvenListeners();
                $cache.fixedTotals.isInitialized = false;
            }
        }
    }

    function makeTotalsStatic() {
        $cache.fixedTotals.isFixed = false;
        $cache.fixedTotals.placeholder.removeClass('cart-footer-placeholder-visible');
        $cache.fixedTotals.totalsEl
            .css({
                left: '',
                top: '',
                width: ''
            })
            .removeClass('cart-totals-fixed');
    }

    function makeTotalsFixed() {
        $cache.fixedTotals.isFixed = true;
        $cache.fixedTotals.placeholder.addClass('cart-footer-placeholder-visible');
        $cache.fixedTotals.totalsEl
            .css({
                width: $cache.fixedTotals.width,
                left: $cache.fixedTotals.offsetLeft,
                top: $cache.fixedTotals.header.height() + 20
            })
            .addClass('cart-totals-fixed');
    }

    function calcTotalsPosition() {
        $cache.fixedTotals.width =  $cache.fixedTotals.totalsEl.width();
        $cache.fixedTotals.height = $cache.fixedTotals.totalsEl.height();
        $cache.fixedTotals.offsetLeft = $cache.fixedTotals.totalsEl.offset().left;
        $cache.fixedTotals.scrollTrigger = $cache.fixedTotals.height + $cache.fixedTotals.totalsEl.offset().top;
        $cache.fixedTotals.placeholder.height($cache.fixedTotals.height)
            .width($cache.fixedTotals.width);
    }

    function addTotalsEvenListeners() {
        $(window).on('scroll.cart.fixedTotals', handleFixedTotals);
    }

    function removeTotalsEvenListeners() {
        $(window).off('scroll.cart.fixedTotals');
    }

    function handleFixedTotals() {
        if ($(window).scrollTop() > $cache.fixedTotals.scrollTrigger) {
            if (!$cache.fixedTotals.isFixed) {
                makeTotalsFixed();
            }
        } else if ($cache.fixedTotals.isFixed) {
            makeTotalsStatic();
        }
    }
    function stickyBlock() {
        if (window.innerWidth > 960) {
            $('.cart-footer').stick_in_parent().on("sticky_kit:bottom", function() {
                $(this).addClass('bottom');
            }).on("sticky_kit:unbottom", function() {
                $(this).removeClass('bottom');
            })
        }
    }
    $(window).load(function(){
        stickyBlock();
    });

    function loadSflItems(options) {
        $.ajax({
            type : 'GET',
            url : options.requestUrl,
            data : {
                sfl_start: options.startIdx,
                sfl_end: options.endIdx
            },
            dataType : 'html',
            success : function(response) {
                $cache.sfl.responseContainer.html(response);
                var responseTableEl = $cache.sfl.responseContainer.find('.js-sfl-table');
                var responseShowItemsQty = Number(responseTableEl.attr('data-sfl-show-items-qty'));

                $cache.sfl.tableEl.attr('data-sfl-show-items-qty', options.showItemsQty + responseShowItemsQty);
                var newSflItems = responseTableEl.children('tbody').children();
                newSflItems
                    .addClass('sfl-item-hidden')
                    .appendTo($cache.sfl.tableEl.children('tbody'));

                $cache.sfl.loaderEl.removeClass('sfl-loader-visible');
                $cache.sfl.isRequestPending = false;

                window.setTimeout(function() {
                    newSflItems.removeClass('sfl-item-hidden');
                }, 0);
            }
        });
    }

    $('.tip').on('mouseenter', function(){
        var $this = $(this);
        if(!$cache.tip) {
            $cache.tip = $('#tooltip');
        }
        var cnt = $($this.data('content'));
        var width = $this.data('width');
        var ctop = $this.offset().top;
        var cleft = $this.offset().left;
        var align = $this.data('align');
        if(!align){
            align = '';
        }

        // Populate tip with content
        $cache.tip.find('.body').html(cnt.html())
        // Adjust width
        if (width) {
            $cache.tip.css('width',width);
        }

        // Adjust position
        if (align.indexOf('right') >= 0) {
            // right align
            if (align.indexOf('innerright') < 0) {
                // for side right, add width of element and 5 pixels for spacing
                cleft = cleft + $this.outerWidth() + 5;
            }
        }
        else {
            // left align
            // subtract width of tip box
            cleft = cleft - $cache.tip.outerWidth();
            if (align.indexOf('innerleft') >= 0) {
                // for inner left, subtract width of element
                cleft = cleft + $this.outerWidth();
            }
            else {
                // default to left outer align
                // for outer left, subtract extra 5 pixels for spacing
                cleft = cleft - 5;
            }
        }
        if (align.indexOf('bottom') >= 0) {
            // bottom align
            if (align.indexOf('innerbottom') < 0) {
                // for outer bottom (aka bottom), add element height and extra 5 pixels for spacing
                ctop = ctop + $this.outerHeight() +5;
            }
        }
        else {
            // for backwards compatiblity, default to 20 pixels up from top of element
            ctop = ctop - 20;
        }

        // Position tip
        $cache.tip.css({'left': cleft, 'top': ctop})
        $cache.tip.stop(clearQueue, jumpToEnd).show();
        var mouseOnTrigger = true;

    }).on('mouseleave', function(){
        tooltipClosing();
        var mouseOnTrigger = false;
    });
    
    if ($('.js-cart-coupon-code').find('.error').length > 0) {
        $('.js-cart-coupon-code').addClass('expanded');

        $('.js-cart-coupon-code input').on('focus.cart.coupon', function() {
            addCouponFieldEvents();
        });
    }

    $('body').on('click', '.js-cart-coupon-toggle', function() {
        $('.js-cart-coupon-code').addClass('expanded');
        addCouponFieldEvents();
    });

    function addCouponFieldEvents() {
        $('body').on('click.cart.coupon', function(e) {
            var $target = $(e.target);
            var isTargetInCouponContainer = $target.closest('.js-cart-coupon-code').length > 0;
            if (!isTargetInCouponContainer) {
                $('.js-cart-coupon-code').removeClass('expanded');
                $('body').off('click.cart.coupon');
                $('.js-cart-coupon-code input').off('focus.cart.coupon');
            }
        });
    }

    /**
     * @listener
     * @description Listens to the select event on the cart product quantity field and updates the cart when triggered
     */
    $('select[name$="_quantity"]').on('change', function () {
        $('button[name$="updateCart"]').trigger('click');
    });
}

exports.init = function () {
    initializeEvents();
    selectBoxIt.selectBoxIt($('.cart-quantity'));
    if (SitePreferences.STORE_PICKUP) {
        cartStoreInventory.init();
    }
    account.initCartLogin();
};

},{"../bonus-products-view":28,"../quickview":69,"../selectboxit":73,"../storeinventory/cart":76,"../util":82,"./account":45}],47:[function(require,module,exports){
'use strict';

var util = require('../../util'),
    validator = require('../../validator'),
    shipping = require('./shipping');
var isCheckingTI = 0;

function checkIfSameAsSavedAddress()
{
	if (isCheckingTI) {
		window.clearTimeout(isCheckingTI);
	}
	
	isCheckingTI = window.setTimeout(doCheckIfSameAsSavedAddress, 500);
}

function doCheckIfSameAsSavedAddress() {
    var $form = $('.shipping-form form.address');
	var $addressList = $('select[name$="_addressList"]', $form);
	
	if ($addressList.length == 0) {
		return false;
	}
	
	var $placeHolderElement = null;
	var hasIdenticalAddress = false;
	
	$('option', $addressList).each(function () {
		var $option = $(this);
		var address = $option.data('address');
		
		if (!address) {
			$placeHolderElement = $option;
		} else if (isIdentical(address, $form)) {
			selectAddress($addressList, $option);
			hasIdenticalAddress = true;
			return false;
		}
	});
	
	if (!hasIdenticalAddress && $placeHolderElement) {
		selectAddress($addressList, $placeHolderElement);
	}
}

function selectAddress($addressList, $option)
{
	$addressList.on('change', supressEvents);
	$option.prop('selected', true);
	$addressList.val($option.attr('value'));
	$addressList.off('change', supressEvents);
}

function supressEvents(event)
{
	event.preventDefault();
	event.stopPropagation();
	
	return false;
}

function isIdentical(address, $form) {
    var identical = true;
    var $field = null;
    for (var field in address) {
        if (field === 'ID' || field === 'UUID' || field === 'key' || field === 'type') {
            continue;
        }
        if (address[field] === null) {
        	address[field] = '';
        }
        var $field = $form.find('[name$="' + field.replace('Code', '') + '"]');
        if ($field.length > 0) {
            identical = identical && $field.val() == address[field];
        }
        if (field === 'postalCode') {
        	$field = $form.find('input.postal');
        	if ($field.length > 0) {
                identical = identical && ($field.val() == address[field] || $field.val() == address['zip']);
        	}
        }
        if (field === 'countryCode') {
        	$field = $form.find('[name$="country"]');
        	if ($field.length > 0) {
                identical = identical && $field.val() == address.countryCode.toUpperCase();
        	}
            $field = $form.find('[name$="state"]');
        	if ($field.length > 0) {
                identical = identical && $field.val() == address.stateCode;
        	}
            $field = $form.find('[name$="zip"]');
        	if ($field.length > 0) {
                identical = identical && ($field.val() == address.postalCode || $field.val() == address.zip);
        	}
        }
        if (field === 'phone') {
        	$field = $('.input-text.phone');
        	if ($field.length > 0) {
            	identical = identical && $field.val() == address.phone;
        	}
        }
        if (!identical) {
        	return false;
        }
    }
    
    return true;
}

function addAddressListener()
{
	var $form = $('.shipping-form form.address');
	var $addressList = $('select[name$="_addressList"]', $form);
	var inputs = [
			$form.find('[name$="country"]'),
			$form.find('[name$="state"]'),
			$form.find('[name$="zip"]'),
			$form.find('input.postal'),
			$form.find('[name$="address1"]'),
			$form.find('[name$="address2"]'),
			$form.find('[name$="city"]'),
			$form.find('[name$="sameshipping"]'),
			$form.find('[name$="firstName"]'),
			$form.find('[name$="lastName"]'),
			$('.input-text.phone')
			];
	for (var i = 0; i < inputs.length; i++) {
		if (inputs[i].length > 0) {
			inputs[i].on('change', checkIfSameAsSavedAddress);
		}
	}
	$form.find('[name$="sameshipping"]').on('change', function () {
		if ($(this).prop('checked')) {
			$addressList.prop('disabled', true).addClass('disabled');
		} else {
			$addressList.prop('disabled', false).removeClass('disabled');
		}
		
	});
	if ($form.find('[name$="sameshipping"]').prop('checked')) {
		$addressList.prop('disabled', true).addClass('disabled');
	} else {
		$addressList.prop('disabled', false).removeClass('disabled');
	}
}

/**
 * @function
 * @description Selects the first address from the list of addresses
 */
exports.init = function () {
    var $form = $('.address');

    // Select address from list
    $('select[name$="_addressList"]', $form).on('change', function () {
        $form.on('change', '.input-text.phone', validator.formatter.phone);

        var selected = $(this).children(':selected').first();
        var selectedAddress = $(selected).data('address');
        var $billingAddressFields = $('#billing-address-fields');
        $(this).addClass('selected');

        if (!selectedAddress) {
        	$billingAddressFields.show();
        	return;
        }
        var $stateEmptyOptionEl = $form.find('.state-field-container select option:first-child');
        var stateEmptyOptionHtml = $('<div>').append($stateEmptyOptionEl.clone())
            .html();
        util.changeStateField(selectedAddress.countryCode, $form, stateEmptyOptionHtml);
        util.fillAddressFields(selectedAddress, $form);
        shipping.updateShippingMethodList();
        util.selectUnfloat();
        if($form.find("select[id$='_state']").val() && $form.find("select[id$='_state']").val().length > 0) {
            $form.find("select[id$='_state']").change();
        }
        $('[name$="shippingAddress_save"], [name$="billing_save"]').removeAttr('disabled');
        $('.input-text.phone').trigger('change');
    });
    
    checkIfSameAsSavedAddress();
    addAddressListener();
};

},{"../../util":82,"../../validator":83,"./shipping":53}],48:[function(require,module,exports){
'use strict';

var ajax = require('../../ajax'),
	dialog = require('../../dialog'),
    formPrepare = require('./formPrepare'),
    giftcard = require('../../giftcard'),
    util = require('../../util'),
    progress = require('../../progress'),
	page = require('../../page'),
    validator = require('../../validator'),
	shipping = require('./shipping');

var $checkoutForm = $('.checkout-billing');
var $avsContainer = $("#avsDiv");

/****************************************************************************************************************/
/*										POPULATE STATE TEXT BOX IF SAME AS SHIPPING							    */
/****************************************************************************************************************/

function populateStateTextBox() {
	if($('#dwfrm_billing_sameshipping').is(':checked')) {
	    populateBillingWithShipping(); 
	}
}

/****************************************************************************************************************/
/*										ON PAGE LOAD ERROR HANDLING FOR CREDIT CARD							    */
/****************************************************************************************************************/

function HandleCreditCardValidationOnPageLoad() {

	// Credit Card Number Elements
	var $creditCardNumberContainer = $('.credit-card-number');
	var $creditCardField = $creditCardNumberContainer.find('input');

	// CVN Elements
	var $cvnContainer = $('.cvn');
	var $cvnField = $cvnContainer.find('input');

	// Expiration Date Elements
	var $expirationDateField = $("#dwfrm_billing_paymentMethods_creditCard_expirationdate");
	var $selectFieldMonth = $("#dwfrm_billing_paymentMethods_creditCard_month");
	var $selectFieldYear = $("#dwfrm_billing_paymentMethods_creditCard_year");
	var month = getMonth($expirationDateField);
	var year = getYear($expirationDateField);

	// Handle Fields: Credit Card and CVN on Page Load
	handleFieldValidationOnPageLoad($creditCardNumberContainer, $creditCardField);
	handleFieldValidationOnPageLoad($cvnContainer, $cvnField);

	// Set Expiration Date
	setExpirationDateOnPageLoad($selectFieldMonth, month, $selectFieldYear, year);

	// Clear Expiration Date if Expired
	clearExpirationDateIfExpired();
} 

function clearExpirationDateIfExpired() {
	if($('.sgx-expiration-date').find('.month').hasClass('error') || $('.sgx-expiration-date').find('.year').hasClass('error')) {
		$('.expiration-date').find('input').val('');
		$('.expiration-date').find('input').blur();
	}
}

function setExpirationDateOnPageLoad($selectFieldMonth, month, $selectFieldYear, year) {
	selectHiddenCreditCardMonth($selectFieldMonth, month);
	selectHiddenCreditCardYear($selectFieldYear, year);
}

function handleFieldValidationOnPageLoad($container, $field, spanErrorId) {
	setFieldEventOnBlur($field, spanErrorId);
	addErrorsOnFieldIfNotValid($container, $field);
}

function addErrorsOnFieldIfNotValid($container, $field) {
	if(containerHasError($container)) {
		addErrorClassToField($field);
		addErrorSpanAfterField($field);
	}
}

function setFieldEventOnBlur($field) {
	$field.blur(function() {
		removeSpanIfValid($field.next('span'));
	});
}

function removeSpanIfValid($span) {
	if(spanIsValid($span)) {
		removeSpan($span);
	}
}

function removeSpan($span) {
	$span.next('span').remove();
}

function spanIsValid($span) {
	return $span.hasClass('valid');
}

function containerHasError($container) {
	return $container.hasClass('error');
}

function addErrorClassToField($field) {
	$field.addClass('error');
}

function addErrorSpanAfterField($field) {
	$("<span></span>").insertAfter($field).addClass('error');
}

/****************************************************************************************************************/
/*										SAME AS SHIPPING CHECKBOX FUNCTIONALITY									*/
/****************************************************************************************************************/

/**
 * @function
 * @description This is the event handler when a user checks or unchecks the same as shipping checkbox. 
 *              When a user checks (enables) this check box - the billing address fields will be populated 
 *              with the shipping address data. 
 *              Otherwise, when the check box is not checked (disabled) the previous address data will be restored. 
 * @param Takes no parameters. 
 */

if ($('#dwfrm_billing_sameshipping:checked').length) {
    $('#billing-address-fields').hide();
}

$('#dwfrm_billing_sameshipping').change(function() {
    // Populate the billing address form with data based on the current state
    // of the same as shipping check box.
    if(this.checked) {

        // Store any input that was entered by the user into hidden fields.
    	// This data will be used to repopulate the billing address fields if a
    	// user unchecks the same as shipping text box.
        saveCurrentBillingAddress();

        // Populate the billing address form with shipping address data.
	    populateBillingWithShipping();
	    $('#billing-address-fields').hide();
    }
    else {
    	populateBillingWithPreviousData();
    	$('#billing-address-fields').show();
    }

    // Always validate the form after the same as shipping check box has been checked.
    formPrepare.validateForm();
    if ($('#my-bag-toggle-button').hasClass('fa-minus')) {
        $('#my-bag-toggle-button').trigger('click');
    }
});

/**
 * @function
 * @description Grabs the hidden fields which contain the previously entered shipping address data from the 
 *              shipping page. This is then used to populate the billing address form address fields since 
 *              the user just checked the same as shipping check box.
 * @param Takes no parameters.
 */
function saveCurrentBillingAddress() {
	
	$('#billing-first-name').val($('#dwfrm_billing_billingAddress_addressFields_firstName').val());
	$('#billing-last-name').val($('#dwfrm_billing_billingAddress_addressFields_lastName').val());
	$('#billing-address1').val($('#dwfrm_billing_billingAddress_addressFields_address1').val());
	$('#billing-address2').val($('#dwfrm_billing_billingAddress_addressFields_address2').val());
	$('#billing-city').val($('#dwfrm_billing_billingAddress_addressFields_city').val());
	$('#billing-zip-code').val($('#dwfrm_billing_billingAddress_addressFields_zip').val());
	$('#billing-state').val($('#dwfrm_billing_billingAddress_addressFields_states_state').val().trim());
	$('#billing-country').val($('#dwfrm_billing_billingAddress_addressFields_country').val());
	$('#billing-phone').val($('#dwfrm_billing_billingAddress_addressFields_phone').val());
	
	setIsSavedBillingState();
} 

/**
 * @function
 * @description Grabs the hidden fields which contain the previously entered shipping address data from the 
 *              shipping page. This is then used to populate the billing address form address fields since 
 *              the user just checked the same as shipping check box.
 * @param Takes no parameters.
 */
function populateBillingWithPreviousData() {
	if (isSavedBillingState()) {
		$('#dwfrm_billing_billingAddress_addressFields_firstName').val($('#billing-first-name').val());
		$('#dwfrm_billing_billingAddress_addressFields_lastName').val($('#billing-last-name').val());
		$('#dwfrm_billing_billingAddress_addressFields_address1').val($('#billing-address1').val());
		$('#dwfrm_billing_billingAddress_addressFields_address2').val($('#billing-address2').val());
		$('#dwfrm_billing_billingAddress_addressFields_city').val($('#billing-city').val());
		$('#dwfrm_billing_billingAddress_addressFields_zip').val($('#billing-zip-code').val());
		$('#dwfrm_billing_billingAddress_addressFields_states_state').val($('#billing-state').val().trim().toUpperCase());
		$('#dwfrm_billing_billingAddress_addressFields_country').val($('#billing-country').val().trim().toUpperCase());
		$('#dwfrm_billing_billingAddress_addressFields_phone').val($('#billing-phone').val());
	}
} 

/**
 * @function 
 * @description Determines whether the hidden billing data cache fields have been updated with data
 * 				besides for empty strings.
 * @param Take no parameters
 */
function isSavedBillingState() {
	return $('#billing-has-saved-data').val().length > 0;
}

/**
 * @function 
 * @description Sets the billing-has-saved-data field to a truthy value if the hidden billing data cache 
 * 				fields contain information other than an empty string. Otherwise it sets the field to a 
 * 				falsey value.
 * @param Take no parameters
 */
function setIsSavedBillingState() {
	var isSavedState = false;
	isSavedState |= $('#billing-first-name').val().length > 0;
	isSavedState |= $('#billing-last-name').val().length > 0;
	isSavedState |= $('#billing-address1').val().length > 0;
	isSavedState |= $('#billing-address2').val().length > 0;
	isSavedState |= $('#billing-city').val().length > 0;
	isSavedState |= $('#billing-zip-code').val().length > 0;
	isSavedState |= $('#billing-state').val().length > 0;
	isSavedState |= $('#billing-country').val().length > 0;
	isSavedState |= $('#billing-phone').val().length > 0;
	
	if (isSavedState) {
		$('#billing-has-saved-data').val('true');
	} else {
		$('#billing-has-saved-data').val('');
	}
}

/**
 * @function
 * @description Grabs the hidden fields which contain the previously entered shipping address data from the 
 *              shipping page. This is then used to populate the billing address form address fields since 
 *              the user just checked the same as shipping check box.
 * @param Takes no parameters.
 */
function populateBillingWithShipping() {
	var zipCodeValue = $('#shipping-zip-code').text();

	if(zipCodeValue !== undefined) {
		$('#dwfrm_billing_billingAddress_addressFields_zip').val(zipCodeValue.trim()).blur();
	}
	$('#dwfrm_billing_billingAddress_addressFields_firstName').val($('#shipping-first-name').text()).blur();
	$('#dwfrm_billing_billingAddress_addressFields_lastName').val($('#shipping-last-name').text()).blur();
	$('#dwfrm_billing_billingAddress_addressFields_address1').val($('#shipping-address1').text()).blur();
	$('#dwfrm_billing_billingAddress_addressFields_address2').val($('#shipping-address2').text()).blur();
	$('#dwfrm_billing_billingAddress_addressFields_city').val($('#shipping-city').text()).blur();
	$('#dwfrm_billing_billingAddress_addressFields_states_state').val($('#shipping-state').text().trim().toUpperCase()).blur();
	$('#dwfrm_billing_billingAddress_addressFields_country').val($('#shipping-country').text().trim().toUpperCase()).blur();
	$('#dwfrm_billing_billingAddress_addressFields_phone').val($('#shipping-phone').text()).blur();
	var shippingEmail = $('#shipping-email').text();
	if (shippingEmail.trim()) {
		$('#dwfrm_billing_billingAddress_email_emailAddress').val(shippingEmail).blur();
	}
} 

/****************************************************************************************************************/
/*										CREDIT CARD METHODS														*/
/****************************************************************************************************************/

/**
 * @function
 * @description Selects the appropriate year based on the user input within the expiration date field
 * @param jQuery Select Field Object for the Expiration Year
 */
function selectHiddenCreditCardYear($selectFieldYear, year) { 
	if(year > 2026) {
		$selectFieldYear.val(2014);
	}
	else {
		$selectFieldYear.val(year);
	}
}

/**
 * @function
 * @description Selects the appropriate month based on the user input within the expiration date field
 * @param jQuery Select Field Object for the Expiration Month
 */
function selectHiddenCreditCardMonth($selectFieldMonth, month) { 
	if(month > 12) {
		$selectFieldMonth.val(1);
	}
	else {
		$selectFieldMonth.val(month);
	}
}

/**
 * @function
 * @description Gets the month from user input
 * @param jQuery Text Box Expiration Date Object
 */
function getMonth($textBoxExpirationDate) {
	if (!$textBoxExpirationDate.length) { return; }

	var month = 1;

	if($textBoxExpirationDate && $textBoxExpirationDate.val().length > 1) {
		month = parseInt($textBoxExpirationDate.val().substring(0, 2));
	}

	return month;
}

/**
 * @function
 * @description Gets the year from user input
 * @param jQuery Text Box Expiration Date Object
 */
function getYear($textBoxExpirationDate) {
    if (!$textBoxExpirationDate.length) { return; }

    var year = 2014;

	if($textBoxExpirationDate && $textBoxExpirationDate.val().length == 7)
		year = parseInt("20" + $textBoxExpirationDate.val().substring(5, 7));

	return year;
}

/**
 * @function
 * @description Selects the credit card type with respect to the credit card parameter being passed in
 * @param jQuery Select Field Object and the Credit Card Type (Visa, Mastercard, AMEX, and/or Discover)
 */
function selectHiddenCreditCardOption ($selectField, creditCardType) {
	$selectField.val(creditCardType);
}

/**
 * @function
 * @description Only allow integers in the credit card number
 * @param jQuery Text Box Object 
 */
function getCreditCardType(creditCardNumber) {
    var creditCardNumber = creditCardNumber.replace(/\s+/g, '');

    // Default credit card type to Visa.
    var creditCardType = '';

    // Ensure credit card number has a minimum of three digits.
    // Default to Visa again just in case it was never set.
    if(creditCardNumber.length > 3) {
        if (/^5[1-5]|^2(?:2(?:2[1-9]|[3-9]\d)|[3-6]\d\d|7(?:[01]\d|20))\d{12}$/.test(creditCardNumber))
            creditCardType = "Master";
        else if (/^4/.test(creditCardNumber))
            creditCardType = "Visa";
        else if (/^3[47]/.test(creditCardNumber))
            creditCardType = "Amex";
        else if (/^(6011|622(12[6-9]|1[3-9][0-9]|[2-8][0-9]{2}|9[0-1][0-9]|92[0-5]|64[4-9])|65)/.test(creditCardNumber))
            creditCardType = "Discover";
    }

	// Return the credit card type.
	return creditCardType;
}

/**
 * @function
 * @description Returns the credit card number the user has just entered in the credit card field
 * @param jQuery Text Box Object 
 */
function getCreditCardNumber($textBox) {
	return $textBox.val();
}
function setMaskCreditCardNumber($textBox) {
    $textBox.val(function (index, value) {
        return value.replace(/\W/gi, '').replace(/(.{4})/g, '$1 ');
    });
}

/**
 * @function
 * @description Only allows integers for the credit card field
 * @param jQuery Text Box Object 
 */
function allowOnlyIntegersOn($textBox) {
	$textBox.keydown(function (e) {
		// Return true if key stroke is a number.
		// Otherwise, return false.
		var isNumber = (e.shiftKey || (e.keyCode >= 48 && e.keyCode <=57) || (e.keyCode >= 96 && e.keyCode <=105));

		// Return true if key stroke is a backspace, delete, tab, escape, and/or enter
		// Otherwise, return false.
		var allowedKey1 = $.inArray(e.keyCode, [46, 8, 9, 27, 13, 110, 190]) !== -1;

		// Return true if key stroke is Ctrl+A or Command+A
		// Otherwise, return false.
		var allowedKey2 = (e.keyCode === 65 && (e.ctrlKey === true || e.metaKey === true));

		// Return true if key stroke is home, end, left, right, down, or up.
		// Otherwise, return false.
		var allowedKey3 = (e.keyCode >= 35 && e.keyCode <= 40);

        // Do not do anything if the current key stroke is one of the
		// allowed keys.
        if (allowedKey1 || allowedKey2 || allowedKey3)
			return;

		// Do not allow key press if the user input is not a number.
        if (!isNumber)
			e.preventDefault();
    });
}

function allowOnlyIntegersCVN($cvn) {
	$cvn.keydown(function (e) {
		var charCode = (e.which) ? e.which : event.keyCode;
		return !(charCode > 31 && (charCode < 48 || charCode > 57));
	});
	$cvn.on('input', function () {
		if ($(this).val().length > 4) {
			$(this).val($(this).val().slice(0,4));
		}
	});
}

/****************************************************************************************************************/

/**
 * @function
 * @description Fills the Credit Card form with the passed data-parameter and clears the former cvn input
 * @param {Object} data The Credit Card data (holder, type, masked number, expiration month/year)
 */
function setCCFields(data) {
    var $creditCard = $('[data-method="CREDIT_CARD"]');
    var $month = $creditCard.find('[name$="_month"]');
    var $year = $creditCard.find('[name$="_year"]');

    $creditCard.find('input[name$="creditCard_owner"]').val(data.holder).trigger('change');
    $creditCard.find('select[name$="_type"]').val(data.type).trigger('change');
    $('.payment-method-image-credit-card').find('.active').removeClass('active');
    $('.payment-method-image-credit-card').find('div').each(function(){
    	if($(this).hasClass(data.type.toLowerCase())){
    		$(this).addClass('active');
    	}
    });
    $creditCard.find('input[name*="_creditCard_number"]').val(data.maskedNumber);
    $("#dwfrm_billing_paymentMethods_creditCard_number").focus();
    $("#dwfrm_billing_paymentMethods_creditCard_number").blur();
    $month.val(data.expirationMonth).trigger('change');
    $year.val(data.expirationYear).trigger('change');
    $('input[name*="_cvn_"], input[name$="_cvn"]', $creditCard).each(function(ind, el) {
    	$(el).val('').trigger('change');
    });

    // Set the expiration checkbox to the value of the select menus for both the
    // month and year fields which are hidden.
    // The hidden select fields are part of the original, SGX architecture.
    // Therefore, this is being implimented as a custimization for the expiration date text box.
    var monthValue = $month.val().length > 1 ? $month.val() : "0" + $month.val();
    var yearValue = $year.val().substr(2, 2);

    // Set the expiration text box to the month and expiration date set within
    // the hidden SGX select fields.
    // Blur this field so it is validated as well.
    $('#dwfrm_billing_paymentMethods_creditCard_expirationdate').val(monthValue + " / " + yearValue).blur();
}

/**
 * @function
 * @description Updates the credit card form with the attributes of a given card
 * @param {String} cardID the credit card ID of a given card
 */
function populateCreditCardForm(cardID) {
    // load card details
    var url = util.appendParamToURL(Urls.billingSelectCC, 'creditCardUUID', cardID);
    ajax.getJson({
        url: url,
        callback: function (data) {
            if (!data) {
                window.alert(Resources.CC_LOAD_ERROR);
                return false;
            }
            setCCFields(data);
        }
    });
}

/**
 * @function
 * @description Changes the payment method form depending on the passed paymentMethodID
 * @param {String} paymentMethodID the ID of the payment method, to which the payment method form should be changed to
 */
function updatePaymentMethod(paymentMethodID) {
    var $paymentMethods = $('.payment-method'),
        $payPal = $('.payment-method-options').find('.PY'),
        $creditCard = $('.payment-method-options').find('.CREDIT_CARD'),
        continueButtonText = $('.checkoutbutton span');

    $paymentMethods.removeClass('payment-method-expanded');

    var $selectedPaymentMethod = $paymentMethods.filter('[data-method="' + paymentMethodID + '"]');
    if ($selectedPaymentMethod.length === 0) {
        $selectedPaymentMethod = $('[data-method="Custom"]');
    }
    $selectedPaymentMethod.addClass('payment-method-expanded');

    // ensure checkbox of payment method is checked
    $('input[name$="_selectedPaymentMethodID"]').removeAttr('checked');
    $('input[value=' + paymentMethodID + ']').prop('checked', 'checked');

    // Add a class of active around the payment method which was just
    // selected by the user.
    // Remove the class of active from the payment method which was not
    // selected by the user.
    switch(paymentMethodID) {
    	case "PY":
    		$payPal.addClass('active');
    		$creditCard.removeClass('active');    		
    		continueButtonText.text(Resources.CONTINUE_PAYPAL);
    		break;
    	default:
    		$creditCard.toggleClass('active');
    		$payPal.removeClass('active');
    		continueButtonText.text(Resources.REVIEW_ORDER);
    		break;
    }

    formPrepare.validateForm();
}

/**
 * @function
 * @description This method's main purpose is to stop the form post if an invalid address has been entered, and pop up the 
 *              AVS Modal. The AVS Modal will allow the user to modify their address. 
 * @param {String} paymentMethodID the ID of the payment method, to which the payment method form should be changed to
 */
function billingLoad() {

	function cError(){
		var countryError = $('select#dwfrm_billing_billingAddress_addressFields_country').hasClass('error');
		return countryError;
	}

	function sError(){
		var stateError = $('select#dwfrm_billing_billingAddress_addressFields_states_state').hasClass('error');
		return stateError;
	}

	function preValidate(){
		var pv = $checkoutForm.validate().form();

		if(cError()){
			$('div#dwfrm_billing_billingAddress_addressFields_countrySelectBoxItContainer').addClass('error');
			$("span[for='dwfrm_billing_billingAddress_addressFields_country']").insertAfter('#dwfrm_billing_billingAddress_addressFields_countrySelectBoxItContainer');

		}

		if(sError()){
			$('div#dwfrm_billing_shippingAddress_addressFields_states_stateSelectBoxItContainer').addClass('error');
			$("span[for='dwfrm_billing_billing_addressFields_states_state']").remove();
		}

		return pv;
	}

	function billingValidate() {

		if(preValidate()){
			var url =  Urls.verifyAddress;
			var data = $checkoutForm.find('fieldset:nth-of-type(2)').serialize();

			$avsContainer.append("<div id=\"newAvsDiv\"></div>");

			var options = {
				width: 600,
				height: 'auto',
				title:''
			};

			ajax.load({
				url: url,
				data: data,
				type:"POST",
				callback: function (resp) {
					app.progress.hide($(this));
					if($.trim(resp) != "{}") {
						$("#avsDiv").html($("#newAvsDiv").html());
				        dialog.open({
				            url: url,
				            target: $("#newAvsDiv"),
				            options: options
				        });
					} else {
						$('#verifyBtn').click();
					}
				}
			});
		}
		else{
			app.progress.hide($(this));
		}

	}

	// Execute on form submission.
	$('#dwfrm_billing').on("submit",function(e) {
		//e.preventDefault();
		//if (!$(this).valid()) {
			//return;
		//}
		//billingValidate();
        var $ccField = $("#dwfrm_billing_paymentMethods_creditCard_number");
		var creditCardNumber = $ccField.val(),
			creditCardType;
		if(($('#creditCardList').length == 0 || ($('#creditCardList').length > 0 && $('#creditCardList').val() == '')) && creditCardNumber.indexOf('****') == -1){
		//if((($('#creditCardList').length > 0 && $('#creditCardList').val() == '')) && creditCardNumber.indexOf('****') == -1){
	        // Replace all spaces with an empty string
	        var processed = creditCardNumber.replace(/ /g, '');
	        var ccFieldVal = parseInt(processed, 10);
	        $ccField.val(ccFieldVal);
		}

		//set hidden card type select field if it's not already set;
		//if the credit card is a saved card, then we can't verify the card type from the card number
		//so we must call out to get the type
		if(creditCardNumber.indexOf('****') != -1){
			var creditCardUUID = $('#creditCardList :selected').val();
			if(creditCardUUID){
				var url = util.appendParamToURL(Urls.billingSelectCC, 'creditCardUUID', creditCardUUID);
			    $.ajax({
			        url: url,
			        type: 'GET',
			        complete: function (data) {
			            if (!data) {
			                window.alert(Resources.CC_LOAD_ERROR);
			                return false;
			            }
			            creditCardType = data;
			            //console.log(data);
			            selectHiddenCreditCardOption($('#dwfrm_billing_paymentMethods_creditCard_type'), data.type);
			        }
			    });
			}
		}else{
			creditCardType = getCreditCardType(creditCardNumber);
			selectHiddenCreditCardOption($('#dwfrm_billing_paymentMethods_creditCard_type'), creditCardType);
		}
	})
	.on('change', '.input-text.phone',  validator.formatter.phone);
	$('.input-text.phone').trigger('change');
    // Validate phone number
    $('.input-text.phone').on('focus change', function () {
        $(this).parent().addClass('focused');
    }).on('blur', function(){
        $(this).parent().removeClass('focused');
    });
}

function initGiftCards() {
    var $billingForm = $('form#dwfrm_billing');
    var $gcApply = $('#gc-apply');
    var $gcCheckBalance = $('#gc-checkbalance');
    var $gcCode = $billingForm.find("input[name$='_giftCertCode']");
    var $gcPin = $billingForm.find("input[name$='_giftCardPin']");
    var $balance = $billingForm.find('div.balance');

    $gcApply.on('click', function (e) {
        e.preventDefault();
        var error = $balance.find('span.error');
        if (!$gcCode.val()) {            
            if (error.length === 0) {
                error = $('<span>').addClass('error').appendTo($balance);
            }
            error.html(Resources.GIFT_CERT_NUMBER_MISSING);
        } else if (!$gcPin.val()) {
            if (error.length === 0) {
                error = $('<span>').addClass('error').appendTo($balance);
            }
            error.html(Resources.GIFT_CERT_PIN_MISSING);
        } else {
            $('.js-payment-methods-container input, .js-payment-methods-container select').removeClass('required error');
            $('.js-billing-address-container input, .js-billing-address-container select').removeClass('required error');
            var actionName = $(this).attr('name');
            $('#fake-gc-apply').attr('name', actionName).val($(this).val());

            progress.show();
            giftcard.checkBalance($gcCode.val(), $gcPin.val(), function (data) {
                // remove the progress overlay
                progress.hide();

                if(!data || !data.giftCertificate) {
                    // error
                    var error = $balance.find('span.error');
                    if (error.length === 0) {
                        error = $('<span>').addClass('error').appendTo($balance);
                    }
                    error.html(Resources.GIFT_CERT_INVALID);
                    return;
                }else{
	                // apply valid giftCertificate
	                // we need to disable all input fields except gift nubmer and pin in order to pass validation during form submition
	                $billingForm.find('input:not([name$="_giftCertCode"], [name$="_giftCardPin"])').removeAttr('required');
	                //$billingForm.find('input:not([name$="_giftCertCode"], [name$="_giftCardPin"]), .form-row').removeAttr('required').removeClass('.required');
	                //We need to disabled all other fields in order not to submit and skip validation
	                $billingForm.find('input:not([name$="_giftCertCode"], [name$="_giftCardPin"], #fake-gc-apply), select').attr('disabled', 'disabled');
	                $billingForm.submit();
                }
            });
        }
    });

    $gcCheckBalance.on('click', function(e) {
        e.preventDefault();

        $balance.text('');
        if ($gcCode.val().length === 0 || $gcCode.val() === 'Gift Card Number') {
            var error = $balance.find('span.error');
            if (error.length === 0) {
                error = $('<span>').addClass('error').appendTo($balance);
            }
            error.html(Resources.GIFT_CERT_NUMBER_MISSING);
            return;
        }

        if ($gcPin.val().length === 0 || $gcPin.val() === 'PIN') {
            var error = $balance.find('span.error');
            if (error.length === 0) {
                error = $('<span>').addClass('error').appendTo($balance);
            }
            error.html(Resources.GIFT_CERT_PIN_MISSING);
            return;
        }

        progress.show();
        giftcard.checkBalance($gcCode.val(), $gcPin.val(), function (data) {
            // remove the progress overlay
            progress.hide();

            if(!data || !data.giftCertificate) {
                // error
                var error = $balance.find('span.error');
                if (error.length === 0) {
                    error = $('<span>').addClass('error').appendTo($balance);
                }
                error.html(Resources.GIFT_CERT_INVALID);
                return;
            }
            // display details in UI
            $balance.find('span.error').remove();
            var balance = data.giftCertificate.balance;
            var balanceMsg = Resources.GIFT_CERT_BALANCE + ' ' + balance;
            $balance.html(balanceMsg);
        });
    });


    $('.gcredemption').on('click', 'a.gcremove', function(e) {
        e.preventDefault();
        var gcId = app.util.trimPrefix($(this).attr('id'), 'rgc-');
        removeGiftCertificate(gcId);
        return false;
    });

    $([$gcCode[0], $gcPin[0]]).on('keyup change', function() {
        validateGCFields()
    });

    validateGCFields();

    function removeGiftCertificate(giftCertificateId) {
        $balance.empty();
        setGiftCardError(null);

        // remove gift certificate
        var url = Urls.removeGiftCertificate;
        url = app.util.appendParamToURL(url, 'giftCertificateID', giftCertificateId);
        app.ajax.getJson({
            url: url,
            callback: function(data) {
                if(!data || !data.giftCertificate || !data.giftCertificate.removed) {
                    setGiftCertError(app.resources.CANTREMOVEGIFTCARD);
                    return false;
                }

                var needredirect = $('.js-gift-cert-used').length > 0;
                if (needredirect) {
                    page.redirect(Urls.billing);
                } else {
                    $("#gc-"+giftCertificateId).remove();
                    shipping.updateSummary();
                }
            }
        });
    }

    function setGiftCardError(msg) {
        var error = $balance.find('span.error');
        if (error.length === 0) {
            error = $('<span>').addClass('error').appendTo($balance);
        }

        if(!msg) {
            error.empty();
        } else {
            error.html(msg)
        }
    }

    function validateGCFields() {
        var isValidFields = ($gcCode.val() !== undefined && $gcCode.val().trim() !== ''
            && $gcPin.val() !== undefined && $gcPin.val().trim() !== '');
        $gcApply.prop('disabled', !isValidFields);
    }
}

/**
 * @function
 * @description loads billing address, Gift Certificates, Coupon and Payment methods
 */
exports.init = function () {
    var $addCoupon = $('#add-coupon');
    var $couponCode = $('input[name$="_couponCode"]');
    var $giftOrPromoCheckBox = $('#dwfrm_billing_usegiftorpromo');
    var $giftOrPromoSection = $('.billing-coupon-code');
    var $selectPaymentMethod = $('.payment-method-options');
    var selectedPaymentMethod = $selectPaymentMethod.find(':checked').val();

    /*****************************************************************************************************/
    /*										GIFT CARD AND PROMO HANDLING								 */
    /*****************************************************************************************************/

    	// Show and/or hide the Gift Card Promotional section
    	// when a user selects the gift card promo checkbox.
    	$giftOrPromoCheckBox.on('click', function (e) {
    		$giftOrPromoSection.toggle();
    	});
    	if ($giftOrPromoCheckBox.prop('checked')) {
    	    $giftOrPromoSection.show();
    	}
    	
    /*****************************************************************************************************/
    /*										CREDIT CARD HANDLING 										 */
    /*****************************************************************************************************/
   
	    var creditCardNumber = "";
		var $textBox = $("#dwfrm_billing_paymentMethods_creditCard_number");
		var $selectField = $('#dwfrm_billing_paymentMethods_creditCard_type');
		var $textBoxExpirationDate = $("#dwfrm_billing_paymentMethods_creditCard_expirationdate");
		var $textBoxCvn = $('input[id*="_creditCard_cvn"]');
		var $selectFieldMonth = $("#dwfrm_billing_paymentMethods_creditCard_month");
		var $selectFieldYear = $("#dwfrm_billing_paymentMethods_creditCard_year");

	    $textBoxCvn.on('keyup change', function(){
	        $(this).val($(this).val().replace(/[^0-9]/g, ''));
	    });

		// Only allow integers on the credit card number 
		// text box field. 
		allowOnlyIntegersOn($textBox);

		// Key Up Event for the Credit Card Number Text Box Field
		$textBox.keyup(function (e) {
			$('#creditCardList').val('');
			var creditCardNumber = getCreditCardNumber($textBox);
			var creditCardType = getCreditCardType(creditCardNumber);
			selectHiddenCreditCardOption($selectField, creditCardType);
            var creditLogo = $('.payment-method-image-credit-card');
            creditLogo.children('div').removeClass('active');
            if (creditCardType) {
                creditLogo.children('.'+creditCardType.toLowerCase()+'').addClass('active');
            }
            $textBox.mask("0000  0000  0000  0000", { watchInputs: true });
            //setMaskCreditCardNumber($textBox);

		});

		// Only allow integers on the credit card expiration
		// text box field.
		allowOnlyIntegersOn($textBoxExpirationDate);
		
		// Key Up Event for the Credit Card's Expiration Date
		$textBoxExpirationDate.keyup(function (e) {
			var $this = $(this);
			var month = getMonth($this);
			var year = getYear($this);

			selectHiddenCreditCardMonth($selectFieldMonth, month);
			selectHiddenCreditCardYear($selectFieldYear, year);
		});
		
		//format input field to correct data if we already have it from saved CC
		if ($.trim($textBoxExpirationDate.val()) != '') {
		    var expirationParts = $.trim($textBoxExpirationDate.val()).split('/');
		    if (expirationParts.length == 2) {
		        var monthValue = $.trim(expirationParts[0]);
		        if (monthValue.length == 1) {
		            monthValue = '0' + monthValue;
		            $textBoxExpirationDate.val(monthValue + ' / ' + expirationParts[1]);
		        }
		    }
		}

		// Mask the Credit Card's Expiration Date
		$textBoxExpirationDate.mask("00 / 00", {placeholder: "MM / YY", watchInputs: true });

	/*****************************************************************************************************/

	//It is required to call this method before formPrepare in order to show CC default fields
	// default payment method to 'CREDIT_CARD'
	updatePaymentMethod((selectedPaymentMethod) ? selectedPaymentMethod : 'CREDIT_CARD');
	
    formPrepare.init({
        formSelector: 'form[id$="billing"]',
        continueSelector: '[name$="billing_save"]'
    });

    billingLoad();
    initGiftCards();

    var $form = $('form[id$="billing"]');
    util.initZipService($form);
    var $stateEmptyOptionEl = $form.find('.state-field-container select option:first-child');
    var stateEmptyOptionHtml = $('<div>').append($stateEmptyOptionEl.clone())
        .html();
    $form.on('change', 'select.country', function() {
    	var value = $(this).val().toLowerCase();

    	if (value == 'us' || value == 'ca') {
    		$('select[name$="_state"]').addClass('required').parent().addClass('required');
    	} else {
    		$('select[name$="_state"]').removeClass('required').parent().removeClass('required');
    	}

        util.changeStateField($(this).val(), $form, stateEmptyOptionHtml);
        populateStateTextBox(); 
    });
    $form.find('select.country').trigger('change');

    $selectPaymentMethod.on('click', 'input[type="radio"]', function () {
        updatePaymentMethod($(this).val());
    });

    // select credit card from list
    $('#creditCardList').on('change', function () {
        var cardUUID = $(this).val();
        if (!cardUUID) {return;}
        populateCreditCardForm(cardUUID); 
    });
    
    $addCoupon.on('click', function (e) {
        e.preventDefault();
        var $error = $checkoutForm.find('.coupon-error'),
            code = $couponCode.val();
        if (code.length === 0) {
            $error.html(Resources.COUPON_CODE_MISSING);
            return;
        }
        else  {
        	$error.html('');
        }

        var url = util.appendParamsToUrl(Urls.addCoupon, {couponCode: code, format: 'ajax'});
        $.getJSON(url, function (data) {
            var fail = false;
            var msg = '';
            if (!data) {
                msg = Resources.BAD_RESPONSE;
                fail = true;
            } else if (!data.success) {
                msg = data.message.split('<').join('&lt;').split('>').join('&gt;');
                fail = true;
            }
            if (fail) {
                $error.html(msg);
                return;
            }
            
            if(data.success) {
            	shipping.updateSummary();
            	var $div = $('div.coupon:last');
            	var $klon = $div.clone();
            	
            	if($klon.hasClass('first')) {
            		$klon.removeClass('first');
            	}
            	
            	$div.after($klon);
            	$klon.find('.message').html('<span class="value">' + data.couponCode + '</span> ' +
		            Resources.COUPON_CODE_SUCCESS);
            	
            	if (data.applied) {
            		$klon.find('.status.not-applied').remove();
            	} else {
            		$klon.find('.status.applied').remove();
            	}
            	$couponCode.val('');
            	
            }

            //basket check for displaying the payment section, if the adjusted total of the basket is 0 after applying the coupon
            //this will force a page refresh to display the coupon message based on a parameter message
            if (data.success && data.baskettotal === 0) {
                window.location.assign(Urls.billing);
            }
        });
    });
    
    $(document).on('click', '.delete-coupon', function (e) {
        e.preventDefault();
        var $button = $(this);
        var $error = $checkoutForm.find('.coupon-error'),
            code = $button.parent().parent().find('.value').text();
        if (code.length === 0) {
            $error.html(Resources.COUPON_CODE_MISSING);
            return;
        } else  { $error.html(''); }

        var url = util.appendParamsToUrl(Urls.deleteCoupon, {couponCode: code, format: 'ajax'});
        $.getJSON(url, function (data) {
            var fail = false;
            var msg = '';
            if (!data) {
                msg = Resources.BAD_RESPONSE;
                fail = true;
            } else if (!data.success) {
                msg = data.error.split('<').join('&lt;').split('>').join('&gt;');
                fail = true;
            }
            if (fail) {
                $error.html(msg);
                return;
            }
            
            if(data.success) {
            	shipping.updateSummary();
            	$button.closest('.redemption.coupon.form-row').remove();
            }
        });
    });
    

    // trigger events on enter
    $couponCode.on('keydown', function (e) {
        if (e.which === 13) {
            e.preventDefault();
            $addCoupon.click();
        }
    });

    $couponCode.on('keyup change', function() {
        validateCouponField();
    });

    validateCouponField();
    HandleCreditCardValidationOnPageLoad();
    
    $('.country-row').addClass("has-float-label");
    $('.state-row').addClass("has-float-label");
    if ($('.select-address').length > 0) {
        $('.select-address').addClass('has-float-label');
        $('.select-address select').on('change blur', function() {
            if (!$(this).val()) {
                $(this).removeClass('valid');
            }
        })
    }

    function validateCouponField() {
        var isValidField = ($couponCode.val() !== undefined && $couponCode.val().trim() !== '');
        $addCoupon.prop('disabled', !isValidField);
    }
};

},{"../../ajax":26,"../../dialog":34,"../../giftcard":37,"../../page":44,"../../progress":68,"../../util":82,"../../validator":83,"./formPrepare":49,"./shipping":53}],49:[function(require,module,exports){
'use strict';

var _ = require('lodash');
var stickyCart = require('../../stickycart');

var $form, $continue, $requiredInputs, validator;

var hasEmptyRequired = function () {
    // filter out only the visible fields
    var requiredValues = $requiredInputs.filter(':visible').map(function () {
        return $(this).val();
    });
    return _(requiredValues).contains('');
};

var validateForm = function () {
    // only validate form when all required fields are filled to avoid
    // throwing errors on empty form
    if (!validator) {
        return;
    }
    if (!hasEmptyRequired() && !hasShippingMethodError()) {
        if (validator.form()) {
            $continue.removeAttr('disabled');
        }
    } else {
        $continue.attr('disabled', 'disabled');
    }
};

var validateEl = function () {
    if (hasShippingMethodError() || ($(this).val() === '' && $(this).attr('name').search('_state') < 0)) {
        $continue.attr('disabled', 'disabled');
    } else {
        // enable continue button on last required field that is valid
        // only validate single field
        if (validator.element(this) && (!hasEmptyRequired() || ($(this).attr('name').search('_state') > 0 && !$(this).hasClass('required')))) {
            $continue.removeAttr('disabled');
        } else {
            $continue.attr('disabled', 'disabled');
        }
    }
};

/**
 * We need to check if we are on the shipping step 
 * and we don't have any shipping method error messages 
 * that doesn't allow to ship order
 */
var hasShippingMethodError = function () {
    var $shippingMethodList = $('#shipping-method-list');
    var valid = false;
    if ($shippingMethodList.length > 0) {
        if ($shippingMethodList.find('.restricted-shipment-error').length > 0) {
        	valid = true;
        } else {
        	valid = false; 
        }
    }
    
    return valid;
}

var init = function (opts) {
    if (!opts.formSelector || !opts.continueSelector) {
        throw new Error('Missing form and continue action selectors.');
    }
    $form = $(opts.formSelector);
    $continue = $(opts.continueSelector);
    validator = $form.validate();
    $requiredInputs = $('.required', $form).find(':input');
    validateForm();
    // start listening
    $requiredInputs.on('focusout', validateEl);
    $requiredInputs.filter('input:not([id$="_creditCard_expirationdate"], [id$="_creditCard_number"])').on('focusout', _.debounce(validateEl, 200));
    stickyCart.init();

};

exports.init = init;
exports.validateForm = validateForm;
exports.validateEl = validateEl;
exports.hasShippingMethodError = hasShippingMethodError;

},{"../../stickycart":75,"lodash":5}],50:[function(require,module,exports){
'use strict';

var address = require('./address'),
    billing = require('./billing'),
    multiship = require('./multiship'),
    shipping = require('./shipping'),
    smartResize = require('../../smartresize'),
    quickview = require('../../quickview'),
    util = require('../../util'),
    mediumBreakpoint = 480;

function supportMessagePosition() {
    var supportMessage = $('.support-message-phone.checkout-progress');
    if (window.innerWidth <= mediumBreakpoint && $('#footer-wrapper').find(supportMessage).length < 1) {
        supportMessage.prependTo('#footer-wrapper');
    } else if (window.innerWidth > mediumBreakpoint && $('.tablet-progress-indicator').find(supportMessage).length < 1) {
        supportMessage.appendTo('.tablet-progress-indicator .checkout-progress-indicator');
    }
}
function mobileSummaryAddClass() {
    if (window.innerWidth <= mediumBreakpoint) {
        $('#checkout-mini-summary').addClass('checkout-mini-summary-mobile');
    }
}
function mobileShowSummary () {
    $('.checkout-mobile-summary .fa').css('visibility','visible');
    $('.checkout-mobile-summary').on('click', function(){
        $(this).toggleClass('checkout-mobile-summary-active');
        $('.checkout-mini-summary-mobile').toggleClass('checkout-mini-summary-mobile-active');
        if ($(this).closest('.top-banner').hasClass('sticky')) {
	        $("html, body").animate({
	            scrollTop: 0
	        }, 1000);
        }
    });
    $('body').on('click', '.mini-summary-close', function() {
        $('.checkout-mobile-summary').removeClass('checkout-mobile-summary-active');
        $('.checkout-mini-summary-mobile').removeClass('checkout-mini-summary-mobile-active');
    });
}
function stickyBlock() {
    if (window.innerWidth > 960) {
        $(".cart-order-totals").stick_in_parent({offset_top : $('.top-banner').height()});
    }
}

function selectFromBak() {
    if ($('#state-id-bak').length && $('#state-id-bak').val().length > 0) {
        var state = $('#state-id-bak').val();
        $('select[name$="_state"]').val(state).attr('selected', true);
        $('select[name$="_state"]').blur();
    }
}

function checkPopulatedFields() {
    $('form[name$="_billing"] input, form[name$="_billing"] select').each(function (index, element) {
        if ($(element).val().length > 0) {
            $(element).blur();
        }
    })
}

function hideSummaryOnLogin() {
    if($('.pt_checkout').length && $('#main .account-login').length) {
        $('.checkout-mobile-summary').hide();
    }
}

exports.stickyBlock = function () {stickyBlock();}

/**
 * @function Initializes the page events depending on the checkout stage (shipping/billing)
 */
exports.init = function () {
    address.init();
    if ($('.checkout-shipping').length > 0 && $('.checkoutmultishipping').length === 0) {
        shipping.init();
    } else if ($('.checkoutmultishipping').length > 0) {
        multiship.init();
    } else {
        billing.init();
    }

    $('.item-edit-details a').on('click', function (e) {
        e.preventDefault();
        quickview.show({
            url: e.target.href,
            source: 'cart',
            customClass: 'ui-dialog_update-item'
        });
    });

    //if on the order review page and there are products that are not available diable the submit order button
    if ($('.order-summary-footer').length > 0) {
        if ($('.notavailable').length > 0) {
            $('.order-summary-footer .submit-order .button-fancy-large').attr('disabled', 'disabled');
        }
    }
    //set selected class for all selects
    $('.pt_checkout').on('change', 'select', function () {
        $(this).addClass('selected');
        $(this).parent().removeClass('unfloat');
    });

    $(window).load(function(){
        stickyBlock();
    });
    hideSummaryOnLogin();
    supportMessagePosition();
    mobileSummaryAddClass();
    mobileShowSummary();
    smartResize(function() {
        supportMessagePosition();
        mobileSummaryAddClass();
    });
    selectFromBak();
    checkPopulatedFields();
    util.selectUnfloat();

    $('.oAuthIcon').off('click').on('click', function (e) {
        $('.OAuthProvider').val(this.id);
    });
};

},{"../../quickview":69,"../../smartresize":74,"../../util":82,"./address":47,"./billing":48,"./multiship":51,"./shipping":53}],51:[function(require,module,exports){
'use strict';

var address = require('./address'),
    formPrepare = require('./formPrepare'),
    dialog = require('../../dialog'),
    stickyCart = require('../../stickycart'),
    validator = require('../../validator'),
    util = require('../../util'),
    ajax = require('../../ajax'),
    page = require('../../page'),
    updateSummary = require('./shipping').updateSummary,
    selectBoxIt = require('../../selectboxit'),
    floatLabels = require('../../float-labels'),
    $cache = {};


function restrictedState(stateList,state) {
    var len = stateList.length;
    var stateListState;
    if(len == 0){
        return false;
    }


    for (i = 0; i < len; i++) {
        stateListState = stateList.states[i];
        if(stateListState == state){
            return true;
        }
    }
    return false;
}


function initializeAddressForm(form) {
    var form = $("#EditAddressForm, #edit-address-form");
    form.find("input[name='format']").remove();
    floatLabels.init();
    validator.initForm(form);
    form.on('change', '.input-text.phone', validator.formatter.phone);
    $('.ui-dialog-titlebar-close').blur();
    form.find($('a.tooltip')).on('click', function (e) {
    	e.preventDefault();
    });

    //initialize form fields
    form.find('input, select').each(function(){
        var val = $(this).val();
        if (val && val.length > 0) {
            $(this).valid();
        }
    });

    form.find('phone').blur(function() {
        var val = $(this).val();
        // autofill fix for masked field
        $(this).val(val);
    });

    //bind checbox styles
    form.find('input.input-checkbox').each(function(){
        if ($(this).parents('.checkbox').length)
            return false;

        var wrap = $(this).closest('.form-row'),
            checked = $(this).is(':checked');

        if (wrap.length){
            wrap.wrapInner('<div class="checkbox" />')
            if (checked)
                wrap.find(".checkbox").addClass('checked')
        } else {
            if(checked){
                $(this).parent().wrapInner('<div class="checkbox checked" />')
            }else{
                $(this).parent().wrapInner('<div class="checkbox" />')
            }

            $(this).wrap('<div class="ch-field" />')
        }
    });

    // Prepopulate city for checkout redesign
    util.initZipService(form);
    var $stateEmptyOptionEl = form.find('.state-field-container select option:first-child');

    var stateEmptyOptionHtml = $('<div>').append($stateEmptyOptionEl.clone())
        .html();
    form.on('change', 'select.country', function() {
        util.changeStateField($(this).val(), form, stateEmptyOptionHtml);
        form.on('change', '.input-text.phone', validator.formatter.phone);
    });
    form.find('select.country').trigger('change');

    form.on("click", "#dialogApplyBtn, .apply-button", function(e) {
        e.preventDefault();

        if ($('.single-shipment').length == 0) {
            var addressId = form.find("input[name$='_addressid']");
            // Replace funky chars in the address id
            addressId.val(addressId.val().replace(/[^\w+-]/g, "-"));
        }

        if (!form.valid()) {
            //initializeAddressForm(form);
            return false;
        }
        var url = util.appendParamsToUrl(form.attr('action'),{format:"ajax"});
        var applyName = $(this).attr('name');
        var options = {
            url: url,
            data: form.serialize()+"&"+applyName+'=x',
            type: "POST"
        };
        $.ajax( options ).done(function(data){
            if (typeof(data) !== 'string' || $.trim(data) == 'success') {
                if (data.success || $.trim(data) == 'success') {
                    dialog.close();
                    if ($('.single-shipment').length > 0) {
                        var addressIDs = [];
                        if ($cache.singleShipmentAdd) {
                            $('.addressentry').each(function(){
                                addressIDs.push($(this).data('uuid'));
                            });
                        }
                        $('.addresslist').load(Urls.addressList, function(){
                            // make sure a shipping address is selected
                            if ($cache.singleShipmentAdd) {
                                // select the newest address
                                $('.addressentry').each(function(){
                                    if (addressIDs.indexOf($(this).data('uuid')) == -1) {
                                        $(this).find('input').prop('checked', true).click();
                                        return false;
                                    }
                                });
                            }
                            else {
                                if ($("input[name$='_shippingAddressID']").length > 0 && $("input[name$='_shippingAddressID']:checked").length == 0) {
                                    $('.preferred-address input').prop('checked', true).click();
                                }
                                else {
                                    $('.addresslist input:checked').click();
                                }
                            }
                            $('.addressentry, .address-create, .address-add').syncHeight();

                        });
                    }
                    else if ($('.checkoutmultishipping.shipments').length > 0) {
                        page.redirect(Urls.multiShipShipments);
                    }
                    else {
                        page.redirect(Urls.multiShip);
                    }
                }
                else {
                    alert(data.message);
                    return false;
                }
            }
            else if ($('.guest-miniaddress').length > 0) {
                dialog.close();
                var multiship = $('.multishipmethods');
                if (multiship.length > 0) {
                    multiship.load(Urls.multiShipMethods, function(){
                        updateSummary();
                    });
                }
                else {
                    /*updateShippingMethodList();*/
                    updateSummary();
                }
                $('.guest-miniaddress').html(data);
            }
            else {
                $('#dialog-container').html(data);
                /*app.account.init();
                app.tooltips.init();*/
                // PDS MERGE
                initializeAddressForm(form);
            }
        });
    })
    .on("click", "#dialogCancelBtn, .close-button, .cancel", function(e){
        e.preventDefault();
        dialog.close();
    })
    .on("click", "#dialogDeleteBtn", function(e){
        e.preventDefault();
        if (!form.valid()) {
            return false;
        }
        var url = util.appendParamsToUrl(form.attr('action'),{format:"ajax"});
        var applyName = form.find('#dialogDeleteBtn').attr('name');
        var options = {
            url: url,
            data: form.serialize()+"&"+applyName+'=x',
            type: "POST"
        };
        $.ajax( options ).done(function(data){
            if( typeof(data)!=='string' ) {
                if ( data.success ) {
                    dialog.close();
                    page.redirect(Urls.multiShip);
                } else {
                    alert(data.message);
                    return false;
                }
            } else {
                $('#dialog-container').html(data);
                /*app.account.init();
                app.tooltips.init();*/
            }
        });
    });
}

function shippingLoad(){
    if ($cache.checkoutForm.hasClass("shipping-addresses")) {
        $('#multiShipAddressForm').on('submit',function(e){
            //prevent checkout when address outside of US and contains hazmat or dropship items
            /*app.progress.show(this);*/

            e.preventDefault();
            $("#avsDiv").append("<div id=\"newAvsDiv\"></div>");
            var data = $(this).serialize();
            var url =  Urls.verifyAddressMultiple;
                      
            ajax.load({
                url:url,
                data:data,
                
                type:"POST",
                callback: function (resp) {
                    if($.trim(resp) != "{}") {
                    	$("#avsDiv").html($("#newAvsDiv").html());
                    	dialog.open({url: url, target:$("#newAvsDiv"), options:{
                             width:630,
                             height:450,
                             title:''
                         }});
                    	
                    } else {
                    	
                        $('#verifyBtn').click();
                    }
                }
            });

            return false;

        });
    }

    stickyCart.init();

    var multiship = $(".checkoutmultishipping");
    if(multiship.length === 0) { return; }

    /*selectBoxIt.selectBoxIt($('.select-field'));*/

    var shippingAddressLists = $(".multiship-addresses-table").find("td.shippingaddress");

    $(shippingAddressLists).each(function(index){
        var addressList = $(this);
        var uuid = $(this).attr("data-uuid");
        var isHazmat = $(this).data("hazmat");
        var isDropShip = $(this).data("dropship");
        var isNoIntlShip = $(this).data("nointlship");
        var addressID = $(this).find(".selectbox").val();

        var hazmatStates = window.hazmatstates;
        var dropshipStates = window.dropshipstates;
        var hazmatStates = '';
        var dropshipStates = '';

        var state = $(this).find("option:selected").data("state") || false;

        var initCountry = $(this).find("option:selected").data("country");
        var isUS = (initCountry == 'US' || initCountry == '') || false;

        var restrictedHazmatState = restrictedState(hazmatStates, state);
        var restrictedDropShipState = restrictedState(dropshipStates, state);


        if(addressID){
            $(this).find("a.address-edit").removeClass("visually-hidden");
            $(this).find(".selectbox").trigger('click').addClass('selected');
        }
        //display error messages for selected addresses onload

        if((!isUS || (isUS && restrictedHazmatState)) && isHazmat){
            $(this).find(".noship-error").removeClass("visually-hidden");
        }
        if(!isUS && isNoIntlShip){
            $(this).find(".noship-error").removeClass("visually-hidden");
        }

        //display error messages for selected addresses on selection change
        $(this).on("change",".selectbox",function(e){
            var newAddressID = $(this).val();

            var shipCountry = $(this).find("option:selected").data("country");
            var shipState = $(this).find("option:selected").data("state") || false;
            var isUS = (shipCountry == 'US' || shipCountry == '') || false;
            var restrictedHazmatState = restrictedState(hazmatStates,shipState);
            var restrictedDropShipState = restrictedState(dropshipStates,shipState);

            if(!newAddressID){
            	 $(this).parents(".select-address").siblings(".address-error").removeClass("visually-hidden");
                $(this).parents(".shippingaddress").find("a.address-edit").addClass("visually-hidden");
            }else{
                $(this).parents(".shippingaddress").find("a.address-edit").removeClass("visually-hidden");
                $(this).parents(".select-address").siblings(".address-error").addClass("visually-hidden");
            }
            

            if(!isUS && (isHazmat || isNoIntlShip)){
                $(this).parents(".select-address").siblings(".noship-error").removeClass("visually-hidden");

            } else if (isUS && isHazmat && restrictedHazmatState){
                $(this).parents(".select-address").siblings(".noship-error").removeClass("visually-hidden");

            } else if (isUS && isDropShip && restrictedDropShipState){
                $(this).parents(".select-address").siblings(".noship-error").removeClass("visually-hidden");

            }else {
                $(this).parents(".select-address").siblings(".noship-error").addClass("visually-hidden");
            }

            //prevent checkout if missing address or dropship/hazmat shipments outside US even if validated address
            isFormAvailableForCheckout();

            //store the shipping address to session
            var url = Urls.storeShippingAddress;
            var options = {
                url: url,
                data: {
                    'pliUUID': uuid,
                    'addressUUID' : $(this).val()
                },
                type: "POST"
            };
            $.ajax( options ).done(function(data){

                if(data.success){

                    return;
                }else{
                    return;
                }
            });
        });
    });

    //prevent checkout if missing address or dropship/hazmat shipments outside US even if validated address
    isFormAvailableForCheckout(false);

    var shipmentMethodsLists = $(".shipping-method").find("td.shippingaddress");

    $(shipmentMethodsLists).each(function(index){
        var uuid = $(this).attr("data-uuid");
        $(this).on("change",".selectbox",function(e){
            //store the shipping address to session
            var url = Urls.storeShippingMethod;
            var options = {
                url: url,
                data: {
                    'shipmentUUID': uuid,
                    'shippingMethodID' : $(this).val()
                },
                type: "POST"
            };
            $.ajax( options ).done(function(data){
                if(data.success){
                    updateSummary();
                    return;
                }else{
                    return;
                }
            });
        });
    });

    multiship.find('[name$="_shippingMethodID"]').click(function () {
        $(this).parent().addClass('radio-button-selected');
        $(this).parent().siblings('div.form-row').removeClass('radio-button-selected');
    });

    multiship.on("change",".shipping-method-radios .input-radio",function(e){
        var options = {
            url: Urls.storeShippingMethod,
            data: {
                'shipmentUUID': $(this).attr("data-uuid"),
                'shippingMethodID' : $(this).val()
            },
            type: "POST"
        };
        $.ajax( options ).done(function(data){

            if (data.success) {
                updateSummary();
                return;
            }
            else {
                return;
            }
        });
    });

    //bind add address in multishipping
    $("a.address-edit, a.address-create").on("click",function(e) {
        e.preventDefault();
        var anchor = $(this);
        var url = anchor.attr("href");
        var title = anchor.attr("title");
        if(anchor.hasClass("edit")) {
            var addressID = anchor.parents("td.shippingaddress").find(".selectbox").val();
            if(!addressID) {
                return false;
            }
            url = util.appendParamToURL(url, "addressID", addressID);
        }
        var dialogWidth = (window.innerWidth <= 668) ? (window.innerWidth).toString() : '668';
        var options = {open: initializeAddressForm, dialogClass:'checkout-popup', width: dialogWidth-40};
        dialog.open({url:url, options:options});
        return false;
    });

    $(".shippingaddress .user-login-hopup").on("click", function(e) {
        $('html, body').animate({scrollTop: 0}, 200);
    });

    //prevent checkout if missing address or dropship/hazmat shipments outside US even if validated address
    function isFormAvailableForCheckout(showError) {
        var missingAddress = false;
        var isHazmat = false;
        var isDropship = false;
        $(shippingAddressLists).each(function(index){
            if(this.classList.contains('pickup')) {
                return true;
            }

            var addressID = $(this).find(".selectbox").val();
            if(!addressID) {
                missingAddress = true;
                if(showError == true){
                	$(this).find(".address-error").removeClass("visually-hidden");
                }
                
            }

            //determine if trying to send hazmat/dropship to improper address outside US
            var badaddress = $(this).find(".noship-error").hasClass("visually-hidden");
            if(!badaddress){
                isHazmat = true;
            }

        });

        if (missingAddress || isHazmat){
            $cache.save.attr('disabled', 'disabled');
            return false;
        } else {
            $cache.save.removeAttr('disabled');
        }
    }

    if ($cache.checkoutForm.hasClass("shipping-addresses")) {
        $cache.save.on("click", isFormAvailableForCheckout);
    }

}


function initializeCache() {
    $cache.checkoutForm = $("form.address");
    $cache.checkoutRedesign = $('.checkout-redesign');
    $cache.addressList = $cache.checkoutForm.find(".select-address select[id$='_addressList']");
    $cache.addressid = $cache.checkoutForm.find("input[name$='_addressid']");
    $cache.firstName = $cache.checkoutForm.find("input[name$='_firstName']");
    $cache.lastName = $cache.checkoutForm.find("input[name$='_lastName']");
    $cache.address1 = $cache.checkoutForm.find("input[name$='_address1']");
    $cache.address2 = $cache.checkoutForm.find("input[name$='_address2']");
    $cache.city = $cache.checkoutForm.find("input[name$='_city']");
    $cache.postalCode = $cache.checkoutForm.find("input[name$='_zip']");
    $cache.phone = $cache.checkoutForm.find("input[name$='_phone']");
    $cache.countryCode = $cache.checkoutForm.find("select[id$='_country']");
    $cache.stateCode = $cache.checkoutForm.find("select[id$='_state']");
    $cache.addToAddressBook = $cache.checkoutForm.find("input[name$='_addToAddressBook']");
    $cache.singleShipmentAdd = false;
    if ($cache.checkoutForm.hasClass("checkout-shipping")) {
        // shipping only
        $cache.useForBilling = $cache.checkoutForm.find("input[name$='_useAsBillingAddress']");
        $cache.giftMessage = $cache.checkoutForm.find(".gift-message-text");
        $cache.shippingMethodList = $("#shipping-method-list");
        $cache.save = $cache.checkoutForm.find("button[name$='_shippingAddress_save']");
        $cache.shippingEmailList = $cache.checkoutForm.find("input[name$='_emailLists_ksp']");
        $cache.saveInfo = $cache.checkoutForm.find("input[name$='_saveInfo']");
        $cache.saveInfoPassword = $cache.checkoutForm.find(".password-input");
        $cache.email = $cache.checkoutForm.find("input[name$='_emailAddress']");
        $cache.singleShipment = $('.single-shipment');
    }
    if ($cache.checkoutForm.hasClass("shipping-addresses")) {
        $cache.save = $cache.checkoutForm.find("button[name$='_addressSelection_save']");
    }
    if ($cache.checkoutForm.hasClass("multiship-delivery-form")) {
        $cache.save = $cache.checkoutForm.find("button[name$='_shippingOptions_save']");
    }
}

function initializeEvents() {
    shippingLoad();
}
function setGiftNote(giftNote, val) {
    var msgTxt = giftNote.find('.textareacontainer');

    if (val !== 'personalizedgiftnote' && val !== 'blankgiftnote') {
        msgTxt.addClass('hide');
        $(msgTxt).find('textarea').blur();
    } else {
        msgTxt.removeClass('hide');
        $(msgTxt).find('textarea').focus();
    }
}

function initializeMultiGiftOptions(form) {

    form.find('.gift-note').each(function(){
        var messageRadioVal = $(this).find('input[name$="_giftMessageOption"]:checked').val();
        setGiftNote($(this), messageRadioVal);
    });

    form.on('change', 'input[name$="_giftMessageOption"]', function(e){
        var giftNote = $(this).closest('.gift-note');
        setGiftNote(giftNote, $(this).val());
    })
    .on('change', 'input[name$="_hasGiftWrap"]', function(e){
        var giftWrap = $(this).closest('.gift-wrap');
        if ($(this).prop('checked')) {
            giftWrap.find('input.wrapping').click();
        }
        else {
            giftWrap.find('input.nowrapping').click();
        }
    })
    .on('change', 'input[name$="_hasNote"]', function(e){
        var giftNote = $(this).closest('.gift-note');
        if ($(this).prop('checked')) {
            giftNote.find('input#personalizedgiftnote').click();
        }
        else {
            giftNote.find('input#nogiftnote').click();
        }
    })
    .on('click', 'button[type="submit"]', function(e) {
        e.preventDefault();
        e.stopImmediatePropagation();

        // Replace line breaks with spaces
        form.find('.giftmessage').each(function() {
            var $this = $(this);
            $this.val($this.val().replace(/\n/g, ' '));
        });

        // Select radio button 'blankgiftnote' if the textarea('.giftmessage') is empty
        form.find('.giftmessage').each(function() {
            var $this = $(this);
            var $parent = $this.parents('.gift-note');
            var $checkbox = $parent.find('input[name$=_giftoptions_hasNote]');

            if ($this.val() == '' && $checkbox.is(':checked')) {
                $parent.find('input[id=blankgiftnote]').prop('checked', true);
            }
        });

        form.submit();
    });

    validator.initForm(form);
    // app.util.limitCharacters(); //TODO
}

function initGiftHopupMS() {

    $('.edit-all-gifts').on('click', '.gift-check', function(e) {
        e.preventDefault();
        var dialogWidth = (window.innerWidth < 768) ? (window.innerWidth - 40).toString() : '720';
        dialog.create({
            target: $('#gift-options-dialog'),
            options: {
                width: dialogWidth,
                title: '',
                dialogClass: 'gift-options-container',
                autoOpen: false
            }
        });

        app.ajax.load({
            url: app.util.ajaxUrl( $(this).attr('rel') ),
            target: $('#gift-options-dialog'),
            callback: function() {
                initializeMultiGiftOptions($('#edit-giftoptions-form'));
                $('#gift-options-dialog').dialog('open');
            }
        });
    });
}



/**
 * @function
 * @description shows gift message box in multiship, and if the page is the multi shipping address page it will call initmultishipshipaddress() to initialize the form
 */
exports.init = function () {
    initializeCache();
    initializeEvents();
    initGiftHopupMS();
};

},{"../../ajax":26,"../../dialog":34,"../../float-labels":36,"../../page":44,"../../selectboxit":73,"../../stickycart":75,"../../util":82,"../../validator":83,"./address":47,"./formPrepare":49,"./shipping":53}],52:[function(require,module,exports){
exports.init = function () {
    initializeEvents();
    var password = $('.input-text.password');
    function initializeEvents() {

        emailAccountLookupProcess();

        /* Disable or Enable the Confirm button */
        var $registerForm = $('#RegistrationForm'),
            $registerFormConfirmButton = $registerForm.find('[name$=profile_confirm]');
        $registerForm.find('input').on('blur', function () {
            var isValid = $registerForm.validate().checkForm();
            if (isValid) {
                $registerForm.valid();
                $registerFormConfirmButton.removeAttr('disabled');
            } else {
                $registerFormConfirmButton.attr('disabled', 'disabled');
            }
        });

        // Order confirmation details toggle
        $(document).on('click', '.js-orderconfirmation-details-toggle', function() {
            var $orderDetails = $(this).closest('.js-order-details-container');
            if ($orderDetails.length > 0) {
                var $orderDetailsBody = $orderDetails.find('.js-order-details-body');
                if ($orderDetails.hasClass('expanded')) {
                    $orderDetailsBody.slideUp(300);
                    $orderDetails.removeClass('expanded');
                } else {
                    $orderDetailsBody.slideDown(300);
                    $orderDetails.addClass('expanded');
                }
            }
        });
    }

    function emailAccountLookupProcess() {
        var $emailAccountLookup = $('.emailaccountlookup');

        // If not already an error and has some data
        if ($emailAccountLookup.length > 0 && !$emailAccountLookup.hasClass('error')
            && $emailAccountLookup.val().length > 3){

            var emailToLookup = $emailAccountLookup.val();
            var emailAccountLookupName = $emailAccountLookup.attr('name');

            params = {email : emailToLookup};
            app.ajax.getJson({
                async: true,
                url: Urls.AccountLoginCheck,
                data: params,
                callback: function (data) {
                    if(data && data.success){
                        // Email Already Exists
                        var validator = $( "#RegistrationForm" ).validate();
                        var error = {};
                        error[emailAccountLookupName] = Resources.INVALID_USERNAMETAKEN;
                        validator.showErrors(error);
                    }
                }
            });
        }
    }
};

},{}],53:[function(require,module,exports){
'use strict';

var ajax = require('../../ajax'),
	dialog = require('../../dialog'),
	stickyCart = require('../../stickycart'),
    formPrepare = require('./formPrepare'),
    progress = require('../../progress'),
    tooltip = require('../../tooltip'),
    validator = require('../../validator'),
    util = require('../../util'),
    index = require('./index'),
    shippingInventory = require('../../storeinventory/shipping');

/****************************************************************************************************************/

/**
 * @function
 * @description Only allows integers for the credit card field
 * @param jQuery Text Box Object
 */
function allowOnlyIntegersOn($textBox) {
	$textBox.keydown(function (e) {
		// Return true if key stroke is a number.
		// Otherwise, return false.
        var isNumber = (e.shiftKey || (e.keyCode >= 48 && e.keyCode <=57) || (e.keyCode >= 96 && e.keyCode <=105));

		// Return true if key stroke is a backspace, delete, tab, escape, and/or enter
		// Otherwise, return false.
		var allowedKey1 = $.inArray(e.keyCode, [46, 8, 9, 27, 13, 110, 190]) !== -1;

		// Return true if key stroke is Ctrl+A or Command+A
		// Otherwise, return false.
		var allowedKey2 = (e.keyCode === 65 && (e.ctrlKey === true || e.metaKey === true));

		// Return true if key stroke is home, end, left, right, down, or up.
		// Otherwise, return false.
		var allowedKey3 = (e.keyCode >= 35 && e.keyCode <= 40);

        // Do not do anything if the current key stroke is one of the
		// allowed keys.
        if (allowedKey1 || allowedKey2 || allowedKey3)
			return;

		// Do not allow key press if the user input is not a number.
        if (!isNumber)
			e.preventDefault();
    });
}

/****************************************************************************************************************/

var shippingMethods;
var $checkoutForm = $('.checkout-shipping');
var $avsContainer = $("#avsDiv");

/**
 * @function
 * @description Initializes gift message box, if shipment is gift
 */
function giftMessageBox() {
    // show gift message box, if shipment is gift
    $('.gift-message-text').toggleClass('hidden', $('input[name$="_shippingAddress_isGift"]:checked').val() !== 'true');
}

/**
 * @function
 * @description updates the order summary based on a possibly recalculated basket after a shipping promotion has been applied
 */
function updateSummary() {
    var $summary = $('#checkout-mini-summary');

    // Copy the my bag content.
    // This is being done since Shop Runner JS runs after app.js.
    $('#my-bag-content-copy').html($('.my-bag-content').clone());

    // load the updated summary area
    $summary.load(Urls.summaryRefreshURL, function () {
        // hide edit shipping method link
        $summary.fadeIn('fast');
        $summary.find('.checkout-mini-cart .minishipment .header a').hide();
        $summary.find('.order-totals-table .order-shipping .label a').hide();

        //update minicart summary on mobile
        var orderValue = $summary.find('.order-total .order-value').html();
        var $mobileSummary = $('.checkout-mobile-summary div div.float-right');
        $mobileSummary.html(orderValue);

        // Get My Bag's copy from the initial page load, and replace the
        // current My Bag returned from this AJAX call.
        $('.my-bag-content').replaceWith($('#my-bag-content-copy').html());
        $('#my-bag-content-copy').html('');
        stickyCart.init();
        index.stickyBlock();
    });
}

/**
 * @function
 * @description Helper method which constructs a URL for an AJAX request using the
 * entered address information as URL request parameters.
 */
function getShippingMethodURL(url, extraParams) {
    var $form = $('.address');
    var params = {
        address1: ($form.find('input[name$="_address1"]').length) ? $form.find('input[name$="_address1"]').val() : '',
        address2: ($form.find('input[name$="_address2"]').length) ? $form.find('input[name$="_address2"]').val() : '',
        countryCode: ($form.find('select[id$="_country"]').length) ? $form.find('select[id$="_country"]').val() : '',
        stateCode: ($form.find('select[id$="_state"], input[id$="_state"]').length) ? $form.find('select[id$="_state"], input[id$="_state"]').val() : '',
        postalCode: ($form.find('input[name$="_zip"]').length) ? $form.find('input[name$="_zip"]').val() : '',
        city: ($form.find('input[name$="_city"]').length) ? $form.find('input[name$="_city"]').val() : ''
    };
    return util.appendParamsToUrl(url, $.extend(params, extraParams));
}

/**
 * @function
 * @description selects a shipping method for the default shipment and updates the summary section on the right hand side
 * @param
 */
function selectShippingMethod(shippingMethodID) {
    // nothing entered
    if (!shippingMethodID) {
        return;
    }
    // attempt to set shipping method
    var url = getShippingMethodURL(Urls.selectShippingMethodsList, {shippingMethodID: shippingMethodID});
    ajax.getJson({
        url: url,
        callback: function (data) {
            updateSummary();
            if (!data || !data.shippingMethodID) {
                window.alert('Couldn\'t select shipping method.');
                return false;
            }
            // display promotion in UI and update the summary section,
            // if some promotions were applied
            $('.shippingpromotions').empty();


            // if (data.shippingPriceAdjustments && data.shippingPriceAdjustments.length > 0) {
            //     var len = data.shippingPriceAdjustments.length;
            //     for (var i=0; i < len; i++) {
            //         var spa = data.shippingPriceAdjustments[i];
            //     }
            // }
        }
    });
}

///////////////////////////////////////////////////////////////////////////////////////////
// 										NEWSLETTER SUBSCRIPTION
///////////////////////////////////////////////////////////////////////////////////////////

function setKSNewsletterCheckBox() {
	// Get the following form field values.
	var email =   $('.email-row').find('input[type=text]').val();
	var country = $('select.select-fieldcountry option:selected').text();
	var subscribe = $('.subscribe-row').find('input[type=checkbox]').is(':checked');

	// RR-231:
	// 	- Default subscribe checkbox to checked for any country that
	// 	  is NOT Canada.
	// 	- Otherwise, default the subscribe checkbox to NOT CHECKED.

	if(country.toLowerCase() != "canada") {
		// Default the subcribe to newsletter checkbox to CHECKED
		// since this is NOT Canada.
		$('.subscribe-row').find('input[type=checkbox]').prop('checked', true);
	}
	else {
		// Default the subcribe to newsletter checkbox to NOT CHECKED
		// since this is Canada.
		$('.subscribe-row').find('input[type=checkbox]').prop('checked', false);
	}
}

//RR-231:
// 	Set the subscribe checkbox to CHECKED if the country selected on
// 	the change event is NOT Canada.
// 	Otherwise, set it to NOT CHECKED.

$('select.select-fieldcountry').change(function() {
	setKSNewsletterCheckBox();
});

// EMAIL SUBSCRIPTION - ON FORM SUBMISSION

$('#dwfrm_singleshipping_shippingAddress').submit(function(){
	//push email signup to dataLayer
	if ($("#dwfrm_singleshipping_shippingAddress_email_emailLists_ksp").is(':checked')) {
		dataLayer.push({"event" : "email-subscribe", "subscribeType": "checkout"});
	}
});

///////////////////////////////////////////////////////////////////////////////////////////

/**
 * @function
 * @description Make an AJAX request to the server to retrieve the list of applicable shipping methods
 * based on the merchandise in the cart and the currently entered shipping address
 * (the address may be only partially entered).  If the list of applicable shipping methods
 * has changed because new address information has been entered, then issue another AJAX
 * request which updates the currently selected shipping method (if needed) and also updates
 * the UI.
 */
function updateShippingMethodList() {
    var $shippingMethodList = $('#shipping-method-list');
    if (!$shippingMethodList || $shippingMethodList.length === 0) { return; }
    var url = getShippingMethodURL(Urls.shippingMethodsJSON);

    ajax.getJson({
        url: url,
        callback: function (data) {
            if (!data) {
                return false;
            }
            if (shippingMethods && shippingMethods.toString() === data.toString()) {
                // No need to update the UI.  The list has not changed.
                return true;
            }

            // We need to update the UI.  The list has changed.
            // Cache the array of returned shipping methods.
            shippingMethods = data;

            // load the shipping method form
            var smlUrl = getShippingMethodURL(Urls.shippingMethodsList);
            $shippingMethodList.load(smlUrl, function () {
                $shippingMethodList.fadeIn('fast');
                //we need to disable continue button if we have any shipping restriction
                var saveShippingAddressButton = $('[name$="_shippingAddress_save"]');
                if (formPrepare.hasShippingMethodError()) {
                	saveShippingAddressButton.attr('disabled', 'disabled');
                } else {
                	saveShippingAddressButton.removeAttr('disabled');
                }
                // rebind the radio buttons onclick function to a handler.
                $shippingMethodList.find('[name$="_shippingMethodID"]').click(function () {

                	// Add a class of radio-button-selected to the selected radio button's form row wrapper
                	$(this).parent().addClass('radio-button-selected');

                	// Remove the class of radio-button-selected on all the non-selected radio button's form row wrapper(s)
                	$(this).parent().siblings('div.form-row').removeClass('radio-button-selected');

                	// Pass the selected shipping method ID into selectShippingMethod
                   	selectShippingMethod($(this).val());

                });
                //trigger country change event in order to validate form and enable continue button
                //it is required for international addresses where we don't have state/province dropdown
                $('form[id$="singleshipping_shippingAddress"]').find('select.country').trigger('change');
                // update the summary
                updateSummary();
                tooltip.init();
                //if nothing is selected in the shipping methods select the first one
                if ($shippingMethodList.find('.input-radio:checked').length === 0) {
                    $shippingMethodList.find('.input-radio:first').prop('checked', 'checked').parent().addClass('radio-button-selected');
                }
            });
        }
    });
}

function initPickUp() {
    var pickUpOptions = $('#pick-up-order-fields .input-radio'),
        pickUpFields = $('#pick-up-order-fields .pick-up-fields');

    pickUpOptions.on('change', function () {
        var el = this;

        if (el.value === 'other') {
            pickUpFields.show();
        } else {
            pickUpFields.hide();
            pickUpFields.find('input').val('');
        }
    });
}

/**
 * @function
 * @description This method's main purpose is to stop the form post if an invalid address has been entered, and pop up the
 *              AVS Modal. The AVS Modal will allow the user to modify their address.
 * @param {String} paymentMethodID the ID of the payment method, to which the payment method form should be changed to
 */
function shippingLoad() {

	function cError(){
		var countryError = $('select#dwfrm_singleshipping_shippingAddress_addressFields_country').hasClass('error');
		return countryError;
	}

	function sError(){
		var stateError = $('select#dwfrm_singleshipping_shippingAddress_addressFields_states_state').hasClass('error');
		return stateError;
	}

	function preValidate(){
		var pv = $checkoutForm.validate().form();

		if(cError()){
			$('#dwfrm_singleshipping_shippingAddress_addressFields_country').addClass('error');
			$("label[for='dwfrm_singleshipping_shippingAddress_addressFields_country']").insertAfter('#dwfrm_singleshipping_shippingAddress_addressFields_country');

		}

		if(sError()){
			$('#dwfrm_singleshipping_shippingAddress_addressFields_states_state').addClass('error');
			$("label[for='dwfrm_singleshipping_shippingAddress_addressFields_states_state']").remove();
		}

		return pv;
	}

	function singleShippingValidate() {
		if(preValidate()) {
			var url =  Urls.verifyAddress;
			var data = $checkoutForm.serialize();
			$avsContainer.append("<div id=\"newAvsDiv\"></div>");

			var width = '600',
                left = '0';

			if (util.isMobile() && window.innerWidth < 630) {
			    width = (window.innerWidth - 30) + '';
			    left = '15';
            }

			var options = {
				width: width,
				height: 'auto',
				title:'',
                left:left
			};

			ajax.load({
				url: url,
				data: data,
				type:"POST",
				callback: function (resp) {
					app.progress.hide($(this));
					if($.trim(resp) != "{}") {
						$("#avsDiv").html($("#newAvsDiv").html());
				        dialog.open({
				            url: url,
				            target: $("#newAvsDiv"),
				            options: options
				        });
					} else {
						$('#verifyBtn').click();
					}
				}
			});
		}
		else {
			app.progress.hide($(this));
		}
	}

	// Execute on form submission.
	$('#dwfrm_singleshipping_shippingAddress').on("submit",function(e) {
		e.preventDefault();

		if (!$(this).valid()) {
			return;
		}

		singleShippingValidate();

		return false;
	}).on('change', '.input-text.phone', validator.formatter.phone);
	$('.input-text.phone').trigger('change');

    // Validate phone number
    $('.input-text.phone').on('focus change', function () {
        $(this).parent().addClass('focused');
    }).on('blur', function(){
        $(this).parent().removeClass('focused');
    });
}

function setGiftNote(giftNote, val) {
    var msgTxt = giftNote.find('.textareacontainer');

    if (val !== 'personalizedgiftnote' && val !== 'blankgiftnote') {
        msgTxt.addClass('hide');
        $(msgTxt).find('textarea').blur();
    } else {
        msgTxt.removeClass('hide');
        $(msgTxt).find('textarea').focus();
    }
}

function initializeMultiGiftOptions(form) {

    form.find('.gift-note').each(function(){
        var messageRadioVal = $(this).find('input[name$="_giftMessageOption"]:checked').val();
        setGiftNote($(this), messageRadioVal);
    });

    form.on('change', 'input[name$="_giftMessageOption"]', function(e){
        var giftNote = $(this).closest('.gift-note');
        setGiftNote(giftNote, $(this).val());
    })
    .on('change', 'input[name$="_hasGiftWrap"]', function(e){
        var giftWrap = $(this).closest('.gift-wrap');
        if ($(this).prop('checked')) {
            giftWrap.find('input.wrapping').click();
        }
        else {
            giftWrap.find('input.nowrapping').click();
        }
    })
    .on('change', 'input[name$="_hasNote"]', function(e){
        var giftNote = $(this).closest('.gift-note');
        if ($(this).prop('checked')) {
            giftNote.find('input#personalizedgiftnote').click();
        }
        else {
            giftNote.find('input#nogiftnote').click();
        }
    })
    .on('click', 'button[type="submit"]', function(e) {
        e.preventDefault();
        e.stopImmediatePropagation();

        // Replace line breaks with spaces
        form.find('.giftmessage').each(function() {
            var $this = $(this);
            $this.val($this.val().replace(/\n/g, ' '));
        });

        // Select radio button 'blankgiftnote' if the textarea('.giftmessage') is empty
        form.find('.giftmessage').each(function() {
            var $this = $(this);
            var $parent = $this.parents('.gift-note');
            var $checkbox = $parent.find('input[name$=_giftoptions_hasNote]');

            if ($this.val() == '' && $checkbox.is(':checked')) {
                $parent.find('input[id=blankgiftnote]').prop('checked', true);
            }
        });

        form.submit();
    });

    validator.initForm(form);
    // app.util.limitCharacters(); //TODO
}

function initGiftHopup() {

    $('.edit-all-gifts').on('click', '.gift-check', function(e) {
        e.preventDefault();
        var dialogWidth = (window.innerWidth < 768) ? (window.innerWidth - 40).toString() : '720';
        dialog.create({
            target: $('#gift-options-dialog'),
            options: {
                width: dialogWidth,
                title: '',
                dialogClass: 'gift-options-container',
                autoOpen: false
            }
        });

        app.ajax.load({
            url: app.util.ajaxUrl( $(this).attr('rel') ),
            target: $('#gift-options-dialog'),
            callback: function() {
                initializeMultiGiftOptions($('#edit-giftoptions-form'));
                $('#gift-options-dialog').dialog('open');
            }
        });
    });
}

/****************************************************************************************************************/

exports.init = function () {
    formPrepare.init({
        continueSelector: '[name$="shippingAddress_save"]',
        formSelector:'[id$="singleshipping_shippingAddress"]'
    });

    shippingLoad();

    $('input[name$="_shippingAddress_isGift"]').on('click', giftMessageBox);

    $('.address').on('change',
        'input[name$="_addressFields_address1"], input[name$="_addressFields_address2"], select[name$="_addressFields_states_state"], input[name$="_addressFields_city"], input[name$="_addressFields_zip"]',
        updateShippingMethodList
    );

    $('.country-row').addClass("has-float-label");
    $('.state-row').addClass("has-float-label");

    if ($('.select-address').length > 0) {
        $('.select-address').addClass('has-float-label');
        $('.select-address select').on('change blur', function() {
            if (!$(this).val()) {
                $(this).removeClass('valid');
            }
        })
    }

    var $form = $('form[id$="singleshipping_shippingAddress"]');
    util.initZipService($form);
    var $stateEmptyOptionEl = $form.find('.state-field-container select option:first-child');
    var stateEmptyOptionHtml = $('<div>').append($stateEmptyOptionEl.clone()).html();
    $form.on('change', 'select.country', function() {
    	var value = $(this).val().toLowerCase();

    	if (value == 'us' || value == 'ca') {
    		$('select[name$="_state"]').addClass('required').parent().addClass('required');
    	} else {
    		$('select[name$="_state"]').removeClass('required').parent().removeClass('required');
    	}

        util.changeStateField($(this).val(), $form, stateEmptyOptionHtml);
        formPrepare.init({
            continueSelector: '[name$="shippingAddress_save"]',
            formSelector:'[id$="singleshipping_shippingAddress"]'
        });
    });
    $form.find('select.country').trigger('change');

    giftMessageBox();
    updateShippingMethodList();
    setKSNewsletterCheckBox();
    initPickUp();
    initGiftHopup();
    shippingInventory.init();
};

exports.updateShippingMethodList = updateShippingMethodList;
exports.updateSummary = updateSummary;

},{"../../ajax":26,"../../dialog":34,"../../progress":68,"../../stickycart":75,"../../storeinventory/shipping":79,"../../tooltip":81,"../../util":82,"../../validator":83,"./formPrepare":49,"./index":50}],54:[function(require,module,exports){
'use strict';

var addProductToCart = require('./product/addToCart'),
    ajax = require('../ajax'),
    page = require('../page'),
    productTile = require('../product-tile'),
    quickview = require('../quickview');

/**
 * @private
 * @function
 * @description Binds the click events to the remove-link and quick-view button
 */
function initializeEvents() {
    $('#compare-table').on('click', '.remove-link', function (e) {
        e.preventDefault();
        ajax.getJson({
            url: this.href,
            callback: function () {
                page.refresh();
            }
        });
    })
    .on('click', '.open-quick-view', function (e) {
        e.preventDefault();
        var url = $(this).closest('.product').find('.thumb-link').attr('href');
        //Very specific case for making inputs outside of dialog available
        $.widget( "ui.dialog", $.ui.dialog, {
            _allowInteraction: function( event ) {
                return !!$( event.target ).is( "input" ) || this._super( event );
            }
        });
        quickview.show({
            url: url,
            source: 'quickview'
        });
    });

    $('#compare-category-list').on('change', function () {
        $(this).closest('form').submit();
    });
}

exports.init = function () {
    productTile.init();
    initializeEvents();
    addProductToCart();
};

},{"../ajax":26,"../page":44,"../product-tile":67,"../quickview":69,"./product/addToCart":55}],55:[function(require,module,exports){
'use strict';

var dialog = require('../../dialog'),
	availability = require('./availability'),
	validator = require('../../validator'),
    minicart = require('../../minicart'),
    page = require('../../page'),
    util = require('../../util'),
    Promise = require('promise'),
    _ = require('lodash'),
    monogramReset = require('../../storeinventory/product').monogramReset,
    validateFormFields = require('../../storeinventory/product').validateFormFields;

/**
 * @description Make the AJAX request to add an item to cart
 * @param {Element} form The form element that contains the item quantity and ID data
 * @returns {Promise}
 */
var addItemToCart = function (form) {
    var $form = $(form),
        $qty = $form.find('input[name="Quantity"]'),
        $pspContainer = $form.parents('.product-set-item'),
        itemID = '';

	if($qty.length == 0){
		$qty = $form.find('select[name="Quantity"]');
	}
	// Fix for ProductSets, as the quantity select isn't within the form.
    if ($pspContainer.length) {
    	// Find the PSP quantity
    	$qty = $pspContainer.find('select[name="Quantity"]');
    	// Remove any prior injected inputs
    	$form.find('input[name="Quantity"]').remove();
    	// Append it to the form
		$form.append('<input name="Quantity" type="hidden" value="' + $qty.val() + '"/>');
		$qty = $form.find('input[name="Quantity"]');
		itemID = $pspContainer.attr('id');
    }
    if ($qty.length === 0 || isNaN($qty.val()) || parseInt($qty.val(), 10) === 0) {
        $qty.val('1');
    }
    return Promise.resolve($.ajax({
        type: 'POST',
        url: util.ajaxUrl(util.appendParamToURL(Urls.addProduct, 'itemID', itemID)),
        data: $form.serialize()
    })).then(function (response) {
        // handle error in the response
        if (response.error) {
        	availability.updateContainer(response);
            throw new Error(response.error);
        } else {
            return response;
        }
    });
};

/**
 * @description Handler to handle the add to cart event
 */
var addToCart = function (e) {
    e.preventDefault();
    var $form = $(this).closest('form');

    validator.initForm($form);
    if (!$form.valid() || !validateFormFields()) {
    	return false;
    }

    addItemToCart($form).then(function (response) {
        var $uuid = $form.find('input[name="uuid"]');
        if (($uuid.length && $uuid.val().length) || $('.sfl-quickview').length) {
            page.refresh();
        } else {
            // do not close quickview if adding individual item that is part of product set
            // @TODO should notify the user some other way that the add action has completed successfully
            if (!$(this).hasClass('sub-product-item')) {
                dialog.close();
            }

            if($('#gcAmountselect').length > 0 ){
            	$("#gcAmount").val($("#gcAmountselect option:first").val());
            	$("#gcAmountselectSelectBoxItText").text($("#gcAmountselect option:first").text());
            }

    		if (typeof dataLayer !== "undefined") {
    			var isProductSet = $('#pdpMain div.product-set').length ? true : false;
                var transactionProducts = [];
                var dlPid, dlSku, dlProductName, dlCategoryID, dlPrice, dlVariant, dlQuantity, dlSize, dlSeasonalCollection, dlColorway, dlItemAtFullPrice, dlAvailability, dlDiscount, dlMonogramming, dlBVAverage, dlMonogramStyle, dlMonogramFont, dlMonogramChars, dlMonogramColor;
                var ecomDetail = null;
                for (var i = 0; i < dataLayer.length; i++) {
                    if (dataLayer[i].event == 'ecomDetail') {
                        ecomDetail = dataLayer[i];
                        break;
                    }

                }
    			var producttiles = $('.product-tile');
                for(i=0;i<producttiles.length;i++){
                	console.log(producttiles.eq(i).attr('data-cgid'));
                }
                if (ecomDetail && 'ecommerce' in ecomDetail
                        && 'detail' in ecomDetail.ecommerce
                        && 'products' in ecomDetail.ecommerce.detail
                        && ecomDetail.ecommerce.detail.products.length
                        && 'category' in ecomDetail.ecommerce.detail.products[0]) {
                    dlCategoryID = ecomDetail.ecommerce.detail.products[0].category;
                    dlPid = ecomDetail.ecommerce.detail.products[0].id;
                    dlProductName = ecomDetail.ecommerce.detail.products[0].name
                } else if (typeof cmProductName !== "undefined") {
                    dlProductName = cmProductName;
                    dlCategoryID = cmCategoryID;
                }
                var form = $('.pdpForm');
                var standardPrice = $('#pdpMain .product-detail .price-standard').length > 0;
                dlQuantity = parseInt($('.quantity-dropdown .selectboxit').find(':selected').text());
    		    dlQuantity = dlQuantity > 0 ? dlQuantity : 1;
                if (isProductSet) {
                    var productSetItem = $(this).closest('div[class^="product-set-item"]');
                    var pidAttr = productSetItem.attr("id");
                    dlSku = $(this).parent().find('input[name="pid"]').val();
                    dlPid = pidAttr.substr(pidAttr.indexOf("-") + 1);
                    dlProductName = $.trim(productSetItem.find('.product-name').text());
                    dlCategoryID = $.trim(productSetItem.find('input[name="cgid"]').val());
                    dlPrice = ($.trim(productSetItem.find('.price-sales').html()).replace("$", ""));
                    dlVariant = $.trim(productSetItem.find(".product-variations .swatches .selected .title").text());
                    dlSize = $.trim(productSetItem.find(".product-variations .swatches.size .selected a").text());
                    // dlSeasonalCollection = '';
                    dlColorway = $.trim(productSetItem.find(".product-variations .swatches.Color .selected a").attr('title'));
                    dlItemAtFullPrice = $.trim(productSetItem.find(".product-price span").html()).replace("$","");
                    dlAvailability = $.trim(productSetItem.find('.availability-msg').attr('data-availible'));
                    // dlDiscount = '';
                    dlMonogramming = '';
                    dlBVAverage = $.trim(productSetItem.find("#BVInlineRatings").text());
                }else {
                    dlSku = $("#pid").val();
                    dlPid = dlPid || $('#product-content').find('div[data-master]').attr('data-master');
                    dlProductName = $.trim($("#product-content .product-name").text());
                    dlCategoryID = $('#pdpMain').attr('data-category');
                    dlPrice = $("#pdpMain .product-detail .price-sales").eq(0).text().split(' ')[0].trim().replace('$', '');
                    dlVariant = $.trim($(".product-variations .swatches .selected .title").text());
                    dlSize = $(".product-variations .swatches.size .selected a").length > 0 ? $.trim($(".product-variations .swatches.size .selected a").text()) : '';
                    // dlSeasonalCollection = '';
                    dlColorway = $.trim($(".product-variations .swatches.Color .selected a").attr('title'));
                    dlItemAtFullPrice = $('#pdpMain').find('.price-standard').length > 0 ? 'N' : 'Y'; // full price?
                    if($(".availability-msg").length > 0){
                    	dlAvailability = $.trim($(".availability-msg").attr('data-availible'));
                    } else if ($(".availability").length > 0) {
                    	dlAvailability = $(".availability").text().trim();
                    }
                    dlDiscount = standardPrice ? parseFloat($('#pdpMain .product-detail .price-standard').eq(0).text().replace('$', '') - $('#pdpMain .product-detail .price-sales').eq(0).text().trim().replace('$','')).toFixed(2) : '';
                    dlMonogramming = $('#pdpMain .monogram-wrapper').length > 0 ? 'Yes' : 'No';
                    dlBVAverage = $.trim($('.BVRRRatingOverall .BVRRRatingNormalImage img').eq(0).attr('title'));
                    if (dlMonogramming ==='Yes') {
                    	dlMonogramStyle = $('#pdpMain .monogram-style-tile.selected .monogram-style-name').text().trim();
                    	dlMonogramFont = $('#pdpMain .monogram-font.selected span').text().trim();
                    	dlMonogramChars = '';
                    	dlMonogramColor = $('#pdpMain .monogram-color-swatch.selected').data('color-config').colorName;
                		$('.monogram-text-input-field').each(function () {
                    		var val = $(this).val();
                    		dlMonogramChars += val;
                    	});
                    }
                }

                transactionProducts.push({
                    "brand" : 'kate',
                    "sku" : dlSku,
                    "id" : dlPid,
                    "name" : dlProductName,
                    "category" : dlCategoryID,
                    "price" : dlPrice,
                    "quantity" : dlQuantity,
                    "variant" : dlVariant,
                    "dimension5" : dlSize, //product size
                    //"dimension9" : dlSeasonalCollection, // seasonal collection the product is part of
                    "dimension10" : dlColorway, //colorway
                    "dimension11" : dlItemAtFullPrice, //Was the item at full price
                    "dimension12" : dlAvailability, //availability of product
                    "dimension13" : dlDiscount, //discount amount if applicable
                    "dimension14" : dlMonogramming, //was monogramming applied
                    //"dimension15" : dlGiftWrap, //was gift wrap selected
                    "dimension16" : dlBVAverage, //bv average star rating
                    "dimension33" : dlMonogramStyle === undefined ? '' : dlMonogramStyle,
                    "dimension34" : dlMonogramFont === undefined ? '' : dlMonogramFont,
                    "dimension35" : dlMonogramChars === undefined ? '' : dlMonogramChars,
                    "dimension36" : dlMonogramColor === undefined ? '' : dlMonogramColor
                });
                dataLayer.push(app.datalayer.getEvent("event","ecomAdd", "ecommerce", " ", "add", transactionProducts));
    		}
        }
        minicart.show(response);
        eGiftCardCleanFields();
        monogramReset();

    }.bind(this));
};

var eGiftCardCleanFields = function () {
	var vgcRecipientName = $('.pdpForm input[name="vgcRecipientName"]');
	var vgcRecipientEmail = $('.pdpForm input[name="vgcRecipientEmail"]');
	var vgcFromName = $('.pdpForm input[name="vgcFromName"]');
	var vgcRecipientEmailConfirm = $('.pdpForm input[name="vgcRecipientEmailConfirm"]');
	var vgcGiftCardMessage = $('.pdpForm textarea[name="vgcGiftCardMessage"]');
	
	if(typeof vgcRecipientName != 'undefined'){vgcRecipientName.val('');}
	if(typeof vgcRecipientEmail != 'undefined'){vgcRecipientEmail.val('');}
	if(typeof vgcFromName != 'undefined'){vgcFromName.val('');}
	if(typeof vgcRecipientEmailConfirm != 'undefined'){vgcRecipientEmailConfirm.val('');}
	if(typeof vgcGiftCardMessage != 'undefined'){vgcGiftCardMessage.val('');}

    var giftCardPDPInfo = $('.js-is-gift-card-pdp-form');
    if (giftCardPDPInfo.length > 0) {
        // remove validation checkmarks
        var validator = $('form.pdpForm').validate();
        validator.resetForm();

        // restore float labels
        giftCardPDPInfo.find('.has-float-label label').css({ opacity: 1 });
    }
};

/**
 * @description Handler to handle the add all items to cart event
 */
var addAllToCart = function (e) {
    e.preventDefault();
    var $productForms = $('#product-set-list').find('form').toArray();
    Promise.all(_.map($productForms, addItemToCart))
        .then(function (responses) {
            dialog.close();
            // show the final response only, which would include all the other items
            minicart.show(responses[responses.length - 1]);
        });
    if (typeof dataLayer !== "undefined") {var productData = $('.product-variations');
	    var transactionProducts = [];
	    var pidAttr, dlSku, dlPid, product, form, dlProductName, dlCategoryID, dlPrice, dlQuantity;
	    for(i=0;i<productData.length;i++){
	    	pidAttr = productData.eq(i);
		    dlSku = pidAttr.attr('data-vid');
		    dlPid = pidAttr.attr('data-master');
		    product = pidAttr.closest('.product-set-item');
		    form = pidAttr.closest('form');
		    dlProductName = $.trim(product.find('.item-name').text());
		    dlCategoryID = form.find('input[name="cgid"]').val();
		    dlPrice = ($.trim(product.find('.price-sales').html()).replace("$", ""));
		    dlQuantity = parseInt(form.find('.quantity-dropdown .selectboxit').find(':selected').text());
		    dlQuantity = dlQuantity > 0 ? dlQuantity : 1;
		    transactionProducts.push({ "sku" : dlSku, "id" : dlPid, "name" : dlProductName, "category" : dlCategoryID, "price" : dlPrice, "quantity" :dlQuantity});
	    }
		dataLayer.push(app.datalayer.getEvent("event","ecomAdd", "ecommerce", " ", "add", transactionProducts));
    }
};

/*
 * @function
 * @description Since there are multiple elements with the add-to-cart ID on the page,
 *  we need to handle each of them individually so that all of the .availability-msg
 *  element's texts aren't concatenated.
 */
function setAddToCartTitle() {
    $('button#add-to-cart').each( function(i, e) {
        var text = $(e).parents('.product-add-to-cart').find('.availability-msg').text().trim();
        $(e).attr('title', text);
    });
}

/**
 * @function
 * @description Binds the click event to a given target for the add-to-cart handling
 */
module.exports = function () {
    setAddToCartTitle();
    $('body').off('click','.add-to-cart').on('click', '.add-to-cart', addToCart);
    $('#add-all-to-cart').on('click', addAllToCart);
};

},{"../../dialog":34,"../../minicart":43,"../../page":44,"../../storeinventory/product":78,"../../util":82,"../../validator":83,"./availability":56,"lodash":5,"promise":6}],56:[function(require,module,exports){
'use strict';

var ajax =  require('../../ajax'),
    util = require('../../util');

var updateContainer = function (data) {
	var $container = typeof data.itemID != 'undefined' ? $('#' + data.itemID) : $('#pdpMain'),
		$availabilityContainer = $container.find('.availability'),
		$availabilityMsg = $availabilityContainer.find('.availability-msg'),
		$addToCart = $container.find('.pdpForm #add-to-cart'),
		$addAllToCart = $('#add-all-to-cart'),
		isQuickView = $('#QuickViewDialog').length,
		isEditItem = $('.ui-dialog_update-item').length,
		message; // this should be lexically scoped, when `let` is supported (ES6)

    if (!$availabilityMsg.length) {
    	$availabilityMsg = $("<div>", {"class": "availability-msg"});
    	$availabilityContainer.append($availabilityMsg);
    }
    if (!data) {
        $availabilityMsg.html(Resources.ITEM_STATUS_NOTAVAILABLE);
        $addToCart.attr('disabled', 'disabled');
        $container.find('#pdpQtySelectSelectBoxIt .selectboxit-text').text('0');
        $container.find('#pdpQtySelectSelectBoxItOptions').remove();
        return;
    }
    $availabilityMsg.empty();
    // Look through levels ... if msg is not empty, then create span el
    if (data.levels.IN_STOCK > 0) {
        if (data.levels.PREORDER === 0 && data.levels.BACKORDER === 0 && data.levels.NOT_AVAILABLE === 0) {
            // Just in stock
            message = Resources.IN_STOCK;
        } else {
            // In stock with conditions ...
            message = data.inStockMsg;
        }
        $availabilityMsg.append('<p class="in-stock-msg">' + message + '</p>');
    }
    if (data.levels.PREORDER > 0) {
        if (data.levels.IN_STOCK === 0 && data.levels.BACKORDER === 0 && data.levels.NOT_AVAILABLE === 0) {
            message = Resources.PREORDER;
        } else {
            message = data.preOrderMsg;
        }
        $availabilityMsg.append('<p class="preorder-msg">' + message + '</p>');
    }
    if (data.levels.BACKORDER > 0) {
        if (data.levels.IN_STOCK === 0 && data.levels.PREORDER === 0 && data.levels.NOT_AVAILABLE === 0) {
            message = Resources.BACKORDER;
        } else {
            message = data.backOrderMsg;
        }
        $availabilityMsg.append('<p class="backorder-msg">' + message + '</p>');
    }
    if (data.inStockDate !== '') {
        $availabilityMsg.append('<p class="in-stock-date-msg">' + String.format(Resources.IN_STOCK_DATE, data.inStockDate) + '</p>');
    }
    if (data.levels.NOT_AVAILABLE > 0) {
        if (data.levels.PREORDER === 0 && data.levels.BACKORDER === 0 && data.levels.IN_STOCK === 0) {
            message = Resources.NOT_AVAILABLE;
        } else {
            message = Resources.REMAIN_NOT_AVAILABLE;
        }
        if (data.cartMaxQuantity.QuantityLeft == 0) {
        	$availabilityMsg.append('<p class="not-available-msg">' + message + '</p>');
        	$addToCart.attr('disabled', 'disabled');
        	$container.find('#pdpQtySelectSelectBoxIt .selectboxit-text').text('0');
        	$container.find('#pdpQtySelectSelectBoxItOptions').remove();
        }
    }
    if (!isEditItem && typeof data.error != 'undefined' && data.error == 'out_of_stock' && data.cartMaxQuantity.QuantityLeft == 0) {
    	  message = Resources.PDP_NOT_AVAILABLE;
    	  $availabilityMsg.append('<p class="not-available-msg">' + message + '</p>');
    	  $addToCart.attr('disabled', 'disabled');
    	  $container.find('#pdpQtySelectSelectBoxIt .selectboxit-text').text('0');
          $container.find('#pdpQtySelectSelectBoxItOptions').remove();
    }
    // RR-467 - If the user is approaching the quantity limit,
    // limit them to the max amount that can be added.
    // If the user is editing an item already in cart, we don't need to enforce the max quantity rule.
    if (!isEditItem && typeof data.cartMaxQuantity != 'undefined') {
		if (data.cartMaxQuantity.OverQuantityLimit && data.cartMaxQuantity.QuantityLeft > 0 && data.cartMaxQuantity.QuantityLeft < $container.find('select[name="Quantity"]').val()) {
			$availabilityMsg.append('<p class="max-cart-quantity-msg">' + data.cartMaxQuantity.quantityMessageAvailable + '</p>');
		} else if (data.cartMaxQuantity.OverQuantityLimit && data.cartMaxQuantity.QuantityLeft == 0 && !(!isEditItem && typeof data.error != 'undefined' && data.error == 'out_of_stock' && data.cartMaxQuantity.QuantityLeft == 0)) {
			$availabilityMsg.append('<p class="max-cart-quantity-msg">' + data.cartMaxQuantity.quantityMessageMax + '</p>');
			$container.find('#pdpQtySelectSelectBoxIt .selectboxit-text').text('0');
	        $container.find('#pdpQtySelectSelectBoxItOptions').remove();
	        $addToCart.attr('disabled', 'disabled');
	    }
    }
    // Ensure that PDP add all button is disabled if one item is not available
    if ($addAllToCart.length) {
    	if (!$('.pdpForm #add-to-cart:disabled').length) {
    		$addAllToCart.prop('disabled', false);
    	} else {
    		$addAllToCart.prop('disabled', true);
    	}
    }
    if (data.status == "NOT_AVAILABLE") {
    	message = 'out of stock';
  	  	$availabilityMsg.append('<p class="not-available-msg">' + message + '</p>');
    }
};

var getAvailability = function () {
	// Don't need to check quantity when adding to cart.
	if ($('.ui-dialog_update-item').length) {
		return;
	}
	var $this = $(this);
	var $pspContainer = $this.parents('.product-set-item');
	var itemID = '';
	var pid = $('#pid');
	if ($pspContainer.length) {
		itemID = $pspContainer.attr('id');
		pid = $pspContainer.find('#pid');
	}
    ajax.getJson({
        url: util.appendParamsToUrl(Urls.getAvailability, {
            pid: pid.first().val(),
            Quantity: $this.val(),
            itemID: itemID
        }),
        callback: updateContainer
    });
};

module.exports = {
	init: function () {
		$('#pdpMain').on('change', 'select[name="Quantity"]', getAvailability);
	},
	updateContainer: updateContainer
};

},{"../../ajax":26,"../../util":82}],57:[function(require,module,exports){
'use strict';
var dialog = require('../../dialog');
var util = require('../../util');
var qs = require('qs');
var url = require('url');
var _ = require('lodash');

var zoomMediaQuery = matchMedia('(min-width: 960px)');
var $cache = {};
	$cache.pdpMain = $('#pdpMain');
	$cache.productThumbnailTiles = $cache.pdpMain.find('#thumbnails .thumb');

/**
 * @description Enables the zoom viewer on the product detail page
 * @param zmq {Media Query List}
 */
function loadZoom (zmq) {
    var $imgZoom = $('#pdpMain .main-image'),
        hiresUrl;
    if (!zmq) {
        zmq = zoomMediaQuery;
    }
    if ($imgZoom.length === 0 || dialog.isActive() || util.isMobile() || !zoomMediaQuery.matches) {
        // remove zoom
        $imgZoom.trigger('zoom.destroy');
        return;
    }
    hiresUrl = $imgZoom.attr('href');

    if (hiresUrl && hiresUrl !== 'null' && hiresUrl.indexOf('noimagelarge') === -1 && zoomMediaQuery.matches) {
        $imgZoom.zoom({
            url: hiresUrl
        });
    }
}

zoomMediaQuery.addListener(loadZoom);

/**
 * @description Sets the main image attributes and the href for the surrounding <a> tag
 * @param {Object} atts Object with url, alt, title and hires properties
 */
function setMainImage (atts, e) {
    var $this = $(e.target).closest('.thumb');
    // Get selected image src
    var src = $this.find('img').attr('src');

    if (!dialog.isActive()) {
        $('.thumb').removeClass('selected');
        $this.addClass('selected');
        if ($('.product-col-1').hasClass('product-set')) {
            $('.product-col-1 .primary-image').attr('src', atts.url);
        } else {
            // Create a new instance of CloudZoom
            var cz = $('.cloudzoom').data('CloudZoom');
            // Load a new small image and zoom image into it:
            var smallImg = src.replace('$productThumbnail$', '$large$');
            var zoomImg = smallImg.replace('$large$', '$fullsize$');
            // Load new images into CloudZoom instance
            cz.loadImage(smallImg, zoomImg);
        }
    } else {
        var selectedImgSrc = src.replace('$productThumbnail$', '$large$');
        var $productPrimaryImg = $('#pdpMain .product-primary-image img.primary-image');
        $productPrimaryImg.attr('src', selectedImgSrc);
        $('#pdpMain #thumbnails .thumb').removeClass('selected');
        $this.addClass('selected');
    }

    updatePinButton(atts.url);
    if (!dialog.isActive() && !util.isMobile()) {
        $('#pdpMain .main-image').attr('href', atts.hires);
    }
}
function thumbnailCarousel(aligment) {
    $('.thumbnail-overlay').jcarousel({
        auto: 0,
        vertical: aligment,
        scroll:1
    });
    $('.jcarousel-control-prev')
    .on('jcarouselcontrol:active', function() {
        $(this).removeClass('inactive');
    })
    .on('jcarouselcontrol:inactive', function() {
        $(this).addClass('inactive');
    })
    .jcarouselControl({
        target: '+=1'
    });

    $('.jcarousel-control-next')
    .on('jcarouselcontrol:active', function() {
        $(this).removeClass('inactive');
    })
    .on('jcarouselcontrol:inactive', function() {
        $(this).addClass('inactive');
    })
    .jcarouselControl({
        target: '-=1'
    });
}
function thumbnailCarouselReload() {
    var isVerticalCarousel = true;
    if (util.getViewport() < 960 || dialog.isActive()) {
        isVerticalCarousel = false;
    }
    $('.thumbnail-overlay').jcarousel('reload', {
        auto: 0,
        vertical: isVerticalCarousel,
        scroll:1
    });
}
function jcarouselEvents() {
    //click functions to manually change main product image on carousel arrow click since arrows are
    //meant to control thumbnails
    $('.product-thumbnails .jcarousel-control-next').on('click',function(e){
        if(util.getViewport() < 961 && util.getViewport() > 481){
            var thumbs = $('li.thumb');
            var activeThumb = thumbs.filter('.selected').index();
            if(activeThumb == 0){
                return
            }
            var newActiveThumb = activeThumb - 1;
            thumbs.eq(activeThumb).removeClass('selected');
            thumbs.eq(newActiveThumb).addClass('selected');
            $('li.thumb.selected').click();
        }
    });
    $('.product-thumbnails .jcarousel-control-prev').on('click',function(e){
        if(util.getViewport() < 961 && util.getViewport() > 481){
            var thumbs = $('li.thumb');
            var activeThumb = thumbs.filter('.selected').index();
            if(activeThumb == (thumbs.length - 1)) {
                return;
            }

            var newActiveThumb = activeThumb + 1;
            thumbs.eq(activeThumb).removeClass('selected');
            thumbs.eq(newActiveThumb).addClass('selected');
            $('li.thumb.selected').click();
        }
    });
}
function updatePinButton (imageUrl) {
    var pinButton = document.querySelector('.share-icon[data-share=pinterest]');
    if (!pinButton) {
        return;
    }
    var newUrl = imageUrl;
    var pdpPrimaryImageElement = document.querySelector('#pdpMain .primary-image');
    if (!pdpPrimaryImageElement) {
        return;
    }
    if (!imageUrl) {
        newUrl = pdpPrimaryImageElement.getAttribute('src');
    }
    var href = url.parse(pinButton.href);
    var query = qs.parse(href.query);
    query.media = url.resolve(window.location.href, newUrl);
    query.url = window.location.href;
    var newHref = url.format(_.extend({}, href, {
        query: query, // query is only used if search is absent
        search: qs.stringify(query)
    }));
    pinButton.href = newHref;
}

/**
 * @description Replaces the images in the image container, for eg. when a different color was clicked.
 */
function replaceImages () {
    var $newMainImage = $('#update-images .product-imagery-container'),
        $newThumbnails = $('#update-images #thumbnails'),
        $mainImage = $('#pdpMain .product-imagery-container'),
        $thumbnails = $('#pdpMain #thumbnails');
    if ($newMainImage.length === 0 || $newThumbnails.length === 0) { return; }

    $mainImage.html($newMainImage.html());
    $thumbnails.html($newThumbnails.html());
    $newMainImage.remove();
    $newThumbnails.remove();
    loadZoom();
    var isVerticalCarousel = true;
    if (util.getViewport() < 960 || dialog.isActive()) {
        isVerticalCarousel = false;
    }
    thumbnailCarousel(isVerticalCarousel);
}

/* @module image
 * @description this module handles the primary image viewer on PDP
 **/

/**
 * @description by default, this function sets up zoom and event handler for thumbnail click
 **/
module.exports = function () {
    if (dialog.isActive() || util.isMobile()) {
        $('#pdpMain .main-image').removeAttr('href');
    }
    updatePinButton();
    //loadZoom();

    // Initialize CloudZoom
    if (!dialog.isActive()) {
        //CloudZoom.quickStart();
    }
    // handle product thumbnail click event
    $('#pdpMain').on('click', '.thumb', function (e) {
        // switch indicator
        e.preventDefault();
        setMainImage($(this).find('.productthumbnail').data('lgimg'), e);
    });

    jcarouselEvents();

};
module.exports.loadZoom = loadZoom;
module.exports.jcarouselEvents = jcarouselEvents;
module.exports.setMainImage = setMainImage;
module.exports.replaceImages = replaceImages;
module.exports.thumbnailCarousel = thumbnailCarousel;
module.exports.thumbnailCarouselReload = thumbnailCarouselReload;

},{"../../dialog":34,"../../util":82,"lodash":5,"qs":16,"url":23}],58:[function(require,module,exports){
'use strict';

var dialog = require('../../dialog'),
	giftcard = require('../../giftcard'),
    productStoreInventory = require('../../storeinventory/product'),
    tooltip = require('../../tooltip'),
    util = require('../../util'),
    addToCart = require('./addToCart'),
    availability = require('./availability'),
    image = require('./image'),
    productSet = require('./productSet'),
    recommendations = require('./recommendations'),
    selectBoxIt = require('../../selectboxit'),
    variant = require('./variant');

var $cache = {
    productThumbnailTiles: $('#pdpMain').find('#thumbnails .thumb'),
    pdpMain: $('#pdpMain')
};
/**
 * @description Initialize product detail page with reviews, recommendation and product navigation.
 */
function initializeDom() {
    recommendations();
    tooltip.init();
    var isVerticalCarousel = true;
    if (util.getViewport() < 960 || dialog.isActive()) {
        isVerticalCarousel = false;
    }
    image.thumbnailCarousel(isVerticalCarousel);
}
function changeTumb() {
	var attrUrl = '';
	var res = '';
	var img;
	$('#thumbnail-carousel .thumb').each(function(){
		img = $(this).find('img');
		attrUrl = img.attr('src');
		res = attrUrl.replace('productThumbnail', 'large');
		img.attr('src',res);
	})
	$('#thumbnail-carousel').slick({
    	dots: true,
		infinite: true,
		centerMode: true,
        centerPadding: '40px',
		speed: 300,
		slidesToShow: 1,
		arrows: false
	});
}

function productThumbnailClick(e) {
    e.preventDefault();
    if (!$('.product-col-1').hasClass('product-set')) {
        $cache.productThumbnailTiles.removeClass('selected');

        var $this = $(e.target).closest('.thumb');

        $this.addClass('selected');

        // Create a new instance of CloudZoom
        var cz = $(".cloudzoom").data("CloudZoom");

        // Get selected image src
        var src = $this.find('img').attr('src');

        // Load a new small image and zoom image into it:
        var smallImg = src.replace("$productThumbnail$", "$large$");
        var zoomImg = smallImg.replace("$large$", "$fullsize$");

        // Load new images into CloudZoom instance
        cz.loadImage(smallImg, zoomImg);
    }
}

/**
 * @description Initialize event handlers on product detail page
 */
function initializeEvents() {

    addToCart();
    availability.init();
    variant();
    image();
    productSet();
    giftcard.init();
    util.smartResize(function () {
        image.thumbnailCarouselReload()
    });

    if (SitePreferences.STORE_PICKUP) {
        productStoreInventory.init();
    }
    $cache.pdpMain.on('click', '.sizeguidelink', function (e) {
        e.preventDefault();
        var width = (window.innerWidth < 480) ? (window.innerWidth - 40).toString() : '450';
        dialog.open({
            url: this.href,
            options: {
            	'width': width,
                dialogClass: "sizeguide-modal"
            }
        });

    });
    // Add to Wishlist and Add to Gift Registry links behaviors
    $cache.pdpMain.on('click', '[data-action="wishlist"], [data-action="gift-registry"]', function () {
        var data = util.getQueryStringParams($('.pdpForm').serialize());
        if (data.cartAction) {
            delete data.cartAction;
        }
        var url = util.appendParamsToUrl(this.href, data);
        this.setAttribute('href', url);
    });

    /*Product Tablet Share button*/
    $cache.pdpMain.on ('click', '.sub-header', function(e){
    	$(this).toggleClass('active');
    });
    // product options
    $cache.pdpMain.on('change', '.product-options select', function () {
        var salesPrice = $cache.pdpMain.find('.product-add-to-cart .price-sales');
        var selectedItem = $(this).children().filter(':selected').first();
        salesPrice.text(selectedItem.data('combined'));
    });

    $cache.pdpMain.on('click', '.select-quantity', function(){
        if(navigator.userAgent.match(/i(Phone|Pad)/i)) {
            $('.selectboxit-options.dropdown-menu').hide();
        }
    });

    // prevent default behavior of thumbnail link and add this Button
    $cache.pdpMain.on('click', '.thumbnail-link', function (e) {
        e.preventDefault();
    });

    $cache.pdpMain.on('click', '.unselectable-overlay', function (e) {
        e.preventDefault();
        $(this).closest('li').find('a').click();
    });

    $('.size-chart-link a').on('click', function (e) {
        e.preventDefault();
        dialog.open({
            url: $(e.target).attr('href')
        });
    });

    $cache.pdpMain.on("click", ".facebook-share", function(e) {
        FB.ui({
            method: 'share',
            href: $(e.target).attr('data-url'),
        }, function(response){});
    });
    $cache.pdpMain.on("click", ".twitter-share a", function(e) {
    	e.preventDefault();
    	window.open(this.href, "Twitter share", "width=800, height=255");
        return false;
    });

    $('body').on('click','#fullscreen-zoom-hopup', function(e) {
        e.preventDefault();

		// Create Dialog
        var params = {};


		//Potentially add monogramming option parameters
		/*var $monogrammingContainer = pdpMain.find('.monogram-container');

		if($monogrammingContainer.length){

			var imgOptions = $monogrammingContainer.data('imageOptions'),
				personalizationType = $monogrammingContainer.find('ul.monogram-styles li.monogram-style-tile.selected').data('style-config').personalizationType;

			var valid = (imgOptions['$ftype'] != null &&
				imgOptions['$fstyle'] !=  null &&
				imgOptions['$dots'] != null &&
				(imgOptions['$chr1'] != null || imgOptions['$chr2'] != null || imgOptions['$chr3'] != null));

			if($monogrammingContainer.find('li.monogram-color-swatch').length){
				valid = valid && imgOptions['$color'] != null;
			}

			if(valid){

				var keys = Object.keys(imgOptions),
					newImgOptions = {};

				//add the prefix to make it easy on the serverside to grab all of the right parameters
				for(var i = 0; i < keys.length;i++){
					var key = "imgOption_"+keys[i];

					newImgOptions[key] = imgOptions[keys[i]];
				}

				newImgOptions["personalizationType"] = personalizationType;

				params = newImgOptions;
			}
		}*/


        var url = util.appendParamsToUrl($(this).attr('href'),params);
        dialog.open({
            url: url,
            options: {
                width: 895,
                dialogClass: 'fullScreen'
            },
            callback: function () {

                var dialogContainer = $('#dialog-container');
                var productImage = dialogContainer.find($('.product-primary-image img'));
                var downloadLink = $('#fullscreen-download a');
                dialogContainer.find($('.ui-dialog-titlebar-close').addClass('fullscreen-zoom-close'));

                var replaceStr = '$s7fullsize$';
				/*if($monogrammingContainer.length){
					replaceStr = "$productThumbnail$";
				}*/

                $('.thumb a').click(function(e) {
                    e.preventDefault();
                    var imageSrc = $(this).attr('href');

                    var fullScreenImg = imageSrc.replace(replaceStr, '$fullscreen$');
                    productImage.attr('src', fullScreenImg);

					// Append Scene7 param force download
                    fullScreenImg += '&download';
                    downloadLink.attr('href', fullScreenImg);
                    $(e.target).closest('li').addClass('selected').siblings().removeClass('selected');
                });
                if($('#dialog-container #thumbnail-carousel li.thumb').length > 4){
	                $('#dialog-container #thumbnail-carousel').slick({
	                	dots: false,
	            		infinite: false,
	            		speed: 300,
	            		slidesToShow: 4,
	            		arrows: true,
	            		vertical: true
	            	});
                }
                var $list = dialogContainer.find('.thumbnail-overlay');

                var next = dialogContainer.find('#next');
                var prev = dialogContainer.find('#prev');


                var $first = $('li:first', $list),
                    $last = $('li:last', $list);

                next.click(function (e) {
                    e.preventDefault();
                    var $next, $selected = dialogContainer.find(('.selected'));
                    $next = $selected.next('li').length ? $selected.next('li') : $first;
                    $selected.removeClass('selected');
                    $next.addClass('selected');
                    var url = $next.find('a').attr('href');
                    /*if ($monogrammingContainer.length){
                        url = url.replace(replaceStr,'$fullscreen$');
                    }*/

                    productImage.attr('src', url);
                    downloadLink.attr('href', url);

                    if ($last.hasClass('selected')) {
                        $('.jcarousel-next').trigger('click');
                    }
                });

                prev.click(function () {
                    var $prev, $selected = dialogContainer.find(('.selected'));
                    $prev = $selected.prev('li').length ? $selected.prev('li') : $last;
                    $selected.removeClass('selected');
                    $prev.addClass('selected');

                    var url = $prev.find('a').attr('href');

                    /*if ($monogrammingContainer.length){
                        url = url.replace(replaceStr,'$fullscreen$');
                    }*/

                    productImage.attr('src', url);
                    downloadLink.attr('href', url);

                    if ($first.hasClass('selected')) {
                        $('.jcarousel-prev').trigger('click');
                    }
                });

                // clear dialog on close
                $('.ui-dialog.fullScreen .ui-icon-closethick').click(function () {
                    $('.ui-dialog.fullScreen .dialog-content').empty();
                });

                var pdpMainCarousel = $('#pdpMain #thumbnail-carousel .selected');
                if (pdpMainCarousel.length) {
                    var selectedIndex = pdpMainCarousel.index();
                    var correspondingFSZoomImage = $list.find('li').eq(selectedIndex).find('a');
                    if (correspondingFSZoomImage.length) {
                        correspondingFSZoomImage.click();
                    }
                }
            }
        });
    });
    $(window).resize(function(){
    	$('#last-visited .slick-slider').slick('refresh');
        $('.pdp-recommendations .product-listing .slick-slider').slick('refresh');
    });

    if (util.getViewport() < 481){
    	changeTumb();
	 } else {
        var carousel = $('#thumbnail-carousel');
        if (carousel.hasClass('slick-initialize')) {
            carousel.slick('unslick');
        }
	 }

    $(window).resize(function(){
        setTimeout(function () {
            if (util.getViewport() < 481) {
            	changeTumb()
            } else {
                var carousel = $('#thumbnail-carousel');
                if (carousel.hasClass('slick-initialize')) {
                    carousel.slick('unslick');
                }
            }
        }, 100);
    });

    //True Fit
    if (typeof tfc !== 'undefined'){
        tfc.event('tfc-fitrec-product', 'success', function(context) {
            fitrec_selectsize(context.fitRecommendation.size, context.fitRecommendation.score, false, context.fitRecommendation.id);
            $('.registry, .wishlist').removeClass('blocked').addClass('wl-action');
            if($(".item-" + context.fitRecommendation.id + " #va-size").val() != ''){
                $('#add-to-cart').removeAttr('disabled');
            }
        });
    }

    function fitrec_selectsize(size, score, usesDropDown, productID){
        //True fit size update
        if($("#item-" + productID).length > 0){
            //Drop Down for size
            if(!$("#item-" + productID).hasClass("tf-size-auto-selected")){
                $("#item-" + productID + " #va-size option:selected").removeAttr("selected");
                $("#item-" + productID + " #va-size option[value*='size=" + size + "']").attr('selected', 'selected');
                //Add class so user can overwrite selection
                $("#item-" + productID).addClass("tf-size-auto-selected");
                //Refresh selectBoxIt
                var selectBox = $("#item-" + productID + " #va-size").selectBoxIt().data("selectBoxIt");
                selectBox.refresh();
                $("#item-" + productID + " #va-size").trigger('change');
            }
        }
        else{
            //Links for size
            if($('.product-variations .size .selected').length < 1){
                $('.size-link-' + size).click();
            }
        }
    }

    // initialize eGC image hidden attributes (only required on page load)
    var eGCImageElement = $('input#gcImage');
    var eGCStorefrontImageElement = $('input#gcStorefrontImage');
    var selectedColor = $('ul.swatches.Color li.selected a');
    if (eGCImageElement.length && selectedColor.length){
    	eGCImageElement.val(selectedColor.data('src'));
    }
    if (eGCStorefrontImageElement.length && selectedColor.length) {
    	eGCStorefrontImageElement.val(selectedColor.attr('href'));
    }

    // init Slick slider when pdp-recommendation has been loaded into page
    document.addEventListener('pdpRecommendationOnLoad', function() {
        initializeSlick($('.pdp-recommendations .product-listing'));
    });

    $cache.productThumbnailTiles.click(productThumbnailClick);
}

function addToCarousel(parentDiv){
	// Pass parent element
    var carouselItem = parentDiv.find('ul');
    var thumbCount = carouselItem.find($('li'));

	// Shift thumbs to fit container 4 thumbs
    if (thumbCount.length == 4){
        thumbCount.addClass('shift-left');
    }

	// If we have 4 or more thumbs init carousel
    if (carouselItem.length && thumbCount.length >= 4) {
    	carouselItem.jcarousel({
            scroll:1,
            itemFallbackDimension: 100
        });

		// Swipe functionality
        carouselItem.touchwipe({
            wipeLeft: function() {
                carouselItem.jcarousel('next');
            },
            wipeRight: function() {
                carouselItem.jcarousel('prev');
            },
            preventDefaultEvents: false
        });
    }
}

function initializeSlick(parentDiv){
    // Pass parent element
    var carouselItem = parentDiv.find('ul');
    var thumbCount = carouselItem.find($('li'));

    if(carouselItem.hasClass('slick-slider')){
        carouselItem.slick('unslick');
    }

    carouselItem.slick({
        infinite: true,
        dots: false,
        slide: 'li',
        responsive: [
            {
                breakpoint: 99999,
                settings: thumbCount.length < 4 ? "unslick" : {slidesToShow: 4}
            },
            {
                breakpoint: 480,
                settings: thumbCount.length <= 2 ? "unslick" : {slidesToShow: 2}
            }
        ]
    });

}

// UIS - Check product inventory
function initializeUIS () {
    var pid = $('input#uisProductID').val();
    var url = app.util.appendParamsToUrl( Urls.uisProductInclude, { productID: pid } );
    $.get( url, null );
}

var product = {
    initializeEvents: initializeEvents,
    init: function () {
        initializeDom();
        initializeEvents();
        initializeUIS();
        selectBoxIt.selectBoxIt($('.select-quantity'));
        selectBoxIt.selectBoxIt($('#gcAmountselect'));
        // Init Recommendations Carousel
        addToCarousel($('#recommendations'));
        // Init "More in" Carousel
        addToCarousel($('#moreInCat'));
        // Init Last Visited Carousel
        initializeSlick($('#last-visited'));
    }
};

module.exports = product;

},{"../../dialog":34,"../../giftcard":37,"../../selectboxit":73,"../../storeinventory/product":78,"../../tooltip":81,"../../util":82,"./addToCart":55,"./availability":56,"./image":57,"./productSet":59,"./recommendations":60,"./variant":61}],59:[function(require,module,exports){
'use strict';

var ajax = require('../../ajax'),
    tooltip = require('../../tooltip'),
    util = require('../../util'),
    selectBoxIt = require('../../selectboxit');

module.exports = function () {
    var $addToCart = $('#add-to-cart'),
        $addAllToCart = $('#add-all-to-cart'),
        $productSetList = $('#product-set-list');

    var updateAddToCartButtons = function () {
        if ($productSetList.find('.add-to-cart[disabled]').length > 0) {
            $addAllToCart.attr('disabled', 'disabled');
            // product set does not have an add-to-cart button, but product bundle does.
            // if the button is already disabled, no need to disable all buttons on the page.
            //$addToCart.attr('disabled', 'disabled');
        } else {
            $addAllToCart.removeAttr('disabled');
            $addToCart.removeAttr('disabled');
        }
    };

    if ($productSetList.length > 0) {
        updateAddToCartButtons();
    }
    // click on swatch for product set
    $productSetList.on('click', '.product-set-item .swatchanchor', function (e) {
        e.preventDefault();

        var $swatchLiElement = $(this).parents('li');
        if ($swatchLiElement.hasClass('unselectable') || $swatchLiElement.hasClass('selected')) {
            return;
        }

        var url = Urls.getSetItem + this.search;
        var $container = $(this).closest('.product-set-item');
        var qty = $container.find('form select[name="Quantity"]').first().val();

        ajax.load({
            url: util.appendParamToURL(url, 'Quantity', isNaN(qty) ? '1' : qty),
            target: $container,
            callback: function () {
                updateAddToCartButtons();
                tooltip.init();
                selectBoxIt.selectBoxIt($('select'));
                //True Fit
                if (tfc !== 'undefined'){
                    tfc.calculate();
                }
            }
        });
    });
};

},{"../../ajax":26,"../../selectboxit":73,"../../tooltip":81,"../../util":82}],60:[function(require,module,exports){
'use strict';

/**
 * @description Creates product recommendation carousel using jQuery jcarousel plugin
 **/
module.exports = function () {
    var $carousel = $('#carousel-recommendations');
    if (!$carousel || $carousel.length === 0 || $carousel.children().length === 0) {
        return;
    }
    $carousel.jcarousel();
    $('#carousel-recommendations .jcarousel-prev')
        .on('jcarouselcontrol:active', function () {
            $(this).removeClass('inactive');
        })
        .on('jcarouselcontrol:inactive', function () {
            $(this).addClass('inactive');
        })
        .jcarouselControl({
            target: '-=1'
        });

    $('#carousel-recommendations .jcarousel-next')
        .on('jcarouselcontrol:active', function () {
            $(this).removeClass('inactive');
        })
        .on('jcarouselcontrol:inactive', function () {
            $(this).addClass('inactive');
        })
        .jcarouselControl({
            target: '+=1'
        });
};

},{}],61:[function(require,module,exports){
'use strict';

var ajax = require('../../ajax'),
    image = require('./image'),
    progress = require('../../progress'),
    productStoreInventory = require('../../storeinventory/product'),
    tooltip = require('../../tooltip'),
    util = require('../../util'),
    dialog = require('../../dialog'),
    selectBoxIt = require('../../selectboxit'),
    fullScreenImage = require('../../storeinventory/product').fullScreenImage;


/**
 * @description update product content with new variant from href, load new content to #product-content panel
 * @param {String} href - url of the new product variant
 **/
function changeTumb() {
	var attrUrl = '';
	var res = '';
	var img;
	$('#thumbnail-carousel .thumb').each(function(){
		img = $(this).find('img');
		attrUrl = img.attr('src');
		res = attrUrl.replace('productThumbnail', 'large');
		img.attr('src',res);
	})
	//if slick is already initialized, we don't need to do anything, so we check for class 'slick-slider'
	if(!$('#thumbnail-carousel').hasClass('slick-slider')){

		$('#thumbnail-carousel').slick({
	    	dots: true,
			infinite: true,
			speed: 300,
			slidesToShow: 1,
			arrows: false
		});
	}
}
var updateContent = function (href) {
    var $pdpForm = $('.pdpForm');
    var qty = $pdpForm.find('select[name="Quantity"]').first().val();
    var params = {
        Quantity: isNaN(qty) ? '1' : qty,
        format: 'ajax'
    };

    var selectedColor = $('#pdpMain').find('.Color .selected-value').first();
    if(selectedColor.length){
        var colorName = selectedColor.attr('data-name').toString();
        var colorValue = selectedColor.attr('data-value').toString();
        if(colorName && colorValue && !params[colorName] && href.indexOf(colorName) == -1){
            // force the auto-selected color into the ajax call
            params[colorName] = colorValue;
        }
    }

    progress.show($('#pdpMain'));
    ajax.load({
        url: util.appendParamsToUrl(href, params),
        target: $('#product-content'),
        callback: function () {
            // Account Protected Links
        	$('.protected').on('click', function(e) {
                e.preventDefault();
                $('#top-banner-interior .account-link-login a.user-login-hopup').click();
            });
        	if (SitePreferences.STORE_PICKUP) {
                productStoreInventory.init();
            }
            image.replaceImages();
            fullScreenImage();
            tooltip.init();
            if (util.getViewport() < 481){
        		changeTumb();
	    	}
            // reload the bazaar voice ratings pane
			if ($('#BVCustomerRatings').length > 0 && typeof $BV != "undefined" && "ui" in $BV) {
				$BV.ui("rr", "show_reviews", configData);
			}
            if (dialog.isActive()) {
             // hide/show thumbnail arrows based on swatch list length
                var $thumbnails = $('#thumbnails');
                var thumbsWidth = 0;
                var $thumbsPrevArrow = $('.jcarousel-control-prev');
                var $thumbsNextArrow = $('.jcarousel-control-next');
                $('.thumb').each(function() {
                    thumbsWidth += $(this).width();
                })
                if (thumbsWidth <= $('#thumbnails').width()) {
                    $thumbsPrevArrow.hide();
                    $thumbsNextArrow.hide();
                }
                image.jcarouselEvents();
            }
            //True Fit
            if (typeof tfc !== 'undefined'){
                tfc.calculate();
            }
            setTimeout( function () {
                selectBoxIt.selectBoxIt($('select.select-quantity'));
            }, 0);
            // in case of asynchronous wait times overriding first change
            setTimeout( function () {
                selectBoxIt.selectBoxIt($('select.select-quantity'));
            }, 250);
            setTimeout( function () {
                selectBoxIt.selectBoxIt($('select.select-quantity'));
            }, 500);
        }
    });
};
var changeAvailabilityPosition = function() {
  if ($('.product-set-item').length == 0) {
        var windowWidth = $(window).width(),
            availabilityContainer = $('.product-add-to-cart').find('.availability');
      if(windowWidth <= 768 && !availabilityContainer.hasClass('tablet-moved')) {
          $(availabilityContainer).addClass('tablet-moved').insertAfter('.a2c-btn-container');
      }
      if(windowWidth > 769 && availabilityContainer.hasClass('tablet-moved')) {
          $(availabilityContainer).removeClass('tablet-moved').insertAfter('.inventory');
      }
  }
}

module.exports = function () {
    var $pdpMain = $('#pdpMain:not([class*="gift-card"])');
    // hover on swatch - should update main image with swatch image
    $pdpMain.on('mouseenter mouseleave', '.swatchanchor', function () {
        var largeImg = $(this).data('lgimg'),
            $imgZoom = $pdpMain.find('.main-image'),
            $mainImage = $pdpMain.find('.primary-image');

        if (!largeImg) { return; }
        // store the old data from main image for mouseleave handler
        $(this).data('lgimg', {
            hires: $imgZoom.attr('href'),
            url: $mainImage.attr('src'),
            alt: $mainImage.attr('alt'),
            title: $mainImage.attr('title')
        });
        // set the main image
        image.setMainImage(largeImg);
    });
       $pdpMain.on('mouseenter', '.swatches.size', function () {
            $('.bx-creative').show();
        }).on('mouseleave', '.swatches.size', function () {
            $('.bx-creative').hide();
        });


    // click on swatch - should replace product content with new variant
    $pdpMain.on('click', '.product-detail .swatchanchor', function (e) {
        e.preventDefault();
        var $liElement = $(this).parents('li');
        if ($liElement.hasClass('selected')) { return; }
        updateContent(this.href);
    });

    // change drop down variation attribute - should replace product content with new variant
    $pdpMain.on('change', '.variation-select', function () {
        if ($(this).val().length === 0) { return; }
        updateContent($(this).val());
    });
    $('#pdpMain.gift-card').on('click', '.product-detail .swatchanchor', function (e) {
        e.preventDefault();
    });
    changeAvailabilityPosition();
    util.smartResize(function () {
        changeAvailabilityPosition();
    });
};
},{"../../ajax":26,"../../dialog":34,"../../progress":68,"../../selectboxit":73,"../../storeinventory/product":78,"../../tooltip":81,"../../util":82,"./image":57}],62:[function(require,module,exports){
'use strict';

var addProductToCart = require('./product/addToCart'),
    ajax = require('../ajax'),
    login = require('../login'),
    quickview = require('../quickview'),
    validator = require('../validator'),
    util = require('../util'),
    selectBoxIt = require('../selectboxit'),
    floatlabels = require('../float-labels');

function maskDateField() {
	$('#dwfrm_giftregistry_event_date').mask("00 / 00 / 00", { watchInputs: true });
	var $dateField = $('#dwfrm_giftregistry_event_datenothidden');
	var dateFieldVal = $dateField.val();
	if (dateFieldVal && dateFieldVal.length == 12) {
		var yearVal = dateFieldVal.substring(10, dateFieldVal.length);
		if (parseInt(yearVal) > 2000) {
			var newVal = dateFieldVal.substring(0, 10) + yearVal.substring(2, yearVal.length);
			$dateField.val(newVal);
		}
	}
	$dateField.mask("00 / 00 / 00", { watchInputs: true });
}

function hideStepIfEdit() {

	if(!$('.tabs').is(':visible')) {
		$('.dynamic').hide();
	}
}

function migratePreToPostFields() {
	var $formBefore = $('fieldset[name=address-before]');
	var $formAfter = $('fieldset[name=address-after]');

	$formAfter.find('[name$="_addressid"]').val($formBefore.find('[name$="_addressid"]').val()).blur();
	$formAfter.find('[name$="_firstname"]').val($formBefore.find('[name$="_firstname"]').val()).blur();
	$formAfter.find('[name$="_lastname"]').val($formBefore.find('[name$="_lastname"]').val()).blur();
	$formAfter.find('[name$="_address1"]').val($formBefore.find('[name$="_address1"]').val()).blur();
	$formAfter.find('[name$="_address2"]').val($formBefore.find('[name$="_address2"]').val()).blur();
	$formAfter.find('[name$="_city"]').val($formBefore.find('[name$="_city"]').val()).blur();
	$formAfter.find('[name$="_country"]').val($formBefore.find('[name$="_country"]').val()).blur();
	$formAfter.find('[name$="_postal"]').val($formBefore.find('[name$="_postal"]').val()).blur();
	$formAfter.find('[name$="_state"]').val($formBefore.find('[name$="_state"]').val()).blur();
	$formAfter.find('[name$="_phone"]').val($formBefore.find('[name$="_phone"]').val()).blur();
}

/**
 * @function
 * @description Loads address details to a given address and fills the address form
 * @param {String} addressID The ID of the address to which data will be loaded
 */
function populateForm(addressID, $form) {
    // load address details
    var url = Urls.giftRegAdd + addressID;
    ajax.getJson({
        url: url,
        callback: function (data) {
            if (!data || !data.address) {
                window.alert(Resources.REG_ADDR_ERROR);
                return false;
            }
            // fill the form
            $form.find('[name$="_addressid"]').val(data.address.ID).blur();
            $form.find('[name$="_firstname"]').val(data.address.firstName).blur();
            $form.find('[name$="_lastname"]').val(data.address.lastName).blur();
            $form.find('[name$="_address1"]').val(data.address.address1).blur();
            $form.find('[name$="_city"]').val(data.address.city).blur();
            $form.find('[name$="_country"]').val(data.address.countryCode.toUpperCase()).blur();
            $form.find('[name$="_postal"]').val(data.address.postalCode).blur();
            if(data.address.countryCode == 'US'){
                $($form.find('[name$="_state"]')).rules('add', {
                    required: true
                });
                $form.find('[name$="_state"]').val(data.address.stateCode.toUpperCase()).blur();
            }else{
                $($form.find('[name$="_state"]')).rules('add', {
                    required: false
                });
                $form.find('[name$="_state"]').val('').blur();
            }
            $form.find('[name$="_phone"]').val(data.address.phone).blur();

            // Address 2 may be empty - need to decide whether to blur the field or not.
            if ($form.find('[name$="_address2"]').length > 0) {
            	$form.find('[name$="_address2"]').val(data.address.address2).blur();
            } else {
            	$form.find('[name$="_address2"]').val(data.address.address2);
            }
            //provide mask for saved address
            $form.find('[name$="_phone"]').unmask().mask("(000) 000-0000").blur();
        }
    });
}

/**
 * @private
 * @function
 * @description Initializes events for the gift registration
 */
function initializeEvents() {
    var $eventAddressForm = $('form[name$="_giftregistry"]'),
        $beforeAddress = $eventAddressForm.find('fieldset[name="address-before"]'),
        $afterAddress = $eventAddressForm.find('fieldset[name="address-after"]');
    	var $publicCheckBox = $('.public-checkbox').find('.input-checkbox');
    	var $hiddenPublicCheckBox = $('.public-checkbox-hidden').find('.input-checkbox');
    	var $quantityDesired = $('.option-quantity-desired').find('.input-text');

    	$publicCheckBox.change(function() {
	        if($(this).is(":checked")) {
	        	$(this).parent().parent().parent().parent().parent().parent().find('.for-details').find('.public-checkbox-hidden').find('.input-checkbox').prop('checked', true);
	        }
	        else {
	        	$(this).parent().parent().parent().parent().parent().parent().find('.for-details').find('.public-checkbox-hidden').find('.input-checkbox').prop('checked', false);
	        }
    	});

    	$quantityDesired.change(function() {
    		$(this).parent().parent().parent().parent().parent().find('.for-details').find('.option-quantity-desired-hidden').find('.input-text').val($(this).val());
    	});


    $('.usepreevent').on('click', function () {
        // filter out storefront toolkit
        $(':input', $beforeAddress).not('[id^="ext"]').not('select[name$="_addressBeforeList"]').each(function () {
            var fieldName = $(this).attr('name'),
                $afterField = $afterAddress.find('[name="' + fieldName.replace('Before', 'After') + '"]');
            $afterField.val($(this).val()).trigger('change');
        });
    });
    $eventAddressForm.on('change', 'select[name$="_addressBeforeList"]', function () {
        var addressID = $(this).val();
        if (addressID.length === 0) { return; }
        populateForm(addressID, $beforeAddress);
    })
    .on('change', 'select[name$="_addressAfterList"]', function () {
        var addressID = $(this).val();
        if (addressID.length === 0) { return; }
        populateForm(addressID, $afterAddress);
    });

    $('.item-edit-details').click(function (e) {
        e.preventDefault();
        var productListID = $('input[name=productListID]').val();
        //Very specific case for making inputs outside of dialog available
        $.widget( "ui.dialog", $.ui.dialog, {
            _allowInteraction: function( event ) {
                return !!$( event.target ).is( "input" ) || this._super( event );
            }
        });
        quickview.show({
            url: e.target.href,
            source: 'giftregistry',
            productlistid: productListID
        });
    });

	// gift registry advanced options on login intercept page
	$('.gift-registry-advanced .toggle').on('click', function(){
		$('.gift-registry-advanced .toggle-content').slideToggle(function(){
			selectBoxIt.selectBoxIt($('.gift-registry-advanced .select-field:visible'));
		});
		return false;
	});

    $("#dwfrm_giftregistry_copyAddress").change(function() {
        if(this.checked) {
        	migratePreToPostFields();
        }
    });

    $("#select-quantity-desired select").change(function() {
    	var currValue = parseInt($(this).val());
    	var attrName = $(this).attr('name');
    	$('input[name="'+attrName+'"]').each(function(ind, el) {
    		$(el).val(currValue);
    		$(el).attr('value', currValue);
    	});
    });

    // gift registry advanced options toggle
    $('.search-giftregistry-toggle-button').on('click', function(e){
    	e.preventDefault();
    	$(this).toggleClass('expanded');
    	$('.gift-registry-advanced-options').toggle();
    });

    var $form = $('#dwfrm_giftregistry_search');
    $form.find('.form-row select').after("<span class='select-arrow'></span>");

	$('button.previous').click(function (e) {
		// Remove the required class so validation
		// does not occur on the form fields
		// since this is the previous button, and validation is not needed.
		$('form').find('input').removeClass('required');
		$('form').find('select').removeClass('required');
	});
	
	//enable mask for number field
    $('#dwfrm_giftregistry').find('.input-text.phone').mask("(000) 000-0000");
}

function setFloatLabelsOnSelectElements () {
	$('.pt_gift-registry').find('select').parent().addClass('has-float-label');
	$('.pt_gift-registry').find('select').parent().find('.text-input-label').addClass('float');
}

function initEventItems() {
	$('.gift-registry-item-row').each(function(){
		var $style = $(this).find('.sku').detach();
		$style.find(".label").text("Style #:");
		$(this).find('.product-list-item').append($style);

		var $price = $(this).find('.price').detach();
		var $priceColumn = $(this).find('.gift-registry-item-row-price');
		$priceColumn.append($price);
		if(!($priceColumn.find('.price-standard').length && $priceColumn.find('.price-sales').length)){
			$priceColumn.find('.price .value .price-standard').removeClass('price-standard');
			$priceColumn.find('.price .value .price-sales').removeClass('price-sales');
		}

		var $priority = $(this).find('.option-priority .value');
		var priorityText = $priority.text();
		$priority.text(priorityText.substr(9, priorityText.length));

		var $quantitySelect = $(this).find('.quantity-select');
		$quantitySelect.after("<span class='select-arrow'></span>");
		var $form = $(this).find("#dwfrm_product_addtocart, #gift-cert-purchase");
		$quantitySelect.on("change", function(){
			$form.find('.hidden-quantity').val($(this).val());
		});
	});
	$('.mobile-registry-item-container').each(function(){
		var $style = $(this).find('.sku').detach();
		$style.find(".label").text("Style #:");
		$(this).find('.product-list-item').append($style);

		var $price = $(this).find('.price').detach();
		var $priceSpan = $(this).find('.registry-item-price');
		$priceSpan.append($price);
		if(!($priceSpan.find('.price-standard').length && $priceSpan.find('.price-sales').length)){
			$priceSpan.find('.price .value .price-standard').removeClass('price-standard');
			$priceSpan.find('.price .value .price-sales').removeClass('price-sales');
		}

		var $priority = $(this).find('.option-priority .value');
		var priorityText = $priority.text();
		$priority.text(priorityText.substr(9, priorityText.length));

		var $quantitySelect = $(this).find('.registry-item-quantity select');
		$quantitySelect.after("<span class='select-arrow'></span>");
	});
}

function checkPopulatedFields() {
    $('#dwfrm_giftregistry_event input').each(function (index, element) {
        if ($(element).val().length > 0) {
            $(element).blur();
        }
    })
}

exports.init = function () {
    setFloatLabelsOnSelectElements();
    initializeEvents();
    addProductToCart();
    hideStepIfEdit();
    maskDateField();
    login.init();
    util.setDeleteConfirmation('.item-list', String.format(Resources.CONFIRM_DELETE, Resources.TITLE_GIFTREGISTRY));
    initEventItems();
    checkPopulatedFields();
};

},{"../ajax":26,"../float-labels":36,"../login":42,"../quickview":69,"../selectboxit":73,"../util":82,"../validator":83,"./product/addToCart":55}],63:[function(require,module,exports){
'use strict';

var compareWidget = require('../compare-widget'),
    giftcard = require('../giftcard'),
    imagesLoaded = require('imagesloaded'),
    productTile = require('../product-tile'),
    progress = require('../progress'),
    smartResize = require('../smartresize'),
    util = require('../util'),
    imagemapresizer = require('../imagemapresizer'),
    interact = require('../interact'),
    mediumBreakpoint = 480,
    largeBreakpoint = 960,
    $cache = {};

var windowWidth = window.innerWidth;

function infiniteScroll() {
    // getting the hidden div, which is the placeholder for the next page
    var loadingPlaceHolder = $('.infinite-scroll-placeholder[data-loading-state="unloaded"]');
    // get url hidden in DOM
    var gridUrl = loadingPlaceHolder.attr('data-grid-url');

    if (loadingPlaceHolder.length === 1 && util.elementInViewport(loadingPlaceHolder.get(0), 250)) {
        // switch state to 'loading'
        // - switches state, so the above selector is only matching once
        // - shows loading indicator
        loadingPlaceHolder.attr('data-loading-state', 'loading');
        loadingPlaceHolder.addClass('infinite-scroll-loading');


        // named wrapper function, which can either be called, if cache is hit, or ajax repsonse is received
        var fillEndlessScrollChunk = function (html) {
            loadingPlaceHolder.removeClass('infinite-scroll-loading');
            loadingPlaceHolder.attr('data-loading-state', 'loaded');
            $('div.search-result-content').append(html);
        };

        // old condition for caching was `'sessionStorage' in window && sessionStorage["scroll-cache_" + gridUrl]`
        // it was removed to temporarily address RAP-2649

        $.ajax({
            type: 'GET',
            dataType: 'html',
            url: gridUrl,
            success: function (response) {
                // put response into cache
                try {
                    sessionStorage['scroll-cache_' + gridUrl] = response;
                } catch (e) {
                    // nothing to catch in case of out of memory of session storage
                    // it will fall back to load via ajax
                }
                // update UI
                fillEndlessScrollChunk(response);
                productTile.init();
                // init swatch color view
                showMoreSwatches();
                // sync height
                tileSync();
            }
        });
        if (typeof dataLayer !== "undefined") {
        	var dataLayer = window.dataLayer = window.dataLayer || [];
        	dataLayer.push(app.datalayer.getEvent("event", "batchedEcomProdImpression"));
        }
    }
}
/**
 * @private
 * @function
 * @description replaces breadcrumbs, lefthand nav and product listing with ajax and puts a loading indicator over the product listing
 */
function updateProductListing(isHashChange) {
    var hash = window.location.hash;
    
    if(hash==='#results-content' || hash==='#results-products') { return; }
    
    var refineUrl = null,
    	encodedHash = "",
    	searchString = "",
    	searchUrl = "";
    
    if (hash.length > 0) {
    	searchString = window.location.search || "?";
    	encodedHash = '&' + hash.substr(1).replace(/\s/g,'%20'); //Required: Firefox allows whitespace in URL, which breaks refinements (KS-1515, KS-1131)
        refineUrl = window.location.pathname + searchString + encodedHash;
    }
    else if (isHashChange) {
        refineUrl = window.location.href;
    }

    if (!refineUrl) { return; }

    searchUrl = util.appendParamToURL(refineUrl, "format", "ajax");

    progress.show($cache.content);
    $.ajax({
        type: 'GET',
        dataType: 'html',
        url: searchUrl,
	    success: function (response) {
	        $cache.content = $cache.main.find(".search-result-content");
	        $cache.filters = $cache.main.find("#filter-container");
	        $cache.count = $cache.main.find(".search-result-count");
	        $cache.countSearch = $cache.main.find(".header-item-result");
	        var newProducts = $(response).find('.search-result-content');
	        var newFilters = $(response).find('#filter-container');
	        var newCount = $(response).find('.search-result-count');
	        var newCountSearch = $(response).find('.header-item-result');
	        $cache.content.replaceWith(newProducts);
	        //if filter is opened now we should replace it with opened filter too
	        if (!$cache.filters.find('.filter-content').hasClass('hide')) {
	            newFilters.find('.filter-content').removeClass('hide');
	        }
	        $cache.filters.replaceWith(newFilters);
	        $cache.count.replaceWith(newCount);
	        $cache.countSearch.replaceWith(newCountSearch);
	        productTile.init();
	        progress.hide();
	        tileSync();
        //close category nav in mobile/tablet
        if (windowWidth <= largeBreakpoint) {
            $('.refinement.Shop.by.Category.displayname').addClass('collapsed').find('ul').hide();
        }
        if (windowWidth > mediumBreakpoint && windowWidth <= largeBreakpoint) {
            $('.filter-container').css('border-top', '1px solid #000');
        }

	        //Rehide sub categories with toggles
	        subToggleInit();

	        //Change Page Title
	        var titleParts = document.title.split('|');
	        document.title = $('.search-result-count h1').text().replace(/^(.)|\s(.)/g, function($1){ return $1.toUpperCase( ); }) + ' | ' + titleParts[1];

	        // trigger scroll to set the header
	        $(window).trigger('scroll');
        }
    });
}

//synchronizes heights of tiles on cat browse pages
function tileSync() {
    imagesLoaded('.search-result-content').on('always', function () {
        $('.search-result-content .product-tile').syncHeight();
    });
}

//save current refinement tabs
function setRefinementCookies() {
    $cache.main.find('.refinement .toggle span').each(function () {
        $.cookie($.trim($(this).text()), $(this).parents('.refinement').hasClass('collapsed'));
    });
}
//Hide lists for sub-toggle
function subToggleInit() {
    if($(".refinement").length && $(".refinement .expandable").length){
        if($(".expandable.active .plus_minus").html()=="+") {
            $(".expandable.active .plus_minus").html("&#8211;");
        }

        $(".expandable").each( function() {
            if(!$(this).hasClass('active')){
                $(this).parent().find("ul:not(.active)").css("display", "none");
            }
        });


    }
}

//Scale dividers height/width for category landing content based on screen width
function scaleDividers() {
    if ($('.cat-landing-slot').length && $('td').length) {
        imagesLoaded('.cat-landing-slot').on('always', function () {
            var imgs = $('.cat-landing-slot').find('img');
            var maxWidth = 0;
            var maxWidthImg;
            jQuery.each(imgs, (function () {
                if ($(this).width() > maxWidth) {
                    maxWidth = $(this).width();
                    maxWidthImg = $(this);
                }
            }));

            var scaleRatio = maxWidth / maxWidthImg['0'].naturalWidth;

            var items = $('.cat-landing-slot').find('td');
            jQuery.each(items, (function () {
                if ($(this).children().length == 0) {
                    if (this.hasAttribute('width')) {
                        $(this).width(Math.round(this.width * scaleRatio));
                    }
                    else if (this.hasAttribute('height')) {
                        $(this).height(Math.round(this.height * scaleRatio));
                    }
                }
            }));
        });
    }
}

function personalizationSlider() {

    var before = $('.slider-bef');
    var after = $('.slider-aft');
    var handle = $('.handle-wrapper');
    var slider = $('.AB-slidebar');
    var tooltip = $('.slider-tip');

    $('.slider-bef').find('img').css('max-width', $('.slider-aft').width());
    $('.handle-wrapper').css('height', $('.slider-aft').height());

    var currentWidth = $(before).width(); //get current width of top image
    var newTopWidth = currentWidth * 2/3; //calculate new top width -> 2/3 of current width


    before.width(newTopWidth); //set top image with new width
    handle.css('left', newTopWidth); //set left margin for bar



    function slideBar(e) {

        setTimeout(function () {
            var newWidth = parseInt($(handle).css('left'));
            // set width of before img div
            before.width(newWidth);
        }, 30);

        e.stopPropagation();
    }

    function slideBarMobile(e) {

        setTimeout(function () {
            var newWidth = parseFloat($(handle).css('left')) + e.dx;
            // set width of before img div
            before.width(newWidth);
            handle.css('left', newWidth + 'px');
        }, 30);

        e.stopPropagation();
    }


    handle.draggable({
        containment: slider,
        axis: 'x'
    });

    slider.bind('drag', slideBar).bind('mousedown touchstart', function(){
        tooltip.fadeOut(10);
    });

    if (window.innerWidth <= largeBreakpoint) {
        interact.interact('.draggable')
        .draggable({
            onmove: slideBarMobile
        });
    }

}
function oasTiles() {
    // prevent adding oasTiles after search refinement
    if (window.location.hash.length) {
        return;
    }
    $('.tiles-container .grid-tile').each(function(){
        if($(this).hasClass('oasDouble') || $(this).hasClass('blank-tile') || $(this).hasClass('oas-tile')) {
            $(this).remove();
        }
    })
    var $productTiles = $('.tiles-container .product-tile');
    var $gridTiles = $('.tiles-container .grid-tile');
    var productTilesNew = $('#search-result-items li.grid-tile');
    // setup OAS slots if they exist
    $('#oasTiles').first().find('li').each( function(index, el) {

        var tilePosition = $(el).attr("tilePosition");
        var blankTile = $('<li class="grid-tile blank-tile">');
        // configure tile position
        if (tilePosition > productTilesNew.length) {
            tilePosition = productTilesNew.length;
        }

        /*
         *   setup tile position - moves the tile to the position in the
         *   list (minus one because zero based array) minus one also makes
         *   it so a tile is never last in the list
         *           *
         *   also accounting for case where oas double tile is between two rows on mobile
         */

        if ($('.oasDouble').length && windowWidth <= mediumBreakpoint && tilePosition % 2 == 0 ) {
            tilePosition -= 1;
        }

        $(el).clone().insertBefore(productTilesNew[tilePosition -1]);
        if ($(this).hasClass('oasDouble')) {
            $(productTilesNew[tilePosition -1]).before(blankTile);
        }
    });


    // RR-6769 do not sync product name height

    // Do not use cached containers here because the amount of tiles in the grid may be changed by JS code above

    // if ($productTiles.length > 0) {
    //     var colCount = (matchMedia('(max-width: ' + mediumBreakpoint + 'px)').matches) ? 2 : 3;
    //
        // Synchronize heights of product names in a row
        // for (var i = 0; i < $gridTiles.length; i += colCount) {
        //     var rowTiles = [];
        //     for (var j = 0; j < colCount; j++) {
        //         var gridTile = $gridTiles[i + j];
        //         if (gridTile) {
        //             rowTiles.push(gridTile);
        //         }
        //     }
        //
        //     $(rowTiles).find('.product-name').syncHeight();
        // }
    // }
}

/**
 * @description add ability to show more than 3 swatches on the product tile
 */
function showMoreSwatches() {
    var productTiles = $('#search-result-items li.grid-tile');;
    if (productTiles.length === 0) return;

    productTiles.find('.product-tile').each(function(){

        var $tile = jQuery(this);
        var $list = $tile.find('.swatch-list');
        var $swatches = $list.find('li');

        if ( $swatches.length > $list.data('max') && $list.find('.more').length == 0){

            var overlayswatch = jQuery('<div/>').addClass('sw-overlay');
            $tile.append(overlayswatch)
            $list.clone().appendTo(overlayswatch);

            var toggle = $('<span/>').addClass('more').text('(+' + ($swatches.length - $list.data('max')) + ')');
            $list.prepend(toggle);
            toggle.on('click', function(){
                overlayswatch.show();
                $tile.find('.product-swatches, .product-name, .product-pricing, .product-promo').hide();
            });

            overlayswatch.on('mouseleave', function(){
                var $overlayswatch = $(this);
                var timeoutID = $overlayswatch.data('timeoutid');
                if(timeoutID){
                    clearTimeout(timeoutID);
                }
                timeoutID = setTimeout(function(){
                    $overlayswatch.data('timeoutid', '');
                    $overlayswatch.hide();
                    $tile.find('.product-swatches, .product-name, .product-pricing, .product-promo').show();
                },2000);
                $overlayswatch.data('timeoutid', timeoutID);
            });
            overlayswatch.on('mouseenter', function(){
                var $overlayswatch = $(this);
                var timeoutID = $overlayswatch.data('timeoutid');
                if(timeoutID){
                    clearTimeout(timeoutID);
                }
            });
            $(document).on('touchstart', function(e) {
                var swcontainer = $('.sw-overlay');
                if (!swcontainer.is(e.target) && swcontainer.has(e.target).length === 0) {
                    swcontainer.hide();
                    $tile.find('.product-swatches, .product-name, .product-pricing, .product-promo').show();
                }
            });
        }
    });
}

/**
 * @private
 * @function
 * @description Initializes events for the following elements:<br/>
 * <p>refinement blocks</p>
 * <p>updating grid: refinements, pagination, breadcrumb</p>
 * <p>item click</p>
 * <p>sorting changes</p>
 */
function initializeEvents() {

    // scroll for sticky header/refinements
    $(window).scroll(function() {
        var scrollFilterConstant = 120,
        headerHeight = $('.top-banner').outerHeight(),
        navHeight = 0,
        catSlotHeight = $('.category-top-slot').outerHeight(),
        scrollTop = $(this).scrollTop(),
        filters = $('#filters'),
        selectedFilters = filters.find('#filters-selected'),
        hasFilters = selectedFilters.length > 0 && selectedFilters.find('.refinement-list').length > 0,
        isSearchPage = $('.pt_product-search-result').length > 0;
        if (windowWidth <= largeBreakpoint) {
            navHeight = 0;
            scrollFilterConstant = 150;
        }
        else {
            navHeight = $('#navigation').outerHeight();
            scrollFilterConstant = 120;
        }
        var filterActive = $('.filter-toggle').hasClass('active');
        if (util.isMobile()) {
	        if (isSearchPage && hasFilters){
		        if (scrollTop > 0) {
		        	$('#site-tab-bar').css('position', 'static');
		        } else {
		        	$('#site-tab-bar').css('position', 'fixed');
		        }
	        }
        }
        if (isSearchPage && hasFilters && !filterActive && !util.isMobile()) {
            if (scrollTop > headerHeight + navHeight + catSlotHeight + scrollFilterConstant) {
                $('.filter-container').css('border-bottom', '0');
                $('#primary').css('marginTop', '215px');
                $('.lower').css('marginTop', '215px');
                filters.addClass('sticky');
            }
            else {
                $('.filter-container').css('border-bottom', '1px solid #000');
                $('#primary').css('marginTop', '0');
                $('.lower').css('marginTop', '0');
                filters.removeClass('sticky');
            }
        }
    });

    // trigger scroll to set the header on page load
    $(window).trigger('scroll');

    var productTiles = jQuery('#search-result-items li.grid-tile');
    //add specific class for product set tiles
    $('.product-tile').has($('.product-set-price')).addClass('product-set-tile');

    if (typeof $cache.checkgiftcardBalance == 'undefined') {
        $cache.checkgiftcardBalance = $('#CheckBalanceButton');
        $cache.giftcardcode= $('.giftcardcode');
        $cache.giftcardpin= $('.giftcardpin');
        $cache.giftcardbalance= $('.balance');
        $cache.giftcardform= $('#gc-checkbalance');
    }
    $cache.checkgiftcardBalance.on("click", function (e) {
        e.preventDefault();
        $cache.giftcardcode = $cache.giftcardcode;
        $cache.giftcardpin = $cache.giftcardpin;
        $cache.giftcardbalance = $cache.giftcardbalance;

        $cache.giftcardbalance.text('');

        if ($cache.giftcardcode.length===0 || $cache.giftcardcode.val().length===0 || $cache.giftcardcode.val() === 'Gift Card Number') {
            var error = $cache.giftcardform.find("span.error");
            if (error.length===0) {
                error = $("<span>").addClass("error").appendTo($cache.giftcardform);
            }
            error.html(Resources.GIFT_CERT_MISSING);
            return;
        }
        if ($cache.giftcardpin.length===0 || $cache.giftcardpin.val().length===0 || $cache.giftcardpin.val() === 'PIN') {
            var error = $cache.giftcardform.find("span.error");
            if (error.length===0) {
                error = $("<span>").addClass("error").appendTo($cache.giftcardform);
            }
            error.html("Please enter the pin number");
            return;
        }

        // PCRSPADES-23: display the progress overlay
        progress.show();
        giftcard.checkBalance($cache.giftcardcode.val(), $cache.giftcardpin.val(), function (data) {
            // remove the progress overlay
            progress.hide();
            // each call remove prev balance
            $cache.giftcardform.find("span.gcbalance").remove();

            if(!data || !data.giftCertificate) {
                // error
                var error = $cache.giftcardform.find("span.error");
                $cache.giftcardform.find("span.gcbalance").remove();

                if (error.length===0) {
                    error = $("<span>").addClass("error").appendTo($cache.giftcardform);
                }
                error.html(Resources.GIFT_CERT_INVALID);
                return;
            }
            // display details in UI
            $cache.giftcardform.find("span.error").remove();
            var balance = data.giftCertificate.balance;
            var gcbalance = $("<span>").addClass("gcbalance").appendTo($cache.giftcardform);
            gcbalance.html(Resources.GIFT_CERT_BALANCE+" "+balance);
        });
    });

    var $main = $('#main');
    // compare checked
    $cache.main.on('click', 'input[type="checkbox"].compare-check', function () {
        var cb = $(this);
        var tile = cb.closest('.product-tile');

        var func = this.checked ? compareWidget.addProduct : compareWidget.removeProduct;
        var itemImg = tile.find('.product-image a img').first();
        func({
            itemid: tile.data('itemid'),
            uuid: tile[0].id,
            img: itemImg,
            cb: cb
        });
    });
    $cache.main.on('click', '.item-count a', function (e) {
    	e.preventDefault();
    	var item =$(this).parent('li')
    	item.toggleClass('open').parent('ul').toggleClass('open-ul').find('li.hide').toggleClass('open');
    });

    var personalizationPage;
    // check if category landing page to hide breadcrumb/filters, scale dividers and images
    if ($('.cat-landing-slot').length ) {
    	if(personalizationPage){
    		addBackgroundCover();
    	}
        if ($('.AB-slidebar').length){
            personalizationSlider();
        }

        // scales divider td's for category landing page content
        scaleDividers();
    } else {
    	$('.filter-container').show();
        $('.filter-buttons').show();
    }
    
  //cat landing page sliders
    if ($('.cat-landing-slot')) {
    	if ($('.slider').length) {
    		(function(e,t,n,r){e.fn.sss=function(r){var i=e.extend({slideShow:true,startOn:0,speed:10000000000000,transition:0,arrows:true},r);return this.each(function(){function y(e){return s.eq(e).height()/o.width()*100+"%"}function b(e){if(!c){c=true;var t=s.eq(e);t.fadeIn(a);s.not(t).fadeOut(a);o.animate({paddingBottom:y(e)},a,function(){c=false});g()}}function w(){l=l===u-1?0:l+1;b(l)}function E(){l=l===0?u-1:l-1;b(l)}var r=e(this),s=r.children().wrapAll('<div class="sss"/>').addClass("ssslide"),o=r.find(".sss"),u=s.length,a=i.transition,f=i.startOn,l=f>u-1?0:f,c=false,h,p,d,v,m,g=i.slideShow?function(){clearTimeout(p);p=setTimeout(w,i.speed)}:e.noop;if(i.arrows){o.append('<div class="sssprev"/>','<div class="sssnext"/>')}m=o.find(".sssnext"),v=o.find(".sssprev");e(t).load(function(){o.css({paddingBottom:y(l)}).click(function(t){h=e(t.target);if(h.is(m)){w()}else if(h.is(v)){E()}});b(l);e(n).keydown(function(e){d=e.keyCode;if(d===39){w()}else if(d===37){E()}})})})}})(jQuery,window,document);
        	$(document).ready(function () {
        	  $('.slider').sss();
        	});
    	}
    }
    
    $('.breadcrumb').show();

    // accounts for issue where sort-by text would otherwise overflow in mobile
    $cache.main.ready(function() {
        if (windowWidth <= 370 && $('.sort-by-text')[0].firstChild.length > 10) {
            $('.sort-toggle').css('padding', '16px 8px');
        }
    });


    // if mobile/tablet then make categorylanding impossible to get to from nav and collapse category list at smaller viewports
    if (windowWidth <= largeBreakpoint) {
        var items = $('.menu-category.level-1 > li');
        jQuery.each(items, function() {
            if ($(this).attr('data-template')){
                var string = $(this).data('template');
                var substring = string.substr(string.lastIndexOf('/') + 1);
            }
        });

        $('.refinement.Shop.by.Category.displayname').addClass('collapsed').find('ul').hide();
    }

    //Handles Resizing of Window
    smartResize(function() {
        if (windowWidth != window.innerWidth) {
            //set new windowWidth
            windowWidth = window.innerWidth;

            // handle collapsing/expanding of refinement sections depending on viewport
            if (windowWidth <= largeBreakpoint) {
                $('.refinement.Shop.by.Category.displayname').addClass('collapsed').find('ul').hide();
                if (windowWidth <= mediumBreakpoint || !($('#filters-selected').children().length > 0)) {
                    $('.filter-container').css('border-top', '0');
                }
                else {
                    $('.filter-container').css('border-top', '1px solid #000');
                }
            }
            else {
                $('.filter-container').css('border-top', '1px solid #000');
                $('.refinement.Shop.by.Category.displayname').removeClass('collapsed').find('ul').show();
            }
        }

        // handles removal of product-tile height for re-synchronization when resizing on cat browse page
        $('.search-result-content .product-tile').removeAttr('style');
        tileSync();

        // scales dividers on category landing pages if they exist and calls function to scale coordinates on maps
        if ($('.cat-landing-slot').length ) {
            scaleDividers();
            $('map').imageMapResize();
        }

        // scales images on personalization shop landing page
        $('.slider-bef').find('img').css('max-width', $('.slider-aft').width());
        $('.handle-wrapper').css('height', $('.slider-aft').height());

        if ($('.slider-bef').width() >= $('.AB-slidebar').width()) {
            //$('.handle-wrapper').css('left', $('.AB-slidebar').width());
            personalizationSlider();
        }
    });

    //Secondary Navigation Toggle
    $cache.main.on('click', '.refinement .toggle', function (e) {
        $(this).parents('.refinement').toggleClass('collapsed').find('#category-level-1').toggle();
        $(this).parents('.refinement').find('.clear-refinement').toggle();
    });

    // Filter Toggle
    $main.on('click', '.filter-toggle', function (e){
        e.preventDefault();
        var $this = $(this);
        //Remove Sort box
        $('.sort-by-container').addClass('hide');
        $('.sort-box .bottom-border-box').removeClass('active');
        $('.sort-box .bottom-border-box .sort-toggle').removeClass('active');
        //
        if ($this.hasClass('active')){
            //Collapse filter panel
            $this.removeClass('active');
            $this.find('.filter-show').removeClass('hide');
            $this.find('.filter-hide').addClass('hide');
            $('.filter-content').addClass('hide');
            if ($('#filters-selected').children().length > 0) {
                $('.filter-container').css('border-bottom', '1px solid #000');
            }
            if ($('#filters').hasClass('sticky')){
                $('.filter-container').css('display', 'none');

            }
            $('#filters-selected').removeClass('hide');
        } else {
            //Show filter panel
            $this.addClass('active');
            $this.find('.filter-show').addClass('hide');
            $this.find('.filter-hide').removeClass('hide');
            $('.filter-content').removeClass('hide');
            $('.filter-container').css('display', 'block');
            if ($('#filters-selected').children().length > 0) {
                $('.filter-container').css('border-bottom', '1px solid #000');
            }
            $('#filters-selected').addClass('hide');
            $('.mCustomScrollbar').mCustomScrollbar();
        }

        // trigger scroll to set the header
        $(window).trigger('scroll');
    });

    // Sort Toggle
    $cache.main.on("click", ".sort-toggle", function (e){
        var $this = $(this);
        //Remove Filter box
        var $filterToggle = $('.filters-bar .filter-toggle');
        if ($filterToggle.length && $filterToggle.hasClass('active')) {
            $filterToggle.trigger('click');
        }
        /*$('.sort-box .bottom-border-box').removeClass('active');*/
        $('.bottom-border-box.filter .filter-toggle').removeClass('active');
        if($this.hasClass('active')){
            //Close Menu
            $this.removeClass('active');
            $this.parent().parent().parent().find('.sort-by-container').addClass('hide');
            $this.parent().parent().find('.bottom-border-box.sort').removeClass('active');
        }else{
            //Show menu
            $this.addClass('active');
            $this.parent().parent().parent().find('.sort-by-container').removeClass('hide');
            $this.parent().parent().find('.bottom-border-box.sort').addClass('active');
        }
    });

    // Close Filter and Sort on clicking outside the filters
    $('body, html').on('click', function (e) {
        var $target = $(e.target);
        if ($target.closest('.filters-bar .filter-content').length ||
            $target.closest('.filters-bar .filter-toggle').length ||
            $target.closest('.filters-bar .sort-box').length || 
            $target.closest('.filters-bar .clear-filters-text').length) {
            return;
        }

        // close Filter
        var $filterToggle = $('.filters-bar .filter-toggle');
        if ($filterToggle.length && $filterToggle.hasClass('active')) {
            $filterToggle.trigger('click');
        }

        // close Sort
        var $sortToggle = $('.filters-bar .sort-toggle');
        if ($sortToggle.length && $sortToggle.hasClass('active')) {
            $sortToggle.trigger('click');
        }
    });

    $cache.main.on("click", ".refinements-view-controls", function (e){
        var $this = $(this),
            $viewMoreRefine = $this.find('.refinements-viewmore'),
            $viewLessRefine = $this.find('.refinements-viewless'),
            $showItems = $this.parent().find('ul').data('show'),
        	$showItemsTablet = $this.parent().find('ul').data('showtablet');
        if($viewMoreRefine.hasClass('hide')){
            //Close Menu
            $viewLessRefine.addClass('hide');
            $viewMoreRefine.removeClass('hide');
            var $it = 1;
            $this.parent().find('.refinement-list li').each(function(){
                if($it > $showItems){
                    $( this ).addClass('hide');
                }
                $it++;
            });
        }else{
            //Show menu
            $viewLessRefine.removeClass('hide');
            $viewMoreRefine.addClass('hide');
            $this.parent().find('li.hide').each(function(){
                $( this ).removeClass('hide');
            });
        }
        if($viewMoreRefine.hasClass('hideTablet')){
            //Close Menu
            $viewLessRefine.addClass('hideTablet');
            $viewMoreRefine.removeClass('hideTablet');
            var $it = 1;
            $this.parent().find('.refinement-list li').each(function(){
                if($it > $showItemsTablet){
                    $( this ).addClass('hideTablet');
                }
                $it++;
            });
        }else{
            //Show menu
            $viewLessRefine.removeClass('hideTablet');
            $viewMoreRefine.addClass('hideTablet');
            $this.parent().find('li.hideTablet').each(function(){
                $( this ).removeClass('hideTablet');
            });
        }
    });

    // handle toggle refinement blocks
    $cache.main.on("click", ".refinement-wrapper a, .pagination a, .breadcrumb-refinement-value a", function (e) {
        if($(this).parent().hasClass("unselectable")) { return; }
        var catparent = $(this).parents('.category-refinement');
        if(catparent.length > 0){
            return true;
        }
        e.preventDefault();
        var uri = util.getUri(this);

        if($(this).closest('.refinement.Category').length > 0 || uri.hash.substring(1) == '') {
            // For when a category refinement is clicked or when a color/size/etc. refinement is cleared
            window.location.href = encodeURI(decodeURIComponent(this.href));
        } else {
            // For when a color/size/etc. refinement is clicked
            setRefinementCookies();
            var refineUrl = uri.hash.substring(1);
            window.location.hash = encodeURI(decodeURIComponent(refineUrl));
        }
        return false;
    });

    $cache.main.on('click', '.gc-check-balance-header', function (e) {
    	e.preventDefault();
    	$(this).toggleClass('expanded');
    });
    //Sub Toggle
    $cache.main.on("click", ".expandable .sub-toggle", function (e) {
        e.preventDefault();
        var $this = $(this);
        var miniList = $this.parent().next();
        if(miniList.length > 0 && (miniList.css('display') == 'none')){
            miniList.css("display", "block");
            $this.find(".plus_minus").html("&#8211;");
            if($this.parent().hasClass("click-collapsed")){
                $this.parent().removeClass("click-collapsed");
            }
            if(!$this.parent().hasClass("click-expanded")){
                $this.parent().addClass("click-expanded");
            }
        }else{
            miniList.css("display", "none");
            $this.find(".plus_minus").html("+");
            if(!$this.parent().hasClass("click-collapsed")){
                $this.parent().addClass("click-collapsed");
            }
            if($this.parent().hasClass("click-expanded")){
                $this.parent().removeClass("click-expanded");
            }
        }

        $(this).toggleClass('expanded');

    });
    subToggleInit();

    //Sort Drop down
    $cache.main.on("click", ".sort-by-list .sort-item", function (e) {
        var $this = $(this);
        var currentHash = window.location.hash;
        var newSortUrl = util.getUri($this.data("url")); 
            // If newSortUrl contains hash
        if(newSortUrl.hash.length > 1) {
                // Seperate the hash params
            var hashLoop = newSortUrl.hash.substr(1).split("&");
                // Loop through hash params
            for(var i=0; i <= hashLoop.length-1; i++){
                    // Split hash param 
                var qsVal = hashLoop[i].split('=');
                    // Check if qs is in current query string
                if(currentHash.indexOf(qsVal[0]) !== -1){
                        // Replace value in querystring with new sort param
                    var regex = new RegExp(qsVal[0] +'=[^\&]+', 'g');
                    currentHash = currentHash.replace(regex, hashLoop[i]);
                }
                else {
                        // else add sort querystring param to hash
                     currentHash += "&"+hashLoop[i];
                }
            }
            window.location.hash = currentHash
        }
        else {
            window.location.href = newSortUrl;
        }
    });
    if($(".sort-by-list .sort-item.sorted-by").length > 0){
        var selectedText = $(".sort-by-list .sorted-by span").html();
        $(".filter-buttons .sort-toggle span.sort-by-text").html(selectedText);
    }

    //Updating Grid for Favorites
    $("#pdpMain, #pdpQuick").on("click", ".favourites-toggle a, .favorites-no-session", function (e) {
        e.preventDefault();

        var uri = util.getUri(this);
        var refineUrl = uri.hash.length > 1 ? uri.hash.substr(1) : "";
        window.location.hash = refineUrl;
        return false;
    });

    $cache.main.on("click", "a.refinement-link", function (e) {
        e.preventDefault();
        var uri = util.getUri($(this).attr('data-hreflink'));
        var refineUrl = uri.hash.length > 1 ? uri.hash.substr(1) : "";
        if (refineUrl != ''){
            window.location.hash = refineUrl;
        }else{
            window.location.href = $(this).attr('data-hreflink');
        }
        return false;
    });

    // handle events item click. append params.
    $cache.main.on("click", "#search-result-items .product-tile a.thumb-link, #search-result-items .product-tile a.name-link", function (e) {

        var a = $(this);
        // get current page refinement values
        var wl = window.location;
        var qsParams = (wl.search.length > 1) ? util.getQueryStringParams(wl.search.substr(1)) : {};
        var hashParams = (wl.hash.length > 1) ? util.getQueryStringParams(wl.hash.substr(1)) : {};
        // merge hash params with querystring params
        var params = $.extend(hashParams, qsParams);
        if (!params.start) {
            params.start = 0;
        }
        // get the index of the selected item and save as start parameter
        var tile = a.closest(".product-tile");
        var idx = tile.data("idx") ? +tile.data("idx") : 0;
        // convert params.start to integer and add index
        params.start=(+params.start)+(idx+1);
        var cgid = tile.data("cgid") ? tile.data("cgid") : '';
        if(cgid != ''){
            params.cgid=cgid;
        }

        if(typeof katespade != 'undefined'){
            // only include hash for KateSpade
            a[0].hash = $.param(params);
        }

        // use the full url
        var fullUrl = a.attr('data-full-url');
        if(fullUrl){
            fullUrl += a[0].hash;
            a.attr('data-full-url', fullUrl);
            if($.browser.msie && $.browser.version < 10) {
                window.location = fullUrl;
            }
            e.preventDefault();
        }

    });

///////////////////////////////////////// handle sorting change  /////////////////////////////////////////////////////////

    $cache.main.on("change", ".sort-by select", function (e) {

        var refineUrl = $(this).find('option:selected').val();
        var uri = util.getUri(refineUrl);
        window.location.hash = uri.query.substr(1);
        return false;
    })
    .on("change", ".items-per-page select", function (e) {
        var refineUrl = $(this).find('option:selected').val();
        var uri = util.getUri(refineUrl);
        window.location.hash = uri.query.substr(1);
        return false;
    });
    // handle hash change
    $(window).on('hashchange', function() {
        updateProductListing(true);
    });

    // product grid swatches
    jQuery(".product-swatches a.more").on('click', function(){
        //jQuery(this).parent().find('.hidden-swatch').slideToggle();
        jQuery(this).closest('.product-swatches')
                    .addClass('showall');
        return false
    });
    jQuery('.product-swatches img.close-swatches-pane').on('click', function() {
        jQuery(this).closest('.product-swatches')
                    .removeClass('showall');
    });



    // Product Tile - show more swatches
    showMoreSwatches();


    // handle events for updating grid
    $main.on('click', '.refinements a, .pagination a, .breadcrumb-refinement-value a, .filter-clear-all .clear-filters-text', function (e) {
        // don't intercept for category and folder refinements, as well as unselectable
        if ($(this).parents('.category-refinement').length > 0 || $(this).parents('.folder-refinement').length > 0 || $(this).parent().hasClass('unselectable')) {
            return;
        }
        //Remove URL hash if user clicks on clear all filters
        if ($(this).hasClass('clear-filters-text')) {
            window.history.pushState({}, window.document.title, this.href);
            window.location.hash = '';
        }
        e.preventDefault();
        updateProductListing(this.href);
    });

    // handle events item click. append params.
    $main.on('click', '.product-tile a:not("#quickviewbutton")', function () {
        var a = $(this);
        // get current page refinement values
        var wl = window.location;

        var qsParams = (wl.search.length > 1) ? util.getQueryStringParams(wl.search.substr(1)) : {};
        var hashParams = (wl.hash.length > 1) ? util.getQueryStringParams(wl.hash.substr(1)) : {};

        // merge hash params with querystring params
        var params = $.extend(hashParams, qsParams);
        if (!params.start) {
            params.start = 0;
        }
        // get the index of the selected item and save as start parameter
        var tile = a.closest('.product-tile');
        var idx = tile.data('idx') ? + tile.data('idx') : 0;

        // convert params.start to integer and add index
        params.start = (+params.start) + (idx + 1);
        // set the hash and allow normal action to continue
        a[0].hash = $.param(params);
    });

    // handle sorting change
    $main.on('change', '.sort-by select', function (e) {
        e.preventDefault();
        updateProductListing($(this).find('option:selected').val());
    })
    .on('change', '.items-per-page select', function () {
        var refineUrl = $(this).find('option:selected').val();
        if (refineUrl === 'INFINITE_SCROLL') {
            $('html').addClass('infinite-scroll').removeClass('disable-infinite-scroll');
        } else {
            $('html').addClass('disable-infinite-scroll').removeClass('infinite-scroll');
            updateProductListing(refineUrl);
        }
    });

    var $productTiles = $('.tiles-container .product-tile');
    var $gridTiles = $('.tiles-container .grid-tile');
    if ($productTiles.length > 0) {
        imagesLoaded('.tiles-container').on('always', function () {
            // Synchronize height of product tiles
            $productTiles.syncHeight()
                .each(function(idx) {
                    $(this).data('idx', idx);
                });
        });
    }
}
//push product tile click to dataLayer
$(".product-tile").click(function(){
	var productID = $.trim($(this).attr('data-itemid'));
	if (dataLayer) {
		var ecommerce = null;
		for (var i = 0; i < dataLayer.length; i++) {
			if ('ecommerce' in dataLayer[i]) {
				var ecommerce = dataLayer[i].ecommerce;
				break;
			}
		}
		if (ecommerce != undefined && 'impressions' in ecommerce) {
			var p;
			for (var i = 0; i < ecommerce.impressions.length; i++) {
				p = ecommerce.impressions[i];
				if (p.id == productID){
					dataLayer.push(app.datalayer.getEvent("event", "ecomProductImpressionClick", "ecommerce", " ", "click", p, p.category));
				}
			}
		}
	}
});

function addBackgroundCover() {
	$('.top-banner').before("<div id='background-cover'></div>");
}

exports.init = function () {
    if (SitePreferences.LISTING_INFINITE_SCROLL) {
        $(window).on('scroll', infiniteScroll);
    }
    $cache = {
        main : $("#main"),
        items : $("#search-result-items")
    };
    $cache.content = $cache.main.find(".search-result-content");
    compareWidget.init();
    if (SitePreferences.LISTING_INFINITE_SCROLL) {
        $(window).on('scroll', infiniteScroll);
    }
    updateProductListing(false);
    productTile.init();
    initializeEvents();
    tileSync();
    oasTiles();
    smartResize(oasTiles);
    $('map').imageMapResize();
};

},{"../compare-widget":30,"../giftcard":37,"../imagemapresizer":39,"../interact":40,"../product-tile":67,"../progress":68,"../smartresize":74,"../util":82,"imagesloaded":4}],64:[function(require,module,exports){
'use strict';
exports.init = function () {
    $('#homepage-slider')
        // responsive slides
        .on('jcarousel:create jcarousel:reload', function () {
            var element = $(this),
                width = element.innerWidth();
            element.jcarousel('items').css('width', width + 'px');
        })
        .jcarousel({
            wrap: 'circular'
        })
        .jcarouselAutoscroll({
            interval: 5000
        });
    $('#homepage-slider .jcarousel-control')
        .on('jcarouselpagination:active', 'a', function () {
            $(this).addClass('active');
        })
        .on('jcarouselpagination:inactive', 'a', function () {
            $(this).removeClass('active');
        })
        .jcarouselPagination({
            item: function (page) {
                return '<a href="#' + page + '">' + page + '</a>';
            }
        });

    $('#vertical-carousel')
        .jcarousel({
            vertical: true
        })
        .jcarouselAutoscroll({
            interval: 5000
        });
    $('#vertical-carousel .jcarousel-prev')
        .on('jcarouselcontrol:active', function () {
            $(this).removeClass('inactive');
        })
        .on('jcarouselcontrol:inactive', function () {
            $(this).addClass('inactive');
        })
        .jcarouselControl({
            target: '-=1'
        });

    $('#vertical-carousel .jcarousel-next')
        .on('jcarouselcontrol:active', function () {
            $(this).removeClass('inactive');
        })
        .on('jcarouselcontrol:inactive', function () {
            $(this).addClass('inactive');
        })
        .jcarouselControl({
            target: '+=1'
        });
};

},{}],65:[function(require,module,exports){
'use strict';
var dialog = require('../dialog'),
    selectBoxIt = require('../selectboxit');

//SG
// $('.store-details-link').on('click', function (e) {
//     e.preventDefault();
//     dialog.open({
//         url: $(e.target).attr('href')
//     });
// });

// Store dom collections
var $cache = {};
// Create the tooltip and its text
var infoWindow;

// Create the large map that is on the find and results page
function largeMap(){
    // Make sure the google api has loaded
    if(typeof google === 'undefined') return false;
    // Call to google
    infoWindow = new google.maps.InfoWindow();
    // Center of USA - {lat : 37.090240, lng : -95.712891};
    $cache.defaultCenter = new google.maps.LatLng(37.090240, -95.712891);

    // Load map with the userLocation
    $cache.mapLarge = new google.maps.Map( $('.wide-map')[0], {
        center : $cache.defaultCenter,
        mapTypeId : google.maps.MapTypeId.ROADMAP,
        zoom : 8,
        minZoom : 2,
        streetViewControl : false});

    $cache.boundsLarge = new google.maps.LatLngBounds();
    // Test to see if we have a list of stores and if so, add markers

    var postalCode = $('input[name="postalCode"]');

    if ($cache.stores.length) {
        addMarkers();
    } else if (postalCode.length) {
        var postal = postalCode.val();
        var geocoder = new google.maps.Geocoder();
        geocoder.geocode({'address':postal},function(results,status){
            if (status == google.maps.GeocoderStatus.OK) {
                $cache.mapLarge.setCenter(results[0].geometry.location);
            }
        });
    }
}

// Add markers to
function addMarkers(){
    // Loop the stores and add the markers
    $cache.stores.each(function(index){
        var store = $(this);
        // If the store doesn't have correct lat/lng data, we return out of the function and don't add it to the map.
        // Returning true allows the loop to continue
        if(store.data('isvalid').toString() != 'true') return true;
        var point = new google.maps.LatLng( parseFloat(store.data('lat')), parseFloat(store.data('lng')) );
        var icon = app.resources['GOOGLE_PIN_' + store.data('storebrand').toUpperCase()];
        var marker = new google.maps.Marker({position : point, map : $cache.mapLarge, icon : icon});

        var html= '<div class="google-location-hopup">' + store.find('.store-information').html() + store.find('.store-address').html() + '<a href="' + store.data('directions') + '" target="_blank">' + app.resources['GOOGLE_DIRECTION'] + '</a></div>';

        // Add a listener to open the tooltip when a user clicks on one of the markers
        google.maps.event.addListener(marker, 'click', function(){
            infoWindow.setContent(html);
            infoWindow.open($cache.mapLarge, marker);
        });

        // Set bounds of map
        $cache.boundsLarge.extend(point);
    });

    // Keep map in bounds
    $cache.mapLarge.fitBounds($cache.boundsLarge);
    var listener = google.maps.event.addListener($cache.mapLarge, "idle", function() {
        if($cache.mapLarge.getZoom() > 12) $cache.mapLarge.setZoom(12);
        google.maps.event.removeListener(listener);
    });
}

// Allow sorting of search results
function sortTabs(){
    // Determine selected tab based on site ID and setup functionality
    $('.store-tabs-menu li').each(function(index){
        var li = $(this);

        // li click functionality
        li.on('click', function(e){
            e.preventDefault();
            // Only allow click if not selected, otherwise select it as active tab
            if(li.hasClass('current')) return;
            // Release previous li
            $cache.tabNav.find('.current').toggleClass('current');
            // Hold/deactivate current li
            li.toggleClass('current');

            // Fade out previous results
            $cache.searchContent.find('.tab-content.current').toggleClass('current').stop(true, true).fadeOut(function(){
                // Fade in new results
                $('div#' + li.attr('id') + 'Section').toggleClass('current').stop(true, true).fadeIn();
            });
        });
    });
}

// FILTER KATE SPADE RESULTS - SPECIFIC ONLY TO THE KATE SPADE TAB
function sortKateResults(){
    $('.search-sort a').on('click', function(e){
        // Prevent default
        e.preventDefault();
        var link = $(this);

        // If current link isn't active
        if(link.attr('class') != 'active'){
            // Release previously active and make this active
            $('.search-sort a.active').toggleClass('active');
            link.toggleClass('active');

            // Sort stores
            // Test to see if we have any stores to display at the end of the filter, otherwise display the no search results alert
            var showing = false;
            var sort = link.attr('href');
            // Hide stores
            $cache.kateStores.each(function(){
                var store = $(this);
                // Hide it from the start
                store.css('display', 'none');
                // Show it if matches sort criteria
                if(sort == "all" || store.hasClass(sort)){
                    store.css('display', 'block');
                    showing = true;
                }
            });
            // If we have no stores to show, we display the alert
            if(!showing) $cache.filter.show();
            else $cache.filter.hide();

            // Hide/Show states
            $cache.states.each(function(index){
                var state = $(this);
                var stateShow = false;

                state.find('.store').each(function(){
                    if($(this).css('display') == "block"){
                        stateShow = true;
                        return;
                    }
                });

                // If we have stores to display, we show the state, otherwise we hide it
                if(stateShow){
                    // If state is inactive, show it
                    if(state.hasClass('inactive')) {
                        state.toggleClass('inactive');
                        state.find('h1.stateHeader').toggleClass('inactive');
                        state.find('.stores').show();
                    }
                    // Display state
                    state.show();
                } else state.hide();
            });
            // Hide/Show countries
            $cache.countries.each(function(index){
                var country = $(this);
                var countryShow = false;

                country.find('.store').each(function(){
                    if($(this).css('display') == "block"){
                        countryShow = true;
                        return;
                    }
                });

                // If we have stores to display, we show the state, otherwise we hide it
                if(countryShow){
                    // If state is inactive, show it
                    if(country.hasClass('inactive')) {
                        country.toggleClass('inactive');
                        country.find('h1.stateHeader').toggleClass('inactive');
                        country.find('.stores').show();
                    }
                    // Display state
                    country.show();
                } else country.hide();
            });
        }
    });
    // TOGGLE STATE HEADERS
    $('.stateHeader').each(function(index){
        var header = $(this);
        header.on('click', function(){
            header.parent().toggleClass('inactive');
            header.toggleClass('inactive');
            header.parent().find('.store').toggle('fast');
        });
    });
}

// IE8 FIX FOR FORM FOCUS: KS-473
function internetExplorerZipFocus(){
    var form = $('form.zip');
    var btn = form.find('button[type="submit"]');

    form.on('submit',function(e){
        e.preventDefault();

        // Collect the required form fields
        var data = "?" + form.serialize();
        // Figure out what type of call this is (from the button)
        data += "&" + btn.attr("name") + "=" + btn.attr("value");
        // Add the serialize data to the form submit
        var url = form.attr('action') + data;

        // Redirect to the correct URL
        window.location = url;
    });
}

// Instantiate the storelocator
var storelocator = {
    init : function(){
        // Cache top level elements
        $cache.tabNav = $('.store-tabs-menu');
        $cache.searchContent = $('.search-content');
        // Cache dom
        $cache.resultsBlock = $('#katespadeContentSection .resultsBlock');
        $cache.filter = $('#katespadeContentSection .filter-no-results');
        $cache.countries = $cache.resultsBlock.find('.country');
        $cache.states = $cache.resultsBlock.find('.state');
        $cache.stores = $cache.searchContent.find('.store');
        $cache.kateStores = $cache.resultsBlock.find('.store');
        // Initialize the sorting/filtering functionality of the kate tab
        sortKateResults();
        // Fade in current content
        $cache.searchContent.find('.tab-content.current').stop(true, true).fadeIn();
        // Allow tab menu to opperate
        sortTabs();

        // SITE SPECIFIC FUNCTIONALITY
        // If on katespade.com, we collect information for the large map
        largeMap();

        // Allow popup of small map (also used for account-nearest stores)
        this.detailsHopup();

        selectBoxIt.selectBoxIt($('.selectBoxed select'));

        // Make sure the zip code search form works correctly on IE8: KS-473
        if($('html').hasClass('ie8')) internetExplorerZipFocus();
    },
    // SMALL MAP HOPUP FUNCTIONALITY
    detailsHopup : function(){
        // Cache Dom
        $cache.storeDetails = $('#store-details-hopup');
        $cache.storeInfo = $cache.storeDetails.find('.store-information');
        $cache.storeDetailsMap = $cache.storeDetails.find('.details-map');
        $cache.popupOverlay = $('.popup-overlay')

        // Hook for the 'map' link
        $('.google-map').on('click', function(e){
            e.preventDefault();
            // If google isn't loaded yet, return
            if(typeof google === 'undefined') return false;

            var link = $(this);
            var id = link.attr('href');
            var store = $('#' + id);
            var point = new google.maps.LatLng(parseFloat(store.data("lat")), parseFloat(store.data('lng')));
            var icon = app.resources['GOOGLE_PIN_' + store.data('storebrand').toUpperCase()];
            // Hide any previous store info
            $cache.storeInfo.children().hide();
            // Check to see if we have created the store info, otherwise, populate the store info
            if(!$cache[id]) {
                $cache.storeInfo.append('<div id="details-' + id + '"></div>');
                $cache[id] = $('#details-' + id);
                store.find('.store-name').clone().appendTo($cache[id]);
                store.find('.store-address').clone().appendTo($cache[id]);
                store.find('.store-hours').clone().appendTo($cache[id]);
                // Create directions link
                $cache[id].append('<a class="directions-link" target="_blank" href="' + store.data('directions') + '">Directions</a>');
                $cache[id].addClass(store.data('storebrand') + 'Info');
            } else $cache[id].show();

            // Add it to the dialog hopup
            $cache.storeDetails.dialog({width: 'auto', height: 'auto', dialogClass : 'store-details-hopup', modal: true });
            // if dialog is open, return
            if(!$cache.storeDetails.dialog("isOpen")) $cache.storeDetails.dialog('open');

            // Create the map if needed
            if(!$cache.mapSmall) {
                $cache.mapSmall = new google.maps.Map($cache.storeDetailsMap[0], {center : point, mapTypeId : google.maps.MapTypeId.ROADMAP, zoom : 6, streetViewControl : false});
                $cache.boundsSmall = new google.maps.LatLngBounds();
            }
            // If previous marker, remove it
            if($cache.markerSmall) $cache.markerSmall.setMap(null);
            // Create new marker
            $cache.markerSmall = new google.maps.Marker({position : point, map : $cache.mapSmall, icon : icon});
            // Make marker bounce
            $cache.markerSmall.setAnimation(google.maps.Animation.DROP);
            // Needed so that google will redraw regions of the map once it is in the hopup and not hidden, which gave it a 0 height
            google.maps.event.trigger($cache.mapSmall, "resize");
            $cache.mapSmall.setZoom(6);
            // Set bounds of map
            $cache.mapSmall.setCenter(point);
        });
    }
};

module.exports = storelocator;


},{"../dialog":34,"../selectboxit":73}],66:[function(require,module,exports){
'use strict';

var addProductToCart = require('./product/addToCart'),
    page = require('../page'),
    login = require('../login'),
    util = require('../util');

exports.init = function () {
    addProductToCart();
    $('#editAddress').on('change', function () {
        page.redirect(util.appendParamToURL(Urls.wishlistAddress, 'AddressID', $(this).val()));
    });

    //add js logic to remove the , from the qty feild to pass regex expression on client side
    $('.option-quantity-desired input').on('focusout', function () {
        $(this).val($(this).val().replace(',', ''));
    });

    login.init();

};

},{"../login":42,"../page":44,"../util":82,"./product/addToCart":55}],67:[function(require,module,exports){
'use strict';

var util = require('./util');

var imagesLoaded = require('imagesloaded'),
    quickview = require('./quickview');

var $cache = {};

function initQuickViewButtons() {
    $('.tiles-container .product-image').on('mouseenter', function () {
    	var $this = $(this);
        var $qvButton = $('#quickviewbutton');
        if ($qvButton.length === 0) {
            $qvButton = $('<a id="quickviewbutton" class="quickview">' + Resources.QUICK_VIEW + '<i class="fa fa-arrows-alt"></i></a>');
            $qvButton.on('click', function (e) {
                e.preventDefault();
                var tileType = $(this).parents('.product-tile').data('tiletype');
                //Very specific case for making inputs outside of dialog available
                $.widget( "ui.dialog", $.ui.dialog, {
                    _allowInteraction: function( event ) {
                        return !!$( event.target ).is( "input" ) || this._super( event );
                    }
                });
                quickview.show({
                    url: $(this).attr('href'),
                    source: 'quickview',
                    customClass: typeof tileType != 'undefined' ? tileType : ''
                });
            });
        }

        var $link = $this.find('.thumb-link');
        $qvButton.attr({
            'href': $link.attr('href'),
            'title': $link.attr('title')
        }).appendTo(this);
    });
}

function gridViewToggle() {
    $('.toggle-grid').on('click', function () {
        $('.search-result-content').toggleClass('wide-tiles');
        $(this).toggleClass('wide');
    });
}

/**
 * @private
 * @function
 * @description Initializes events on the product-tile for the following elements:
 * - swatches
 * - thumbnails
 */
function initializeEvents() {
    initQuickViewButtons();
    gridViewToggle();
    
    $cache.container.on('touchstart click mouseenter', '.swatch-list a.swatch', function (e) {
        // don't follow the link on mobile devices
        if (util.isMobile()) {
            e.preventDefault();
        }
        // get current thumb details
        var link = $(this);
        var tile = link.closest(".grid-tile");
        var thumb = tile.find(".product-image a.thumb-link img").filter(":not(.lazy):first");
        var thumbLink = tile.find(".product-image a.thumb-link");
        var secondThumb = tile.find(".product-image a.thumb-link img").filter(":not(.lazy):last");
        var swatchImg = link.children("img").filter(":first");
        var data = link.data("thumb");

        var currentAtts = {
            src : thumb.attr("src"),
            alt : thumb.attr("alt"),
            title : thumb.attr("title")
        }

        thumb.attr({
            src : (thumb.data('alt-src') == data.src) ? data['alt-src'] : data.src,
            alt : decodeURIComponent(data.alt)
        }).data('alt-src', data['alt-src']);

        secondThumb.attr({
            src : (thumb.data('alt-src') == data.src) ? data.src : data['alt-src'],
            alt : decodeURIComponent(data.alt)
        }).data('alt-src',thumb.attr('src'));

        thumb.attr('data-assetname',swatchImg.data('assetname'));
        swatchImg.data("thumb", currentAtts);
        // Remove failed class in case the new swatch has images the previous swatch lacked
        thumb.removeClass('failed');

        if (secondThumb.attr("src") == "null") {
            secondThumb.addClass('failed');
        } else {
            secondThumb.removeClass('failed');
        }
        
        // set thumb product's href equal to swatch's href
        thumbLink.attr('href', link.attr('href'));
        
    });
    $cache.container.on('mouseleave', '.swatch-list', function () {
        // Restore current thumb image
        var $tile = $(this).closest('.product-tile'),
            $thumb = $tile.find('.product-image .thumb-link img').eq(1),
            $thumbLink = $tile.find(".product-image a.thumb-link"),
            $selectedSwatch = $tile.find('.swatch-list .swatch.selected'),
            baseurl = $thumb.data('baseurl');
            
        // set up base image
        if ($selectedSwatch.length && $selectedSwatch.data('thumb') && $selectedSwatch.data('thumb')['src']) {
            $thumb.attr('src', $selectedSwatch.data('thumb')['src']);
        } else if (baseurl) {
            $thumb.attr('src', baseurl);
        }
        // set up base href
        if ($selectedSwatch.length) {
            $thumbLink.attr('href', $selectedSwatch.attr('href'));
        }
        
    });

}

exports.init = function () {
    $cache = {
        container: $('.tiles-container')
    };

    initializeEvents();
};

},{"./quickview":69,"./util":82,"imagesloaded":4}],68:[function(require,module,exports){
'use strict';

var $loader;

/**
 * @function
 * @description Shows an AJAX-loader on top of a given container
 * @param {Element} container The Element on top of which the AJAX-Loader will be shown
 */
var show = function (container) {
    var target = (!container || $(container).length === 0) ? $('body') : $(container);
    $loader = $loader || $('.loader');

    if ($loader.length === 0) {
        $loader = $('<div/>').addClass('loader')
            .append($('<div/>').addClass('loader-indicator'), $('<div/>').addClass('loader-bg'));
    }
    return $loader.appendTo(target).show();
};
/**
 * @function
 * @description Hides an AJAX-loader
 */
var hide = function () {
    if ($loader) {
        $loader.hide();
    }
};

exports.show = show;
exports.hide = hide;

},{}],69:[function(require,module,exports){
'use strict';

var dialog = require('./dialog'),
    product = require('./pages/product'),
    util = require('./util'),
    _ = require('lodash');


var makeUrl = function (url, source, productListID) {
    if (source) {
        url = util.appendParamToURL(url, 'source', source);
    }
    if (productListID) {
        url = util.appendParamToURL(url, 'productlistid', productListID);
    }
    return url;
};

/**
 * @param {String} url Product URL
 * @returns {String} Product Url without search parameters if it was seo-friendly url
 *          or Product Url with pid search parameter only if it was not seo-friendly
 */
function normalizeProductUrl(url) {
    if (url.indexOf('?') !== -1) {
        var pidPosition = url.indexOf('?pid=');
        if (pidPosition === -1) {
            pidPosition = url.indexOf('&pid=');
        }
        if (pidPosition !== -1) {
            var urlNoParams = url.substring(0, url.indexOf('?'));
            var pidValueStartPosition = pidPosition + 5;
            var pidValueEndPosition = url.indexOf('&', pidValueStartPosition);
            if (pidValueEndPosition === -1) {
                pidValueEndPosition = url.length;
            }
            var pidValue = url.slice(pidValueStartPosition, pidValueEndPosition);
            if (pidValue !== '') {
                return urlNoParams + '?pid=' + pidValue;
            } else {
                return urlNoParams;
            }
        } else {
            return url.substring(0, url.indexOf('?'))
        }
    } else {
        return url;
    }
}

function allowOutOfStockClick(e, overlay){
	e.preventDefault();
    overlay.closest('li').find('a').click();
}

var quickview = {
    init: function () {
        if (!this.exists()) {
            this.$container = $('<div/>').attr('id', 'QuickViewDialog').appendTo(document.body);
        }
        this.productLinks = $('#search-result-items .product-tile:not(.product-set-tile) .thumb-link').map(function (index, thumbLink) {
            return normalizeProductUrl($(thumbLink).attr('href'));
        });
        $(".promotion-callout a.tooltip").on("click", function(e) {
        	e.preventDefault();
        });
        
    },

    setup: function (qvUrl) {

        // hide/show thumbnail arrows based on swatch list length
        var $thumbnails = $('#thumbnails');
        var thumbsWidth = 0;
        var $thumbsPrevArrow = $('.jcarousel-control-prev');
        var $thumbsNextArrow = $('.jcarousel-control-next');
        $('.thumb').each(function() {
            thumbsWidth += $(this).width();
        })
        if (thumbsWidth <= $('#thumbnails').width()) {
            $thumbsPrevArrow.hide();
            $thumbsNextArrow.hide();
        }

        var $btnNext = $('.quickview-next'),
            $btnPrev = $('.quickview-prev');

        product.init();

        this.productLinkIndex = _(this.productLinks).findIndex(function (url) {
            return url === normalizeProductUrl(qvUrl);
        });

        // hide the buttons on the compare page or when there are no other products
        if (this.productLinks.length <= 1 || $('.compareremovecell').length > 0) {
            $btnNext.hide();
            $btnPrev.hide();
            return;
        }

        if (this.productLinkIndex === this.productLinks.length - 1) {
            $btnNext.attr('disabled', 'disabled');
        }
        if (this.productLinkIndex === 0) {
            $btnPrev.attr('disabled', 'disabled');
        }

        $btnNext.on('click', function (e) {
            e.preventDefault();
            this.navigateQuickview(1);
        }.bind(this));
        $btnPrev.on('click', function (e) {
            e.preventDefault();
            this.navigateQuickview(-1);
        }.bind(this));
        
        if (typeof tfc !== "undefined" && typeof tfc.calculate === "function") {
    		tfc.calculate(); // Add TrueFit widget
    	}
    },

    /**
     * @param {Number} step - How many products away from current product to navigate to. Negative number means navigate backward
     */
    navigateQuickview: function (step) {
        // default step to 0
        var self = this;
        this.productLinkIndex += (step ? step : 0);
        var url = makeUrl(this.productLinks[this.productLinkIndex], 'quickview');
        dialog.replace({
            useContainer: self.$container,
            url: url,
            callback: function() {
                quickview.setup.call(quickview, url);
                // add class for gift-card products
                var $quickViewDialog = $('.ui-dialog_quick-view');
                var $isGift = $quickViewDialog.find('#isGiftCard');
                if ($isGift.length) {
                    $quickViewDialog.addClass('giftCard');
                } else {
                    $quickViewDialog.removeClass('giftCard');
                }
            }
        });       
        
    },

    /**
     * @description show quick view dialog
     * @param {Object} options
     * @param {String} options.url - url of the product details
     * @param {String} options.source - source of the dialog to be appended to URL
     * @param {String} options.class - custom class to add to the dialog
     * @param {String} options.productlistid - to be appended to URL
     * @param {Function} options.callback - callback once the dialog is opened
     */
    show: function (options) {
        var url;
        if (!this.exists()) {
            this.init();
        }
        url = makeUrl(options.url, options.source, options.productlistid);
        var dialogWidth = window.matchMedia('(min-width: 961px)').matches ? 820 : 720;
        if ((options.source === 'cart' || options.source === 'sfl-add' || options.source === 'giftregistry') && window.innerWidth <= 768) {
            dialogWidth = (window.innerWidth <= 668) ? (window.innerWidth).toString() : '668';
        }
        if ($('.ui-dialog_quick-view').length) {
            $('.ui-dialog_quick-view').remove();
        }
        this.$container.empty();

        dialog.open({
            target: this.$container,
            url: url,
            options: {
                width: dialogWidth,
                title: Resources.QUICK_VIEW_POPUP,
                dialogClass: 'ui-dialog_quick-view ' + (typeof options.customClass != 'undefined' ? options.customClass : ''),
                open: function () {
                    this.setup(url);
                    if (typeof options.callback === 'function') { options.callback(); }
                    if ($('#pdpMain.gift-card').length) {
                    	var linkurl = $('#pdpMain.gift-card').find('.full-details-link a').attr('href');
                    	if (linkurl) {
                    		$('#pdpMain.gift-card .swatches.Color li a').attr('href',linkurl);
                    	}
                    }
                }.bind(this)
            }
        });
        //must be initialize in the dialog creation so it is available 
        $('#QuickViewDialog').on('click', '.unselectable-overlay', function (e) {
            allowOutOfStockClick(e,$(this));
        });
    },
    exists: function () {
        return this.$container && (this.$container.length > 0);
    }
};

module.exports = quickview;

},{"./dialog":34,"./pages/product":58,"./util":82,"lodash":5}],70:[function(require,module,exports){
'use strict';

/**
 * copied from https://github.com/darkskyapp/string-hash
 */
function hashFn(str) {
    var hash = 5381,
        i = str.length;

    while (i) {
        hash = (hash * 33) ^ str.charCodeAt(--i);
    }
    /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
    * integers. Since we want the results to be always positive, convert the
    * signed int to an unsigned by doing an unsigned bitshift. */
    return hash >>> 0;
}

/**
 * Create rating based on hash ranging from 2-5
 * @param pid
 */
function getRating(pid) {
    return hashFn(pid.toString()) % 30 / 10 + 2;
}

module.exports = {
    init: function () {
        $('.product-review').each(function (index, review) {
            var pid = $(review).data('pid');
            if (!pid) {
                return;
            }
            // rating range from 2 - 5
            var rating = getRating(pid);
            var baseRating = Math.floor(rating);
            var starsCount = 0;
            for (var i = 0; i < baseRating; i++) {
                $('.rating', review).append('<i class="fa fa-star"></i>');
                starsCount++;
            }
            // give half star for anything in between
            if (rating > baseRating) {
                $('.rating', review).append('<i class="fa fa-star-half-o"></i>');
                starsCount++;
            }
            if (starsCount < 5) {
                for (var j = 0; j < 5 - starsCount; j++) {
                    $('.rating', review).append('<i class="fa fa-star-o"></i>');
                }
            }
        });
    }
};

},{}],71:[function(require,module,exports){
'use strict';

/**
 * @private
 * @function
 * @description Binds event to the place holder (.blur)
 */
function initializeEvents() {
//	This code breaks search form validation
	
//    $('#q').focus(function () {
//        var input = $(this);
//        if (input.val() === input.attr('placeholder')) {
//            input.val('');
//        }
//    })
//    .blur(function () {
//        var input = $(this);
//        if (input.val() === '' || input.val() === input.attr('placeholder')) {
//            input.val(input.attr('placeholder'));
//        }
//    })
//    .blur();
}

exports.init = initializeEvents;

},{}],72:[function(require,module,exports){
'use strict';

var util = require('./util');

var currentQuery = null,
    lastQuery = null,
    runningQuery = null,
    listTotal = -1,
    listCurrent = -1,
    delay = 30,
    $resultsContainer,
    mobileMenuBreakpoint = 960;
/**
 * @function
 * @description Handles keyboard's arrow keys
 * @param keyCode Code of an arrow key to be handled
 */
function handleArrowKeys(keyCode) {
    switch (keyCode) {
        case 38:
            // keyUp
            listCurrent = (listCurrent <= 0) ? (listTotal - 1) : (listCurrent - 1);
            break;
        case 40:
            // keyDown
            listCurrent = (listCurrent >= listTotal - 1) ? 0 : listCurrent + 1;
            break;
        default:
            // reset
            listCurrent = -1;
            return false;
    }

    $resultsContainer.children().removeClass('selected').eq(listCurrent).addClass('selected');
    $('input[name="q"]').val($resultsContainer.find('.selected .suggestionterm').first().text());
    return true;
}

/*
 * @function
 * @description	The default placeholder has poor contrast on mobile, and we will not have a placeholder pseudo-element
 * 				until CSS4 is released. Until then we can have a "fake" placeholder that can be styled.
 */
function mobilePlaceholderContrast() {
	var $mobileSearchField = $('.header-search-mobile .katesearchval');
	
	$mobileSearchField.on('focus', function (e) {
    	var $this = $(this);
		var placeholderText = $this.prop('placeholder');
    	if ($this.val() === placeholderText) {
    		$this.val("");
        } else {
    		return false;
        }
    }).on('blur', function (e) {
        var $this = $(this);
        var ph = $this.prop('placeholder');
        if ($this.val() === "") {
            $this.val(ph);
        } else {
            return false;
        }
    }).val($mobileSearchField.prop('placeholder'));
}

var searchsuggest = {
    /**
     * @function
     * @description Configures parameters and required object instances
     */
    init: function (container, defaultValue) {
        var $searchContainer = $(container);
        var $searchForm = $searchContainer.find('form[name="simpleSearch"]');
        var $searchField = $searchForm.find('input[name="q"]');

        // disable browser auto complete
        $searchField.attr('autocomplete', 'off');

        // on focus listener (clear default value)
        $searchField.focus(function () {
            if (!$resultsContainer) {
                // create results container if needed
                $resultsContainer = $('<div/>').attr('id', 'search-suggestions').appendTo($searchContainer);
            }
            if ($searchField.val() === defaultValue) {
                $searchField.val('');
            }
        });
        
        $(document).on('click', function (e) {
            if (!$searchContainer.is(e.target)) {
                setTimeout(this.clearResults, 200);
            }
        }.bind(this));
        // on key up listener
        $searchField.keyup(function (e) {

            // get keyCode (window.event is for IE)
            var keyCode = e.keyCode || window.event.keyCode;

            // check and treat up and down arrows
            if (handleArrowKeys(keyCode)) {
                return;
            }
            // check for an ENTER or ESC
            if (keyCode === 13 || keyCode === 27) {
                this.clearResults();
                return;
            }

            currentQuery = $searchField.val().trim();

            // no query currently running, init an update
            if (!runningQuery) {
                runningQuery = currentQuery;
                setTimeout(this.suggest.bind(this), delay);
            }
        }.bind(this));
        
        mobilePlaceholderContrast();
    },

    /**
     * @function
     * @description trigger suggest action
     */
    suggest: function () {
        // check whether query to execute (runningQuery) is still up to date and had not changed in the meanwhile
        // (we had a little delay)
        if (runningQuery !== currentQuery) {
            // update running query to the most recent search phrase
            runningQuery = currentQuery;
        }

        // if it's empty clear the results box and return
        if (runningQuery.length === 0) {
            this.clearResults();
            runningQuery = null;
            return;
        }

        // if the current search phrase is the same as for the last suggestion call, just return
        if (lastQuery === runningQuery) {
            runningQuery = null;
            return;
        }

        // build the request url
        var reqUrl = util.appendParamToURL(Urls.searchsuggest, 'q', runningQuery);

        // execute server call
        $.get(reqUrl, function (data) {
            var suggestionHTML = data,
                ansLength = suggestionHTML.trim().length;

            // if there are results populate the results div
            if (ansLength === 0) {
                this.clearResults();
            } else {
                // update the results div
                $resultsContainer.html(suggestionHTML).fadeIn(200);
                if (navigator.userAgent.search(/webkit/i) < 0) {
                    $('.suggestion-wrapper').mCustomScrollbar();
                }
                // prevent the main nav from also scrolling in mobile
                // make the nav the same height of the search container
                // only if the container is taller than the viewport
                if (window.innerWidth < mobileMenuBreakpoint) {
                    var searchContainerHeight = $('.header-search-mobile').outerHeight();
                    var vpHeight = window.innerHeight;
                    if (vpHeight < searchContainerHeight) {
                        $('#navigation').addClass('noScroll').css('height', searchContainerHeight);
                        // this becomes the scrollable container so the user can see all of the results
                        $('.navigation-top').first().css('height', vpHeight).css('overflow-y', 'scroll');
                    } else {
                        // if the container is shorter than the viewport height just prevent the nav from scrolling
                        $('#navigation').addClass('noScroll');
                    }
                }
            }

            // record the query that has been executed
            lastQuery = runningQuery;
            // reset currently running query
            runningQuery = null;

            // check for another required update (if current search phrase is different from just executed call)
            if (currentQuery !== lastQuery) {
                // ... and execute immediately if search has changed while this server call was in transit
                runningQuery = currentQuery;
                setTimeout(this.suggest.bind(this), delay);
            }
            this.hideLeftPanel();
        }.bind(this));
    },
    /**
     * @function
     * @description
     */
    clearResults: function () {
        if (!$resultsContainer) { return; }
        $resultsContainer.fadeOut(200, function () {$resultsContainer.empty();});
        // let the nav scroll again
        if (window.innerWidth < mobileMenuBreakpoint) {
            $('.search-suggestion-wrapper').removeAttr('style');
            $('#navigation').removeAttr('style').removeClass('noScroll');
            $('.navigation-top').first().removeAttr('style');
        }
    },
    /**
     * @function
     * @description
     */
    hideLeftPanel: function () {
        //hide left panel if there is only a matching suggested custom phrase
        if ($('.search-suggestion-left-panel-hit').length === 1 && $('.search-phrase-suggestion a').text().replace(/(^[\s]+|[\s]+$)/g, '').toUpperCase() === $('.search-suggestion-left-panel-hit a').text().toUpperCase()) {
            $('.search-suggestion-left-panel').css('display', 'none');
            $('.search-suggestion-wrapper-full').addClass('search-suggestion-wrapper');
            $('.search-suggestion-wrapper').removeClass('search-suggestion-wrapper-full');
        }
    }
};

module.exports = searchsuggest;
},{"./util":82}],73:[function(require,module,exports){
'use strict';
function selectBoxIt(select) {
    var items = select.filter('select');
    if (items.length == 0) {
        return;
    }

    items.each(function() {
        var item = $(this);
        try {
            item.addClass('replaced');
            var sb = item.selectBoxIt().data('selectBoxIt');
            sb.refresh();
            items.bind({
                'open': function() {
                    $(this).next('.selectboxit-container').addClass('open')
                },
                'close' : function() {
                    $(this).next('.selectboxit-container').removeClass('open')
                },
                'focusin' : function() {
                    $(this).next('.selectboxit-container').addClass('focus');
                },
                'focusout' : function() {
                    $(this).next('.selectboxit-container').removeClass('focus');
                }
            });
            // add availablity message within dropdown
            sb.dropdownContainer.find('li[data-text] a').each(
                function() {
                    var a = $(this);
                    var li = a.parent();
                    var dataText = li.data('text');
                    if (dataText) {
                        var html = a.html();
                        if (html.indexOf(dataText) == -1) {
                            li.addClass('avail');
                            a.html('<span class="size">' + html
                                    + '</span>&nbsp;<span class="msg">'
                                    + dataText + '</span>');
                        }
                    }
                }
            );
        } catch (e) {}
    });
}
module.exports.selectBoxIt = selectBoxIt;

},{}],74:[function(require,module,exports){
'use strict';

/**
 * Execute callback function when the user has stopped resizing the screen.
 * @param callback {Function} The callback function to execute.
 */

var smartresize = function (callback) {
    var timeout;

    window.addEventListener('resize', function () {
        clearTimeout(timeout);
        timeout = setTimeout(callback, 100);
    });

    return callback;
};

module.exports = smartresize;

},{}],75:[function(require,module,exports){
'use strict';

/**
 * MY BAG - EXPAND AND MINIMIZE FUNCTIONALITY VIA CHECKOUT
 * WE ARE REBINDING THE EVENT HERE SINCE IT IS INCLUDED INSIDE OF
 * MINISUMMARY.ISML WHICH IS RETURNED VIA AJAX WHEN A USER CHANGES THE
 * SHIPPING METHOD.
 */

var stickyCart = {
    init: function () {

        $('#my-bag-toggle-button').on('click', function(e) {
            //control height of expanded bag
            var summaryBlock =  $('.cart-order-totals');
            var contentBlock = $('.checkout-mini-summary');
            
            if (summaryBlock.height() > contentBlock.height()) {
                summaryBlock.find('.my-bag-content').addClass('scrolable');
            } else {
                summaryBlock.find('.my-bag-content').removeClass('scrolable');
            }
            // show expanded bag
            $(this).toggleClass('fa-minus')
                .parents('.my-bag-checkout').toggleClass('expanded');
            $('.my-bag-content').toggle();

            //reload sticky block
            $(document.body).trigger('sticky_kit:recalc');

        });
    }
};

module.exports = stickyCart;

},{}],76:[function(require,module,exports){
'use strict';

var inventory = require('./');
var product = require('../storeinventory/product');
var util = require('../util');

var cartInventory = {
    setSelectedStore: function (storeId,uuid) {
        var $selectedStore = $('.store-tile.' + storeId + '.selected'),
            $lineItem = $('.cart-row[data-uuid="' + uuid + '"]'),
            storeAddress = $selectedStore.find('.store-address').html(),
            storeStatus = $selectedStore.find('.store-status').data('status'),
            storeStatusText = $selectedStore.find('.store-status').text(),
            storeStr = Resources.PICK_UP_AT.replace('{0}',$selectedStore.find('.store-name').text().trim()),
            storeValHtml = '<span id="storeVal">'+storeStr+'</span>';
        this.selectedStore = storeId;



        $lineItem.find('.instore-delivery .selected-store-address')
            .data('storeId', storeId)
            .attr('data-store-id', storeId)
            .html(storeAddress);
        $lineItem.find('.instore-delivery .selected-store-availability')
            .data('status', storeStatus)
            .attr('data-status', storeStatus)
            .text(storeStatusText);
        // $lineItem.find('.instore-delivery .delivery-option').removeAttr('disabled').trigger('click');

        var homeDelContainers = $lineItem.find('.home-delivery');

        homeDelContainers.each(function () {
            var el = this;
            var storeVal = el.querySelectorAll('#storeVal');

            if (storeVal.length > 0) {
                for(var i = 0, size = storeVal.length; i < size; i++) {
                    var item = storeVal[i];
                    item.remove();
                }
            }

            el.insertAdjacentHTML('afterBegin',storeValHtml);
        });
        
        //hide country restriction message if it exists
        var finalSaleRow = $lineItem.next('.final-sale-row');
        if (finalSaleRow.length && finalSaleRow.find('.item-restriction-messages').length) {
            finalSaleRow.find('.item-restriction-messages').addClass('visually-hidden');
        }

        User.storeId = storeId;

        $.ajax({
            url: Urls.setStorePickup,
            type: 'GET',
            data: {plid: uuid, storeid: storeId, storepickup: 'true'}
        });
        $.ajax({
            url: Urls.setPreferredStore,
            type: 'POST',
            data: {storeId: storeId}
        });
    },
    cartSelectStore: function (selectedStore) {
        var self = this;
        var itemRow = document.querySelector('.cart-row[data-uuid="'+self.uuid+'"]');
        var colorEl = itemRow.querySelector('div[data-attribute="color"] .value');
        var qtyEl = itemRow.querySelector('.cart-quantity');
        var priceEl = itemRow.querySelector('.price-total');
        var pid =  itemRow.dataset.pid;

        var productColor = colorEl ? colorEl.textContent.trim() : '';
        var productPrice = priceEl ? priceEl.textContent.trim() : '';
        var productQty =  qtyEl ?  qtyEl.value : '';

        $.ajax({
            dataType: 'html',
            url: util.appendParamsToUrl(Urls.getProductInfo, {
                pid: pid,
                productColor: productColor,
                productPrice: productPrice,
                productQty: productQty
            }),
            success: function (response) {
                User.pickupContent = response;

                inventory.selectStoreDialog({
                    pid: pid,
                    pickupContent: User.pickupContent,
                    stores: [],
                    selectedStoreId: selectedStore,
                    selectedStoreText: Resources.SELECTED_STORE,
                    continueCallback: function () {

                        var itemDelOptions = $('.cart-row[data-uuid="'+self.uuid+'"] .item-delivery-options');
                        itemDelOptions.find('.active').removeClass('active');
                        itemDelOptions.find('.home-delivery').addClass('active');
                    },
                    selectStoreCallback: function(storeId) {
                        self.setSelectedStore(storeId,self.uuid);
                    }
                });
            }
        });
    },
    setDeliveryOption: function (value, storeId) {
        var data = {
            plid: this.uuid,
            storepickup: (value === 'store' ? true : false)
        };
        if (value === 'store') {
            data.storepickup = true;
            data.storeid = storeId;
        } else {
            data.storepickup = false;
        }
        $.ajax({
            url: Urls.setStorePickup,
            data: data,
            success: function () {location.reload();}
        });
    },
    init: function () {
        var self = this,
            itemDelOptions = document.querySelectorAll('.cart-row .do-btn');

        for (var i = 0, size = itemDelOptions.length; i < size; i++) {
            itemDelOptions[i].addEventListener('click',function (e) {
                var el = this.previousElementSibling,
                    itemDelWrapper = el.parentElement.parentElement;

                var val = el.value;

                if (val === 'home') {
                    itemDelWrapper.querySelector('.active').classList.remove('active');
                    //show country restriction message if it exists
                    var finalSaleRow = jQuery(itemDelWrapper).closest('.cart-row').next('.final-sale-row');
                    if (finalSaleRow.length && finalSaleRow.find('.item-restriction-messages').length) {
                        finalSaleRow.find('.item-restriction-messages').removeClass('visually-hidden');
                    }
                    if (typeof itemDelWrapper.querySelector('.instore-delivery') != undefined) {
                    	itemDelWrapper.querySelector('.instore-delivery').classList.add('active')
                    }
                } else if(val === 'store') {
                    itemDelWrapper.querySelector('.set-preferred-store').click();
                }

                // reset the uuid
                var $el = jQuery(el);
                var selectedStore = $el.closest('.instore-delivery').find('.selected-store-address').data('storeId');
                self.uuid = $el.closest('.cart-row').data('uuid');
                self.setDeliveryOption(el, selectedStore);
            });
        }

        $('.cart-row .set-preferred-store').on('click', function (e) {
            e.preventDefault();
            self.uuid = this.dataset.uuid;
            self.pid = this.dataset.pid;
            var selectedStore = $(this).closest('.instore-delivery').find('.selected-store-address').data('storeId');

            if (!User.zip) {
                self.cartSelectStore(selectedStore);
            } else {
                self.cartSelectStore(selectedStore);
            }
        });
    }
};

module.exports = cartInventory;

},{"../storeinventory/product":78,"../util":82,"./":77}],77:[function(require,module,exports){
'use strict';

var _ = require('lodash'),
    dialog = require('../dialog'),
    TPromise = require('promise'),
    util = require('../util');

var newLine = '\n';
var storeTemplate = function (store, selectedStoreId, selectedStoreText) {
    //handles deprecation and organization of store hours info
	
    var storeHoursStacked,
        storeHoursLong,
        storeHoursOnly = store.storeHours;

    if (storeHoursOnly.indexOf('<br><br>') != -1) {
        storeHoursOnly = store.storeHours.split('<br><br>')[0];
    }
    if (storeHoursOnly.indexOf('<br /><br />') != -1) {
        storeHoursOnly = store.storeHours.split('<br /><br />')[0];
    }

	storeHoursOnly = storeHoursOnly.replace('<br>', '<br />', 'g');
	storeHoursOnly = storeHoursOnly.replace('<br >', '<br />', 'g');
	storeHoursStacked = storeHoursOnly.replace('<br/>', '<br />', 'g');
	storeHoursLong = storeHoursStacked.replace('<br />', ', \u00A0', 'g');

    var storePhone = '';        
    if (store.phone) {
    	storePhone = '<br/><a href="tel:' + store.phone + '">' + store.phone + '</a>';
    }
	var qAttr = "";
	if(store.address1    != null) qAttr += store.address1 + ", ";
	if(store.address2    != null) qAttr += store.address2 + ", ";
	if(store.city        != null) qAttr += store.city + ", ";
	if(store.postalCode  != null) qAttr += store.postalCode + ", ";
	if(store.stateCode   != null) qAttr += store.stateCode + ", ";
	if(store.countryCode != null) qAttr += store.countryCode;
	var glink = "http://maps.google.com/maps?hl=en&f=q&q=" + encodeURI(qAttr);

    return [
        '<li class="store-tile ' + store.storeId + (store.storeId === selectedStoreId ? ' selected' : '') + '">',
        '    <span class="recommended-shop-msg">' + 'your recommended shop' + '</span>',
        '    <button class="select-store-radio" data-store-id="' + store.storeId + '"' +
        (store.statusclass !== 'store-in-stock' ? 'disabled="disabled"' : '') + '>',
        '    </button>',
        '    <div class="store-primary-info">',
        '        <p class="store-name">',
        '            ' + store.name + '<br/>',
        '        </p>',
        '        <p class="store-address">',
        '            ' + store.address1 + '<br/>',
        '            ' + store.city + ', ' + store.stateCode + ' ' + store.postalCode,
        '        </p>',
        '    </div>',
        '    <div class="store-secondary-info">',
        '        <p class="store-status" data-status="' + store.statusclass + '">' + store.status + '</p>',
        '        <p class="store-hours-stacked">' + storeHoursStacked + '</p>',
        '        <p class="store-hours-long">' + storeHoursLong + '</p>',
        '    </div>',
        '    <a href="' + glink + '" class="store-map-toggle directions" target="_blank">' + 'MAP' + '</a>',
        '    <div class="store-map-container">',
        '       <div class="store-map"></div>',
        '    </div>',
        '</li>'
    ].join(newLine);
};

var storeListTemplate = function (pickupContent, stores, selectedStoreId, selectedStoreText) {
    var templateContent = '';
    if (stores.length) {
        return [
            pickupContent,
            '<div class="store-list-container">',
            '<span class="stores-availability-msg">available at ' + stores.length + ' shops</span>',
            '<ul class="store-list">',
            _.map(stores, function (store) {
                return storeTemplate(store, selectedStoreId, selectedStoreText);
            }).join(newLine),
            '</ul>',
            '</div>'
        ].join(newLine);
    } else {
        return [
            pickupContent,
            '<div class="store-list-container">',
            '<span class="stores-availability-msg">available at ' + stores.length + ' shops</span>',
            '</div>'
        ].join(newLine);
    }
};

var zipPromptTemplate = function () {
    return [
        '<div id="preferred-store-panel">',
        '    <input type="text" id="user-zip" placeholder="' + Resources.ENTER_ZIP + '" name="zipCode"/>',
        '</div>'
    ].join(newLine);
};

/**
 * @description test whether zipcode is valid for either US or Canada
 * @return {Boolean} true if the zipcode is valid for either country, false if it's invalid for both
 **/
var validateZipCode = function (zipCode) {
    var regexes = {
            canada: /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJKLMNPRSTVWXYZ]( )?\d[ABCEGHJKLMNPRSTVWXYZ]\d$/i,
            usa: /^\d{5}(-\d{4})?$/
        },
        valid = false;
    if (!zipCode) { return; }
    _.each(regexes, function (re) {
        var regexp = new RegExp(re);
        valid = regexp.test(zipCode);
    });
    return valid;
};

var storeinventory = {
    zipPrompt: function (callback) {
        var self = this;
        dialog.open({
            html: zipPromptTemplate(),
            options: {
                title: Resources.STORE_NEAR_YOU,
                width: 500,
                buttons: [{
                    text: Resources.SEARCH,
                    click: function () {
                        var zipCode = $('#user-zip').val();
                        if (validateZipCode(zipCode)) {
                            self.setUserZip(zipCode);
                            if (callback) {
                                callback(zipCode);
                            }
                        }
                    }
                }],
                open: function () {
                    $('#user-zip').on('keypress', function (e) {
                        if (e.which === 13) {
                            // trigger the search button
                            $('.ui-dialog-buttonset .ui-button').trigger('click');
                        }
                    });
                }
            }
        });
    },
    getStoresInventory: function (pid) {
        return TPromise.resolve($.ajax({
            url: util.appendParamsToUrl(Urls.storesInventory, {
                pid: pid,
                zipCode: User.zip,
                storeId: User.storeId
            }),
            dataType: 'json'
        }));
    },
    /**
     * @description open the dialog to select store
     * @param {Array} options.stores
     * @param {String} options.selectedStoreId
     * @param {String} options.selectedStoreText
     * @param {Function} options.continueCallback
     * @param {Function} options.selectStoreCallback
     **/
    selectStoreDialog: function (options) {
        User.stores = options.stores;
        var self = this,
            pid = options.pid,
            pickupContent = options.pickupContent,
            selectedStoreId = options.selectedStoreId,
            selectedStoreText = options.selectedStoreText,
            storeList = storeListTemplate(pickupContent, User.stores, selectedStoreId, selectedStoreText),
            dialogWidth = (window.innerWidth < 708) ? (window.innerWidth).toString() : '668';

        dialog.open({
            html: storeList,
            options: {
                buttons: [{
                    text: Resources.CONTINUE_WITH_STORE,
                    click: function () {
                        if (options.continueCallback) {
                            options.continueCallback(User.stores);
                        }
                        dialog.close();
                    }
                }],
                width: dialogWidth,
                position: { my: "top", at: "top+100", of: window },
                dialogClass: 'store-pickup-dialog',
                close: function() {
                    $('body').removeClass('store-pickup-dialog-opened');
                },
                open: function () {
                	$("#showStoresForm").validate();
                	$('.pickup-product-attribute.pQuantity .value').html($('#pdpQtySelectSelectBoxItText').html());
                    var setStoreEvents = function() {
                        $('.select-store-radio').on('click', function (e) {
                            e.preventDefault();
                            var storeId = $(this).data('storeId');
                            // if the store is already selected, don't select again
                            if (!$(this).parent().hasClass('selected')) {
                                $('.store-list .store-tile.selected').removeClass('selected');
                                $(this).closest('.store-tile').addClass('selected');
                                if (options.selectStoreCallback) {
                                    options.selectStoreCallback(storeId);
                                }
                            }
                        });

                        $('.store-map-toggle').not('.directions').on('click', function (e) {
                            e.preventDefault();
                            var mapContainer = $(this).closest($('.store-tile')).find($('.store-map'));
                            mapContainer.toggle();
                            $(this).toggleClass('visible');
                            $(this).closest($('.store-tile')).find($('.store-map-container')).toggleClass('visible');
                            if (!mapContainer.children().length) {
                                var map = new google.maps.Map(mapContainer[0], {
                                    zoom: 8,
                                  });
                                var geocoder = new google.maps.Geocoder();
                                var address = $(this).closest($('.store-tile')).find($('.store-address'))[0].innerText;
                                geocoder.geocode({'address': address}, function(results, status) {
                                    if (status === 'OK') {
                                        map.setCenter(results[0].geometry.location);
                                        var marker = new google.maps.Marker({
                                            map: map,
                                            position: results[0].geometry.location
                                        });
                                    } else {
                                        alert('Geocode was not successful for the following reason: ' + status);
                                    }
                                });
                            }
                        });
                    }

                    var updateStoreList = function () {
                        var zipCode = $('.zip-input').val();
                        var maxDistance = $('.distance-input').val();
                        if (validateZipCode(zipCode)) {

                            // We want to show customer's Preferred Store at the top of the stores list
                            // even if preferred store zip code is out of search range

                            // We perform stores search by zip and max distance at first
                            // If there is the Preferred Store in the search results, no additional request is needed
                            // Otherwise, we get Preferred Store data and add it to the first position in the search results

                            // Promise to get stores near the provided zip
                            var storesPromise = TPromise.resolve(
                                $.ajax({
                                    dataType: 'json',
                                    url: util.appendParamsToUrl(Urls.storesInventory, {
                                        zipCode: zipCode,
                                        maxDistance: maxDistance,
                                        pid: pid,
                                        storeId: User.storeId
                                    })
                                })
                            );

                            // Promise to get preferred store ID and zip for logged in customers
                            // (it resolves with an empty object for not logged in customers)
                            var preferredStoreIdPromise = TPromise.resolve(
                                $.ajax({
                                    dataType: 'json',
                                    url: Urls.getPreferredStore
                                })
                            );

                            TPromise.all([storesPromise, preferredStoreIdPromise])
                                .then(function(res) {
                                    var stores = res[0];
                                    var prefStoreIdResponse = res[1];
                                    var prefStorePromise;

                                    if (prefStoreIdResponse.storeId) {

                                        // Check if the Preferred Store is present in the store list already,
                                        var prefStoreIdx = _.findIndex(stores, { 'storeId': prefStoreIdResponse.storeId });
                                        if (prefStoreIdx !== -1 && prefStoreIdx !== 0) {

                                            // If so, get preferred store from the stores list
                                            var prefStore = stores.splice(prefStoreIdx, 1)[0];
                                            prefStorePromise = TPromise.resolve(prefStore);

                                        } else {
                                            // Otherwise get the Preferred Store data from server
                                            prefStorePromise = TPromise.resolve(
                                                $.ajax({
                                                    dataType: 'json',
                                                    url: util.appendParamsToUrl(Urls.storesInventory, {
                                                        zipCode: prefStoreIdResponse.storeZip,
                                                        maxDistance: 10,
                                                        pid: pid
                                                    })
                                                })
                                            ).then(function(prefStoresRes) {
                                                return _.find(prefStoresRes, { 'storeId': prefStoreIdResponse.storeId });
                                            })
                                        }
                                    } else {
                                        prefStorePromise = TPromise.resolve(null);
                                    }

                                    prefStorePromise.then(function(prefStore) {
                                        if (prefStore) {
                                            stores.unshift(prefStore);
                                        }
                                        User.stores = stores;
                                        $('.store-list-container').empty();
                                        $('.store-list-container').append('<span class="stores-availability-msg">available at ' + stores.length + ' shops</span>');
                                        if (stores.length) {
                                            $('.store-list-container').append('<div class="store-list"></div>');
                                            $('.store-list').append(_.map(stores, function (store) {
                                                return storeTemplate(store, selectedStoreId, selectedStoreText);
                                            }).join(newLine));
                                            setStoreEvents();
                                            $('.select-store-radio').each(function() {
                                                var parentEl = this.parentElement;
                                                if ($(this).data('storeId') == User.storeId || parentEl.classList.contains('selected')) {
                                                    parentEl.classList.remove('selected');
                                                    $(this).click();
                                                }
                                            });
                                            $('.show-more').remove();
                                            var AllOther = parseInt(stores.length-3);
                                            if (stores.length > 3) {
                                                $('.ui-dialog-buttonset').append('<button class="show-more more-btn">view all SHOPS ('+AllOther+')+</button>');
                                            }
                                            var list = $('.store-list .store-tile');
                                            var numToShow = 3;
                                            var button = $('.show-more');
                                            var numInList = list.length;
                                            var isShowing = true;
                                            list.hide();
                                            list.slice(0, numToShow).show();
                                            var onFadeComplete = function() {
                                                var nowShowing = list.filter(':visible').length;
                                                if(nowShowing == numInList && isShowing) {
                                                    isShowing = false;
                                                    button.text('view less SHOPS');
                                                }
                                                if(nowShowing == numToShow) {
                                                    button.text('view all SHOPS ('+ AllOther+')+');
                                                    isShowing = true;
                                                }
                                            };

                                            button.click(function() {
                                                var showing = list.filter(':visible').length;
                                                if(isShowing){
                                                    list.slice(showing - 1, showing + numToShow).fadeIn(100,onFadeComplete);
                                                }
                                                else{
                                                    list.slice(numToShow , numInList).fadeOut(100,onFadeComplete);
                                                }
                                            });
                                        }
                                    });
                                });
                        }
                    };

                    $('#showStoresForm').on('submit', function(e) {
                        e.preventDefault();
                        updateStoreList();
                    });

                    $('.distance-input').on('change', function(e) {
                        e.preventDefault();
                        updateStoreList();
                        $('.distance-input-label')[0].innerHTML = 'Radius: ' + $('.distance-input option:selected')[0].value + ' miles';
                    });
                    
                    $('.zip-input').on('change', function(e) {
                        e.preventDefault();
                        updateStoreList();
                        $('.distance-input-label')[0].innerHTML = 'Radius: ' + $('.distance-input option:selected')[0].value + ' miles';
                    });

                    setTimeout(function (){

                        setStoreEvents();

                        //initialize display of distance and zipcode used

                        $('.distance-input-label')[0].innerHTML = 'Radius: ' + $('.distance-input option:selected')[0].value + ' miles';

                        $.ajax({
                            dataType: 'json',
                            url: Urls.getZipCode,
                            success: function (response) {

                                if (response[0].userDefaultZip) {
                                    $('input.zip-input').val(response[0].userDefaultZip);
                                } else if (response[0].zip) {
                                    $('input.zip-input').val(response[0].zip);
                                }

                                if ($('input.zip-input').val()) {
                                    $('#showStoresForm').trigger('submit');
                                }
                            }
                        });

                    }, 50);
                }
            }
        });
        setTimeout(function (){
            var topOffset = ($(window).width() < 708) ? 61 : (($(window).width() - 708) / 2) + 61;
            if (topOffset > 100) {
                topOffset = 100;
            }
            topOffset = $(window).scrollTop() + topOffset;
            $('.ui-dialog').css('top', topOffset.toString() + 'px');
            
            $('body').addClass('store-pickup-dialog-opened');
        }, 50);

    },
    setUserZip: function (zip) {
        User.zip = zip;
        $.ajax({
            type: 'POST',
            url: Urls.setZipCode,
            data: {
                zipCode: zip
            }
        });
    },
    shippingLoad: function () {
        var $checkoutForm = $('.address');
        $checkoutForm.off('click');
        $checkoutForm.on('click', 'input[name$="_shippingAddress_isGift"]', function () {
            $(this).parent().siblings('.gift-message-text').toggleClass('hidden', $('input[name$="_shippingAddress_isGift"]:checked').val());
        });
    }
};

module.exports = storeinventory;

},{"../dialog":34,"../util":82,"lodash":5,"promise":6}],78:[function(require,module,exports){
'use strict';
var dialog = require('../dialog');
var util = require('../util');
var $cache = {
	pdpMain : $('#pdpMain'),
	pdpForm : $("#pdpMain form.pdpForm"),
	productThumbnailTiles: $('#pdpMain').find('#thumbnails .thumb'),
	addAllToCart : $('#add-all-to-cart'),
	productSetList : $(".product-set-list"),

	//monogramming
	monogramcontainer : $('#pdpMain .monogram-container'),
	monogramformfields : $('.monogram-form-fields'),

	// monogramming style container
	monogramstyles : $('#pdpMain .monogram-container').find('ul.monogram-styles'),
	monogramstyletiles : $('#pdpMain .monogram-container').find('li.monogram-style-tile'),
	selectedStyleConfig : null,

	// options
	monogramingoptionscontainer : $('#pdpMain .monogram-container').find('.monogram-options-container'),

	// font
	monogramfontselect : $('#pdpMain .monogram-container').find('.monogram-font-select'),
	fonttilebase : $('#pdpMain .monogram-container').find('.monogram-font-base.visually-hidden').clone(),

	// characters
	monogramtextinputcontainer : $('#pdpMain .monogram-container').find('.monogram-text-input-container'),
	monogramtexttitle : $('#pdpMain .monogram-container').find('.text-input-title'),
	monogramtextinputbody : $('#pdpMain .monogram-container').find('.monogram-text-input-body'),
	monograminputbase : $('#pdpMain .monogram-container').find('.monogram-text-input-wrapper').clone(),
	focusedinput : null,// used as a container for the currently
								// focused input, to allow symbols to be
								// added there
	monogramtextinputclear : $('#pdpMain .monogram-container').find('.monogram-text-input-clear'),

	// symbols
	monogramsymbollist : $('#pdpMain .monogram-container').find('.monogram-symbol-list'),
	monogramsymbolselectioncontainer : $('#pdpMain .monogram-container').find('.monogram-symbol-selection-container'),
	symbolbase : $('#pdpMain .monogram-container').find('.monogram-symbol-base.visually-hidden').clone(),

	// dots
	monogramdotscontainer : $('#pdpMain .monogram-container').find('div.monogram-dots-container'),
	monogramdotsoptions : $('#pdpMain .monogram-container').find('li.dots-option'),

	// colors
	monogramcolors : $('#pdpMain .monogram-container').find('li.monogram-color-swatch')


};
function initializeEvents(){
	if($cache.pdpMain.length > 0){
		$("#pdpMain, #quick-view-dialog").on("click", ".product-thumbnails li a", function(e) {
			e.preventDefault();

			var variations = $('.product-variations');

			// Create a new instance of CloudZoom
			var cz = $(".cloudzoom").data("CloudZoom");

			// Get selected image src
			var src = $(this).find('img').attr('src');
			var pdpImg = $('.primary-image.cloudzoom');

			// Load a new small image and zoom image into it:
			var smallImg = src.replace("$productThumbnail$", "$large$");
	        var zoomImg = smallImg.replace("$large$", "$s7fullsize$");

	        // Load new images into CloudZoom instance
	        var isQuickView = function() {
				var $qvcontainer = $('#quick-view-dialog');
				return ($qvcontainer.length>0);
			};
	        if(!isQuickView){
	        	cz.loadImage(smallImg, zoomImg);
	        }
		});

		if ($cache.pdpMain.find('#thumbnails li').length <= 4) {
			$('#thumbnails .jcarousel-control-prev').hide();
			$('#thumbnails .jcarousel-control-next').hide();
		}

		if(window.innerWidth < 960){
			$('#social-product-set #social-header').click(function(){
				$('#social-product-set .social-icons').slideToggle();
			})
		}
	}
	$('body').on('click', '.twitter-share a', function(e){
		e.preventDefault();
	});
    $cache.pdpMain.off("click.swatches")
	.on("click.swatches", "div.product-detail a.swatchanchor, div.product-set-details a.swatchanchor", function (e) {
		// FIXME: every time the variation changes, an additional listener is added.
		// This is due to the variation.js also applying like events.
		// The functionality from this file should be moved into variant.js, or other specific sub-namespace (giftcard.js, productset.js, and the like).
		// product.js should be Store Inventory specific!
		e.preventDefault();

		var anchor = $(this),
			parentList = anchor.parent("li"),
			qty = $('.pdpForm select[name="Quantity"]').first().val(),
			productSet = $(anchor).closest('.product-set-item'),
			isProductSet = productSet.length > 0,
			params = {
				Quantity : isNaN(qty) ? "1" : qty
			},
			parent = anchor.closest("ul.swatches"),
			attributeContainer = parent.closest('li'),
			isColor = parent.hasClass("Color"),
			container = parent.closest('.product-variations'),
			inputId = container.find('input[name=pid]');

		if (isProductSet) {
			// updateProductSet(anchor);
			return;
		}

		// pause and reposition flowplayer if currently active
		try{
			if(flowplayer && flowplayer()){
				var videoPlayer = $('.flowplayer-container');
				if(videoPlayer.children().length != 0){
					videoPlayer.css('top','-999px').css('position', 'absolute');
				}
			}
		} catch(e) {

		}


		// Don't allow preselection of a monogram color unless text is submitted
		if(parent.hasClass('monogram') && $('input[name=dwfrm_customizer_monogram_text]').val() == '' && !$cache.monoReset) return false;


		if (parentList.hasClass("selected")) {
			return;
		} else if (parentList.length > 0) {

			parentList.parent('ul').find('li').each(function(e){
				$(this).removeClass("selected");

				// Set previously un selectable element back to initial state
				if($(this).hasClass('prev-unselectable')){
					$(this).addClass("unselectable");
				}
			});

			// set class of previously un selectable li
			if(parentList.hasClass('unselectable')){
				parentList.removeClass("unselectable");
				parentList.addClass("prev-unselectable");
			}
			setTimeout(function() {
			    parentList.addClass("selected");
			}, 0);

		}

		if (!this.href) {
			return; // if no href, then return
		}

		// keep the gift card info intact when changing the gift card amount

		var egiftcard = $('.pdpForm input[name="egiftcard"]');
		var giftcard = $('.pdpForm input[name="giftcard"]');

		egiftcard = egiftcard.length && egiftcard.first().val() == 'true' ? true : false;
		giftcard = giftcard.length && giftcard.first().val() == 'true' ? true : false;

		if(giftcard || egiftcard){

			var gcAmount = $('#gcAmount').first().val();
			if(gcAmount){
				params['gcAmount'] = gcAmount;
			}

			if(egiftcard){

				var vgcRecipientName = $('.pdpForm input[name="vgcRecipientName"]').first().val();
				var vgcRecipientEmail = $('.pdpForm input[name="vgcRecipientEmail"]').first().val();
				var vgcFromName = $('.pdpForm input[name="vgcFromName"]').first().val();
				var vgcFromEmail = $('.pdpForm input[name="vgcFromEmail"]').first().val();
				var vgcGiftCardMessage = $('.pdpForm textarea[name="vgcGiftCardMessage"]').first().val();

				if(vgcRecipientName){
					params['vgcRecipientName'] = vgcRecipientName;
				}
				if(vgcRecipientEmail){
					params['vgcRecipientEmail'] = vgcRecipientEmail;
				}
				if(vgcFromName){
					params['vgcFromName'] = vgcFromName;
				}
				if(vgcFromEmail){
					params['vgcFromEmail'] = vgcFromEmail;
				}
				if(vgcGiftCardMessage){
					params['vgcGiftCardMessage'] = vgcGiftCardMessage;
				}

			}

		}

		// keep the product list id for use with the gift registry quick edit
		var productlistid = $('.pdpForm input[name="productlistid"]');
		if(productlistid.length){
			params['productlistid'] = productlistid.first().val();
		}

		params['pagesource'] = $('.pdpForm input[name="pagesource"]').first().val();

		var target = (productSet.length > 0 && productSet.children.length > 0) ? productSet : anchor.closest('.product-detail').find('#product-content');
		var targetdetail =(productSet.length > 0 && productSet.children.length > 0) ? productSet : anchor.closest('.product-short-description').find('#short-description');
		var newHref = this.href;

		var selectedColor = container.find('.Color .selected-value').first();
		if(selectedColor.length){
			var colorName = selectedColor.attr('data-name').toString();
			var colorValue = selectedColor.attr('data-value').toString();
			if(colorName && colorValue && !params[colorName] && newHref.indexOf(colorName) == -1){
				// force the auto-selected color into the ajax call
				params[colorName] = colorValue;
			}
		}
		//Add dropship monogram text if set.
		if($('input[name="mt"]').length > 0){
			if($('input[name="mt"]').val().length >= 1){
				params['mt'] = $('input[name="mt"]').val();
				params['mc'] = $('input[name="mc"]').val();
			}
		}

		var url = app.util.appendParamsToUrl(newHref, params);

		if($('#product-set-list').length > 0){
			params['productset'] = true;
			url = app.util.appendParamsToUrl(url, params);
		}

		app.ajax.load({
			url: decodeURIComponent(url),
			callback : function (data) {
				var resetSize = false;

				var pdpMain = $cache.pdpMain;

				target.html(data);

				if (resetSize){
					target.find('select.size-select').val('');
				}

				var res = $(data);

				// update price for mobile

				try {
					// empty the mobile price container
					$('.price-mobile').empty();

					// append product price
					res.find('span.product-price').appendTo('.price-mobile');
					res.find('div.debutDates').appendTo('.price-mobile');
					// pdp promotion tooltips
					$('.pt_product-details a.tooltip').each(function() {
						// The contents of the h2 element will be the title of the hopup
						var text = $(this)
									.parent()
									.find('h2')
					    			.text();
						// the tooltip-content element contains the dialog body
						var dlg = $(this).find('.tooltip-content').dialog({
							dialogClass: 'tooltip-pdp-promo',
							autoOpen: false,
							modal: true,
							title: text,
							 open: function() {
								$('.ui-widget-overlay').bind('click', function() {
									$('.tooltip-pdp-promo').dialog('close');
								});
							}
						});
						// show the hopup when the link is clicked
						$(this).on('click', function(e) {
							e.preventDefault();
							dlg.dialog("open");
						});
					});
				} catch(e) {
					// console.log(e.message);
				}

				parent.before(res.find('ul.swatches'));
				parent.remove();
				var desc = $('#small-description');
				var detailDesc = $('#small-details');
				if(desc != null){
					desc.empty();
					res.find('.description-heading, .short-left, .short-right').appendTo(desc);
				}
				if(detailDesc != null){
					detailDesc.empty();
					res.find('#detail-longDesc').appendTo(detailDesc);
				}

				var newId = res.find('input[name=pid]').val();
				inputId.val(newId);
				// Copy variation attributes other than the current one from the
				// returned HTML into the current page replacing the corresponding
				// element. This ensures that the update references for those
				// variations reflect the change to this variation (e.g. changing
				// the size doesn't revert the color)
				var attributes = res.find('li.attribute').toArray();
				var current = container.find('li.attribute').toArray();
				var skip = current.indexOf(attributeContainer[0]);
				for (var i = 0; i < current.length; i++) {
				if (i == skip) continue;
					var cur = $(current[i]);
					cur.before(attributes[i]);
					cur.remove();
				}

				/* Run replaceImages and replaceContent in parallel via a
					nifty trick w/ setTimeout */
				if (isColor) {
					if(Resources.CLOUD_ZOOM_ENABLED){
						replaceCloudZoomImages(pdpMain);
						replaceContent();
						fullScreenImage();
					}
					else{
						// note scene7 functionality does not actually use this
						setTimeout(function(){replaceImages(pdpMain);}, 1);
						setTimeout(replaceContent, 1);
					}
				}

				/* FIXME: This is a long-running method that was blocking
					image replacement. Find out why and make it better. */
				setTimeout(initializeEvents, 1);

				app.product.initAddThis();
				app.product.initAddToCart();

				bazzarvoiceClearHopup();

				var productSetItem = container.closest('.product-set-item');

				if (productSetItem.length > 0) {

					if(window.innerWidth < 480){
						var productThumbnails = productSetItem.find('.product-set-image img');
						var newThumbnail = productSetItem.find('.swatches.Color .selected').attr('data-pimage');
						productThumbnails.attr('src', newThumbnail);
						productSetItem.find(".select-quantity").trigger("change");
					}else{
						var productThumbnails = res.find('.product-thumbnails img');
						if (productThumbnails.length > 0) {
							var newThumbnail = productThumbnails.eq(0).attr('src').replace('/C_','/N_').replace('productThumb', 'product2x2');
							productSetItem.find('.product-thumbnail').attr('src', newThumbnail);
						}
					}

					var oldQuantitySelect = productSetItem.find('.select-quantity');
					oldQuantitySelect.before(res.find('select.select-quantity'));
					oldQuantitySelect.remove();

					var oldAvailability = productSetItem.find('.availability-messaging');
					oldAvailability.before(res.find('.availability-messaging'));
					oldAvailability.remove();

					var oldPid = productSetItem.find('input[name=pid]');
					oldPid.before(res.find('input[name=pid]'));
					oldPid.remove();

					if (container.find('select.size-select').val()) {
						productSetItem.removeAttr('invalid')
								.find('button.add-to-cart')
								.removeAttr('disabled');

						if (container.closest('.product-set').find('.product-set-item[invalid]').length == 0) {
							$('#add-all-to-cart').removeAttr('disabled');
						}
					}
				}


				app.tooltips.init();

				// for the e-gift card on PDP
				if($cache.pdpForm.find('.gift-card-info').length){
					app.validator.initForm('form.pdpForm');
					app.util.limitCharacters();
				}

				if (typeof FB != 'undefined' && 'XFBML' in FB && 'parse' in FB.XFBML) {
					$('fb\\:like').attr('href',newHref);
					FB.XFBML.parse();
				}
				// reload the bazaar voice ratings pane
				if ($('#BVCustomerRatings').length > 0 && typeof $BV != "undefined" && "ui" in $BV) {
					$BV.ui("rr", "show_reviews", configData);
				}

				// reload ShopRunner content
				if (typeof(sr_updateMessages) == 'function') {
					sr_updateMessages();
				}


				//True Fit
				if (typeof tfc !== 'undefined'){
					tfc.calculate();
				}

			}

		}); // end of ajax load

	}); // end of pdp swatch click handler


	//locatorInit();

	CloudZoom.quickStart();

	//monogramming events
	$cache.monogramstyletiles.click(monogramStyleTileClick);
	$cache.monogramdotsoptions.click(dotsOptionClick);
	$cache.monogramcolors.click(monogramColorClick);
	$cache.monogramtextinputclear.click(textInputClearClick);

}//end initializeEvents

function initializeDom(){
	if($cache.monogramcontainer.length > 0){
		$cache.monogramcontainer.data('imageOptions',{});
		$cache.monogramcontainer.data('imageOptions')['$dots'] = 0;
		$cache.monogramcontainer.find('.monogram-font-select').empty();
		$cache.monogramcontainer.find('.monogram-text-input-body').empty();
		$cache.monogramcontainer.find('.monogram-symbol-list').empty();
		$cache.fonttilebase.removeClass('monogram-font-base visually-hidden').addClass('monogram-font');
		$cache.symbolbase.removeClass('monogram-symbol-base visually-hidden').addClass('monogram-symbol');

		if(window.innerWidth <= 480){
			$('.product-add-to-cart').appendTo('.product-col-1');
		}else{
			$('.product-add-to-cart').appendTo('#product-content');
			$('.product-actions').appendTo('#product-content');
		}
	}

}
var _ = require('lodash'),
    inventory = require('./');

var newLine = '\n';
var pdpStoreTemplate = function (store) {
    return [
        '<li class="store-list-item ' + (store.storeId === User.storeId ? ' selected' : '') + '">',
        '    <div class="store-address">' + store.address1 + ', ' + store.city + ' ' + store.stateCode +
        ' ' + store.postalCode + '</div>',
        '    <div class="store-status" data-status="' + store.statusclass + '">' + store.status + '</div>',
        '</li>'
    ].join(newLine);
};
var pdpStoresListingTemplate = function (stores) {
    if (stores && stores.length) {
        return [
            '<div class="store-list-pdp-container">',
            (stores.length > 1 ? '    <a class="stores-toggle collapsed" href="#">' + Resources.SEE_MORE + '</a>' : ''),
            '    <ul class="store-list-pdp">',
            _.map(stores, pdpStoreTemplate).join(newLine),
            '    </ul>',
            '</div>'
        ].join(newLine);
    }
};

var storesListing = function (stores) {
    // list all stores on PDP page
    if ($('.selected-store-info').length) {
        $('.pdp_locator_button').css('height', '');
        $('.selected-store-info').remove();
    }

    for (var i = 0; i < stores.length; i++) {
        if (stores[i].storeId === User.storeId) {
            $('#storepickup').val('true');
            $('#storeid').val(User.storeId);
            $('.pdp_locator_button').css('height', '60px');
            $('.pdp_locator_button').append( ['<div class="selected-store-info">' +
                                              '    <span class="selected-store-msg">' + Resources.STORE_PICKUP_SELECTEDSHOP + '</span>' +
                                              '    <span class="selected-store-address">' + stores[i].name + '</span>' +
                                              '    <span class="change-store-msg">' + Resources.STORE_PICKUP_CHANGE + '</span>' +
                                              '</div>'
                                             ].join(newLine));
        }
    }

};

var productInventory = {
    setPreferredStore: function (storeId) {
    	var self = this;
    	var isCartPage = document.querySelector('.pt_cart');
        User.storeId = storeId;

        if (isCartPage) {
            var itemRow = document.querySelector('.cart-row[data-pid="'+self.pid+'"]');

            $.ajax({
                url: Urls.setStorePickup,
                type: 'GET',
                data: {plid: itemRow.dataset.uuid, storeid: storeId, storepickup: 'true'}
            });
		}


        $.ajax({
            url: Urls.setPreferredStore,
            type: 'POST',
            data: {storeId: storeId}
        });
    },
    productSelectStore: function () {
        var self = this;
        var pid = this.pid;
        inventory.getStoresInventory(this.pid).then(function (stores) {

            inventory.selectStoreDialog({
                pid: pid,
                pickupContent: User.pickupContent,
                stores: stores,
                selectedStoreId: User.storeId,
                selectedStoreText: Resources.PREFERRED_STORE,
                continueCallback: storesListing,
                selectStoreCallback: self.setPreferredStore
            });
        }).done();
    },
    init: function () {
        User.storeId = '';
        User.zip = '';
        User.pickupContent = '';
        var self = this;
        this.productinfo = '';
        this.pid = $('input[name="pid"]').val();

        var productColor = $('.swatches.Color .selected .title').length ? $('.swatches.Color .selected .title')[0].innerText : '';
        var productPrice = $('.price-sales').length ? $('.price-sales')[0].innerText : '';
        var productQty = $('select[name="Quantity"]').length ? $('select[name="Quantity"]')[0].value : '';

        $.ajax({
            dataType: 'html',
            url: util.appendParamsToUrl(Urls.getProductInfo, {
                pid: this.pid,
                productColor: productColor,
                productPrice: productPrice,
                productQty: productQty
            }),
            success: function (response) {
                //$('.store-product-info').append(response);
                User.pickupContent = response;
            }
        });

        setTimeout(function (){
            $('.pdp_locator_button').on('click', function (e) {
                e.preventDefault();
                // Show error if it exists
                if ($cache.pdpMain.find(".pdp_locator_error").length > 0) {
                    $cache.pdpMain.find(".pdp_locator_error").show();
                    return;
                }
                self.productSelectStore();
            });
        }, 1);

    }
};
var mainImage = {
	init : function(){
		var isQuickView = (function() {
			var $qvcontainer = $('#quick-view-dialog');
			return ($qvcontainer.length>0);
		})();
		if (!isQuickView) {
			var handleImgLoad = function(e, $img) {
				if (!$img) $img = $(this);
				$img.css('margin-top', ($img.height() / 2) * -1 + 'px');
				$img.show();
			};
			setTimeout(function (){
				// check for no image
				$cache.pdpMain.find('.product-primary-image').each(function(){
					var $div = $(this);
					mainImage.noImageHandler($div.find('img').not('.fullscreen-zoom-icon'), function(img){
						var $img = $(img);
						var $div = $(img).closest('.product-primary-image');
						$img.remove();
						if($div.children().length == 0){
							$div.addClass('no-image');
						}
					});
					if($div.children().length == 0){
						$div.addClass('no-image');
					}
				});
			}, 3000);
		}
		else{
			// in quick view
			$cache.pdpMain.find('.product-primary-image img').not('.fullscree-zoom-icon').each(function(){
				mainImage.noImageHandler(this);
			});

		};
	},
	noImageHandler : function(img, errorHandler) {
		var $img = $(img);
		$img.on('error', function(){
			if(errorHandler){
				errorHandler(this);
			}
			else{
				mainImage.noImage(this);
			}
		});
		// reload image in case we missed the error event
		var src = $img.attr('src');
		//$img.attr('src', ''); // this line crashes iOS 6.0
		if(Resources && Resources.BLANK_IMAGE_URL){
			$img.attr('src', Resources.BLANK_IMAGE_URL);
		}
		$img.attr('src', src);
	},
	noImage : function(img) {
		if(Resources && Resources.NO_IMAGE_URL){
			var $img = $(img);
			$img.attr('data-failed-src', $img.attr('src'));
			$img.attr('src', Resources.NO_IMAGE_URL);
		}
	}

}

function doUpdateImages(){

	if(validateImageOptions()){

		app.monogram.init();

		var qs = getQueryString();

		var baseImage;// = "http://katespade.scene7.com/is/image/KateSpadeRender?src=ir{KateSpadeRender/{0}?obj=FLOW/MNGRM&decal&src=is{KateSpade/mono_ksny?{1}}&sharp=1&res=150&resMode=sharp2}&$productThumbnail$";

		switch($cache.selectedStyleConfig.personalizationType){
			case "Monogramming":
				baseImage = Resources.MONOGRAMMING_MONOGRAM_BASE_URL;
				break;
			case "Engraving":
				baseImage = Resources.MONOGRAMMING_ENGRAVING_BASE_URL;
				break;
			default:
				baseImage = Resources.MONOGRAMMING_MONOGRAM_BASE_URL;
				break;
		}


		$('.product-thumbnails .thumb').each(function(index){
			var $this = $(this);
			var $link = $this.find('a');
			var $img = $link.find('img');


			var baseImageUrl = $link.attr('thumbnail-data'),
				urlBase = baseImageUrl.split('?')[0];

			// If image is a monogram image, return rendered monogram URL
			if (urlBase.indexOf("_R") == urlBase.length-2) {
				var splitBase = urlBase.split('/');

				//get the image code {sku}_{style}
				var assetName = splitBase[splitBase.length - 1];

				assetName = assetName.replace(/_R$/, '');


				var newThumbnail = baseImage.format(assetName,qs);

				var zoomImg = newThumbnail.replace("$productThumbnail$", "$fullsize$");

				$link.attr('href',zoomImg);

				$img.attr('src',newThumbnail);

				//monogram-display_monogram-preview-image
				if(index === 0){
					var cartImage = newThumbnail.replace("$productThumbnail$","$shoppingCart$")
					$cache.monogramformfields.find("input[name='monogram-display_monogram-thumb-image']").val(cartImage)
				}
			}



		});


		// get the instance of CloudZoom
		var cz = $("img.primary-image.cloudzoom").data("CloudZoom");

		// Get selected image src
		var $selectedThumb = $cache.productThumbnailTiles.filter('.selected');
		var src = $selectedThumb.find('img').attr('src');

		// Load a new small image and zoom image into it:
		var smallImg = src.replace("$productThumbnail$", "$large$");
		var zoomImg = smallImg.replace("$large$", "$fullsize$");

		//replace the thumbnail in slider with large image Bug: RR-717
		$selectedThumb.find('img').attr('src', smallImg)

		// Load new images into CloudZoom instance
		cz.loadImage(smallImg, zoomImg);



		switch($cache.selectedStyleConfig.personalizationType){
			case "Monogramming":
				baseImage = Resources.MONOGRAMMING_PREVIEW_BASE_URL;
				break;
			case "Engraving":
				baseImage = Resources.ENGRAVING_PREVIEW_BASE_URL;
				break;
			default:
				baseImage = Resources.MONOGRAMMING_PREVIEW_BASE_URL;
				break;
		}
		var previewURL = baseImage.format(qs);
		$cache.monogramformfields.find("input[name='monogram-display_monogram-preview-image']").val(previewURL);
	}
}


function storeLocate() {
	var locateZip = $(".pdp_locator_input");
	if (locateZip.length > 0 && locateZip.valid()) {
		var results = $(".pdp_locator_results");
		var radiusDropdown = $(".pdp_locator_radius");
		var notFoundError = $(".pdp_locator_notfound");

		// Show loading gif and hide errors
		results.empty().addClass("loading");
		notFoundError.hide();

		var data = {
			"max_radius" : radiusDropdown.val(),
			"zip" : $(".pdp_locator_input").val(),
			"variation_id" : $("#pid").val()
		};

		// Load locate results
		results.load(Urls.LocateStores, data, function () {
			// Remove loading gif
			results.removeClass("loading");
			// If locator radius was automatically increased due to lack of results, change dropdown to new radius
			var preview = results.find(".pdp_locator_preview");
			if (preview.hasClass("radiusIncreased") || preview.length == 0) {
				var newRadiusSelection = preview.data("radius");
				if (!newRadiusSelection) {
					newRadiusSelection = radiusDropdown.find("option").length - 1;
				}
				else {
					newRadiusSelection = radiusDropdown.find("option[value="+newRadiusSelection+"]").index();
				}
				radiusDropdown.data("suppress", true).prop("selectedIndex", newRadiusSelection).trigger("change");
			}
			// Show not found error if there are no results
			if (results.find(".pdp_locator_preview").length == 0) {
				notFoundError.show();
			}
		});
	}
}

//Use data from swatch href to display image
function fullScreenImage(){
	var swatches = $('.swatches li.selected a');
	var selectedVariation = $('.swatches li.selected a').attr('href');

	if(swatches.length >= 1 && selectedVariation){
		var fullScreenZoomLink = $('#fullscreen-zoom-hopup');
		var selectedVariation = selectedVariation.replace("Product-Variation", "Product-GetFullScreenImage");
		fullScreenZoomLink.attr('href', selectedVariation);
	}
}

$(function() {
	var mobileIcon = $('#mobile-zoom-icon');
	var pdpMain = $('#pdpMain');

		if(pdpMain.length >= 1){
			fullScreenImage();

			var isGiftCard = $('#isGiftCard').length;
			if(isGiftCard){
				$('#fullscreen-zoom-hopup').addClass('visually-hidden');
			}

			$('body').on('click','#fullscreen-zoom-hopup',function(e){
				e.preventDefault();

				// Create Dialog
				var dlg = app.dialog.create({options : {
					width: 895,
					dialogClass: "fullScreen"
				}});

				var params = {};


				//Potentially add monogramming option parameters
				var $monogrammingContainer = pdpMain.find('.monogram-container');

				if($monogrammingContainer.length){

					var imgOptions = $monogrammingContainer.data('imageOptions');
					if($monogrammingContainer.find('ul.monogram-styles li.monogram-style-tile.selected').length != 0){
						var	personalizationType = $monogrammingContainer.find('ul.monogram-styles li.monogram-style-tile.selected').attr('data-style-config').personalizationType;
					}
					var valid = (imgOptions['$ftype'] != null &&
						imgOptions['$fstyle'] !=  null &&
						imgOptions['$dots'] != null &&
						(imgOptions['$chr1'] != null || imgOptions['$chr2'] != null || imgOptions['$chr3'] != null));

					if($monogrammingContainer.find('li.monogram-color-swatch').length){
						valid = valid && imgOptions['$color'] != null;
					}

					if(valid){

						var keys = Object.keys(imgOptions),
							newImgOptions = {};

						//add the prefix to make it easy on the serverside to grab all of the right parameters
						for(var i = 0; i < keys.length;i++){
							var key = "imgOption_"+keys[i];

							newImgOptions[key] = imgOptions[keys[i]];
						}

						newImgOptions["personalizationType"] = personalizationType;

						params = newImgOptions;
					}
				}


				var url = app.util.appendParamsToUrl($(this).attr("href"),params);
				//if URL is built on monogram page, it is incomplete and cannot be rendered
				if(url.indexOf('size') < 0){
					return false;
				}
				$.ajax({
					url:url,
					target:dlg,
					callback: function () {

						dlg.dialog("open");

						var dialogContainer = $('#dialog-container');
						var productImage = dialogContainer.find($('.product-primary-image img'));
						var downloadLink = $('#fullscreen-download a');
						dialogContainer.find($('.ui-dialog-titlebar-close').addClass('fullscreen-zoom-close'));

						var replaceStr = "$s7fullsize$";
						if($monogrammingContainer.length){
							replaceStr = "$productThumbnail$";
						}

						$(".thumb a").click(function(e) {
							e.preventDefault();
							var imageSrc = $(this).attr('href');

							var fullScreenImg = imageSrc.replace(replaceStr, "$fullscreen$");
							productImage.attr('src', fullScreenImg);

							// Append Scene7 param force download
							fullScreenImg += '&download';
							downloadLink.attr('href', fullScreenImg);
							$(e.target).closest("li").addClass("selected").siblings().removeClass("selected");
						});

						var $list = dialogContainer.find('ul');
						$list.jcarousel({
							auto: 0,
							vertical:true,
							scroll:1
						});
						var next = dialogContainer.find('#next');
						var prev = dialogContainer.find('#prev');
						if ($('.fullScreen').find('#thumbnail-carousel li').length < 5) {
							next.hide();
							prev.hide();
						} else {
							$('#thumbnails .jcarousel-prev').css("cssText", "display: block !important;");
							$('#thumbnails .jcarousel-next').css("cssText", "display: block !important;");
						}

						var $first = $('li:first', $list),
							$last = $('li:last', $list);

						next.click(function (e) {
							var $next, $selected = dialogContainer.find((".selected"));
						    $next = $selected.next('li').length ? $selected.next('li') : $first;
						    $selected.removeClass("selected");
						    $next.addClass('selected');

						    var url = $next.find('a').attr("href");

						    if($monogrammingContainer.length){
						    	url = url.replace(replaceStr,"$fullscreen$");
							}

							productImage.attr('src', url);
							downloadLink.attr('href', url);

							if ($last.hasClass('selected')) {
								$(".jcarousel-next").trigger( "click" );
							}
						});

						prev.click(function () {
							var $prev, $selected = dialogContainer.find((".selected"));
						    $prev = $selected.prev('li').length ? $selected.prev('li') : $last;
						    $selected.removeClass("selected");
						    $prev.addClass('selected');

						    var url = $prev.find('a').attr("href");

						    if($monogrammingContainer.length){
						    	url = url.replace(replaceStr,"$fullscreen$");
							}

							productImage.attr('src', url);
							downloadLink.attr('href', url);

							if ($first.hasClass('selected')) {
								$(".jcarousel-prev").trigger( "click" );
							}
						});

						var pdpMainCarousel = $('#pdpMain #thumbnail-carousel .selected');
						if (pdpMainCarousel.length) {
							var selectedIndex = pdpMainCarousel.index();
							var correspondingFSZoomImage = $list.find('li').eq(selectedIndex).find('a');
							if (correspondingFSZoomImage.length) {
								correspondingFSZoomImage.click();
							}
						}
					}
				});
			});

			if ($("html").is('.touch')) {
				mobileIcon.show();
				var overlayTimeOut = Resources.ZOOM_OVERLAY_TIMEOUT;
				setTimeout(function(){
					mobileIcon.fadeOut("1000");
				}, overlayTimeOut);
			}

			$cache.pdpMain.on('click', '#mobile-fullscreen', function(e) {
				e.preventDefault();
				var imgURL = $('.thumb.slick-current a').attr('href');
				var modalcontainer = $('#mobile-fullscreen-modal');
				var img =  $('<img/>');
				img[0].src = imgURL;

				modalcontainer.empty();
				modalcontainer.append(img)

				var dlg = $('#mobile-fullscreen-modal').dialog({
					width: $('#main').width(),
					minHeight: 750,
					position: { my: "left top", at: "top", of: window },
					dialogClass: 'mobile-fullscreen-modal'
				});

				dlg.dialog('open');

				var czInstance = new CloudZoom(modalcontainer.find('img').eq(0), {
					autoInside: 740,
					zoomSizeMode: 'lens'
				});

				dlg.off().on( "dialogclose", function( event, ui ) {
					dlg.dialog('destroy');
					czInstance.destroy();
				});

			});
			$('#main').on('click', '.thumb.slick-slide.slick-current', function() {
				var width = $('#main').width();
				if (width <= 480) {
					$('#mobile-fullscreen').click();
				}
			})
		}

});

$cache.pdpMain.find('.product-primary-image img').on('mousemove', function(e){
	if (!$("html").is('.touch')) {
		var pdpMain = $('#pdpMain');
		if(pdpMain.length){
			$('#zoom-tip').show().css({'left': e.pageX + 20, 'top': e.pageY - 20 - pdpMain.offset().top});
		}
	}
}).on('mouseleave', function(){
	$('#zoom-tip').hide();
}).on('click', function(e){
	var $self = $(this).css('cursor', 'wait');
	var $zoomedCtr = $('#zoomed-image');
	var imgSrc = $self.data('big');
	var img = new Image();
	img.onload=function(){
		//$self.removeAttr('style');
		$self.css('cursor','');
		$zoomedCtr.fadeIn(200);
		if ($("html").is('.touch')) {
			centerZoom();
		} else {
			zoomInteraction(e);
		}
	};
	img.src=imgSrc;
	$zoomedCtr.find('img').attr('src', imgSrc);
});

//   zoom interaction
function zoomInteraction(event){
	var $container = $('#zoomed-image');
	var $image = $container.find('img');
	var container_wid = $container.width();
	var container_hei = $container.height();
	var image_wid = $image.width();
	var image_hei = $image.height();
	var offset = $container.offset();
	var maskWidth  = $("#zoomed-image").width();
	var maskHeight = $("#zoomed-image").height();
	var x1,y1,x2,y2;


	if(container_wid < image_wid) {
		var wid_diff = image_wid - container_wid;
		var new_left = -(wid_diff/2);

		$image.css({
			left: new_left
		});
		x1 = 2*new_left;
		x2 = 0;

	} else {
		var new_left = (container_wid - image_wid)/2;

		$image.css({
			left: new_left
		});

		x1 = 0;
		x2 = 2*new_left;
	}

	if(container_hei < image_hei) {
		var hei_diff = (image_hei - container_hei)/container_hei;
		var new_top = 0 - ((event.pageY - offset.top) * hei_diff) ;

		$image.css({
			top: new_top
		});
		// 108 is the height of the header
		y1 = -( image_hei/2 + 108);
		y2 = 108;
	}

	$('#zoomed-image img').draggable({ containment: [x1,y1,x2,y2], scroll: false});
}

function centerZoom() {
	var $container = $('#zoomed-image'),
		$image = $container.find('img'),
		container_wid = $container.height(),
		container_hei = $container.width(),
		image_wid = $image.width(),
		image_hei = $image.height();

	if(container_wid < image_wid) {
		var wid_diff = (image_wid - container_wid)/container_wid;
		var new_left = 0 - (1 * wid_diff) - (container_wid/2);
		$image.css({
			left: new_left
		});
	} else {
		$image.css({
			left: 0 - (image_wid/2)
		});
	}

	$image.css({
		'top': '0px'
	});
}

function replaceContent() {
	var $updateContentCtr = $cache.pdpMain.find("#updateTabs"),
		$oldTabs = $updateContentCtr.find('.tab-content'),
		isQuickView = (function() {
			var $qvcontainer = $('#quick-view-dialog');
			return ($qvcontainer.length>0);
		})();

	if($updateContentCtr.length > 0) {
		$.each($oldTabs, function(index, oldTab) {
			var $oldTab = $(oldTab),
			$oldTabId = $oldTab.attr('id'),
			$newTab = '',
			newContent = '';

			if($oldTabId){
				$newTab = $updateContentCtr.find('[data-rel='+ $oldTabId +']');
				newContent = $newTab.html();
			}

			if ($newTab != '' && $newTab.length > 0) {
				$oldTab.empty().html(newContent);
			}
		});
		$updateContentCtr.remove();

		var vertical = true

		$('#thumbnail-carousel').jcarousel({
			auto: 0,
			vertical:vertical,
			scroll:1
		});
		$(function() {
			var pdpMain = $('#pdpMain');
			var iscNext = pdpMain.find($('.jcarousel-next')).is(':hidden');
			var iscPrev = pdpMain.find($('.jcarousel-prev')).is(':hidden');
			var carouselClip = pdpMain.find('.jcarousel-clip');

			if(iscNext && iscPrev){
				carouselClip.css({'margin-top': '0'});
			}
		});
		if ($('#pdpMain').find('#thumbnails li').length <= 4) {
			$('#thumbnails .jcarousel-prev').hide();
			$('#thumbnails .jcarousel-next').hide();

		}
	}
}

function replaceCloudZoomImages(pdpMain) {
	var newImages = $("#update-images");
	var imageContainer = pdpMain.find(".product-col-1:first");

	imageContainer.html(newImages.html());
	newImages.remove();
	app.product.initMobilePDPCarousel();

	var isQuickView = (function() {
		var $qvcontainer = $('#quick-view-dialog');
		return ($qvcontainer.length>0);
	})();

	if (!isQuickView){
		// Re hook
		CloudZoom.quickStart();
	}
	else{
		app.quickView.initQuickViewCarousel();
	}
}

function replaceImages(pdpMain) {
	var $updateImagesCtr = pdpMain.find("#update-images"),
		$mainImageCtr = pdpMain.find(".product-image-container:first"),
		thumbnails = pdpMain.find('.product-thumbnails:first'),
		newThumbnails = $updateImagesCtr.find('.product-thumbnails'),
		newMainImages = $updateImagesCtr.find('.product-image-container'),
		currentPos = Number($mainImageCtr.find('li.current').attr('jcarouselindex'))-1 || 0,
		isQuickView = (function() {
			var $qvcontainer = $('#quick-view-dialog');
			return ($qvcontainer.length>0);
		})();


	$mainImageCtr.replaceWith(newMainImages);
	$updateImagesCtr.remove();

}

//Use for AJAX Requests - Checks and closes any BazzarVoice Hopup Dom Elements
function bazzarvoiceClearHopup(){
	try{
		var bvReadCloseBtn = $('#ui-dialog-title-RevContainer').next('.ui-dialog-titlebar-close');
		var bvSubmitCloseBtn = $('#ui-dialog-title-BVSubmissionContainer').next('.ui-dialog-titlebar-close');

		if(bvReadCloseBtn.is(':visible'))
			bvReadCloseBtn.trigger('click');

		if(bvSubmitCloseBtn.is(':visible'))
			bvSubmitCloseBtn.trigger('click');
	} catch(e) {
		//error
	}
}

/*Functions for Monogramming*/
function validateFormFields(){
	var valid = true;
	if ($('.monogram-container').length === 0) {
		return valid;
	}

	if(($cache.selectedStyleConfig.minChar == $cache.selectedStyleConfig.maxChar) && $cache.selectedStyleConfig.maxChar <= 3){
		for(var i = 1; i <= $cache.selectedStyleConfig.maxChar; i++){
			var $ele = $cache.monogramformfields.find('input[name="monogram_CHAR' + i + '"]');

			if(!$ele.val()){
				valid = false;
				setErrorMessage($ele);

				break;
			}
		}

	}else{
		// if we have a "word" type, make sure we have at least 1 character
		if($cache.selectedStyleConfig.maxChar > 3){
			var $ele = $cache.monogramformfields.find('input[name="monogram_CHAR1"]');
			if(!$ele.val()){
				valid = false;
				setErrorMessage($ele);
			}
		// else, we have a range of characters, so check to make sure there
		// is at least 1 field populated
		}else{
			var count = 0;

			for(var i = 1; i <= $cache.selectedStyleConfig.maxChar; i++)
			{
				var $ele = $cache.monogramformfields.find('input[name="monogram_CHAR' + i + '"]');

				if( $ele.val() )
				{
					count++;
				}
			}

			if( count < $cache.selectedStyleConfig.minChar || count > $cache.selectedStyleConfig.maxChar )
			{
				valid = false;
				var $ele = $cache.monogramformfields.find('input[name="monogram_CHAR1"]');
				// show the error message
				setErrorMessage($ele);
			}
			else
			{
				valid = true;
			}
		}
	}
	return valid;
}
function setErrorMessage($ele){
	// set an error class on $ele, we have one with the red border
	// show the error message
	$('.monogram-text-input-wrapper input').addClass('error');
	$('.monogram-text-missing-input-error').show();
}
function clearErrorMessages(){
	$('.monogram-text-input-wrapper input').removeClass('error');
	$('.monogram-text-input-error').hide();
}

function monogramReset() {
    var monoContainer = $('.monogram-container');
    if (monoContainer.length == 0) {
        return;
    } else {
        //remove the characters
        $('.monogram-text-input-field').val('').trigger("keyup").removeClass("error");
        $(".monogram-text-input-error").hide();

        // hide the bottom containers
        $cache.monogramcontainer.find('.monogram-section').addClass('inactive-section');
        $cache.monogramcontainer.find('.monogram-options-body').slideUp();
        $cache.monogramcontainer.find('.monogram-colors-section-body').slideUp();
        $cache.monogramcontainer.find('.monogram-section-title, .monogram-toggle-icon').addClass('inactive');
        $cache.monogramcontainer.find('.monogram-section-title .color-name').addClass('visually-hidden');
        $cache.pdpMain.find('.product-add-to-cart .availability .value').html("");

        // adjust 'choose a style' section
        $cache.monogramstyletiles.removeClass('selected');
        $cache.monogramcontainer.find('.monogram-section').first().removeClass('inactive-section');
        $cache.monogramcontainer.find('.monogram-section-title').first().removeClass('inactive');
        $cache.monogramcontainer.find('.monogram-toggle-icon').first().removeClass('inactive');

        // disable the a2c button
        $('button#add-to-cart').attr("disabled", "disabled");

        // unbind click events for slide Up/Down
        $cache.monogramcontainer.find('.monogram-section-toggle span').off('click');
    }
}

function monogramStyleTileClick(e){
	var $this = $cache.monogramstyles.find(e.target).closest('li.monogram-style-tile');

	if($this.hasClass('selected')){
		return;
	}

	// do changes for the tiles and style selection
	$cache.monogramstyletiles.removeClass('selected');
	$this.addClass('selected');



	var styleConfig = $this.data('style-config');
	$cache.selectedStyleConfig = styleConfig;

	/**
	 * setup fonts
	 */
	$cache.monogramfontselect.empty();
	var fontConfig;
	for (var i = 0; i < styleConfig.availableFonts.length; i++){
		fontConfig = styleConfig.availableFonts[i];
		createFontTile(fontConfig,i);
	}

	/**
	 * setup characters
	 */
	// setup title
	var charactersTitle;
	if(styleConfig.minChar != styleConfig.maxChar){
		charactersTitle = "type in " + styleConfig.minChar + " - " + styleConfig.maxChar + " characters"
	}else{

		charactersTitle = "type in " + styleConfig.maxChar + " character";

		if(styleConfig.maxChar !== 1){
			charactersTitle += "s";
		}
	}
	$cache.monogramtexttitle.text(charactersTitle);


	// save off existing characters
	// only save if we aren't switching from a word
	if($cache.monogramcontainer.data('inputType') !== 'word'){
		var existingCharacters = {};
		$cache.monogramtextinputbody.find('input').each(function(){
			var $this  = $(this),
				position = $this.data('position');

			if(position){
				var o = {"val":$this.val(),
						"isSymbol":$this.hasClass('font-symbol'),
						"symbolConfig":$this.data('symbol-config')
						};
				existingCharacters[position] = o;
			}
		});
	}


	$cache.monogramtextinputbody.empty();

	/**
	 * setup input fields
	 */
	if(styleConfig.maxChar <=3){
		$cache.monogramcontainer.data('inputType','char');

		var $textInput;
		var $hiddenCharInputs = $cache.monogramformfields.find("input[name^='monogram_CHAR']");

		for(var i = 1; i <= 3;i++ ){
			if(i <= styleConfig.maxChar){
				// create input
				$textInput = createTextInput(styleConfig,i);
			}
			$cache.monogramcontainer.data('imageOptions')['$chr'+i] = "";
		}
		$cache.monogramtextinputclear.parent().removeClass('word');

		// if values are present for CHAR inputs that exceed the maxChar
		// count, set those values to empty;
		$.each($hiddenCharInputs, function (i,el) {
			if (i >= styleConfig.maxChar) {
				$(el).val('');
			}
		});

	// build big text field
	}else{

		$cache.monogramcontainer.data('inputType','word');

		createWordInput(styleConfig);
		$cache.monogramtextinputclear.parent().addClass('word');
	}
	// show/hide the 'first/last/middle' text
	$cache.monogramtextinputcontainer.find('.traditional-caption').toggle($cache.selectedStyleConfig.traditional);
	$cache.monogramtextinputcontainer.toggleClass('traditional',$cache.selectedStyleConfig.traditional);

	// clear out existing field data
	$cache.monogramformfields.find('input[name^="CHAR"]').val("");

	// repopulate characters
	// only repopulate if the inputType we're dealing with individual input
	// fields
	// and we're switching from a style that had characters input
	if($cache.monogramcontainer.data('inputType') === 'char' && existingCharacters){
		var $inputs = $cache.monogramtextinputbody.find('input');
		$.each(Object.keys(existingCharacters),function(i,char){

			// does the position match?
			var $input = $inputs.filter(function(){
				return $(this).data('position') === char;
			}).first();

			// if so, set the new value
			if($input.length){
				var existingCharacter = existingCharacters[char],
					char = existingCharacter.val,
					s7Val = char;


				// is this a symbol, and does the style support this symbol?
				if(existingCharacter.isSymbol){

					// loop over all the available configs and see if we can
					// find a match
					var isSymbolAvailable = false;
					for(var i = 0; i < $cache.selectedStyleConfig.availableSymbols.length; i++){
						var config = $cache.selectedStyleConfig.availableSymbols[i];

						if(config.character === existingCharacter.symbolConfig.character){
							isSymbolAvailable = true;
						}
						if(isSymbolAvailable){
							break;
						}
					}

					if(isSymbolAvailable){
						$input.addClass('font-symbol');
						$input.data('symbol-config',existingCharacter.symbolConfig);
						s7Val = existingCharacter.symbolConfig.scene7Code;
					}else{
						char = "";
						s7Val = "";
					}
				}

				$input.val(char);
				$cache.monogramcontainer.data('imageOptions')[$input.data('position')] = s7Val;
			}
		});
	}

	/**
	 * setup symbols
	 */
	var availableSymbols = styleConfig.availableSymbols;
	$cache.monogramsymbollist.empty();
	if(availableSymbols && availableSymbols.length > 0){
		var symbolConfig;
		for(var i = 0; i < availableSymbols.length; i++){
			symbolConfig = availableSymbols[i];
			if(symbolConfig.fontCode){
				createSymbol(symbolConfig,i);
			}
		}

		$cache.monogramsymbolselectioncontainer.show();
	}else{

		$cache.monogramsymbolselectioncontainer.hide();

		// TODO-MONO: empty out any selected symbols

	}


	/**
	 * setup dots
	 */
	if(!styleConfig.dotsAllowed){
		// set dots hidden input value for form submission
		$cache.monogramformfields.find("input[name=monogram_DOTS]").val('N');

		// set image values
		$cache.monogramcontainer.data('imageOptions')['$dots'] = 0;

		// hide dots section
		$cache.monogramdotscontainer.slideUp();

	}else{
		$cache.monogramdotscontainer.find('.dots-title').toggleClass('traditional',$cache.selectedStyleConfig.traditional);
		$cache.monogramingoptionscontainer.find('.monogram-text-input-error').toggleClass('traditional',$cache.selectedStyleConfig.traditional);
	}

	/**
	 * Do initial setup click events
	 */
	$cache.monogramfontselect.find('li.monogram-font').first().click();
	if($cache.monogramcolors.length){
		$cache.monogramcolors.first().click();
	}

	// Set style values for form submission
	$cache.monogramformfields.find("input[name='monogram_TRADITIONAL']").val(styleConfig.traditional ? "Y" : "N");
	$cache.monogramformfields.find("input[name='monogram_SIZE']").val(styleConfig.fontSize);
	$cache.monogramformfields.find("input[name='monogram_ALT_SIZE']").val(styleConfig.fontAltSize);
	$cache.monogramformfields.find("input[name='monogram_STYLE']").val(styleConfig.styleName);
	$cache.monogramformfields.find("input[name='monogram-display_monogram-style-name']").val(styleConfig.styleName);
	$cache.monogramformfields.find("input[name='personalization-type']").val(styleConfig.personalizationType);


	// set image values
	$cache.monogramcontainer.data('imageOptions')['$ftype'] = styleConfig.styleID;
	if($cache.monogramcolors.length){
		$cache.monogramcontainer.data('imageOptions')['$color'] = $cache.monogramcolors.filter('li.selected').data('color-config').s7Code;
	}

	// show the bottom containers
	$cache.monogramcontainer.find('.monogram-section').removeClass('inactive-section');
	$cache.monogramcontainer.find('.monogram-options-body').slideDown();
	$cache.monogramcontainer.find('.monogram-colors-section-body').slideDown();
	$cache.monogramcontainer.find('.monogram-section-title, .monogram-toggle-icon').removeClass('inactive');
	$cache.monogramcontainer.find('.monogram-section-title .color-name').removeClass('visually-hidden');
	$cache.pdpMain.find('.product-add-to-cart .availability .value').html("");

	$cache.monogramtextinputcontainer.find('input').first().focus();

	updateImages();
	// enable the a2c button
	var title = $('button#add-to-cart').attr('rel');
	//$('button#add-to-cart').attr('title',title).removeAttr("disabled");
	$('.monogram-text-missing-input-error').hide();

	if(!$cache.monogramcontainer.find('.monogram-section-toggle span').hasClass('enabled')) {
		$cache.monogramcontainer.find('.monogram-section-toggle span').click(monogramSectionToggleClick);
	}
}

function monogramSectionToggleClick(e){
	var $monogramsectioncontainer = $(e.target).closest('div.monogram-section');
	$monogramsectioncontainer.toggleClass('inactive-section');
	$monogramsectioncontainer.find('.monogram-section-body').slideToggle();
	$monogramsectioncontainer.find('.monogram-section-title').toggleClass('inactive');
	$monogramsectioncontainer.find('.monogram-toggle-icon').toggleClass('inactive');
	$monogramsectioncontainer.find('.monogram-toggle-icon').addClass('enabled');
	$monogramsectioncontainer.find('.monogram-section-title .color-name').toggleClass('visually-hidden');
}

function monogramFontClick(e){
	var $this = $(e.target).closest('li.monogram-font');

	if($this.hasClass('selected')){
		return;
	}

	$cache.monogramfontselect.find('li.monogram-font').removeClass('selected');
	$this.addClass('selected');
	var fontData = $this.data('font-config');
	var $inputs = $cache.monogramtextinputbody.find('input').not('.font-symbol');
	$inputs.css('font-family',fontData.fontStyle);

	$inputs.toggleClass('monogram-text-input-field-bold',fontData.bold);

	$inputs.toggleClass('monogram-text-input-field-italic',fontData.italic);

	// set font field values for form submission
	$cache.monogramformfields.find("input[name='monogram_FONT']").val(fontData.radialFont);
	$cache.monogramformfields.find("input[name='monogram_BOLD']").val(fontData.bold ? "Y" : "N");
	$cache.monogramformfields.find("input[name='monogram_ITALIC']").val(fontData.italic ? "Y" : "N");

	// set image vars
	$cache.monogramcontainer.data('imageOptions')['$fstyle'] = fontData.fontName.toLowerCase();

	updateImages();
}

function monogramColorClick(e){
	var $this = $(e.target).closest('li.monogram-color-swatch');

	if($this.hasClass('selected')){
		return;
	}

	$cache.monogramcolors.removeClass('selected');
	$this.addClass('selected');

	var colorConfig = $this.data('color-config')

	$cache.monogramcontainer.data('imageOptions')['$color'] = colorConfig.s7Code;

	$cache.monogramformfields.find("input[name='monogram_COLOR']").val(colorConfig.radialCode);
	$cache.monogramformfields.find("input[name='monogram-display_monogram-color-name']").val(colorConfig.colorName);

	$cache.monogramcontainer.find('.monogram-section-title .color-name').text(colorConfig.colorName);

	updateImages();

}

function textInputFocus(e){
	var $this = $(e.target);
	$cache.monogramtextinputbody.find('input').removeClass('focused');
	$this.addClass('focused');
	$cache.focusedinput = $this;

	var disableDoubleWideSymbols = false;

	if($cache.monogramsymbollist.find('li.monogram-symbol.double-wide.selected').length > 0){
		disableDoubleWideSymbols = true;
		if($this.hasClass('font-symbol')){
			var symbolConfig = $this.data('symbol-config');
			if(symbolConfig.width == 2 ){
				disableDoubleWideSymbols = false;
			}
		}
	}

	$cache.monogramsymbollist.find('li.monogram-symbol.double-wide').toggleClass('unselectable-double-wide-symbol', disableDoubleWideSymbols);
}

function textInputBlur(e){
	$(e.target).removeClass('focused');
	$('.monogram-text-missing-input-error').hide();
}

function textInputKeyUp(e){
	var $this = $(e.target),
		val = $this.val(),
		updateCharacter = false,
		valIsValid = false;

	// check if we need to upper or lowercase this
	if(val){
		switch($cache.selectedStyleConfig.monogrammingFontCase){
			case "forceUpper":
				val = val.toUpperCase();
				break;

			case "forceLower":
				val = val.toLowerCase();
				break;
		}
	}


	valIsValid = $cache.selectedStyleConfig.charactersList.indexOf(val) > -1;

	// if the field was a symbol, and we deleted it, we need to remove the
	// symbol data and reapply the old fonts
	// also, updated the selected symbols and the inputted characters
	if( $this.hasClass("font-symbol") && val === ""){

		var symbolConfig = $this.data('symbol-config');
		if(symbolConfig.width == 2){
			$cache.monogramsymbollist.find('li.monogram-symbol.double-wide').toggleClass('unselectable-double-wide-symbol', false);
		}

		setInputBackToNormal($this);

		updateCharacter = true;

	// if the field is NOT a symbol, or it is a symbol and someone
	// highlighted and changed it
	}else if( !$this.hasClass('font-symbol') || $this.hasClass("font-symbol") && valIsValid){

		// if it was a highlight and change? switch input field back to
		// being normal
		if($this.hasClass("font-symbol") && valIsValid){
			setInputBackToNormal($this);
		}

		if($cache.selectedStyleConfig.minChar !== $cache.selectedStyleConfig.maxChar){
			valIsValid = valIsValid || $this.val() === "";
		}

		if(!valIsValid){
			val = "";
		}else if ((e.key && e.key.length == 1) || (app.isMobileUserAgent && valIsValid)){
			$this.closest('div').next().find('input').focus();
		}

		$this.toggleClass('error',!valIsValid);
		$('.monogram-text-invalid-input-error').toggle(!valIsValid);

		updateCharacter = true;
	}

	if(updateCharacter){
		$this.val(val);

		$cache.monogramcontainer.data('imageOptions')[$this.data('position')] = val;

		$cache.monogramformfields.find("input[name='monogram_CHAR" + $this.data('index') + "']").val(val);

		$cache.monogramcontainer.data('imageOptions')['$chars'] = Object.keys($cache.monogramcontainer.data('imageOptions')).filter(function(item){
			return item.indexOf('$chr') === 0;
		}).length;
	}

	updateImages();
    validateMonogramInputValues();
}

function setInputBackToNormal($inputField){
	var $selectedFont = $cache.monogramfontselect.find('li.monogram-font.selected'),
	fontData = $selectedFont.data('font-config');

	$inputField.css('font-family',fontData.fontStyle);
	$inputField.toggleClass('monogram-text-input-field-bold',fontData.bold);
	$inputField.toggleClass('monogram-text-input-field-italic',fontData.italic);

	$inputField.removeClass("font-symbol");

	updateSymbolsSelected();
}

function wordInputKeyUp(e){
	var $this = $(e.target),
		val = $this.val().split(''),
		valid = true;

	for(var i = 0; i < val.length; i++){
		valid = valid && $cache.selectedStyleConfig.charactersList.indexOf(val[i]) > -1;
	}

	if($cache.selectedStyleConfig.minChar !== $cache.selectedStyleConfig.maxChar){
		valid = valid || $this.val() === "";
	}

	if(!valid){
		val = "";
	}

	var maxChars = $cache.selectedStyleConfig.maxChar;

	for(var i = 1;i <= maxChars; i++){
		delete $cache.monogramcontainer.data('imageOptions')['$chr'+i];
		$cache.monogramformfields.find('input[name="monogram_CHAR'+i+'"]').val("");
	}

	var index,
		wordLength = val.length,
		letter;
	for(var i = 1; i <= maxChars; i++){
		index = i-1;
		if(index < wordLength){
			letter = val[index];
		}else{
			letter = "";
		}

		$cache.monogramcontainer.data('imageOptions')['$chr'+i] = letter;
		$cache.monogramformfields.find('input[name="monogram_CHAR'+i+'"]').val(letter);
	}


	$cache.monogramcontainer.data('imageOptions')['$chars'] = wordLength;

	updateImages();

	$this.toggleClass('error',!valid);
	$('.monogram-text-invalid-input-error').toggle(!valid);
    validateMonogramInputValues();
}

function symbolClick(e){

	if($cache.focusedinput == null){ return; }

	$cache.focusedinput.focus();

	var $this = $(e.target).closest('li.monogram-symbol');

	if($this.hasClass('unselectable-double-wide-symbol')){ return; }

	$this.addClass('selected');

	var symbolConfig = $this.data('symbol-config');

	// clear out old font-family and use the symbol font family
	$cache.focusedinput.removeAttr('style');
	$cache.focusedinput.addClass('font-symbol');
	$cache.focusedinput.removeClass('monogram-text-input-field-italic monogram-text-input-field-bold error');

	// add the symbol
	var val = $('<div>').html(symbolConfig.fontCode).text();
	$cache.focusedinput.val(val);
	$cache.focusedinput.data('symbol-config',symbolConfig);

	// clear error messaging
	$('.monogram-text-invalid-input-error').hide();
	$cache.focusedinput.removeClass('error');

	// set the image options for use in re-rendering the images
	$cache.monogramcontainer.data('imageOptions')[$cache.focusedinput.data('position')] = symbolConfig.scene7Code;

	var index = $cache.focusedinput.data('index');

	$cache.monogramformfields.find("input[name='monogram_CHAR" + index + "']").val(symbolConfig.radialCode);

	updateSymbolsSelected();

	if(index !== $cache.selectedStyleConfig.maxChar){
		if(symbolConfig.width == 2){
			$cache.monogramsymbollist.find('li.monogram-symbol.double-wide').toggleClass('unselectable-double-wide-symbol', true);
		}
		$cache.focusedinput.closest('div').next().find('input').focus();
	}


	updateImages();
	validateMonogramInputValues();
}

function updateSymbolsSelected(){
	var $symbols = $cache.monogramsymbollist.find('li.monogram-symbol');

	$symbols.each(function(){
		var currentSymbolConfig = $(this).data('symbol-config'),
			symbolCount = 0;

		$cache.monogramtextinputbody.find('input').each(function(){
			var $field = $(this);

			if($field.hasClass('font-symbol')){
				var fieldSymbolConfig = $field.data('symbol-config');

				if(fieldSymbolConfig.character === currentSymbolConfig.character){
					symbolCount++;
				}
			}
		});

		if(symbolCount === 0){
			$symbols.each(function(){
				var $this = $(this),
					data = $this.data('symbol-config');

				if(currentSymbolConfig.character === data.character){
					$this.removeClass('selected');
				}
			});

		}
	});
}

function dotsOptionClick(e){
	var $this = $(e.target).closest('li.dots-option');

	if($this.hasClass('selected')){
		return;
	}

	$cache.monogramdotsoptions.removeClass('selected');
	$this.addClass('selected');

	// set dots hidden input value for form submission
	$cache.monogramformfields.find("input[name=monogram_DOTS]").val($this.data('value') ? "Y" : "N");

	// set image values
	$cache.monogramcontainer.data('imageOptions')['$dots'] = $this.data('value') ? 1 : 0;

	updateImages();
}

function textInputClearClick(e){
    // disable the a2c button
    var title = $('button#add-to-cart').attr('rel');
    $('button#add-to-cart').attr('title',$('button#add-to-cart').attr('rel')).attr("disabled", "disabled");
	$cache.monogramtextinputbody.find("input").val("");
	$cache.monogramtextinputbody.find('input').removeClass('font-symbol');
	$cache.monogramsymbollist.find('li.monogram-symbol').removeClass('selected unselectable-double-wide-symbol');
	$cache.monogramformfields.find("input[name^='monogram_CHAR").val("");

	var imageOptions = $cache.monogramcontainer.data('imageOptions');
	var keys = Object.keys(imageOptions);
	for(var i = 0; i < keys.length; i++){
		var key = keys[i];
		if(key.indexOf('$chr') === 0){
			imageOptions[key] = "";
		}
	}
	$cache.monogramcontainer.data('imageOptions',imageOptions);
	updateSymbolsSelected();
	updateImages();
	clearErrorMessages();
}

function createFontTile(font,i){
	/**
	 * <li class="monogram-font"> <span class="font-name"></span> </li>
	 */
	var $font = $cache.fonttilebase.clone();
	$font.find('.font-name').text(font.fontName);
	$font.find('.font-name').css("font-family",font.fontStyle);

	if(font.bold){
		$font.find('.font-name').addClass("monogram-font-style-bold");
	}

	if(font.italic){
		$font.find('.font-name').addClass("monogram-font-style-italic");
	}

	$font.data('font-config',font);

	if(i ===0){
		$font.addClass('first-monogram-font');
	}

	$font.click(monogramFontClick);

	$cache.monogramfontselect.append($font);
}

function createTextInput(styleConfig,i){
	var $textInput = $cache.monograminputbase.clone(),
		$input = $textInput.find('input');

	if($cache.monogramfontselect.find('.monogram-font.selected').length === 1){
		$input.css('font-family',$cache.monogramfontselect.find('.monogram-font.selected').data('font-config').fontStyle);
	}

	$input.data('position','$chr'+i);

	$input.data('index',i);

	if(i === 2 && styleConfig.traditional){
		$input.addClass('monogram-text-input-field-traditional-middle')
	}

	if(styleConfig.maxChar === 1){
		$input.addClass('monogram-text-input-field-single');
	}else if(styleConfig.maxChar === 2){
		$input.addClass('monogram-text-input-field-double');
	}

	switch(styleConfig.monogrammingFontCase){
		case "forceUpper":
			$input.addClass("monogram-font-case-upper");
			break;

		case "forceLower":
			$input.addClass("monogram-font-case-lower");
			break;
	}

	$input.focus(textInputFocus);
	$input.blur(textInputBlur);
	$input.keyup(textInputKeyUp);

	$cache.monogramtextinputbody.append($textInput);

	return $textInput;
}

function createWordInput(styleConfig){
	var $textInput = $cache.monograminputbase.clone(),
	$input = $textInput.find('input');

	if($cache.monogramfontselect.find('.monogram-font.selected').length === 1){
		$input.css('font-family',$cache.monogramfontselect.find('.monogram-font.selected').data('font-config').fontStyle);
	}

	$input.attr('maxlength',styleConfig.maxChar);

	$input.addClass('monogram-word-input-field');

	$input.focus(textInputFocus);
	$input.blur(textInputBlur);
	$input.keyup(wordInputKeyUp);

	$cache.monogramtextinputbody.append($textInput);
}

function createSymbol(symbolConfig,i){
	/**
	 * <li class="monogram-symbol"> <div class="monogram-symbol-field
	 * font-symbol"/> </li>
	 */
	var $symbol = $cache.symbolbase.clone();
	// add ADA label attrs
	$symbol.attr('aria-label', symbolConfig.character)
	$symbol.find('div').attr('aria-label', symbolConfig.character)
	$symbol.find('div').html(symbolConfig.fontCode);
	$symbol.data('symbol-config',symbolConfig);

	if(symbolConfig.width === 2){
		$symbol.addClass("double-wide");
	}
	if(symbolConfig.fontSize){
		$symbol.find('div').css('font-size',symbolConfig.fontSize);
	}

	$symbol.click(symbolClick)

	$cache.monogramsymbollist.append($symbol);
}


function updateImages(){
	if($cache.imagesTimeout){
		window.clearTimeout($cache.imagesTimeout);
	}
	$cache.imagesTimeout = window.setTimeout(doUpdateImages,500);
}

function validateMonogramInputValues(){

	var monogramTextInputValid = false;
	//$('.monogram-text-input-body').find('monogram-text-input-field').each(function() {
    var monogramTextInputs = $('.monogram-text-input-field');
    for (var i = 0; i< monogramTextInputs.length; i++) {
        if ($(monogramTextInputs[i]).val().trim() != '') {
        	monogramTextInputValid = true;
            break;
        }
    }

    //if all inputs are filled out, enable Add To Cart button
    if (monogramTextInputValid) {
        var title = $('button#add-to-cart').attr('rel');
        $('button#add-to-cart').attr('title',title).removeAttr("disabled");
    } else {
        // disable the a2c button
        $('button#add-to-cart').attr("disabled", "disabled");
    }
}


function getQueryString(){
	var imgOptions = $cache.monogramcontainer.data('imageOptions'),
		keys = Object.keys(imgOptions),
		qs = [],
		key;

	for(var i = 0; i < keys.length; i++){
		key = keys[i];
		qs.push(key + "=" + imgOptions[key]);
	}

	return qs.join("&");
}

function validateImageOptions(){
	var imgOptions = $cache.monogramcontainer.data('imageOptions');

	var valid = (imgOptions['$ftype'] != null &&
		imgOptions['$fstyle'] !=  null &&
		imgOptions['$dots'] != null &&
		(imgOptions['$chr1'] != null || imgOptions['$chr2'] != null || imgOptions['$chr3'] != null));

	if($cache.monogramcolors.length){
		valid = valid && imgOptions['$color'] != null;
	}

	return valid;
}

function resetMonogrammingPage(){
	textInputClearClick();
	$cache.monogramstyletiles.removeClass('selected');

	// hide the bottom containers
	$cache.monogramcontainer.find('.monogram-options-body').slideUp();
	$cache.monogramcontainer.find('.monogram-colors-section-body').slideUp();
	$cache.monogramcontainer.find('.monogram-section-title, .monogram-toggle-icon').addClass('inactive');
	$cache.monogramcontainer.find('.monogram-section-title .color-name').addClass('visually-hidden');

	// disable the a2c button
	$('button#add-to-cart').attr("disabled","disabled");
	$('.monogram-text-missing-input-error').show();
}

function setAddToCartHandler(e) {
	e.preventDefault();
	if (!validateFormFields()) {
		return;
	}

	var form = $(this).closest('form');
	var qty = form.find("select[name='Quantity']");
	var isSubItem = $(this).hasClass("sub-product-item");
	if(qty.length === 0 || isNaN(qty.val()) || parseInt(qty.val(), 10) === 0) {
		qty.val("1");
	}

	// for gift registry
	var itemid = $(this).data('itemid');
	if(itemid){
		$('input[name=itemid]').val(itemid);
	}
	var qtyelem = $(this).data('qtyelem');
	if(qtyelem){
		qtyelem = $('select[name=' + qtyelem + ']').first();
		if(qtyelem){
			$('input[name=Quantity]').val(qtyelem.val());
		}
	}

	var pdpMain = ($cache ? $cache.pdpMain : null);

	var data = form.serialize();

	app.cart.update(data + '&flyout=true', function (response) {
		resetMonogrammingPage();
		if (response.error == 'out_of_stock') {
			var outofstockmessage = (typeof katespade != 'undefined') ? Resources.PRODUCT_OUT_OF_STOCK_FLYOUT : Resources.KSS_PRODUCT_OUT_OF_STOCK_FLYOUT;
			app.minicart.flyout(response,pdpMain,null,outofstockmessage);
			return;
		}
		// refresh the quantity and check for purchase limit
		if(typeof katespade != 'undefined'){ // for now only enable on
												// kate spade and kate sale
			app.product.updateQuantity({checkPurchaseLimit:true});
		}
		var miniCartV2 = $(".mini-cart-refresh.v2");
		if (miniCartV2.length == 0) {
			app.minicart.flyout(response, pdpMain, form.find("#add-to-cart"));
		}

		// update the minicart, but don't show it
		var url = app.util.ajaxUrl(app.urls.minicart);
		$.post(url, null, function(response) {
			if (miniCartV2.length > 0) {
				app.minicart.show(response);
				// show ADDED! on the add to cart button for 2 seconds
				var a2c = form.find('#add-to-cart');
				if (!a2c.data('text')) {
					a2c.data('text', a2c.text());
				}
				a2c.text(Resources.PRODUCT_ADDED);
				if ($cache.addedTimer) {
					clearTimeout($cache.addedTimer);
				}
				$cache.addedTimer = setTimeout(function(){
					a2c.text(a2c.data('text'));
					a2c.data('text', null);
				}, 2000);
			}
			else {
				app.minicart.update(response);
			}
		});

	});

	if (typeof dataLayer !== "undefined") {
		dataLayer.push(app.datalayer.getEvent("event", "addToCart"));
		// dataLayer.push({ "event" : "addToCart"});
		var transactionProducts = [];
		var dlPid, dlSku, dlProductName, dlCategoryID, dlPrice, dlQuantity;
		if (typeof cmProductName !== "undefined") {
			dlProductName = cmProductName;
			dlCategoryID = cmCategoryID;
		} else {
			var dlProductName = form.attr("data-pname");
			var dlCategoryID = form.attr("data-pcat");
		}

			dlSku = $("#pid").val();
			dlPid = $('#product-content').find('div[data-master]').attr('data-master');
			// dlProductName set previously
			// dlCategoryID set previously
			dlPrice = ($.trim($(".price-sales").html().trim()).replace("$", ""));
			dlQuantity = parseInt(qty.val(), 10);

		transactionProducts.push({ "sku" : dlSku, "pid" : dlPid, "name" : dlProductName, "category" : dlCategoryID, "price" : dlPrice, "quantity" :dlQuantity });

		dataLayer.push(app.datalayer.getEvent("transactionProducts", transactionProducts));
		// dataLayer.push({"transactionProducts" : transactionProducts });
	}
}
/*End Monogramming functions*/


mainImage.init();
initializeEvents();
initializeDom();

module.exports = productInventory;
module.exports.monogramReset = monogramReset;
module.exports.fullScreenImage = fullScreenImage;
module.exports.validateFormFields = validateFormFields;
},{"../dialog":34,"../util":82,"./":77,"lodash":5}],79:[function(require,module,exports){
'use strict';

var util = require('../util');
var inventory = require('./');
var TPromise = require('promise');

var shippingInventory = {

    shipInstead: function(uuid) {
        TPromise.resolve(
            $.ajax({
                url: Urls.setStorePickup,
                type: 'GET',
                data: { plid: uuid, storeid: '', storepickup: 'false'}
            })
        ).then(function() {
            setTimeout(function() {
                window.location.reload();
            }, 0);
        });
    },

    openEditStoreDialog: function($shipmentContainer) {
        var $colorEl = $shipmentContainer.find('div[data-attribute="color"] .value');
        var $priceEl = $shipmentContainer.find('.mini-product-price-total');
        var $qtyEl = $shipmentContainer.find('.mini-product-quantity');

        var shipmentData = $shipmentContainer.data();
        var pid =  shipmentData.pid;
        var uuid = shipmentData.uuid;
        var selectedStore = shipmentData.storeId;
        var newSelectedStoreId = '';
        var productColor = ($colorEl.length > 0) ? $colorEl.text().trim() : '';
        var productPrice = ($priceEl.length > 0) ? $priceEl.text().trim() : '';
        var productQty =  ($qtyEl.length > 0) ?  $qtyEl.text().trim() : '';

        TPromise.resolve(
            $.ajax({
                dataType: 'html',
                url: util.appendParamsToUrl(Urls.getProductInfo, {
                    pid: pid,
                    productColor: productColor,
                    productPrice: productPrice,
                    productQty: productQty
                })
            })
        ).then(function(response) {
            inventory.selectStoreDialog({
                pid: pid,
                pickupContent: response,
                stores: [],
                selectedStoreId: selectedStore,
                selectedStoreText: Resources.SELECTED_STORE,
                selectStoreCallback: function(storeId) {
                    newSelectedStoreId = storeId;
                },
                continueCallback: function () {
                    if (newSelectedStoreId !== '' && newSelectedStoreId !== selectedStore) {
                        TPromise.resolve($.ajax({
                            url: Urls.setStorePickup,
                            type: 'GET',
                            data: {
                                plid: uuid,
                                storeid: newSelectedStoreId,
                                storepickup: 'true'
                            }
                        })).then(function() {
                            setTimeout(function() {
                                window.location.reload();
                            }, 0);
                        });
                    }
                }
            });
        });
    },

    init: function () {
        var self = this;

        $(document).on('click', '.js-shipping-ship-instead', function(e) {
            e.preventDefault();
            var uuid = $(this).data('uuid');
            self.shipInstead(uuid);
        });

        $(document).on('click', '.js-shipping-edit-store', function(e) {
            e.preventDefault();
            var $shipmentContainer = $(this);
            self.openEditStoreDialog($shipmentContainer);
        });
    }
};

module.exports = shippingInventory;

},{"../util":82,"./":77,"promise":6}],80:[function(require,module,exports){
'use strict';

/**
 * Checks the TLS and displays a warning if appropriate
 * @function getUserAgent Checks the TLS and displays a warning if appropriate
 **/
function getUserAgent() {
    // Use an external service to check the TLS of the browser
    // NOTE: this implementation uses https://www.howsmyssl.com
    //     you may also wish to consider the API available at https://www.ssllabs.com/projects/ssllabs-apis/index.html
    var url = 'https://www.howsmyssl.com/a/check';
    var cookieName = 'dw_TLSWarning';
    var cookieValue = getCookie(cookieName);

    // Test to see if this browser has already been flagged by looking at its cookies
    if (!cookieValue) {
        getTLS(url, function (message) {
            if (message.length > 0) {
                showWarning(message[0]);

                // the browser is bad - set the cookie to true (for 15 minutes)
                setCookie(cookieName, 'true', 15);
            } else {
                // else the browser is good, set the cookie to false (for 30 days) so we don't check again
                setCookie(cookieName, 'false', 60 * 24 * 30);
            }
        });
    } else if (cookieValue === 'true') {
        // if we already know that this is an invalid browser, show the warning
        showWarning(Resources.TLS_WARNING);
    }
}

/**
 * Calls out to the TLS service and calls the callback with a message (if necessary)
 * @function getTLS
 *
 * @param {string} url - URL of external TLS-checking API
 * @param {function} callback - function to call with response
 **/
function getTLS(url, callback) {
    var message = [];

    // First, see if the browser is among the suspect browsers to see if a TLS check is necessary
    var userAgent = navigator.userAgent;

    /** This list derived from https://www.ssllabs.com/ssltest/clients.html **/
    var badBrowsers = ['MSIE 6.0','MSIE 7.0','MSIE 8.0','MSIE 9.0','MSIE 10.0',
                       'Android 2.3.7', 'Android 4.0.4', 'Android 4.1.1', 'Android 4.2.2', 'Android 4.3',
                       'Safari 5.1.9 / OS X 10.6.8', 'Safari 6.0.4 / OS X 10.8.4 '];
    function checkTLSLevel(data) {
        // If we can determine the TLS level, check to see if it's less than 1.2
        if (parseFloat(data.tls_version.split(' ')[1]) < 1.1) {
            message.push(Resources.TLS_WARNING);
            callback(message);

            //If you want to track statistics on bad TLS hits, include this call
            $.ajax({url: Urls.TLSBadTLS});
        }
    }

    function reportBadBrowser () {
        // If the TLS level cannot be determined just report that this browser is suspect
        message.push(Resources.TLS_WARNING);
        callback(message);

        //If you want to track statistics on deprecated browsers, include this call
        $.ajax({url: Urls.TLSBadBrowser});
    }

    for (var i = 0; i < badBrowsers.length; i++) {
        if (userAgent.match(badBrowsers[i])) {
            // It's a suspect browser, let's see what it's TLS level is
            $.ajax({
                url: url
            }).done(checkTLSLevel).fail(reportBadBrowser);
            break;
        }
    }

    /** For testing purposes, uncomment this block
        message.push(Resources.TLS_WARNING);
    **/
    callback(message);
}

/**
 * @function showWarning turns on the browser-compatibility-alert and sets the message
 *
 * @param {string} message - the message that will be shown upon detection of a bad browser
 **/
function showWarning(message) {
    $('<div/>').addClass('browser-compatibility-alert').append($('<p/>').addClass('browser-error').html(message)).appendTo('#browser-check');
}

/**
 * @function getCookie
 *
 * @param {string} key - The cookie name
 * @returns {string} value - the value of the cookie if found, null otherwise
 **/
function getCookie(key) {
    var cookies = document.cookie.split(';');
    for (var i = 0; i < cookies.length; i++) {
        var tokens = cookies[i].split('=');
        var cookieKey = tokens[0].trim();
        if (cookieKey === key) {
            return tokens[1];
        }
    }
    return '';
}

/**
 * @function setCookie
 *
 * @param {string} key - The cookie name
 * @param {string} value - The cookie value
 * @param {integer} minutes - The number of minutes to expire the cookie
 **/
function setCookie (key, value, minutes) {
    var date = new Date();
    date.setTime(date + (minutes * 60 * 1000));

    document.cookie = key + '=' + value + '; expires=' + date.toGMTString() + '; path=/';
}

/**
 * Export the getUserAgent function
 */

exports.getUserAgent = getUserAgent;

},{}],81:[function(require,module,exports){
'use strict';

/**
 * @function
 * @description Initializes the tooltip-content and layout
 */
exports.init = function () {
    $(document).tooltip({
        items: '.tooltip',
        track: true,
        position: {
            my: "left+30 center",
            at: "right center",
            collision: "flipfit",
            using: function( position, feedback ) {
                var $this = $(this);
                // set up tooltip position
                $this.css( position );
                // add extra class to determine tooltip's horizontal position(left or right)
                var horizontalPos = 'horizontal-pos-' + feedback.horizontal;
                $this.find('.ui-tooltip-content').addClass(horizontalPos);
            }
        },
        content: function () {
            return $(this).find('.tooltip-content').html();
        },
        open: function() {
        	$('.ui-tooltip-content').after().click(function () {
        });}
    });

    $('.tooltip').on('click', function (e) {
        e.preventDefault();
    });

    $('.share-link').on('click', function (e) {
        e.preventDefault();
        var target = $(this).data('target');
        if (!target) {
            return;
        }
        $(target).toggleClass('active');
    });
};

},{}],82:[function(require,module,exports){
'use strict';

var _ = require('lodash');

var util = {
    /**
     * @function
     * @description appends the parameter with the given name and value to the given url and returns the changed url
     * @param {String} url the url to which the parameter will be added
     * @param {String} name the name of the parameter
     * @param {String} value the value of the parameter
     */
    appendParamToURL: function (url, name, value) {
        // quit if the param already exists
    	if (name.indexOf('source') == -1 && url.indexOf(name + '=') !== -1) {
            return url;
        }
        var separator = url.indexOf('?') !== -1 ? '&' : '?';
        return url + separator + name + '=' + encodeURIComponent(value);
    },

    getUri : function (o) {
        var a;
        if (o.tagName && $(o).attr("href")) {
            a = o;
        }
        else if (typeof o === "string") {
            a = document.createElement("a");
            a.href = o;
        }
        else {
            return null;
        }
        var pathParts = '';
        if (a.pathname) {
            pathParts = a.pathname.split('/');
        }
        return {
            protocol : a.protocol, //http:
            host : a.host, //www.myexample.com
            hostname : a.hostname, //www.myexample.com'
            port : a.port, //:80
            path : a.pathname, // /sub1/sub2
            query : a.search, // ?param1=val1&param2=val2
            queryParams : a.search.length > 1 ? util.getQueryStringParams(a.search.substr(1)) : {},
            hash : a.hash, // #OU812,5150
            url : a.protocol+ "//" + a.host + a.pathname,
            urlWithQuery : a.protocol+ "//" + a.host + a.port + a.pathname + a.search,
            page : pathParts.length > 0 ? pathParts[pathParts.length-1] : '' // sub2
        };
    },

    /**
     * @function
     * @description remove the parameter and its value from the given url and returns the changed url
     * @param {String} url the url from which the parameter will be removed
     * @param {String} name the name of parameter that will be removed from url
     */
    removeParamFromURL: function (url, name) {
        if (url.indexOf('?') === -1 || url.indexOf(name + '=') === -1) {
            return url;
        }
        var hash;
        var params;
        var domain = url.split('?')[0];
        var paramUrl = url.split('?')[1];
        var newParams = [];
        // if there is a hash at the end, store the hash
        if (paramUrl.indexOf('#') > -1) {
            hash = paramUrl.split('#')[1] || '';
            paramUrl = paramUrl.split('#')[0];
        }
        params = paramUrl.split('&');
        for (var i = 0; i < params.length; i++) {
            // put back param to newParams array if it is not the one to be removed
            if (params[i].split('=')[0] !== name) {
                newParams.push(params[i]);
            }
        }
        return domain + '?' + newParams.join('&') + (hash ? '#' + hash : '');
    },

    /**
     * @function
     * @description appends the parameters to the given url and returns the changed url
     * @param {String} url the url to which the parameters will be added
     * @param {Object} params
     */
    appendParamsToUrl: function (url, params) {
        var _url = url;
        _.each(params, function (value, name) {
            _url = this.appendParamToURL(_url, name, value);
        }.bind(this));
        return _url;
    },
    /**
     * @function
     * @description extract the query string from URL
     * @param {String} url the url to extra query string from
     **/
    getQueryString: function (url) {
        var qs;
        if (!_.isString(url)) { return; }
        var a = document.createElement('a');
        a.href = url;
        if (a.search) {
            qs = a.search.substr(1); // remove the leading ?
        }
        return qs;
    },
    /**
     * @function
     * @description
     * @param {String}
     * @param {String}
     */
    elementInViewport: function (el, offsetToTop) {
        var top = el.offsetTop,
            left = el.offsetLeft,
            width = el.offsetWidth,
            height = el.offsetHeight;

        while (el.offsetParent) {
            el = el.offsetParent;
            top += el.offsetTop;
            left += el.offsetLeft;
        }

        if (typeof(offsetToTop) !== 'undefined') {
            top -= offsetToTop;
        }

        if (window.pageXOffset !== null) {
            return (
                top < (window.pageYOffset + window.innerHeight) &&
                left < (window.pageXOffset + window.innerWidth) &&
                (top + height) > window.pageYOffset &&
                (left + width) > window.pageXOffset
            );
        }

        if (document.compatMode === 'CSS1Compat') {
            return (
                top < (window.document.documentElement.scrollTop + window.document.documentElement.clientHeight) &&
                left < (window.document.documentElement.scrollLeft + window.document.documentElement.clientWidth) &&
                (top + height) > window.document.documentElement.scrollTop &&
                (left + width) > window.document.documentElement.scrollLeft
            );
        }
    },

    /**
     * @function
     * @description Appends the parameter 'format=ajax' to a given path
     * @param {String} path the relative path
     */
    ajaxUrl: function (path) {
        return this.appendParamToURL(path, 'format', 'ajax');
    },

    /**
     * @function
     * @description
     * @param {String} url
     */
    toAbsoluteUrl: function (url) {
        if (url.indexOf('http') !== 0 && url.charAt(0) !== '/') {
            url = '/' + url;
        }
        return url;
    },
    /**
     * @function
     * @description Loads css dynamically from given urls
     * @param {Array} urls Array of urls from which css will be dynamically loaded.
     */
    loadDynamicCss: function (urls) {
        var i, len = urls.length;
        for (i = 0; i < len; i++) {
            this.loadedCssFiles.push(this.loadCssFile(urls[i]));
        }
    },

    /**
     * @function
     * @description Loads css file dynamically from given url
     * @param {String} url The url from which css file will be dynamically loaded.
     */
    loadCssFile: function (url) {
        return $('<link/>').appendTo($('head')).attr({
            type: 'text/css',
            rel: 'stylesheet'
        }).attr('href', url); // for i.e. <9, href must be added after link has been appended to head
    },
    // array to keep track of the dynamically loaded CSS files
    loadedCssFiles: [],

    /**
     * @function
     * @description Removes all css files which were dynamically loaded
     */
    clearDynamicCss: function () {
        var i = this.loadedCssFiles.length;
        while (0 > i--) {
            $(this.loadedCssFiles[i]).remove();
        }
        this.loadedCssFiles = [];
    },
    /**
     * @function
     * @description Extracts all parameters from a given query string into an object
     * @param {String} qs The query string from which the parameters will be extracted
     */
    getQueryStringParams: function (qs) {
        if (!qs || qs.length === 0) { return {}; }
        var params = {},
            unescapedQS = decodeURIComponent(qs);
        // Use the String::replace method to iterate over each
        // name-value pair in the string.
        unescapedQS.replace(new RegExp('([^?=&]+)(=([^&]*))?', 'g'),
            function ($0, $1, $2, $3) {
                params[$1] = $3;
            }
        );
        return params;
    },

    fillAddressFields: function (address, $form) {
        for (var field in address) {
            if (field === 'ID' || field === 'UUID' || field === 'key') {
                continue;
            }
            // if the key in address object ends with 'Code', remove that suffix
            $form.find('[name$="' + field.replace('Code', '') + '"]').val(address[field]).blur();
            if (field === 'postalCode') {
                $form.find('input.postal').attr('value', address[field]).blur();
            }
            // update the state fields
            if (field === 'countryCode') {
            	$form.find('[name$="country"]').val(address.countryCode.toUpperCase()).blur();
                // retrigger state selection after country has changed
                // this results in duplication of the state code, but is a necessary evil
                // for now because sometimes countryCode comes after stateCode
                $form.find('[name$="state"]').val(address.stateCode).blur();
                $form.find('[name$="zip"]').val(address.postalCode).blur();
            }
        }
        util.selectUnfloat();
    },
    /**
     * @function
     * @description Updates the number of the remaining character
     * based on the character limit in a text area
     */
    limitCharacters: function () {
        $('form').find('textarea[data-character-limit]').each(function () {
            var characterLimit = $(this).data('character-limit');
            var charCountHtml = String.format(Resources.CHAR_LIMIT_MSG,
                '<span class="char-remain-count">' + characterLimit + '</span>',
                '<span class="char-allowed-count">' + characterLimit + '</span>');
            var charCountContainer = $(this).next('div.char-count');
            if (charCountContainer.length === 0) {
                charCountContainer = $('<div class="char-count"/>').insertAfter($(this));
            }
            charCountContainer.html(charCountHtml);
            // trigger the keydown event so that any existing character data is calculated
            $(this).change();
        });
    },
    /**
     * @function
     * @description Binds the onclick-event to a delete button on a given container,
     * which opens a confirmation box with a given message
     * @param {String} container The name of element to which the function will be bind
     * @param {String} message The message the will be shown upon a click
     */
    setDeleteConfirmation: function (container, message) {
        $(container).on('click', '.delete', function () {
            return window.confirm(message);
        });
    },
    /**
     * @function
     * @description Scrolls a browser window to a given x point
     * @param {String} The x coordinate
     */
    scrollBrowser: function (xLocation) {
        $('html, body').animate({scrollTop: xLocation}, 500);
    },

    isMobile: function () {
        var mobileAgentHash = ['mobile', 'tablet', 'phone', 'ipad', 'ipod', 'android', 'blackberry', 'windows ce', 'opera mini', 'palm'];
        var idx = 0;
        var isMobile = false;
        var userAgent = (navigator.userAgent).toLowerCase();

        while (mobileAgentHash[idx] && !isMobile) {
            isMobile = (userAgent.indexOf(mobileAgentHash[idx]) >= 0);
            idx++;
        }
        return isMobile;
    },
    
    isTouchSupported: function() {
        return ('ontouchstart' in window) || (navigator.msMaxTouchPoints > 0);
    },
    
    getViewport: function () {
        var w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
        return w;
    },

    changeStateField : function(country, form, stateEmptyOptionHtml) {
        var stateElements = {
            container: form.find('.state-field-container')
        };
        stateElements.label = stateElements.container.find('label .text-input-label');
        stateElements.input = stateElements.container.find('select');

        var stateIntlElements = {
            container: form.find('.state-field-intl-container')
        };
        stateIntlElements.label = stateIntlElements.container.find('label .text-input-label');
        stateIntlElements.input = stateIntlElements.container.find('input');

        var fieldIdBak = 'state-id-bak';
        var fieldId = form.find("input[name$='_state'], select[name$='_state']").attr('id');
        var zipRow = form.find('.form-row.zip-row');
        var zipLabel = zipRow.find('.text-input-label');
        var zipInput = zipRow.find('input');
        var countries = window.Countries || window.countries;
        var countryConfig = countries[country];

        if (country === '' || country === 'US' || country === 'CA') {
            showStateElements(stateElements, true);
            hideStateElements(stateIntlElements);
            util.togglePhoneMask(form, true);
        } else {
            hideStateElements(stateElements);
            showStateElements(stateIntlElements, false);
            util.togglePhoneMask(form, false);
            /*$('#dwfrm_singleshipping_shippingAddress_addressFields_states_state').parent().css("display","none");
    		$('#dwfrm_singleshipping_shippingAddress_addressFields_states_state option[value="OTHER"]').prop('selected', true);
    		
    		$('#dwfrm_billing_billingAddress_addressFields_states_state').parent().css("display","none");
     		$('#dwfrm_billing_billingAddress_addressFields_states_state option[value="OTHER"]').prop('selected', true);*/
        }

        if (countryConfig && countryConfig.ziplabel) {
            zipLabel.html(countryConfig.ziplabel);
            zipInput.attr('placeholder', countryConfig.ziplabel)
        }

        function showStateElements(stateElements, required) {
            var stateVal = stateElements.input.val();

            stateElements.container.removeClass('visually-hidden')
                .css({ display: 'inline-block' });
            stateElements.input.attr({
                id: fieldId,
                name: fieldId
            });
            stateElements.label.attr('for', fieldId);

            if (required) {
                stateElements.input.addClass('required');
            } else {
                stateElements.input.removeClass('required');
            }

            if (countryConfig) {
                stateElements.label.html(countryConfig.regionLabel || countryConfig.label);
                stateElements.input.attr('placeholder', countryConfig.regionLabel || countryConfig.label);

                if (!_.isEmpty(countryConfig.regions)) {
                    var regionOptionsHtml = stateEmptyOptionHtml;
                    for (var region in countryConfig.regions) {
                        var regionLabel = countryConfig.regions[region];
                        regionOptionsHtml += '<option value="' + region + '" class="select-option"' +
                            ' label="' + regionLabel + '">' + regionLabel + '</option>';
                    }
                    stateElements.input.html(regionOptionsHtml);
                    if (stateVal && stateElements.input.find('option[value=' + stateVal + ']').length > 0) {
                        stateElements.input.val(stateVal);
                    }
                }
            }
            stateElements.input.removeClass('error valid').next('span.error').remove();
        }

        function hideStateElements(stateElements) {
            stateElements.container.addClass('visually-hidden')
                .css({ display: 'none' });
            stateElements.label.attr('for', fieldIdBak);
            stateElements.input.removeClass('required')
                .attr({
                    id: fieldIdBak,
                    name: fieldIdBak
                });
        }
        this.selectUnfloat();
    },

    /**
     * Toggles a format for the phone number when run
     * 
     * @param 	obj 	form
     * @param 	bool 	mask
     * @var 	obj 	phone
     * @return 	VOID
     */
    togglePhoneMask : function (form, mask) {
        var phone = form.find('input.phone');
        if (phone.length) {
            if(mask) {
                phone.mask("(000) 000-0000", { watchInputs: false });
            } else {
                phone.unmask();
            }
        }
    },
 
    initZipService : function (form) {
        // Prepopulate city for checkout redesign
        if (form.length > 0) {
            var country = form.find("select[name$='_country']");
            var postalCode = form.find("input[name$='_zip'], input[name$='_postal']");
            var city = form.find("input[name$='_city']");
            var stateCode = form.find("select[id$='_state']");

            postalCode.on('blur', function() {
                if (country.length > 0 && (country.val() === 'US' || country.val() === '')) {
                    var zip = $(this).val();
                    // only prepopulate if have a full zip
                    if (zip.length >= 5) {
                        $.ajax({
                            url: Urls.getCityStateFromZip,
                            dataType: 'json',
                            data: {
                                'zip': zip
                            }
                        }).done(function(data) {
                            if (data) {
                                if (data.city) {
                                    city.val(capitalizeWords(data.city)).blur();
                                    city.trigger('change');
                                }
                                if (data.state) {
                                    stateCode.val(data.state).blur();
                                    stateCode.trigger('change');
                                }
                            }
                        });
                    }
                }
            });
        }
    },

    // Submit a form via ajax (only if it is valid) and allow for a call back
    formsubmit : function(form, btn, type, callback){
        // Check to see if form is valid
        if (!form.valid()) return;
        // If valid, send the form via ajax
        // Data to send to the jquery call
        var url = app.util.appendParamToURL(form.attr('action'), "format", "ajax");
        // Collect the required form fields
        var data = form.serialize();
        // Figure out what type of call this is (from the button)
        data += "&" + btn.attr("name") + "=" + btn.attr("value");
        // make the server call
        $.ajax({
            url : url,
            data : data,
            type: "POST",
            dataType: type || "html"
        })
        .done(function(e, textStatus){
            if(!callback) return;
            callback(e, textStatus);
        })
        .fail(function (e, textStatus) {
            if(textStatus === "parsererror") {
                alert(textStatus);
            }
        });
    },

    selectUnfloat: function() {
        setTimeout(function () {
            $('.pt_checkout select').each(function (i, el) {
                if ($(el).val() && $(el).val().length < 1) {
                    $(el).parent().addClass('unfloat');
                }
            });
        },100);
    },
    /**
     * Execute callback function when the user has stopped resizing the screen.
     * @param callback {Function} The callback function to execute.
     */
    smartResize: function (callback) {
        var timeout;

        window.addEventListener('resize', function () {
            clearTimeout(timeout);
            timeout = setTimeout(callback, 100);
        });

        return callback;
    },
};

function capitalizeWords(str) {
    str = str.toLowerCase();
    return str.replace(/(\b)([a-zA-Z])/g,
        function(firstLetter){
            return firstLetter.toUpperCase();
        });
}

module.exports = util;

},{"lodash":5}],83:[function(require,module,exports){
'use strict';

var naPhone = /^\(?([2-9][0-8][0-9])\)?[\-\. ]?([2-9][0-9]{2})\-([0-9]{4})(\s*x[0-9]+)?$/;
var regex = {
    phone: {
        us: naPhone,
        ca: naPhone,
        fr: /^0[1-6]{1}(([0-9]{2}){4})|((\s[0-9]{2}){4})|((-[0-9]{2}){4})$/,
        it: /^(([0-9]{2,4})([-\s\/]{0,1})([0-9]{4,8}))?$/,
        jp: /^(0\d{1,4}- ?)?\d{1,4}-\d{4}$/,
        cn: /.*/,
        gb: /^((\(?0\d{4}\)?\s?\d{3}\s?\d{3})|(\(?0\d{3}\)?\s?\d{3}\s?\d{4})|(\(?0\d{2}\)?\s?\d{4}\s?\d{4}))(\s?\#(\d{4}|\d{3}))?$/,
        extension: /(\s*x[0-9]+)/
    },
    email : /^[\w.+-]+@[\w.-]+\.[\w]{2,6}$/,
    postal: {
        us: /^(?!0{3})[0-9]{5}(-?\d{4})?$/,
        ca: /^[ABCEGHJKLMNPRSTVXY]{1}\d{1}[A-Z]{1} *\d{1}[A-Z]{1}\d{1}$/i,
        /* 
        	COMMENTING OUT THE COUNTRIES BELOW SINCE THESE REGULAR EXPRESSIONS 
        	ARE CURRENTLY NOT BEING USED.
        fr: /^(F-)?((2[A|B])|[0-9]{2})[0-9]{3}$/,
        it: /^([0-9]){5}$/,
        jp: /^([0-9]){3}[-]([0-9]){4}$/,
        cn: /^([0-9]){6}$/,
        */
        gb: /^([A-PR-UWYZ0-9][A-HK-Y0-9][AEHMNPRTVXY0-9]?[ABEHMNPRVWXY0-9]? {1,2}[0-9][ABD-HJLN-UW-Z]{2}|GIR 0AA)$/
    },
    notCC: /^(?!(([0-9 -]){13,19})).*$/,
    char_range : /^[\u0020-\u007E\u00BF-\u00FF]*$/,
    just_digits: /[^\d]/g
};
// global form validator settings
var settings = {
    errorClass: 'error',
    errorElement: 'span',
    onkeyup: false,
    onfocusout: function (element) {
        if (!this.checkable(element)) {
            this.element(element);
        }
    }
};

var formatter = {
		phone: formatPhone
};

/**
 * @function
 * @description Validates a given phone number against the countries phone regex
 * @param {String} value The phone number which will be validated
 * @param {String} el The input field
 */
var validatePhone = function (value, el) {
    var country = $(el).closest('form').find('.country');
	if (country.val() == 'US' || country.val() == 'CA') {
	    if (country.length === 0 || country.val().length === 0 || !regex.phone[country.val().toLowerCase()]) {
	        return true;
	    }
	
	    var rgx = regex.phone[country.val().toLowerCase()];
	    var isOptional = this.optional(el);
	    var isValid = rgx.test($.trim(value));
	}
	else {
        var isOptional = true;
	}
	    
    return isOptional || isValid;
};

/**
 * @function
 * @description Formats a phone number to a match a valid regex
 * @param {Object} The JQuery object holding a reference to the phone number input field to be formatted.
 */
function formatPhone (e, selfTriggered) {
	if (selfTriggered) {
		return false; // avoid an infinite loop
	}
 	var $phone = $(this),
	number = $phone.val().toLowerCase(),
	digits = number.replace(regex.just_digits, ""),
	country = $phone.closest('form').find('.country');

	// No formatting for non US or CA phone numbers
	if (country.val() != 'US' && country.val() != 'CA') {
		return false;
	}

    if((number.length > 0) && (number.indexOf('-') == -1)) {
        var formattedNumber = '(';
        formattedNumber += digits.substr(0,3);
        formattedNumber += ') ';
        formattedNumber += digits.substr(3,3);
        formattedNumber += '-';
        formattedNumber += digits.substr(6,4);
        number = formattedNumber;
        $phone.val(formattedNumber);
    }

    $phone.mask("(000) 000-0000");

	if (number.length > 0) {
        $phone.parent().addClass('focused');
    }

    if (country.length === 0 || country.val().length === 0 || !regex.phone[country.val().toLowerCase()]) {
        return true;
    }

    var rgx = regex.phone[country.val().toLowerCase()];
    var isValid = rgx.test($.trim(number));

    if (isValid == false) {
        $phone.parent().removeClass('focused');
    }
	$phone.trigger('change', [true]); // validator function must run after the value changes
}

/**
 * @function
 * @description Validates a given email address.
 * @param {String} value The phone number which will be validated
 * @param {String} el The input field
 */
function validateEmail(value, el) {
	var isOptional = this.optional(el);
	var isValid = regex.email.test($.trim(value));
	return isOptional || isValid; 
} 

/**
 * @function
 * @description Validates a given postal code against the all countries postal regular expression.
 * @param {String} value The postal code which will be validated
 * @param {String} el The input field
 */
function validateAllPostal(value, el) {
    var isValid = false;
    var isOptional = this.optional(el);

    for(var country in regex.postal) {
        if(regex.postal[country].test($.trim(value)) == true){
        	isValid = true;
        	return isOptional || isValid;
        }
    }
    return isOptional || isValid;
}

/**
 * @function
 * @description Validates a given postal code against the country's postal regular expression.
 * @param {String} value The postal code which will be validated
 * @param {String} el The input field
 */
function validatePostal(value, el) {
    var $country = $(el).closest('fieldset').find('.input-select.country');

    if (value.length < 4) {return false;}
 
    if($country.length === 0 || $country.val().length === 0 || !regex.postal[$country.val().toLowerCase()]) {
        return true;
    }
    var rgx = regex.postal[$country.val().toLowerCase()];
    var isValid = rgx.test($.trim(value));

    return isValid;
}

/**
 * @function
 * @description Validates that a credit card owner is not a Credit card number
 * @param {String} value The owner field which will be validated
 * @param {String} el The input field
 */
var validateOwner = function (value) {
    var isValid = regex.notCC.test($.trim(value));
    return isValid;
};

/**
 * @function
 * @description Validates a recipient confirmation email matches recipient email
 * @param {String} value The recipient confirmation email which will be validated
 * @param {String} el The input field
 */
function recipientEmailConfirm(value, el) {
    var isOptional = this.optional(el);
    var recipientEmail = $('input[name="vgcRecipientEmail"]');
    var isValid = ( regex.email.test($.trim(value)) && value.toLowerCase() === recipientEmail.val().toLowerCase() );
    return isOptional || isValid;
}

function validateGiftMsg(value, el) {
    var isOptional = this.optional(el);
    var isValid = ( regex.char_range.test($.trim(value)) );
    return isOptional || isValid;
}

function confirmPassword(value, el) {
    var isOptional = this.optional(el);
    var form = $(el).closest('form');
    var passwordField = form.find('input.password');
    var isValid = false;
    if(passwordField.length > 0) isValid = (value == passwordField.val());
    return isOptional || isValid;
}

var validateGiftRegistryEventDate = function (value) { 
		// Get date from form field input
	var month = parseInt(value.substring(0, 2));
	var day = parseInt(value.substring(5, 7));
	var year = parseInt("20"+parseInt(value.substring(10, 12)));
		// Create new date object
	var eventDate = new Date(year, month-1, day);
	var currentDate = new Date();
		// Make sure event date is past current date
	if(value.length == 12 && (eventDate >= currentDate)) {
		$('#dwfrm_giftregistry_event_date').val(month + ' / ' + day + ' / ' + year); 
		return true;
	} 
	else {
		return false;
	}
};

function comparePassword(value) {
    return $('.input-text.password').val() == value;
}

function validateCC(value, el) {
	//if cc number has * in it, it is a saved card and does not need to be validated
	if(value.indexOf('****') == -1){
	    var isOptional = this.optional(el);
	    value = value.replace(/\s+/g, '');
	    if (value.length < 13) {
	        return isOptional || false;
	    }
	    if (/^(5[1-5]|2[2-7][0-9])/.test(value) || /^4/.test(value) || /^3[47]/.test(value) || /^6(?:011|5|4[4-9])/.test(value)) {
	        return isOptional || luhn.verify(value);
	    } else {
	        return isOptional || false;
	    }
	}else{
		return true;
	}
}

function validateMissingCCExpirationDate (value) {
    var yearData =  value.substr(4, 3);
    var monthData = value.substr(0, 2);
    yearData = '20'+parseInt(yearData);
    if (yearData.length == 4 && parseInt(monthData) > 0 && parseInt(monthData) < 13) {
        return true;
    } else {
        return false;
    }
    
}


function validateCCExpirationDate (value) {
    var yearData =  value.substr(4, 3);
    var monthData = value.substr(0, 2);
    var currentYear =  new Date().getFullYear();
    var currentMonth = new Date().getMonth()+1;
    var allowYear = currentYear + 9;
    yearData = '20'+parseInt(yearData);
    if ( (yearData == currentYear && monthData >= currentMonth) || (yearData <= allowYear && yearData > currentYear) ) {
        return true;
    } else {
        return false
    }
}

var luhn = {
    verify: function(digits) {
        var sum = this.sum(digits, true);
        return sum > 0 && sum % 10 === 0;
    },
    sum: function(digits, even) {
        var sum = 0,
          digit = 0,
          i = digits.length;

        while (i--) {
            digit = Number(digits[i]);
            sum += (even = !even) ? this.computed[digit] : digit;
        }

        return sum;
    },
    computed: [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]
};

/**
 * Add password comparisson method to jQuery validation plugin.
 * Text fields must have 'creditcard' css class to be validated as email
 */
$.validator.addMethod("passwordconfirm", comparePassword, Resources.VALIDATE_INVALID_PASSMATCH);

/**
 * Add credit card expiration date validation method to jQuery validation plugin.
 * Text fields must have 'creditcard' css class to be validated as email
 */
$.validator.addMethod("cc-missing-expiration", validateMissingCCExpirationDate, Resources.MISSING_EXPIRATION);

/**
 * Add credit card expiration date validation method to jQuery validation plugin.
 * Text fields must have 'creditcard' css class to be validated as email
 */
$.validator.addMethod("cc-valid-expiration", validateCCExpirationDate, Resources.INVALID_EXPIRATION);

/**
 * Add credit card validation method to jQuery validation plugin.
 * Text fields must have 'creditcard' css class to be validated as email
 */
$.validator.addMethod("credit-card-number", validateCC, Resources.VALIDATE_NUMBER);

/**
 * validateGiftRegistryEventDate verifies the first two digits are the month, the third and fourth digit is a day
 */
$.validator.addMethod('datenothidden', validateGiftRegistryEventDate, Resources.VALIDATE_DATE);

/**
 * Add email address validation method to jQuery validation plugin.
 * Text fields must have 'email' css class to be validated as email 
 */
$.validator.addMethod("email", validateEmail, Resources.INVALID_EMAIL);

/**
 * Add postal code validation method to jQuery validation plugin.
 * Text fields must have 'postalAll' css class to be validated as postal code
 */
$.validator.addMethod("postalAll", validateAllPostal, Resources.INVALID_POSTAL);

/**
 * Add postal code validation method to jQuery validation plugin.
 * Text fields must have 'postal' css class to be validated as postal code
 */
$.validator.addMethod("postal", validatePostal, Resources.INVALID_POSTAL);

/**
 * Add phone validation method to jQuery validation plugin.
 * Text fields must have 'phone' css class to be validated as phone
 */
$.validator.addMethod('phone', validatePhone, Resources.INVALID_PHONE);

/**
 * Add CCOwner validation method to jQuery validation plugin.
 * Text fields must have 'owner' css class to be validated as not a credit card
 */
$.validator.addMethod('owner', validateOwner, Resources.INVALID_OWNER);

/**
 * Add gift cert amount validation method to jQuery validation plugin.
 * Text fields must have 'gift-cert-amont' css class to be validated
 */
$.validator.addMethod('gift-cert-amount', function (value, el) {
    var isOptional = this.optional(el);
    var isValid = (!isNaN(value)) && (parseFloat(value) >= 5) && (parseFloat(value) <= 5000);
    return isOptional || isValid;
}, Resources.GIFT_CERT_AMOUNT_INVALID);

/**
 * Add gift message validation
 */
$.validator.addMethod('gift-message-chars', validateGiftMsg, Resources.VALIDATE_CHARRANGE);

/**
 * Add positive number validation method to jQuery validation plugin.
 * Text fields must have 'positivenumber' css class to be validated as positivenumber
 */
$.validator.addMethod('positivenumber', function (value) {
    if ($.trim(value).length === 0) { return true; }
    return (!isNaN(value) && Number(value) >= 0);
}, ''); // '' should be replaced with error message if needed

$.validator.addMethod("recipient-email-confirm", recipientEmailConfirm, Resources.VALIDATE_INVALID_EMAILMATCH);

/**
 * Add password confirm validation method to jQuery validation plugin.
 * Text fields must have 'passwordconfirm' css class to be validated as password
 */
$.validator.addMethod("passwordconfirm", confirmPassword, Resources.INVALID_PASSWORDMATCH);

$.extend($.validator.messages, {
    required: Resources.VALIDATE_REQUIRED,
    remote: Resources.VALIDATE_REMOTE,
    email: Resources.VALIDATE_EMAIL,
    url: Resources.VALIDATE_URL,
    date: Resources.VALIDATE_DATE,
    dateISO: Resources.VALIDATE_DATEISO,
    number: Resources.VALIDATE_NUMBER,
    digits: Resources.VALIDATE_DIGITS,
    creditcard: Resources.VALIDATE_CREDITCARD,
    equalTo: Resources.VALIDATE_EQUALTO,
    maxlength: $.validator.format(Resources.VALIDATE_MAXLENGTH),
    minlength: $.validator.format(Resources.VALIDATE_MINLENGTH),
    rangelength: $.validator.format(Resources.VALIDATE_RANGELENGTH),
    range: $.validator.format(Resources.VALIDATE_RANGE),
    max: $.validator.format(Resources.VALIDATE_MAX),
    min: $.validator.format(Resources.VALIDATE_MIN)
});

var validator = {
    regex: regex,
    settings: settings,
    formatter: formatter,
    init: function () {
        var self = this;
        $('form:not(.suppress)').each(function () {
                // Forms having required input fields with data-required-text='' attribute, create customized error messages for clientside form validation
            if ($(this).find('input[data-required-text].required, select[data-required-text].required').length > 0) {
                    // Create new messages object for validate settings
                self.settings.messages = {};
                    // Loop thru each required field to extract the error message
                $(this).find('input[data-required-text].required').each(function() {
                    self.settings.messages[ $(this).attr('id') ] = {
                        'required': $(this).data('required-text')
                    };
                });
            }

            $(this).validate(self.settings);
        });
    },
    initForm: function (f, settings) {
        $(f).validate(settings != null ? settings : this.settings);
    }
};

module.exports = validator;

},{}]},{},[27])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYXNhcC9icm93c2VyLWFzYXAuanMiLCJub2RlX21vZHVsZXMvYXNhcC9icm93c2VyLXJhdy5qcyIsIm5vZGVfbW9kdWxlcy9ldi1lbWl0dGVyL2V2LWVtaXR0ZXIuanMiLCJub2RlX21vZHVsZXMvaW1hZ2VzbG9hZGVkL2ltYWdlc2xvYWRlZC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvbWlzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9taXNlL2xpYi9jb3JlLmpzIiwibm9kZV9tb2R1bGVzL3Byb21pc2UvbGliL2RvbmUuanMiLCJub2RlX21vZHVsZXMvcHJvbWlzZS9saWIvZXM2LWV4dGVuc2lvbnMuanMiLCJub2RlX21vZHVsZXMvcHJvbWlzZS9saWIvZmluYWxseS5qcyIsIm5vZGVfbW9kdWxlcy9wcm9taXNlL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9taXNlL2xpYi9ub2RlLWV4dGVuc2lvbnMuanMiLCJub2RlX21vZHVsZXMvcHJvbWlzZS9saWIvc3luY2hyb25vdXMuanMiLCJub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJub2RlX21vZHVsZXMvcXMvbGliL2Zvcm1hdHMuanMiLCJub2RlX21vZHVsZXMvcXMvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3FzL2xpYi9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9xcy9saWIvc3RyaW5naWZ5LmpzIiwibm9kZV9tb2R1bGVzL3FzL2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCJub2RlX21vZHVsZXMvdXJsL3V0aWwuanMiLCJ0ZW1wLWx5b25zY2ctZGVtYW5kd2FyZS1yZWYtYXBwL1ZhbGlkYXRpb25SdWxlcy5qcyIsInRlbXAtbHlvbnNjZy1kZW1hbmR3YXJlLXJlZi1hcHAvYWpheC5qcyIsInRlbXAtbHlvbnNjZy1kZW1hbmR3YXJlLXJlZi1hcHAvYXBwLmpzIiwidGVtcC1seW9uc2NnLWRlbWFuZHdhcmUtcmVmLWFwcC9ib251cy1wcm9kdWN0cy12aWV3LmpzIiwidGVtcC1seW9uc2NnLWRlbWFuZHdhcmUtcmVmLWFwcC9jYXB0Y2hhLmpzIiwidGVtcC1seW9uc2NnLWRlbWFuZHdhcmUtcmVmLWFwcC9jb21wYXJlLXdpZGdldC5qcyIsInRlbXAtbHlvbnNjZy1kZW1hbmR3YXJlLXJlZi1hcHAvY29va2llcHJpdmFjeS5qcyIsInRlbXAtbHlvbnNjZy1kZW1hbmR3YXJlLXJlZi1hcHAvY291bnRyaWVzLmpzIiwidGVtcC1seW9uc2NnLWRlbWFuZHdhcmUtcmVmLWFwcC9kYXRhbGF5ZXIuanMiLCJ0ZW1wLWx5b25zY2ctZGVtYW5kd2FyZS1yZWYtYXBwL2RpYWxvZy5qcyIsInRlbXAtbHlvbnNjZy1kZW1hbmR3YXJlLXJlZi1hcHAvZW1haWxzdWJzY3JpcHRpb24uanMiLCJ0ZW1wLWx5b25zY2ctZGVtYW5kd2FyZS1yZWYtYXBwL2Zsb2F0LWxhYmVscy5qcyIsInRlbXAtbHlvbnNjZy1kZW1hbmR3YXJlLXJlZi1hcHAvZ2lmdGNhcmQuanMiLCJ0ZW1wLWx5b25zY2ctZGVtYW5kd2FyZS1yZWYtYXBwL2dpZnRjZXJ0LmpzIiwidGVtcC1seW9uc2NnLWRlbWFuZHdhcmUtcmVmLWFwcC9pbWFnZW1hcHJlc2l6ZXIuanMiLCJ0ZW1wLWx5b25zY2ctZGVtYW5kd2FyZS1yZWYtYXBwL2ludGVyYWN0LmpzIiwidGVtcC1seW9uc2NnLWRlbWFuZHdhcmUtcmVmLWFwcC9qcXVlcnktZXh0LmpzIiwidGVtcC1seW9uc2NnLWRlbWFuZHdhcmUtcmVmLWFwcC9sb2dpbi5qcyIsInRlbXAtbHlvbnNjZy1kZW1hbmR3YXJlLXJlZi1hcHAvbWluaWNhcnQuanMiLCJ0ZW1wLWx5b25zY2ctZGVtYW5kd2FyZS1yZWYtYXBwL3BhZ2UuanMiLCJ0ZW1wLWx5b25zY2ctZGVtYW5kd2FyZS1yZWYtYXBwL3BhZ2VzL2FjY291bnQuanMiLCJ0ZW1wLWx5b25zY2ctZGVtYW5kd2FyZS1yZWYtYXBwL3BhZ2VzL2NhcnQuanMiLCJ0ZW1wLWx5b25zY2ctZGVtYW5kd2FyZS1yZWYtYXBwL3BhZ2VzL2NoZWNrb3V0L2FkZHJlc3MuanMiLCJ0ZW1wLWx5b25zY2ctZGVtYW5kd2FyZS1yZWYtYXBwL3BhZ2VzL2NoZWNrb3V0L2JpbGxpbmcuanMiLCJ0ZW1wLWx5b25zY2ctZGVtYW5kd2FyZS1yZWYtYXBwL3BhZ2VzL2NoZWNrb3V0L2Zvcm1QcmVwYXJlLmpzIiwidGVtcC1seW9uc2NnLWRlbWFuZHdhcmUtcmVmLWFwcC9wYWdlcy9jaGVja291dC9pbmRleC5qcyIsInRlbXAtbHlvbnNjZy1kZW1hbmR3YXJlLXJlZi1hcHAvcGFnZXMvY2hlY2tvdXQvbXVsdGlzaGlwLmpzIiwidGVtcC1seW9uc2NnLWRlbWFuZHdhcmUtcmVmLWFwcC9wYWdlcy9jaGVja291dC9vcmRlcmNvbmZpcm1hdGlvbi5qcyIsInRlbXAtbHlvbnNjZy1kZW1hbmR3YXJlLXJlZi1hcHAvcGFnZXMvY2hlY2tvdXQvc2hpcHBpbmcuanMiLCJ0ZW1wLWx5b25zY2ctZGVtYW5kd2FyZS1yZWYtYXBwL3BhZ2VzL2NvbXBhcmUuanMiLCJ0ZW1wLWx5b25zY2ctZGVtYW5kd2FyZS1yZWYtYXBwL3BhZ2VzL3Byb2R1Y3QvYWRkVG9DYXJ0LmpzIiwidGVtcC1seW9uc2NnLWRlbWFuZHdhcmUtcmVmLWFwcC9wYWdlcy9wcm9kdWN0L2F2YWlsYWJpbGl0eS5qcyIsInRlbXAtbHlvbnNjZy1kZW1hbmR3YXJlLXJlZi1hcHAvcGFnZXMvcHJvZHVjdC9pbWFnZS5qcyIsInRlbXAtbHlvbnNjZy1kZW1hbmR3YXJlLXJlZi1hcHAvcGFnZXMvcHJvZHVjdC9pbmRleC5qcyIsInRlbXAtbHlvbnNjZy1kZW1hbmR3YXJlLXJlZi1hcHAvcGFnZXMvcHJvZHVjdC9wcm9kdWN0U2V0LmpzIiwidGVtcC1seW9uc2NnLWRlbWFuZHdhcmUtcmVmLWFwcC9wYWdlcy9wcm9kdWN0L3JlY29tbWVuZGF0aW9ucy5qcyIsInRlbXAtbHlvbnNjZy1kZW1hbmR3YXJlLXJlZi1hcHAvcGFnZXMvcHJvZHVjdC92YXJpYW50LmpzIiwidGVtcC1seW9uc2NnLWRlbWFuZHdhcmUtcmVmLWFwcC9wYWdlcy9yZWdpc3RyeS5qcyIsInRlbXAtbHlvbnNjZy1kZW1hbmR3YXJlLXJlZi1hcHAvcGFnZXMvc2VhcmNoLmpzIiwidGVtcC1seW9uc2NnLWRlbWFuZHdhcmUtcmVmLWFwcC9wYWdlcy9zdG9yZWZyb250LmpzIiwidGVtcC1seW9uc2NnLWRlbWFuZHdhcmUtcmVmLWFwcC9wYWdlcy9zdG9yZWxvY2F0b3IuanMiLCJ0ZW1wLWx5b25zY2ctZGVtYW5kd2FyZS1yZWYtYXBwL3BhZ2VzL3dpc2hsaXN0LmpzIiwidGVtcC1seW9uc2NnLWRlbWFuZHdhcmUtcmVmLWFwcC9wcm9kdWN0LXRpbGUuanMiLCJ0ZW1wLWx5b25zY2ctZGVtYW5kd2FyZS1yZWYtYXBwL3Byb2dyZXNzLmpzIiwidGVtcC1seW9uc2NnLWRlbWFuZHdhcmUtcmVmLWFwcC9xdWlja3ZpZXcuanMiLCJ0ZW1wLWx5b25zY2ctZGVtYW5kd2FyZS1yZWYtYXBwL3JhdGluZy5qcyIsInRlbXAtbHlvbnNjZy1kZW1hbmR3YXJlLXJlZi1hcHAvc2VhcmNocGxhY2Vob2xkZXIuanMiLCJ0ZW1wLWx5b25zY2ctZGVtYW5kd2FyZS1yZWYtYXBwL3NlYXJjaHN1Z2dlc3QuanMiLCJ0ZW1wLWx5b25zY2ctZGVtYW5kd2FyZS1yZWYtYXBwL3NlbGVjdGJveGl0LmpzIiwidGVtcC1seW9uc2NnLWRlbWFuZHdhcmUtcmVmLWFwcC9zbWFydHJlc2l6ZS5qcyIsInRlbXAtbHlvbnNjZy1kZW1hbmR3YXJlLXJlZi1hcHAvc3RpY2t5Y2FydC5qcyIsInRlbXAtbHlvbnNjZy1kZW1hbmR3YXJlLXJlZi1hcHAvc3RvcmVpbnZlbnRvcnkvY2FydC5qcyIsInRlbXAtbHlvbnNjZy1kZW1hbmR3YXJlLXJlZi1hcHAvc3RvcmVpbnZlbnRvcnkvaW5kZXguanMiLCJ0ZW1wLWx5b25zY2ctZGVtYW5kd2FyZS1yZWYtYXBwL3N0b3JlaW52ZW50b3J5L3Byb2R1Y3QuanMiLCJ0ZW1wLWx5b25zY2ctZGVtYW5kd2FyZS1yZWYtYXBwL3N0b3JlaW52ZW50b3J5L3NoaXBwaW5nLmpzIiwidGVtcC1seW9uc2NnLWRlbWFuZHdhcmUtcmVmLWFwcC90bHMuanMiLCJ0ZW1wLWx5b25zY2ctZGVtYW5kd2FyZS1yZWYtYXBwL3Rvb2x0aXAuanMiLCJ0ZW1wLWx5b25zY2ctZGVtYW5kd2FyZS1yZWYtYXBwL3V0aWwuanMiLCJ0ZW1wLWx5b25zY2ctZGVtYW5kd2FyZS1yZWYtYXBwL3ZhbGlkYXRvci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvallBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzV0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMThGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3gxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2dDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2lDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6aEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6aUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDenFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gcmF3QXNhcCBwcm92aWRlcyBldmVyeXRoaW5nIHdlIG5lZWQgZXhjZXB0IGV4Y2VwdGlvbiBtYW5hZ2VtZW50LlxudmFyIHJhd0FzYXAgPSByZXF1aXJlKFwiLi9yYXdcIik7XG4vLyBSYXdUYXNrcyBhcmUgcmVjeWNsZWQgdG8gcmVkdWNlIEdDIGNodXJuLlxudmFyIGZyZWVUYXNrcyA9IFtdO1xuLy8gV2UgcXVldWUgZXJyb3JzIHRvIGVuc3VyZSB0aGV5IGFyZSB0aHJvd24gaW4gcmlnaHQgb3JkZXIgKEZJRk8pLlxuLy8gQXJyYXktYXMtcXVldWUgaXMgZ29vZCBlbm91Z2ggaGVyZSwgc2luY2Ugd2UgYXJlIGp1c3QgZGVhbGluZyB3aXRoIGV4Y2VwdGlvbnMuXG52YXIgcGVuZGluZ0Vycm9ycyA9IFtdO1xudmFyIHJlcXVlc3RFcnJvclRocm93ID0gcmF3QXNhcC5tYWtlUmVxdWVzdENhbGxGcm9tVGltZXIodGhyb3dGaXJzdEVycm9yKTtcblxuZnVuY3Rpb24gdGhyb3dGaXJzdEVycm9yKCkge1xuICAgIGlmIChwZW5kaW5nRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBwZW5kaW5nRXJyb3JzLnNoaWZ0KCk7XG4gICAgfVxufVxuXG4vKipcbiAqIENhbGxzIGEgdGFzayBhcyBzb29uIGFzIHBvc3NpYmxlIGFmdGVyIHJldHVybmluZywgaW4gaXRzIG93biBldmVudCwgd2l0aCBwcmlvcml0eVxuICogb3ZlciBvdGhlciBldmVudHMgbGlrZSBhbmltYXRpb24sIHJlZmxvdywgYW5kIHJlcGFpbnQuIEFuIGVycm9yIHRocm93biBmcm9tIGFuXG4gKiBldmVudCB3aWxsIG5vdCBpbnRlcnJ1cHQsIG5vciBldmVuIHN1YnN0YW50aWFsbHkgc2xvdyBkb3duIHRoZSBwcm9jZXNzaW5nIG9mXG4gKiBvdGhlciBldmVudHMsIGJ1dCB3aWxsIGJlIHJhdGhlciBwb3N0cG9uZWQgdG8gYSBsb3dlciBwcmlvcml0eSBldmVudC5cbiAqIEBwYXJhbSB7e2NhbGx9fSB0YXNrIEEgY2FsbGFibGUgb2JqZWN0LCB0eXBpY2FsbHkgYSBmdW5jdGlvbiB0aGF0IHRha2VzIG5vXG4gKiBhcmd1bWVudHMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gYXNhcDtcbmZ1bmN0aW9uIGFzYXAodGFzaykge1xuICAgIHZhciByYXdUYXNrO1xuICAgIGlmIChmcmVlVGFza3MubGVuZ3RoKSB7XG4gICAgICAgIHJhd1Rhc2sgPSBmcmVlVGFza3MucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmF3VGFzayA9IG5ldyBSYXdUYXNrKCk7XG4gICAgfVxuICAgIHJhd1Rhc2sudGFzayA9IHRhc2s7XG4gICAgcmF3QXNhcChyYXdUYXNrKTtcbn1cblxuLy8gV2Ugd3JhcCB0YXNrcyB3aXRoIHJlY3ljbGFibGUgdGFzayBvYmplY3RzLiAgQSB0YXNrIG9iamVjdCBpbXBsZW1lbnRzXG4vLyBgY2FsbGAsIGp1c3QgbGlrZSBhIGZ1bmN0aW9uLlxuZnVuY3Rpb24gUmF3VGFzaygpIHtcbiAgICB0aGlzLnRhc2sgPSBudWxsO1xufVxuXG4vLyBUaGUgc29sZSBwdXJwb3NlIG9mIHdyYXBwaW5nIHRoZSB0YXNrIGlzIHRvIGNhdGNoIHRoZSBleGNlcHRpb24gYW5kIHJlY3ljbGVcbi8vIHRoZSB0YXNrIG9iamVjdCBhZnRlciBpdHMgc2luZ2xlIHVzZS5cblJhd1Rhc2sucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy50YXNrLmNhbGwoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoYXNhcC5vbmVycm9yKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGhvb2sgZXhpc3RzIHB1cmVseSBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAgICAgICAgICAgIC8vIEl0cyBuYW1lIHdpbGwgYmUgcGVyaW9kaWNhbGx5IHJhbmRvbWl6ZWQgdG8gYnJlYWsgYW55IGNvZGUgdGhhdFxuICAgICAgICAgICAgLy8gZGVwZW5kcyBvbiBpdHMgZXhpc3RlbmNlLlxuICAgICAgICAgICAgYXNhcC5vbmVycm9yKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEluIGEgd2ViIGJyb3dzZXIsIGV4Y2VwdGlvbnMgYXJlIG5vdCBmYXRhbC4gSG93ZXZlciwgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIHNsb3dpbmcgZG93biB0aGUgcXVldWUgb2YgcGVuZGluZyB0YXNrcywgd2UgcmV0aHJvdyB0aGUgZXJyb3IgaW4gYVxuICAgICAgICAgICAgLy8gbG93ZXIgcHJpb3JpdHkgdHVybi5cbiAgICAgICAgICAgIHBlbmRpbmdFcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgICAgICByZXF1ZXN0RXJyb3JUaHJvdygpO1xuICAgICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICAgICAgZnJlZVRhc2tzW2ZyZWVUYXNrcy5sZW5ndGhdID0gdGhpcztcbiAgICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFVzZSB0aGUgZmFzdGVzdCBtZWFucyBwb3NzaWJsZSB0byBleGVjdXRlIGEgdGFzayBpbiBpdHMgb3duIHR1cm4sIHdpdGhcbi8vIHByaW9yaXR5IG92ZXIgb3RoZXIgZXZlbnRzIGluY2x1ZGluZyBJTywgYW5pbWF0aW9uLCByZWZsb3csIGFuZCByZWRyYXdcbi8vIGV2ZW50cyBpbiBicm93c2Vycy5cbi8vXG4vLyBBbiBleGNlcHRpb24gdGhyb3duIGJ5IGEgdGFzayB3aWxsIHBlcm1hbmVudGx5IGludGVycnVwdCB0aGUgcHJvY2Vzc2luZyBvZlxuLy8gc3Vic2VxdWVudCB0YXNrcy4gVGhlIGhpZ2hlciBsZXZlbCBgYXNhcGAgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGlmIGFuXG4vLyBleGNlcHRpb24gaXMgdGhyb3duIGJ5IGEgdGFzaywgdGhhdCB0aGUgdGFzayBxdWV1ZSB3aWxsIGNvbnRpbnVlIGZsdXNoaW5nIGFzXG4vLyBzb29uIGFzIHBvc3NpYmxlLCBidXQgaWYgeW91IHVzZSBgcmF3QXNhcGAgZGlyZWN0bHksIHlvdSBhcmUgcmVzcG9uc2libGUgdG9cbi8vIGVpdGhlciBlbnN1cmUgdGhhdCBubyBleGNlcHRpb25zIGFyZSB0aHJvd24gZnJvbSB5b3VyIHRhc2ssIG9yIHRvIG1hbnVhbGx5XG4vLyBjYWxsIGByYXdBc2FwLnJlcXVlc3RGbHVzaGAgaWYgYW4gZXhjZXB0aW9uIGlzIHRocm93bi5cbm1vZHVsZS5leHBvcnRzID0gcmF3QXNhcDtcbmZ1bmN0aW9uIHJhd0FzYXAodGFzaykge1xuICAgIGlmICghcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHJlcXVlc3RGbHVzaCgpO1xuICAgICAgICBmbHVzaGluZyA9IHRydWU7XG4gICAgfVxuICAgIC8vIEVxdWl2YWxlbnQgdG8gcHVzaCwgYnV0IGF2b2lkcyBhIGZ1bmN0aW9uIGNhbGwuXG4gICAgcXVldWVbcXVldWUubGVuZ3RoXSA9IHRhc2s7XG59XG5cbnZhciBxdWV1ZSA9IFtdO1xuLy8gT25jZSBhIGZsdXNoIGhhcyBiZWVuIHJlcXVlc3RlZCwgbm8gZnVydGhlciBjYWxscyB0byBgcmVxdWVzdEZsdXNoYCBhcmVcbi8vIG5lY2Vzc2FyeSB1bnRpbCB0aGUgbmV4dCBgZmx1c2hgIGNvbXBsZXRlcy5cbnZhciBmbHVzaGluZyA9IGZhbHNlO1xuLy8gYHJlcXVlc3RGbHVzaGAgaXMgYW4gaW1wbGVtZW50YXRpb24tc3BlY2lmaWMgbWV0aG9kIHRoYXQgYXR0ZW1wdHMgdG8ga2lja1xuLy8gb2ZmIGEgYGZsdXNoYCBldmVudCBhcyBxdWlja2x5IGFzIHBvc3NpYmxlLiBgZmx1c2hgIHdpbGwgYXR0ZW1wdCB0byBleGhhdXN0XG4vLyB0aGUgZXZlbnQgcXVldWUgYmVmb3JlIHlpZWxkaW5nIHRvIHRoZSBicm93c2VyJ3Mgb3duIGV2ZW50IGxvb3AuXG52YXIgcmVxdWVzdEZsdXNoO1xuLy8gVGhlIHBvc2l0aW9uIG9mIHRoZSBuZXh0IHRhc2sgdG8gZXhlY3V0ZSBpbiB0aGUgdGFzayBxdWV1ZS4gVGhpcyBpc1xuLy8gcHJlc2VydmVkIGJldHdlZW4gY2FsbHMgdG8gYGZsdXNoYCBzbyB0aGF0IGl0IGNhbiBiZSByZXN1bWVkIGlmXG4vLyBhIHRhc2sgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbnZhciBpbmRleCA9IDA7XG4vLyBJZiBhIHRhc2sgc2NoZWR1bGVzIGFkZGl0aW9uYWwgdGFza3MgcmVjdXJzaXZlbHksIHRoZSB0YXNrIHF1ZXVlIGNhbiBncm93XG4vLyB1bmJvdW5kZWQuIFRvIHByZXZlbnQgbWVtb3J5IGV4aGF1c3Rpb24sIHRoZSB0YXNrIHF1ZXVlIHdpbGwgcGVyaW9kaWNhbGx5XG4vLyB0cnVuY2F0ZSBhbHJlYWR5LWNvbXBsZXRlZCB0YXNrcy5cbnZhciBjYXBhY2l0eSA9IDEwMjQ7XG5cbi8vIFRoZSBmbHVzaCBmdW5jdGlvbiBwcm9jZXNzZXMgYWxsIHRhc2tzIHRoYXQgaGF2ZSBiZWVuIHNjaGVkdWxlZCB3aXRoXG4vLyBgcmF3QXNhcGAgdW5sZXNzIGFuZCB1bnRpbCBvbmUgb2YgdGhvc2UgdGFza3MgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbi8vIElmIGEgdGFzayB0aHJvd3MgYW4gZXhjZXB0aW9uLCBgZmx1c2hgIGVuc3VyZXMgdGhhdCBpdHMgc3RhdGUgd2lsbCByZW1haW5cbi8vIGNvbnNpc3RlbnQgYW5kIHdpbGwgcmVzdW1lIHdoZXJlIGl0IGxlZnQgb2ZmIHdoZW4gY2FsbGVkIGFnYWluLlxuLy8gSG93ZXZlciwgYGZsdXNoYCBkb2VzIG5vdCBtYWtlIGFueSBhcnJhbmdlbWVudHMgdG8gYmUgY2FsbGVkIGFnYWluIGlmIGFuXG4vLyBleGNlcHRpb24gaXMgdGhyb3duLlxuZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgd2hpbGUgKGluZGV4IDwgcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBpbmRleDtcbiAgICAgICAgLy8gQWR2YW5jZSB0aGUgaW5kZXggYmVmb3JlIGNhbGxpbmcgdGhlIHRhc2suIFRoaXMgZW5zdXJlcyB0aGF0IHdlIHdpbGxcbiAgICAgICAgLy8gYmVnaW4gZmx1c2hpbmcgb24gdGhlIG5leHQgdGFzayB0aGUgdGFzayB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICAgIGluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICBxdWV1ZVtjdXJyZW50SW5kZXhdLmNhbGwoKTtcbiAgICAgICAgLy8gUHJldmVudCBsZWFraW5nIG1lbW9yeSBmb3IgbG9uZyBjaGFpbnMgb2YgcmVjdXJzaXZlIGNhbGxzIHRvIGBhc2FwYC5cbiAgICAgICAgLy8gSWYgd2UgY2FsbCBgYXNhcGAgd2l0aGluIHRhc2tzIHNjaGVkdWxlZCBieSBgYXNhcGAsIHRoZSBxdWV1ZSB3aWxsXG4gICAgICAgIC8vIGdyb3csIGJ1dCB0byBhdm9pZCBhbiBPKG4pIHdhbGsgZm9yIGV2ZXJ5IHRhc2sgd2UgZXhlY3V0ZSwgd2UgZG9uJ3RcbiAgICAgICAgLy8gc2hpZnQgdGFza3Mgb2ZmIHRoZSBxdWV1ZSBhZnRlciB0aGV5IGhhdmUgYmVlbiBleGVjdXRlZC5cbiAgICAgICAgLy8gSW5zdGVhZCwgd2UgcGVyaW9kaWNhbGx5IHNoaWZ0IDEwMjQgdGFza3Mgb2ZmIHRoZSBxdWV1ZS5cbiAgICAgICAgaWYgKGluZGV4ID4gY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IHNoaWZ0IGFsbCB2YWx1ZXMgc3RhcnRpbmcgYXQgdGhlIGluZGV4IGJhY2sgdG8gdGhlXG4gICAgICAgICAgICAvLyBiZWdpbm5pbmcgb2YgdGhlIHF1ZXVlLlxuICAgICAgICAgICAgZm9yICh2YXIgc2NhbiA9IDAsIG5ld0xlbmd0aCA9IHF1ZXVlLmxlbmd0aCAtIGluZGV4OyBzY2FuIDwgbmV3TGVuZ3RoOyBzY2FuKyspIHtcbiAgICAgICAgICAgICAgICBxdWV1ZVtzY2FuXSA9IHF1ZXVlW3NjYW4gKyBpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWV1ZS5sZW5ndGggLT0gaW5kZXg7XG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICBpbmRleCA9IDA7XG4gICAgZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLy8gYHJlcXVlc3RGbHVzaGAgaXMgaW1wbGVtZW50ZWQgdXNpbmcgYSBzdHJhdGVneSBiYXNlZCBvbiBkYXRhIGNvbGxlY3RlZCBmcm9tXG4vLyBldmVyeSBhdmFpbGFibGUgU2F1Y2VMYWJzIFNlbGVuaXVtIHdlYiBkcml2ZXIgd29ya2VyIGF0IHRpbWUgb2Ygd3JpdGluZy5cbi8vIGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL3NwcmVhZHNoZWV0cy9kLzFtRy01VVlHdXA1cXhHZEVNV2toUDZCV0N6MDUzTlViMkUxUW9VVFUxNnVBL2VkaXQjZ2lkPTc4MzcyNDU5M1xuXG4vLyBTYWZhcmkgNiBhbmQgNi4xIGZvciBkZXNrdG9wLCBpUGFkLCBhbmQgaVBob25lIGFyZSB0aGUgb25seSBicm93c2VycyB0aGF0XG4vLyBoYXZlIFdlYktpdE11dGF0aW9uT2JzZXJ2ZXIgYnV0IG5vdCB1bi1wcmVmaXhlZCBNdXRhdGlvbk9ic2VydmVyLlxuLy8gTXVzdCB1c2UgYGdsb2JhbGAgb3IgYHNlbGZgIGluc3RlYWQgb2YgYHdpbmRvd2AgdG8gd29yayBpbiBib3RoIGZyYW1lcyBhbmQgd2ViXG4vLyB3b3JrZXJzLiBgZ2xvYmFsYCBpcyBhIHByb3Zpc2lvbiBvZiBCcm93c2VyaWZ5LCBNciwgTXJzLCBvciBNb3AuXG5cbi8qIGdsb2JhbHMgc2VsZiAqL1xudmFyIHNjb3BlID0gdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHNlbGY7XG52YXIgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBzY29wZS5NdXRhdGlvbk9ic2VydmVyIHx8IHNjb3BlLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG5cbi8vIE11dGF0aW9uT2JzZXJ2ZXJzIGFyZSBkZXNpcmFibGUgYmVjYXVzZSB0aGV5IGhhdmUgaGlnaCBwcmlvcml0eSBhbmQgd29ya1xuLy8gcmVsaWFibHkgZXZlcnl3aGVyZSB0aGV5IGFyZSBpbXBsZW1lbnRlZC5cbi8vIFRoZXkgYXJlIGltcGxlbWVudGVkIGluIGFsbCBtb2Rlcm4gYnJvd3NlcnMuXG4vL1xuLy8gLSBBbmRyb2lkIDQtNC4zXG4vLyAtIENocm9tZSAyNi0zNFxuLy8gLSBGaXJlZm94IDE0LTI5XG4vLyAtIEludGVybmV0IEV4cGxvcmVyIDExXG4vLyAtIGlQYWQgU2FmYXJpIDYtNy4xXG4vLyAtIGlQaG9uZSBTYWZhcmkgNy03LjFcbi8vIC0gU2FmYXJpIDYtN1xuaWYgKHR5cGVvZiBCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmVxdWVzdEZsdXNoID0gbWFrZVJlcXVlc3RDYWxsRnJvbU11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpO1xuXG4vLyBNZXNzYWdlQ2hhbm5lbHMgYXJlIGRlc2lyYWJsZSBiZWNhdXNlIHRoZXkgZ2l2ZSBkaXJlY3QgYWNjZXNzIHRvIHRoZSBIVE1MXG4vLyB0YXNrIHF1ZXVlLCBhcmUgaW1wbGVtZW50ZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAsIFNhZmFyaSA1LjAtMSwgYW5kIE9wZXJhXG4vLyAxMS0xMiwgYW5kIGluIHdlYiB3b3JrZXJzIGluIG1hbnkgZW5naW5lcy5cbi8vIEFsdGhvdWdoIG1lc3NhZ2UgY2hhbm5lbHMgeWllbGQgdG8gYW55IHF1ZXVlZCByZW5kZXJpbmcgYW5kIElPIHRhc2tzLCB0aGV5XG4vLyB3b3VsZCBiZSBiZXR0ZXIgdGhhbiBpbXBvc2luZyB0aGUgNG1zIGRlbGF5IG9mIHRpbWVycy5cbi8vIEhvd2V2ZXIsIHRoZXkgZG8gbm90IHdvcmsgcmVsaWFibHkgaW4gSW50ZXJuZXQgRXhwbG9yZXIgb3IgU2FmYXJpLlxuXG4vLyBJbnRlcm5ldCBFeHBsb3JlciAxMCBpcyB0aGUgb25seSBicm93c2VyIHRoYXQgaGFzIHNldEltbWVkaWF0ZSBidXQgZG9lc1xuLy8gbm90IGhhdmUgTXV0YXRpb25PYnNlcnZlcnMuXG4vLyBBbHRob3VnaCBzZXRJbW1lZGlhdGUgeWllbGRzIHRvIHRoZSBicm93c2VyJ3MgcmVuZGVyZXIsIGl0IHdvdWxkIGJlXG4vLyBwcmVmZXJyYWJsZSB0byBmYWxsaW5nIGJhY2sgdG8gc2V0VGltZW91dCBzaW5jZSBpdCBkb2VzIG5vdCBoYXZlXG4vLyB0aGUgbWluaW11bSA0bXMgcGVuYWx0eS5cbi8vIFVuZm9ydHVuYXRlbHkgdGhlcmUgYXBwZWFycyB0byBiZSBhIGJ1ZyBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMCBNb2JpbGUgKGFuZFxuLy8gRGVza3RvcCB0byBhIGxlc3NlciBleHRlbnQpIHRoYXQgcmVuZGVycyBib3RoIHNldEltbWVkaWF0ZSBhbmRcbi8vIE1lc3NhZ2VDaGFubmVsIHVzZWxlc3MgZm9yIHRoZSBwdXJwb3NlcyBvZiBBU0FQLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2tyaXNrb3dhbC9xL2lzc3Vlcy8zOTZcblxuLy8gVGltZXJzIGFyZSBpbXBsZW1lbnRlZCB1bml2ZXJzYWxseS5cbi8vIFdlIGZhbGwgYmFjayB0byB0aW1lcnMgaW4gd29ya2VycyBpbiBtb3N0IGVuZ2luZXMsIGFuZCBpbiBmb3JlZ3JvdW5kXG4vLyBjb250ZXh0cyBpbiB0aGUgZm9sbG93aW5nIGJyb3dzZXJzLlxuLy8gSG93ZXZlciwgbm90ZSB0aGF0IGV2ZW4gdGhpcyBzaW1wbGUgY2FzZSByZXF1aXJlcyBudWFuY2VzIHRvIG9wZXJhdGUgaW4gYVxuLy8gYnJvYWQgc3BlY3RydW0gb2YgYnJvd3NlcnMuXG4vL1xuLy8gLSBGaXJlZm94IDMtMTNcbi8vIC0gSW50ZXJuZXQgRXhwbG9yZXIgNi05XG4vLyAtIGlQYWQgU2FmYXJpIDQuM1xuLy8gLSBMeW54IDIuOC43XG59IGVsc2Uge1xuICAgIHJlcXVlc3RGbHVzaCA9IG1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcihmbHVzaCk7XG59XG5cbi8vIGByZXF1ZXN0Rmx1c2hgIHJlcXVlc3RzIHRoYXQgdGhlIGhpZ2ggcHJpb3JpdHkgZXZlbnQgcXVldWUgYmUgZmx1c2hlZCBhc1xuLy8gc29vbiBhcyBwb3NzaWJsZS5cbi8vIFRoaXMgaXMgdXNlZnVsIHRvIHByZXZlbnQgYW4gZXJyb3IgdGhyb3duIGluIGEgdGFzayBmcm9tIHN0YWxsaW5nIHRoZSBldmVudFxuLy8gcXVldWUgaWYgdGhlIGV4Y2VwdGlvbiBoYW5kbGVkIGJ5IE5vZGUuanPigJlzXG4vLyBgcHJvY2Vzcy5vbihcInVuY2F1Z2h0RXhjZXB0aW9uXCIpYCBvciBieSBhIGRvbWFpbi5cbnJhd0FzYXAucmVxdWVzdEZsdXNoID0gcmVxdWVzdEZsdXNoO1xuXG4vLyBUbyByZXF1ZXN0IGEgaGlnaCBwcmlvcml0eSBldmVudCwgd2UgaW5kdWNlIGEgbXV0YXRpb24gb2JzZXJ2ZXIgYnkgdG9nZ2xpbmdcbi8vIHRoZSB0ZXh0IG9mIGEgdGV4dCBub2RlIGJldHdlZW4gXCIxXCIgYW5kIFwiLTFcIi5cbmZ1bmN0aW9uIG1ha2VSZXF1ZXN0Q2FsbEZyb21NdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRvZ2dsZSA9IDE7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKTtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO1xuICAgIG9ic2VydmVyLm9ic2VydmUobm9kZSwge2NoYXJhY3RlckRhdGE6IHRydWV9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4gICAgICAgIHRvZ2dsZSA9IC10b2dnbGU7XG4gICAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZTtcbiAgICB9O1xufVxuXG4vLyBUaGUgbWVzc2FnZSBjaGFubmVsIHRlY2huaXF1ZSB3YXMgZGlzY292ZXJlZCBieSBNYWx0ZSBVYmwgYW5kIHdhcyB0aGVcbi8vIG9yaWdpbmFsIGZvdW5kYXRpb24gZm9yIHRoaXMgbGlicmFyeS5cbi8vIGh0dHA6Ly93d3cubm9uYmxvY2tpbmcuaW8vMjAxMS8wNi93aW5kb3duZXh0dGljay5odG1sXG5cbi8vIFNhZmFyaSA2LjAuNSAoYXQgbGVhc3QpIGludGVybWl0dGVudGx5IGZhaWxzIHRvIGNyZWF0ZSBtZXNzYWdlIHBvcnRzIG9uIGFcbi8vIHBhZ2UncyBmaXJzdCBsb2FkLiBUaGFua2Z1bGx5LCB0aGlzIHZlcnNpb24gb2YgU2FmYXJpIHN1cHBvcnRzXG4vLyBNdXRhdGlvbk9ic2VydmVycywgc28gd2UgZG9uJ3QgbmVlZCB0byBmYWxsIGJhY2sgaW4gdGhhdCBjYXNlLlxuXG4vLyBmdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tTWVzc2FnZUNoYW5uZWwoY2FsbGJhY2spIHtcbi8vICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuLy8gICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gY2FsbGJhY2s7XG4vLyAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RDYWxsKCkge1xuLy8gICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuLy8gICAgIH07XG4vLyB9XG5cbi8vIEZvciByZWFzb25zIGV4cGxhaW5lZCBhYm92ZSwgd2UgYXJlIGFsc28gdW5hYmxlIHRvIHVzZSBgc2V0SW1tZWRpYXRlYFxuLy8gdW5kZXIgYW55IGNpcmN1bXN0YW5jZXMuXG4vLyBFdmVuIGlmIHdlIHdlcmUsIHRoZXJlIGlzIGFub3RoZXIgYnVnIGluIEludGVybmV0IEV4cGxvcmVyIDEwLlxuLy8gSXQgaXMgbm90IHN1ZmZpY2llbnQgdG8gYXNzaWduIGBzZXRJbW1lZGlhdGVgIHRvIGByZXF1ZXN0Rmx1c2hgIGJlY2F1c2Vcbi8vIGBzZXRJbW1lZGlhdGVgIG11c3QgYmUgY2FsbGVkICpieSBuYW1lKiBhbmQgdGhlcmVmb3JlIG11c3QgYmUgd3JhcHBlZCBpbiBhXG4vLyBjbG9zdXJlLlxuLy8gTmV2ZXIgZm9yZ2V0LlxuXG4vLyBmdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tU2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4vLyAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RDYWxsKCkge1xuLy8gICAgICAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xuLy8gICAgIH07XG4vLyB9XG5cbi8vIFNhZmFyaSA2LjAgaGFzIGEgcHJvYmxlbSB3aGVyZSB0aW1lcnMgd2lsbCBnZXQgbG9zdCB3aGlsZSB0aGUgdXNlciBpc1xuLy8gc2Nyb2xsaW5nLiBUaGlzIHByb2JsZW0gZG9lcyBub3QgaW1wYWN0IEFTQVAgYmVjYXVzZSBTYWZhcmkgNi4wIHN1cHBvcnRzXG4vLyBtdXRhdGlvbiBvYnNlcnZlcnMsIHNvIHRoYXQgaW1wbGVtZW50YXRpb24gaXMgdXNlZCBpbnN0ZWFkLlxuLy8gSG93ZXZlciwgaWYgd2UgZXZlciBlbGVjdCB0byB1c2UgdGltZXJzIGluIFNhZmFyaSwgdGhlIHByZXZhbGVudCB3b3JrLWFyb3VuZFxuLy8gaXMgdG8gYWRkIGEgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIHRoYXQgY2FsbHMgZm9yIGEgZmx1c2guXG5cbi8vIGBzZXRUaW1lb3V0YCBkb2VzIG5vdCBjYWxsIHRoZSBwYXNzZWQgY2FsbGJhY2sgaWYgdGhlIGRlbGF5IGlzIGxlc3MgdGhhblxuLy8gYXBwcm94aW1hdGVseSA3IGluIHdlYiB3b3JrZXJzIGluIEZpcmVmb3ggOCB0aHJvdWdoIDE4LCBhbmQgc29tZXRpbWVzIG5vdFxuLy8gZXZlbiB0aGVuLlxuXG5mdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tVGltZXIoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4gICAgICAgIC8vIFdlIGRpc3BhdGNoIGEgdGltZW91dCB3aXRoIGEgc3BlY2lmaWVkIGRlbGF5IG9mIDAgZm9yIGVuZ2luZXMgdGhhdFxuICAgICAgICAvLyBjYW4gcmVsaWFibHkgYWNjb21tb2RhdGUgdGhhdCByZXF1ZXN0LiBUaGlzIHdpbGwgdXN1YWxseSBiZSBzbmFwcGVkXG4gICAgICAgIC8vIHRvIGEgNCBtaWxpc2Vjb25kIGRlbGF5LCBidXQgb25jZSB3ZSdyZSBmbHVzaGluZywgdGhlcmUncyBubyBkZWxheVxuICAgICAgICAvLyBiZXR3ZWVuIGV2ZW50cy5cbiAgICAgICAgdmFyIHRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KGhhbmRsZVRpbWVyLCAwKTtcbiAgICAgICAgLy8gSG93ZXZlciwgc2luY2UgdGhpcyB0aW1lciBnZXRzIGZyZXF1ZW50bHkgZHJvcHBlZCBpbiBGaXJlZm94XG4gICAgICAgIC8vIHdvcmtlcnMsIHdlIGVubGlzdCBhbiBpbnRlcnZhbCBoYW5kbGUgdGhhdCB3aWxsIHRyeSB0byBmaXJlXG4gICAgICAgIC8vIGFuIGV2ZW50IDIwIHRpbWVzIHBlciBzZWNvbmQgdW50aWwgaXQgc3VjY2VlZHMuXG4gICAgICAgIHZhciBpbnRlcnZhbEhhbmRsZSA9IHNldEludGVydmFsKGhhbmRsZVRpbWVyLCA1MCk7XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlVGltZXIoKSB7XG4gICAgICAgICAgICAvLyBXaGljaGV2ZXIgdGltZXIgc3VjY2VlZHMgd2lsbCBjYW5jZWwgYm90aCB0aW1lcnMgYW5kXG4gICAgICAgICAgICAvLyBleGVjdXRlIHRoZSBjYWxsYmFjay5cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxIYW5kbGUpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8vIFRoaXMgaXMgZm9yIGBhc2FwLmpzYCBvbmx5LlxuLy8gSXRzIG5hbWUgd2lsbCBiZSBwZXJpb2RpY2FsbHkgcmFuZG9taXplZCB0byBicmVhayBhbnkgY29kZSB0aGF0IGRlcGVuZHMgb25cbi8vIGl0cyBleGlzdGVuY2UuXG5yYXdBc2FwLm1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lciA9IG1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcjtcblxuLy8gQVNBUCB3YXMgb3JpZ2luYWxseSBhIG5leHRUaWNrIHNoaW0gaW5jbHVkZWQgaW4gUS4gVGhpcyB3YXMgZmFjdG9yZWQgb3V0XG4vLyBpbnRvIHRoaXMgQVNBUCBwYWNrYWdlLiBJdCB3YXMgbGF0ZXIgYWRhcHRlZCB0byBSU1ZQIHdoaWNoIG1hZGUgZnVydGhlclxuLy8gYW1lbmRtZW50cy4gVGhlc2UgZGVjaXNpb25zLCBwYXJ0aWN1bGFybHkgdG8gbWFyZ2luYWxpemUgTWVzc2FnZUNoYW5uZWwgYW5kXG4vLyB0byBjYXB0dXJlIHRoZSBNdXRhdGlvbk9ic2VydmVyIGltcGxlbWVudGF0aW9uIGluIGEgY2xvc3VyZSwgd2VyZSBpbnRlZ3JhdGVkXG4vLyBiYWNrIGludG8gQVNBUCBwcm9wZXIuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGlsZGVpby9yc3ZwLmpzL2Jsb2IvY2RkZjcyMzI1NDZhOWNmODU4NTI0Yjc1Y2RlNmY5ZWRmNzI2MjBhNy9saWIvcnN2cC9hc2FwLmpzXG4iLCIvKipcbiAqIEV2RW1pdHRlciB2MS4xLjBcbiAqIExpbCcgZXZlbnQgZW1pdHRlclxuICogTUlUIExpY2Vuc2VcbiAqL1xuXG4vKiBqc2hpbnQgdW51c2VkOiB0cnVlLCB1bmRlZjogdHJ1ZSwgc3RyaWN0OiB0cnVlICovXG5cbiggZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcbiAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG4gIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qIGdsb2JhbHMgZGVmaW5lLCBtb2R1bGUsIHdpbmRvdyAqL1xuICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgIC8vIEFNRCAtIFJlcXVpcmVKU1xuICAgIGRlZmluZSggZmFjdG9yeSApO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTIC0gQnJvd3NlcmlmeSwgV2VicGFja1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgIGdsb2JhbC5FdkVtaXR0ZXIgPSBmYWN0b3J5KCk7XG4gIH1cblxufSggdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gRXZFbWl0dGVyKCkge31cblxudmFyIHByb3RvID0gRXZFbWl0dGVyLnByb3RvdHlwZTtcblxucHJvdG8ub24gPSBmdW5jdGlvbiggZXZlbnROYW1lLCBsaXN0ZW5lciApIHtcbiAgaWYgKCAhZXZlbnROYW1lIHx8ICFsaXN0ZW5lciApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gc2V0IGV2ZW50cyBoYXNoXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIC8vIHNldCBsaXN0ZW5lcnMgYXJyYXlcbiAgdmFyIGxpc3RlbmVycyA9IGV2ZW50c1sgZXZlbnROYW1lIF0gPSBldmVudHNbIGV2ZW50TmFtZSBdIHx8IFtdO1xuICAvLyBvbmx5IGFkZCBvbmNlXG4gIGlmICggbGlzdGVuZXJzLmluZGV4T2YoIGxpc3RlbmVyICkgPT0gLTEgKSB7XG4gICAgbGlzdGVuZXJzLnB1c2goIGxpc3RlbmVyICk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLm9uY2UgPSBmdW5jdGlvbiggZXZlbnROYW1lLCBsaXN0ZW5lciApIHtcbiAgaWYgKCAhZXZlbnROYW1lIHx8ICFsaXN0ZW5lciApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gYWRkIGV2ZW50XG4gIHRoaXMub24oIGV2ZW50TmFtZSwgbGlzdGVuZXIgKTtcbiAgLy8gc2V0IG9uY2UgZmxhZ1xuICAvLyBzZXQgb25jZUV2ZW50cyBoYXNoXG4gIHZhciBvbmNlRXZlbnRzID0gdGhpcy5fb25jZUV2ZW50cyA9IHRoaXMuX29uY2VFdmVudHMgfHwge307XG4gIC8vIHNldCBvbmNlTGlzdGVuZXJzIG9iamVjdFxuICB2YXIgb25jZUxpc3RlbmVycyA9IG9uY2VFdmVudHNbIGV2ZW50TmFtZSBdID0gb25jZUV2ZW50c1sgZXZlbnROYW1lIF0gfHwge307XG4gIC8vIHNldCBmbGFnXG4gIG9uY2VMaXN0ZW5lcnNbIGxpc3RlbmVyIF0gPSB0cnVlO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ub2ZmID0gZnVuY3Rpb24oIGV2ZW50TmFtZSwgbGlzdGVuZXIgKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzWyBldmVudE5hbWUgXTtcbiAgaWYgKCAhbGlzdGVuZXJzIHx8ICFsaXN0ZW5lcnMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZiggbGlzdGVuZXIgKTtcbiAgaWYgKCBpbmRleCAhPSAtMSApIHtcbiAgICBsaXN0ZW5lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5lbWl0RXZlbnQgPSBmdW5jdGlvbiggZXZlbnROYW1lLCBhcmdzICkge1xuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1sgZXZlbnROYW1lIF07XG4gIGlmICggIWxpc3RlbmVycyB8fCAhbGlzdGVuZXJzLmxlbmd0aCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gY29weSBvdmVyIHRvIGF2b2lkIGludGVyZmVyZW5jZSBpZiAub2ZmKCkgaW4gbGlzdGVuZXJcbiAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKDApO1xuICBhcmdzID0gYXJncyB8fCBbXTtcbiAgLy8gb25jZSBzdHVmZlxuICB2YXIgb25jZUxpc3RlbmVycyA9IHRoaXMuX29uY2VFdmVudHMgJiYgdGhpcy5fb25jZUV2ZW50c1sgZXZlbnROYW1lIF07XG5cbiAgZm9yICggdmFyIGk9MDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKyApIHtcbiAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV1cbiAgICB2YXIgaXNPbmNlID0gb25jZUxpc3RlbmVycyAmJiBvbmNlTGlzdGVuZXJzWyBsaXN0ZW5lciBdO1xuICAgIGlmICggaXNPbmNlICkge1xuICAgICAgLy8gcmVtb3ZlIGxpc3RlbmVyXG4gICAgICAvLyByZW1vdmUgYmVmb3JlIHRyaWdnZXIgdG8gcHJldmVudCByZWN1cnNpb25cbiAgICAgIHRoaXMub2ZmKCBldmVudE5hbWUsIGxpc3RlbmVyICk7XG4gICAgICAvLyB1bnNldCBvbmNlIGZsYWdcbiAgICAgIGRlbGV0ZSBvbmNlTGlzdGVuZXJzWyBsaXN0ZW5lciBdO1xuICAgIH1cbiAgICAvLyB0cmlnZ2VyIGxpc3RlbmVyXG4gICAgbGlzdGVuZXIuYXBwbHkoIHRoaXMsIGFyZ3MgKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8uYWxsT2ZmID0gZnVuY3Rpb24oKSB7XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHM7XG4gIGRlbGV0ZSB0aGlzLl9vbmNlRXZlbnRzO1xufTtcblxucmV0dXJuIEV2RW1pdHRlcjtcblxufSkpO1xuIiwiLyohXG4gKiBpbWFnZXNMb2FkZWQgdjQuMS4zXG4gKiBKYXZhU2NyaXB0IGlzIGFsbCBsaWtlIFwiWW91IGltYWdlcyBhcmUgZG9uZSB5ZXQgb3Igd2hhdD9cIlxuICogTUlUIExpY2Vuc2VcbiAqL1xuXG4oIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7ICd1c2Ugc3RyaWN0JztcbiAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG5cbiAgLypnbG9iYWwgZGVmaW5lOiBmYWxzZSwgbW9kdWxlOiBmYWxzZSwgcmVxdWlyZTogZmFsc2UgKi9cblxuICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgIC8vIEFNRFxuICAgIGRlZmluZSggW1xuICAgICAgJ2V2LWVtaXR0ZXIvZXYtZW1pdHRlcidcbiAgICBdLCBmdW5jdGlvbiggRXZFbWl0dGVyICkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkoIHdpbmRvdywgRXZFbWl0dGVyICk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICByZXF1aXJlKCdldi1lbWl0dGVyJylcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgd2luZG93LmltYWdlc0xvYWRlZCA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICB3aW5kb3cuRXZFbWl0dGVyXG4gICAgKTtcbiAgfVxuXG59KSggdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzLFxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgZmFjdG9yeSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5mdW5jdGlvbiBmYWN0b3J5KCB3aW5kb3csIEV2RW1pdHRlciApIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgJCA9IHdpbmRvdy5qUXVlcnk7XG52YXIgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBoZWxwZXJzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbi8vIGV4dGVuZCBvYmplY3RzXG5mdW5jdGlvbiBleHRlbmQoIGEsIGIgKSB7XG4gIGZvciAoIHZhciBwcm9wIGluIGIgKSB7XG4gICAgYVsgcHJvcCBdID0gYlsgcHJvcCBdO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG4vLyB0dXJuIGVsZW1lbnQgb3Igbm9kZUxpc3QgaW50byBhbiBhcnJheVxuZnVuY3Rpb24gbWFrZUFycmF5KCBvYmogKSB7XG4gIHZhciBhcnkgPSBbXTtcbiAgaWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApIHtcbiAgICAvLyB1c2Ugb2JqZWN0IGlmIGFscmVhZHkgYW4gYXJyYXlcbiAgICBhcnkgPSBvYmo7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBvYmoubGVuZ3RoID09ICdudW1iZXInICkge1xuICAgIC8vIGNvbnZlcnQgbm9kZUxpc3QgdG8gYXJyYXlcbiAgICBmb3IgKCB2YXIgaT0wOyBpIDwgb2JqLmxlbmd0aDsgaSsrICkge1xuICAgICAgYXJ5LnB1c2goIG9ialtpXSApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBhcnJheSBvZiBzaW5nbGUgaW5kZXhcbiAgICBhcnkucHVzaCggb2JqICk7XG4gIH1cbiAgcmV0dXJuIGFyeTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gaW1hZ2VzTG9hZGVkIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheSwgRWxlbWVudCwgTm9kZUxpc3QsIFN0cmluZ30gZWxlbVxuICogQHBhcmFtIHtPYmplY3Qgb3IgRnVuY3Rpb259IG9wdGlvbnMgLSBpZiBmdW5jdGlvbiwgdXNlIGFzIGNhbGxiYWNrXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkFsd2F5cyAtIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIEltYWdlc0xvYWRlZCggZWxlbSwgb3B0aW9ucywgb25BbHdheXMgKSB7XG4gIC8vIGNvZXJjZSBJbWFnZXNMb2FkZWQoKSB3aXRob3V0IG5ldywgdG8gYmUgbmV3IEltYWdlc0xvYWRlZCgpXG4gIGlmICggISggdGhpcyBpbnN0YW5jZW9mIEltYWdlc0xvYWRlZCApICkge1xuICAgIHJldHVybiBuZXcgSW1hZ2VzTG9hZGVkKCBlbGVtLCBvcHRpb25zLCBvbkFsd2F5cyApO1xuICB9XG4gIC8vIHVzZSBlbGVtIGFzIHNlbGVjdG9yIHN0cmluZ1xuICBpZiAoIHR5cGVvZiBlbGVtID09ICdzdHJpbmcnICkge1xuICAgIGVsZW0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCBlbGVtICk7XG4gIH1cblxuICB0aGlzLmVsZW1lbnRzID0gbWFrZUFycmF5KCBlbGVtICk7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCgge30sIHRoaXMub3B0aW9ucyApO1xuXG4gIGlmICggdHlwZW9mIG9wdGlvbnMgPT0gJ2Z1bmN0aW9uJyApIHtcbiAgICBvbkFsd2F5cyA9IG9wdGlvbnM7XG4gIH0gZWxzZSB7XG4gICAgZXh0ZW5kKCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMgKTtcbiAgfVxuXG4gIGlmICggb25BbHdheXMgKSB7XG4gICAgdGhpcy5vbiggJ2Fsd2F5cycsIG9uQWx3YXlzICk7XG4gIH1cblxuICB0aGlzLmdldEltYWdlcygpO1xuXG4gIGlmICggJCApIHtcbiAgICAvLyBhZGQgalF1ZXJ5IERlZmVycmVkIG9iamVjdFxuICAgIHRoaXMuanFEZWZlcnJlZCA9IG5ldyAkLkRlZmVycmVkKCk7XG4gIH1cblxuICAvLyBIQUNLIGNoZWNrIGFzeW5jIHRvIGFsbG93IHRpbWUgdG8gYmluZCBsaXN0ZW5lcnNcbiAgc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jaGVjaygpO1xuICB9LmJpbmQoIHRoaXMgKSk7XG59XG5cbkltYWdlc0xvYWRlZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdkVtaXR0ZXIucHJvdG90eXBlICk7XG5cbkltYWdlc0xvYWRlZC5wcm90b3R5cGUub3B0aW9ucyA9IHt9O1xuXG5JbWFnZXNMb2FkZWQucHJvdG90eXBlLmdldEltYWdlcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmltYWdlcyA9IFtdO1xuXG4gIC8vIGZpbHRlciAmIGZpbmQgaXRlbXMgaWYgd2UgaGF2ZSBhbiBpdGVtIHNlbGVjdG9yXG4gIHRoaXMuZWxlbWVudHMuZm9yRWFjaCggdGhpcy5hZGRFbGVtZW50SW1hZ2VzLCB0aGlzICk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gZWxlbWVudFxuICovXG5JbWFnZXNMb2FkZWQucHJvdG90eXBlLmFkZEVsZW1lbnRJbWFnZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgLy8gZmlsdGVyIHNpYmxpbmdzXG4gIGlmICggZWxlbS5ub2RlTmFtZSA9PSAnSU1HJyApIHtcbiAgICB0aGlzLmFkZEltYWdlKCBlbGVtICk7XG4gIH1cbiAgLy8gZ2V0IGJhY2tncm91bmQgaW1hZ2Ugb24gZWxlbWVudFxuICBpZiAoIHRoaXMub3B0aW9ucy5iYWNrZ3JvdW5kID09PSB0cnVlICkge1xuICAgIHRoaXMuYWRkRWxlbWVudEJhY2tncm91bmRJbWFnZXMoIGVsZW0gKTtcbiAgfVxuXG4gIC8vIGZpbmQgY2hpbGRyZW5cbiAgLy8gbm8gbm9uLWVsZW1lbnQgbm9kZXMsICMxNDNcbiAgdmFyIG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcbiAgaWYgKCAhbm9kZVR5cGUgfHwgIWVsZW1lbnROb2RlVHlwZXNbIG5vZGVUeXBlIF0gKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjaGlsZEltZ3MgPSBlbGVtLnF1ZXJ5U2VsZWN0b3JBbGwoJ2ltZycpO1xuICAvLyBjb25jYXQgY2hpbGRFbGVtcyB0byBmaWx0ZXJGb3VuZCBhcnJheVxuICBmb3IgKCB2YXIgaT0wOyBpIDwgY2hpbGRJbWdzLmxlbmd0aDsgaSsrICkge1xuICAgIHZhciBpbWcgPSBjaGlsZEltZ3NbaV07XG4gICAgdGhpcy5hZGRJbWFnZSggaW1nICk7XG4gIH1cblxuICAvLyBnZXQgY2hpbGQgYmFja2dyb3VuZCBpbWFnZXNcbiAgaWYgKCB0eXBlb2YgdGhpcy5vcHRpb25zLmJhY2tncm91bmQgPT0gJ3N0cmluZycgKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gZWxlbS5xdWVyeVNlbGVjdG9yQWxsKCB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZCApO1xuICAgIGZvciAoIGk9MDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrICkge1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICB0aGlzLmFkZEVsZW1lbnRCYWNrZ3JvdW5kSW1hZ2VzKCBjaGlsZCApO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGVsZW1lbnROb2RlVHlwZXMgPSB7XG4gIDE6IHRydWUsXG4gIDk6IHRydWUsXG4gIDExOiB0cnVlXG59O1xuXG5JbWFnZXNMb2FkZWQucHJvdG90eXBlLmFkZEVsZW1lbnRCYWNrZ3JvdW5kSW1hZ2VzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcbiAgaWYgKCAhc3R5bGUgKSB7XG4gICAgLy8gRmlyZWZveCByZXR1cm5zIG51bGwgaWYgaW4gYSBoaWRkZW4gaWZyYW1lIGh0dHBzOi8vYnVnemlsLmxhLzU0ODM5N1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBnZXQgdXJsIGluc2lkZSB1cmwoXCIuLi5cIilcbiAgdmFyIHJlVVJMID0gL3VybFxcKChbJ1wiXSk/KC4qPylcXDFcXCkvZ2k7XG4gIHZhciBtYXRjaGVzID0gcmVVUkwuZXhlYyggc3R5bGUuYmFja2dyb3VuZEltYWdlICk7XG4gIHdoaWxlICggbWF0Y2hlcyAhPT0gbnVsbCApIHtcbiAgICB2YXIgdXJsID0gbWF0Y2hlcyAmJiBtYXRjaGVzWzJdO1xuICAgIGlmICggdXJsICkge1xuICAgICAgdGhpcy5hZGRCYWNrZ3JvdW5kKCB1cmwsIGVsZW0gKTtcbiAgICB9XG4gICAgbWF0Y2hlcyA9IHJlVVJMLmV4ZWMoIHN0eWxlLmJhY2tncm91bmRJbWFnZSApO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SW1hZ2V9IGltZ1xuICovXG5JbWFnZXNMb2FkZWQucHJvdG90eXBlLmFkZEltYWdlID0gZnVuY3Rpb24oIGltZyApIHtcbiAgdmFyIGxvYWRpbmdJbWFnZSA9IG5ldyBMb2FkaW5nSW1hZ2UoIGltZyApO1xuICB0aGlzLmltYWdlcy5wdXNoKCBsb2FkaW5nSW1hZ2UgKTtcbn07XG5cbkltYWdlc0xvYWRlZC5wcm90b3R5cGUuYWRkQmFja2dyb3VuZCA9IGZ1bmN0aW9uKCB1cmwsIGVsZW0gKSB7XG4gIHZhciBiYWNrZ3JvdW5kID0gbmV3IEJhY2tncm91bmQoIHVybCwgZWxlbSApO1xuICB0aGlzLmltYWdlcy5wdXNoKCBiYWNrZ3JvdW5kICk7XG59O1xuXG5JbWFnZXNMb2FkZWQucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIHRoaXMucHJvZ3Jlc3NlZENvdW50ID0gMDtcbiAgdGhpcy5oYXNBbnlCcm9rZW4gPSBmYWxzZTtcbiAgLy8gY29tcGxldGUgaWYgbm8gaW1hZ2VzXG4gIGlmICggIXRoaXMuaW1hZ2VzLmxlbmd0aCApIHtcbiAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Qcm9ncmVzcyggaW1hZ2UsIGVsZW0sIG1lc3NhZ2UgKSB7XG4gICAgLy8gSEFDSyAtIENocm9tZSB0cmlnZ2VycyBldmVudCBiZWZvcmUgb2JqZWN0IHByb3BlcnRpZXMgaGF2ZSBjaGFuZ2VkLiAjODNcbiAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgIF90aGlzLnByb2dyZXNzKCBpbWFnZSwgZWxlbSwgbWVzc2FnZSApO1xuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5pbWFnZXMuZm9yRWFjaCggZnVuY3Rpb24oIGxvYWRpbmdJbWFnZSApIHtcbiAgICBsb2FkaW5nSW1hZ2Uub25jZSggJ3Byb2dyZXNzJywgb25Qcm9ncmVzcyApO1xuICAgIGxvYWRpbmdJbWFnZS5jaGVjaygpO1xuICB9KTtcbn07XG5cbkltYWdlc0xvYWRlZC5wcm90b3R5cGUucHJvZ3Jlc3MgPSBmdW5jdGlvbiggaW1hZ2UsIGVsZW0sIG1lc3NhZ2UgKSB7XG4gIHRoaXMucHJvZ3Jlc3NlZENvdW50Kys7XG4gIHRoaXMuaGFzQW55QnJva2VuID0gdGhpcy5oYXNBbnlCcm9rZW4gfHwgIWltYWdlLmlzTG9hZGVkO1xuICAvLyBwcm9ncmVzcyBldmVudFxuICB0aGlzLmVtaXRFdmVudCggJ3Byb2dyZXNzJywgWyB0aGlzLCBpbWFnZSwgZWxlbSBdICk7XG4gIGlmICggdGhpcy5qcURlZmVycmVkICYmIHRoaXMuanFEZWZlcnJlZC5ub3RpZnkgKSB7XG4gICAgdGhpcy5qcURlZmVycmVkLm5vdGlmeSggdGhpcywgaW1hZ2UgKTtcbiAgfVxuICAvLyBjaGVjayBpZiBjb21wbGV0ZWRcbiAgaWYgKCB0aGlzLnByb2dyZXNzZWRDb3VudCA9PSB0aGlzLmltYWdlcy5sZW5ndGggKSB7XG4gICAgdGhpcy5jb21wbGV0ZSgpO1xuICB9XG5cbiAgaWYgKCB0aGlzLm9wdGlvbnMuZGVidWcgJiYgY29uc29sZSApIHtcbiAgICBjb25zb2xlLmxvZyggJ3Byb2dyZXNzOiAnICsgbWVzc2FnZSwgaW1hZ2UsIGVsZW0gKTtcbiAgfVxufTtcblxuSW1hZ2VzTG9hZGVkLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZXZlbnROYW1lID0gdGhpcy5oYXNBbnlCcm9rZW4gPyAnZmFpbCcgOiAnZG9uZSc7XG4gIHRoaXMuaXNDb21wbGV0ZSA9IHRydWU7XG4gIHRoaXMuZW1pdEV2ZW50KCBldmVudE5hbWUsIFsgdGhpcyBdICk7XG4gIHRoaXMuZW1pdEV2ZW50KCAnYWx3YXlzJywgWyB0aGlzIF0gKTtcbiAgaWYgKCB0aGlzLmpxRGVmZXJyZWQgKSB7XG4gICAgdmFyIGpxTWV0aG9kID0gdGhpcy5oYXNBbnlCcm9rZW4gPyAncmVqZWN0JyA6ICdyZXNvbHZlJztcbiAgICB0aGlzLmpxRGVmZXJyZWRbIGpxTWV0aG9kIF0oIHRoaXMgKTtcbiAgfVxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbmZ1bmN0aW9uIExvYWRpbmdJbWFnZSggaW1nICkge1xuICB0aGlzLmltZyA9IGltZztcbn1cblxuTG9hZGluZ0ltYWdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2RW1pdHRlci5wcm90b3R5cGUgKTtcblxuTG9hZGluZ0ltYWdlLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKCkge1xuICAvLyBJZiBjb21wbGV0ZSBpcyB0cnVlIGFuZCBicm93c2VyIHN1cHBvcnRzIG5hdHVyYWwgc2l6ZXMsXG4gIC8vIHRyeSB0byBjaGVjayBmb3IgaW1hZ2Ugc3RhdHVzIG1hbnVhbGx5LlxuICB2YXIgaXNDb21wbGV0ZSA9IHRoaXMuZ2V0SXNJbWFnZUNvbXBsZXRlKCk7XG4gIGlmICggaXNDb21wbGV0ZSApIHtcbiAgICAvLyByZXBvcnQgYmFzZWQgb24gbmF0dXJhbFdpZHRoXG4gICAgdGhpcy5jb25maXJtKCB0aGlzLmltZy5uYXR1cmFsV2lkdGggIT09IDAsICduYXR1cmFsV2lkdGgnICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgbm9uZSBvZiB0aGUgY2hlY2tzIGFib3ZlIG1hdGNoZWQsIHNpbXVsYXRlIGxvYWRpbmcgb24gZGV0YWNoZWQgZWxlbWVudC5cbiAgdGhpcy5wcm94eUltYWdlID0gbmV3IEltYWdlKCk7XG4gIHRoaXMucHJveHlJbWFnZS5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIHRoaXMgKTtcbiAgdGhpcy5wcm94eUltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIHRoaXMgKTtcbiAgLy8gYmluZCB0byBpbWFnZSBhcyB3ZWxsIGZvciBGaXJlZm94LiAjMTkxXG4gIHRoaXMuaW1nLmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgdGhpcyApO1xuICB0aGlzLmltZy5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCB0aGlzICk7XG4gIHRoaXMucHJveHlJbWFnZS5zcmMgPSB0aGlzLmltZy5zcmM7XG59O1xuXG5Mb2FkaW5nSW1hZ2UucHJvdG90eXBlLmdldElzSW1hZ2VDb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5pbWcuY29tcGxldGUgJiYgdGhpcy5pbWcubmF0dXJhbFdpZHRoICE9PSB1bmRlZmluZWQ7XG59O1xuXG5Mb2FkaW5nSW1hZ2UucHJvdG90eXBlLmNvbmZpcm0gPSBmdW5jdGlvbiggaXNMb2FkZWQsIG1lc3NhZ2UgKSB7XG4gIHRoaXMuaXNMb2FkZWQgPSBpc0xvYWRlZDtcbiAgdGhpcy5lbWl0RXZlbnQoICdwcm9ncmVzcycsIFsgdGhpcywgdGhpcy5pbWcsIG1lc3NhZ2UgXSApO1xufTtcblxuLy8gLS0tLS0gZXZlbnRzIC0tLS0tIC8vXG5cbi8vIHRyaWdnZXIgc3BlY2lmaWVkIGhhbmRsZXIgZm9yIGV2ZW50IHR5cGVcbkxvYWRpbmdJbWFnZS5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciBtZXRob2QgPSAnb24nICsgZXZlbnQudHlwZTtcbiAgaWYgKCB0aGlzWyBtZXRob2QgXSApIHtcbiAgICB0aGlzWyBtZXRob2QgXSggZXZlbnQgKTtcbiAgfVxufTtcblxuTG9hZGluZ0ltYWdlLnByb3RvdHlwZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jb25maXJtKCB0cnVlLCAnb25sb2FkJyApO1xuICB0aGlzLnVuYmluZEV2ZW50cygpO1xufTtcblxuTG9hZGluZ0ltYWdlLnByb3RvdHlwZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY29uZmlybSggZmFsc2UsICdvbmVycm9yJyApO1xuICB0aGlzLnVuYmluZEV2ZW50cygpO1xufTtcblxuTG9hZGluZ0ltYWdlLnByb3RvdHlwZS51bmJpbmRFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wcm94eUltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdsb2FkJywgdGhpcyApO1xuICB0aGlzLnByb3h5SW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgdGhpcyApO1xuICB0aGlzLmltZy5yZW1vdmVFdmVudExpc3RlbmVyKCAnbG9hZCcsIHRoaXMgKTtcbiAgdGhpcy5pbWcucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgdGhpcyApO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gQmFja2dyb3VuZCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5mdW5jdGlvbiBCYWNrZ3JvdW5kKCB1cmwsIGVsZW1lbnQgKSB7XG4gIHRoaXMudXJsID0gdXJsO1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLmltZyA9IG5ldyBJbWFnZSgpO1xufVxuXG4vLyBpbmhlcml0IExvYWRpbmdJbWFnZSBwcm90b3R5cGVcbkJhY2tncm91bmQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTG9hZGluZ0ltYWdlLnByb3RvdHlwZSApO1xuXG5CYWNrZ3JvdW5kLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmltZy5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIHRoaXMgKTtcbiAgdGhpcy5pbWcuYWRkRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgdGhpcyApO1xuICB0aGlzLmltZy5zcmMgPSB0aGlzLnVybDtcbiAgLy8gY2hlY2sgaWYgaW1hZ2UgaXMgYWxyZWFkeSBjb21wbGV0ZVxuICB2YXIgaXNDb21wbGV0ZSA9IHRoaXMuZ2V0SXNJbWFnZUNvbXBsZXRlKCk7XG4gIGlmICggaXNDb21wbGV0ZSApIHtcbiAgICB0aGlzLmNvbmZpcm0oIHRoaXMuaW1nLm5hdHVyYWxXaWR0aCAhPT0gMCwgJ25hdHVyYWxXaWR0aCcgKTtcbiAgICB0aGlzLnVuYmluZEV2ZW50cygpO1xuICB9XG59O1xuXG5CYWNrZ3JvdW5kLnByb3RvdHlwZS51bmJpbmRFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pbWcucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCB0aGlzICk7XG4gIHRoaXMuaW1nLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdlcnJvcicsIHRoaXMgKTtcbn07XG5cbkJhY2tncm91bmQucHJvdG90eXBlLmNvbmZpcm0gPSBmdW5jdGlvbiggaXNMb2FkZWQsIG1lc3NhZ2UgKSB7XG4gIHRoaXMuaXNMb2FkZWQgPSBpc0xvYWRlZDtcbiAgdGhpcy5lbWl0RXZlbnQoICdwcm9ncmVzcycsIFsgdGhpcywgdGhpcy5lbGVtZW50LCBtZXNzYWdlIF0gKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGpRdWVyeSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5JbWFnZXNMb2FkZWQubWFrZUpRdWVyeVBsdWdpbiA9IGZ1bmN0aW9uKCBqUXVlcnkgKSB7XG4gIGpRdWVyeSA9IGpRdWVyeSB8fCB3aW5kb3cualF1ZXJ5O1xuICBpZiAoICFqUXVlcnkgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHNldCBsb2NhbCB2YXJpYWJsZVxuICAkID0galF1ZXJ5O1xuICAvLyAkKCkuaW1hZ2VzTG9hZGVkKClcbiAgJC5mbi5pbWFnZXNMb2FkZWQgPSBmdW5jdGlvbiggb3B0aW9ucywgY2FsbGJhY2sgKSB7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IEltYWdlc0xvYWRlZCggdGhpcywgb3B0aW9ucywgY2FsbGJhY2sgKTtcbiAgICByZXR1cm4gaW5zdGFuY2UuanFEZWZlcnJlZC5wcm9taXNlKCAkKHRoaXMpICk7XG4gIH07XG59O1xuLy8gdHJ5IG1ha2luZyBwbHVnaW5cbkltYWdlc0xvYWRlZC5tYWtlSlF1ZXJ5UGx1Z2luKCk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5yZXR1cm4gSW1hZ2VzTG9hZGVkO1xuXG59KTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIGxvZGFzaCAzLjEwLjEgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gLWQgLW8gLi9pbmRleC5qc2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuOyhmdW5jdGlvbigpIHtcblxuICAvKiogVXNlZCBhcyBhIHNhZmUgcmVmZXJlbmNlIGZvciBgdW5kZWZpbmVkYCBpbiBwcmUtRVM1IGVudmlyb25tZW50cy4gKi9cbiAgdmFyIHVuZGVmaW5lZDtcblxuICAvKiogVXNlZCBhcyB0aGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuICovXG4gIHZhciBWRVJTSU9OID0gJzMuMTAuMSc7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3Igd3JhcHBlciBtZXRhZGF0YS4gKi9cbiAgdmFyIEJJTkRfRkxBRyA9IDEsXG4gICAgICBCSU5EX0tFWV9GTEFHID0gMixcbiAgICAgIENVUlJZX0JPVU5EX0ZMQUcgPSA0LFxuICAgICAgQ1VSUllfRkxBRyA9IDgsXG4gICAgICBDVVJSWV9SSUdIVF9GTEFHID0gMTYsXG4gICAgICBQQVJUSUFMX0ZMQUcgPSAzMixcbiAgICAgIFBBUlRJQUxfUklHSFRfRkxBRyA9IDY0LFxuICAgICAgQVJZX0ZMQUcgPSAxMjgsXG4gICAgICBSRUFSR19GTEFHID0gMjU2O1xuXG4gIC8qKiBVc2VkIGFzIGRlZmF1bHQgb3B0aW9ucyBmb3IgYF8udHJ1bmNgLiAqL1xuICB2YXIgREVGQVVMVF9UUlVOQ19MRU5HVEggPSAzMCxcbiAgICAgIERFRkFVTFRfVFJVTkNfT01JU1NJT04gPSAnLi4uJztcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgd2hlbiBhIGZ1bmN0aW9uIGJlY29tZXMgaG90LiAqL1xuICB2YXIgSE9UX0NPVU5UID0gMTUwLFxuICAgICAgSE9UX1NQQU4gPSAxNjtcblxuICAvKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbiAgdmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbiAgLyoqIFVzZWQgdG8gaW5kaWNhdGUgdGhlIHR5cGUgb2YgbGF6eSBpdGVyYXRlZXMuICovXG4gIHZhciBMQVpZX0ZJTFRFUl9GTEFHID0gMSxcbiAgICAgIExBWllfTUFQX0ZMQUcgPSAyO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG4gIHZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIGludGVybmFsIGFyZ3VtZW50IHBsYWNlaG9sZGVyLiAqL1xuICB2YXIgUExBQ0VIT0xERVIgPSAnX19sb2Rhc2hfcGxhY2Vob2xkZXJfXyc7XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuICB2YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbiAgdmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuICAvKiogVXNlZCB0byBtYXRjaCBlbXB0eSBzdHJpbmcgbGl0ZXJhbHMgaW4gY29tcGlsZWQgdGVtcGxhdGUgc291cmNlLiAqL1xuICB2YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycy4gKi9cbiAgdmFyIHJlRXNjYXBlZEh0bWwgPSAvJig/OmFtcHxsdHxndHxxdW90fCMzOXwjOTYpOy9nLFxuICAgICAgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIidgXS9nLFxuICAgICAgcmVIYXNFc2NhcGVkSHRtbCA9IFJlZ0V4cChyZUVzY2FwZWRIdG1sLnNvdXJjZSksXG4gICAgICByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbiAgdmFyIHJlRXNjYXBlID0gLzwlLShbXFxzXFxTXSs/KSU+L2csXG4gICAgICByZUV2YWx1YXRlID0gLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICAgIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG4gIHZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXG5cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvLFxuICAgICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXG5cXFxcXXxcXFxcLikqPylcXDIpXFxdL2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1wYXR0ZXJucylcbiAgICogYW5kIHRob3NlIG91dGxpbmVkIGJ5IFtgRXNjYXBlUmVnRXhwUGF0dGVybmBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWVzY2FwZXJlZ2V4cHBhdHRlcm4pLlxuICAgKi9cbiAgdmFyIHJlUmVnRXhwQ2hhcnMgPSAvXls6ISxdfFtcXFxcXiQuKis/KClbXFxde318XFwvXXwoXlswLTlhLWZBLUZucnR1dnhdKXwoW1xcblxcclxcdTIwMjhcXHUyMDI5XSkvZyxcbiAgICAgIHJlSGFzUmVnRXhwQ2hhcnMgPSBSZWdFeHAocmVSZWdFeHBDaGFycy5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuICovXG4gIHZhciByZUNvbWJvTWFyayA9IC9bXFx1MDMwMC1cXHUwMzZmXFx1ZmUyMC1cXHVmZTIzXS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggW0VTIHRlbXBsYXRlIGRlbGltaXRlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRlbXBsYXRlLWxpdGVyYWwtbGV4aWNhbC1jb21wb25lbnRzKS4gKi9cbiAgdmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVIYXNIZXhQcmVmaXggPSAvXjBbeFhdLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSA+IDUpLiAqL1xuICB2YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG4gIHZhciByZUlzVWludCA9IC9eXFxkKyQvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGxhdGluLTEgc3VwcGxlbWVudGFyeSBsZXR0ZXJzIChleGNsdWRpbmcgbWF0aGVtYXRpY2FsIG9wZXJhdG9ycykuICovXG4gIHZhciByZUxhdGluMSA9IC9bXFx4YzAtXFx4ZDZcXHhkOC1cXHhkZVxceGRmLVxceGY2XFx4ZjgtXFx4ZmZdL2c7XG5cbiAgLyoqIFVzZWQgdG8gZW5zdXJlIGNhcHR1cmluZyBvcmRlciBvZiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xuICB2YXIgcmVOb01hdGNoID0gLygkXikvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbiAgdmFyIHJlVW5lc2NhcGVkU3RyaW5nID0gL1snXFxuXFxyXFx1MjAyOFxcdTIwMjlcXFxcXS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHdvcmRzIHRvIGNyZWF0ZSBjb21wb3VuZCB3b3Jkcy4gKi9cbiAgdmFyIHJlV29yZHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHVwcGVyID0gJ1tBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGVdJyxcbiAgICAgICAgbG93ZXIgPSAnW2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZl0rJztcblxuICAgIHJldHVybiBSZWdFeHAodXBwZXIgKyAnKyg/PScgKyB1cHBlciArIGxvd2VyICsgJyl8JyArIHVwcGVyICsgJz8nICsgbG93ZXIgKyAnfCcgKyB1cHBlciArICcrfFswLTldKycsICdnJyk7XG4gIH0oKSk7XG5cbiAgLyoqIFVzZWQgdG8gYXNzaWduIGRlZmF1bHQgYGNvbnRleHRgIG9iamVjdCBwcm9wZXJ0aWVzLiAqL1xuICB2YXIgY29udGV4dFByb3BzID0gW1xuICAgICdBcnJheScsICdBcnJheUJ1ZmZlcicsICdEYXRlJywgJ0Vycm9yJywgJ0Zsb2F0MzJBcnJheScsICdGbG9hdDY0QXJyYXknLFxuICAgICdGdW5jdGlvbicsICdJbnQ4QXJyYXknLCAnSW50MTZBcnJheScsICdJbnQzMkFycmF5JywgJ01hdGgnLCAnTnVtYmVyJyxcbiAgICAnT2JqZWN0JywgJ1JlZ0V4cCcsICdTZXQnLCAnU3RyaW5nJywgJ18nLCAnY2xlYXJUaW1lb3V0JywgJ2lzRmluaXRlJyxcbiAgICAncGFyc2VGbG9hdCcsICdwYXJzZUludCcsICdzZXRUaW1lb3V0JywgJ1R5cGVFcnJvcicsICdVaW50OEFycmF5JyxcbiAgICAnVWludDhDbGFtcGVkQXJyYXknLCAnVWludDE2QXJyYXknLCAnVWludDMyQXJyYXknLCAnV2Vha01hcCdcbiAgXTtcblxuICAvKiogVXNlZCB0byBtYWtlIHRlbXBsYXRlIHNvdXJjZVVSTHMgZWFzaWVyIHRvIGlkZW50aWZ5LiAqL1xuICB2YXIgdGVtcGxhdGVDb3VudGVyID0gLTE7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xuICB2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbiAgdHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgdHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID0gdHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPSB0eXBlZEFycmF5VGFnc1ttYXBUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID0gdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPSB0eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG4gIHZhciBjbG9uZWFibGVUYWdzID0ge307XG4gIGNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MzJUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuICBjbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuICBjbG9uZWFibGVUYWdzW21hcFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbiAgLyoqIFVzZWQgdG8gbWFwIGxhdGluLTEgc3VwcGxlbWVudGFyeSBsZXR0ZXJzIHRvIGJhc2ljIGxhdGluIGxldHRlcnMuICovXG4gIHZhciBkZWJ1cnJlZExldHRlcnMgPSB7XG4gICAgJ1xceGMwJzogJ0EnLCAgJ1xceGMxJzogJ0EnLCAnXFx4YzInOiAnQScsICdcXHhjMyc6ICdBJywgJ1xceGM0JzogJ0EnLCAnXFx4YzUnOiAnQScsXG4gICAgJ1xceGUwJzogJ2EnLCAgJ1xceGUxJzogJ2EnLCAnXFx4ZTInOiAnYScsICdcXHhlMyc6ICdhJywgJ1xceGU0JzogJ2EnLCAnXFx4ZTUnOiAnYScsXG4gICAgJ1xceGM3JzogJ0MnLCAgJ1xceGU3JzogJ2MnLFxuICAgICdcXHhkMCc6ICdEJywgICdcXHhmMCc6ICdkJyxcbiAgICAnXFx4YzgnOiAnRScsICAnXFx4YzknOiAnRScsICdcXHhjYSc6ICdFJywgJ1xceGNiJzogJ0UnLFxuICAgICdcXHhlOCc6ICdlJywgICdcXHhlOSc6ICdlJywgJ1xceGVhJzogJ2UnLCAnXFx4ZWInOiAnZScsXG4gICAgJ1xceGNDJzogJ0knLCAgJ1xceGNkJzogJ0knLCAnXFx4Y2UnOiAnSScsICdcXHhjZic6ICdJJyxcbiAgICAnXFx4ZUMnOiAnaScsICAnXFx4ZWQnOiAnaScsICdcXHhlZSc6ICdpJywgJ1xceGVmJzogJ2knLFxuICAgICdcXHhkMSc6ICdOJywgICdcXHhmMSc6ICduJyxcbiAgICAnXFx4ZDInOiAnTycsICAnXFx4ZDMnOiAnTycsICdcXHhkNCc6ICdPJywgJ1xceGQ1JzogJ08nLCAnXFx4ZDYnOiAnTycsICdcXHhkOCc6ICdPJyxcbiAgICAnXFx4ZjInOiAnbycsICAnXFx4ZjMnOiAnbycsICdcXHhmNCc6ICdvJywgJ1xceGY1JzogJ28nLCAnXFx4ZjYnOiAnbycsICdcXHhmOCc6ICdvJyxcbiAgICAnXFx4ZDknOiAnVScsICAnXFx4ZGEnOiAnVScsICdcXHhkYic6ICdVJywgJ1xceGRjJzogJ1UnLFxuICAgICdcXHhmOSc6ICd1JywgICdcXHhmYSc6ICd1JywgJ1xceGZiJzogJ3UnLCAnXFx4ZmMnOiAndScsXG4gICAgJ1xceGRkJzogJ1knLCAgJ1xceGZkJzogJ3knLCAnXFx4ZmYnOiAneScsXG4gICAgJ1xceGM2JzogJ0FlJywgJ1xceGU2JzogJ2FlJyxcbiAgICAnXFx4ZGUnOiAnVGgnLCAnXFx4ZmUnOiAndGgnLFxuICAgICdcXHhkZic6ICdzcydcbiAgfTtcblxuICAvKiogVXNlZCB0byBtYXAgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLiAqL1xuICB2YXIgaHRtbEVzY2FwZXMgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnLFxuICAgICdgJzogJyYjOTY7J1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuICovXG4gIHZhciBodG1sVW5lc2NhcGVzID0ge1xuICAgICcmYW1wOyc6ICcmJyxcbiAgICAnJmx0Oyc6ICc8JyxcbiAgICAnJmd0Oyc6ICc+JyxcbiAgICAnJnF1b3Q7JzogJ1wiJyxcbiAgICAnJiMzOTsnOiBcIidcIixcbiAgICAnJiM5NjsnOiAnYCdcbiAgfTtcblxuICAvKiogVXNlZCB0byBkZXRlcm1pbmUgaWYgdmFsdWVzIGFyZSBvZiB0aGUgbGFuZ3VhZ2UgdHlwZSBgT2JqZWN0YC4gKi9cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgICdmdW5jdGlvbic6IHRydWUsXG4gICAgJ29iamVjdCc6IHRydWVcbiAgfTtcblxuICAvKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHJlZ2V4ZXMuICovXG4gIHZhciByZWdleHBFc2NhcGVzID0ge1xuICAgICcwJzogJ3gzMCcsICcxJzogJ3gzMScsICcyJzogJ3gzMicsICczJzogJ3gzMycsICc0JzogJ3gzNCcsXG4gICAgJzUnOiAneDM1JywgJzYnOiAneDM2JywgJzcnOiAneDM3JywgJzgnOiAneDM4JywgJzknOiAneDM5JyxcbiAgICAnQSc6ICd4NDEnLCAnQic6ICd4NDInLCAnQyc6ICd4NDMnLCAnRCc6ICd4NDQnLCAnRSc6ICd4NDUnLCAnRic6ICd4NDYnLFxuICAgICdhJzogJ3g2MScsICdiJzogJ3g2MicsICdjJzogJ3g2MycsICdkJzogJ3g2NCcsICdlJzogJ3g2NScsICdmJzogJ3g2NicsXG4gICAgJ24nOiAneDZlJywgJ3InOiAneDcyJywgJ3QnOiAneDc0JywgJ3UnOiAneDc1JywgJ3YnOiAneDc2JywgJ3gnOiAneDc4J1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xuICB2YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFxyJzogJ3InLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbiAgdmFyIGZyZWVNb2R1bGUgPSBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbiAgdmFyIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlICYmIHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgJiYgZ2xvYmFsO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG4gIHZhciBmcmVlU2VsZiA9IG9iamVjdFR5cGVzW3R5cGVvZiBzZWxmXSAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ICYmIHNlbGY7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGB3aW5kb3dgLiAqL1xuICB2YXIgZnJlZVdpbmRvdyA9IG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyAmJiB3aW5kb3cuT2JqZWN0ICYmIHdpbmRvdztcblxuICAvKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xuICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cyAmJiBmcmVlRXhwb3J0cztcblxuICAvKipcbiAgICogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICpcbiAgICogVGhlIGB0aGlzYCB2YWx1ZSBpcyB1c2VkIGlmIGl0J3MgdGhlIGdsb2JhbCBvYmplY3QgdG8gYXZvaWQgR3JlYXNlbW9ua2V5J3NcbiAgICogcmVzdHJpY3RlZCBgd2luZG93YCBvYmplY3QsIG90aGVyd2lzZSB0aGUgYHdpbmRvd2Agb2JqZWN0IGlzIHVzZWQuXG4gICAqL1xuICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgKChmcmVlV2luZG93ICE9PSAodGhpcyAmJiB0aGlzLndpbmRvdykpICYmIGZyZWVXaW5kb3cpIHx8IGZyZWVTZWxmIHx8IHRoaXM7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBjb21wYXJlQXNjZW5kaW5nYCB3aGljaCBjb21wYXJlcyB2YWx1ZXMgYW5kXG4gICAqIHNvcnRzIHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyIHdpdGhvdXQgZ3VhcmFudGVlaW5nIGEgc3RhYmxlIHNvcnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gICAgaWYgKHZhbHVlICE9PSBvdGhlcikge1xuICAgICAgdmFyIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICAgIHZhbElzVW5kZWYgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkLFxuICAgICAgICAgIHZhbElzUmVmbGV4aXZlID0gdmFsdWUgPT09IHZhbHVlO1xuXG4gICAgICB2YXIgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgICAgb3RoSXNVbmRlZiA9IG90aGVyID09PSB1bmRlZmluZWQsXG4gICAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXI7XG5cbiAgICAgIGlmICgodmFsdWUgPiBvdGhlciAmJiAhb3RoSXNOdWxsKSB8fCAhdmFsSXNSZWZsZXhpdmUgfHxcbiAgICAgICAgICAodmFsSXNOdWxsICYmICFvdGhJc1VuZGVmICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICh2YWxJc1VuZGVmICYmIG90aElzUmVmbGV4aXZlKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIGlmICgodmFsdWUgPCBvdGhlciAmJiAhdmFsSXNOdWxsKSB8fCAhb3RoSXNSZWZsZXhpdmUgfHxcbiAgICAgICAgICAob3RoSXNOdWxsICYmICF2YWxJc1VuZGVmICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgIChvdGhJc1VuZGVmICYmIHZhbElzUmVmbGV4aXZlKSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAgICogc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbVJpZ2h0KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGJpbmFyeSBzZWFyY2hlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIGlmICh2YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpbmRleE9mTmFOKGFycmF5LCBmcm9tSW5kZXgpO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNGdW5jdGlvbmAgd2l0aG91dCBzdXBwb3J0IGZvciBlbnZpcm9ubWVudHNcbiAgICogd2l0aCBpbmNvcnJlY3QgYHR5cGVvZmAgcmVzdWx0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIEF2b2lkIGEgQ2hha3JhIEpJVCBidWcgaW4gY29tcGF0aWJpbGl0eSBtb2RlcyBvZiBJRSAxMS5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL2lzc3Vlcy8xNjIxIGZvciBtb3JlIGRldGFpbHMuXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgaWYgaXQncyBub3Qgb25lLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWRcbiAgICogZm9yIGBudWxsYCBvciBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiAodmFsdWUgKyAnJyk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUxlZnRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNoYXJhY3RlclxuICAgKiBvZiBgc3RyaW5nYCB0aGF0IGlzIG5vdCBmb3VuZCBpbiBgY2hhcnNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJzIFRoZSBjaGFyYWN0ZXJzIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXIgbm90IGZvdW5kIGluIGBjaGFyc2AuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyc0xlZnRJbmRleChzdHJpbmcsIGNoYXJzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBjaGFycy5pbmRleE9mKHN0cmluZy5jaGFyQXQoaW5kZXgpKSA+IC0xKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltUmlnaHRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3QgY2hhcmFjdGVyXG4gICAqIG9mIGBzdHJpbmdgIHRoYXQgaXMgbm90IGZvdW5kIGluIGBjaGFyc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnMgVGhlIGNoYXJhY3RlcnMgdG8gZmluZC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgY2hhcmFjdGVyIG5vdCBmb3VuZCBpbiBgY2hhcnNgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhcnNSaWdodEluZGV4KHN0cmluZywgY2hhcnMpIHtcbiAgICB2YXIgaW5kZXggPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGluZGV4LS0gJiYgY2hhcnMuaW5kZXhPZihzdHJpbmcuY2hhckF0KGluZGV4KSkgPiAtMSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5zb3J0QnlgIHRvIGNvbXBhcmUgdHJhbnNmb3JtZWQgZWxlbWVudHMgb2YgYSBjb2xsZWN0aW9uIGFuZCBzdGFibGVcbiAgICogc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcob2JqZWN0LCBvdGhlcikge1xuICAgIHJldHVybiBiYXNlQ29tcGFyZUFzY2VuZGluZyhvYmplY3QuY3JpdGVyaWEsIG90aGVyLmNyaXRlcmlhKSB8fCAob2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uc29ydEJ5T3JkZXJgIHRvIGNvbXBhcmUgbXVsdGlwbGUgcHJvcGVydGllcyBvZiBhIHZhbHVlIHRvIGFub3RoZXJcbiAgICogYW5kIHN0YWJsZSBzb3J0IHRoZW0uXG4gICAqXG4gICAqIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICAgKiBhIHZhbHVlIGlzIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgaWYgaXRzIGNvcnJlc3BvbmRpbmcgb3JkZXIgaXMgXCJhc2NcIiwgYW5kXG4gICAqIGRlc2NlbmRpbmcgaWYgXCJkZXNjXCIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW5bXX0gb3JkZXJzIFRoZSBvcmRlciB0byBzb3J0IGJ5IGZvciBlYWNoIHByb3BlcnR5LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIG9iakNyaXRlcmlhID0gb2JqZWN0LmNyaXRlcmlhLFxuICAgICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsXG4gICAgICAgIG9yZGVyc0xlbmd0aCA9IG9yZGVycy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VDb21wYXJlQXNjZW5kaW5nKG9iakNyaXRlcmlhW2luZGV4XSwgb3RoQ3JpdGVyaWFbaW5kZXhdKTtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IG9yZGVyc0xlbmd0aCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9yZGVyID0gb3JkZXJzW2luZGV4XTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCAqICgob3JkZXIgPT09ICdhc2MnIHx8IG9yZGVyID09PSB0cnVlKSA/IDEgOiAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgICAvLyB0aGF0IGNhdXNlcyBpdCwgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCB0byBwcm92aWRlIHRoZSBzYW1lIHZhbHVlIGZvclxuICAgIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgLy9cbiAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAgIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5kZWJ1cnJgIHRvIGNvbnZlcnQgbGF0aW4tMSBzdXBwbGVtZW50YXJ5IGxldHRlcnMgdG8gYmFzaWMgbGF0aW4gbGV0dGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxldHRlciBUaGUgbWF0Y2hlZCBsZXR0ZXIgdG8gZGVidXJyLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBkZWJ1cnJMZXR0ZXIobGV0dGVyKSB7XG4gICAgcmV0dXJuIGRlYnVycmVkTGV0dGVyc1tsZXR0ZXJdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZUh0bWxDaGFyKGNocikge1xuICAgIHJldHVybiBodG1sRXNjYXBlc1tjaHJdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uZXNjYXBlUmVnRXhwYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHJlZ2V4ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxlYWRpbmdDaGFyIFRoZSBjYXB0dXJlIGdyb3VwIGZvciBhIGxlYWRpbmcgY2hhcmFjdGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gd2hpdGVzcGFjZUNoYXIgVGhlIGNhcHR1cmUgZ3JvdXAgZm9yIGEgd2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwQ2hhcihjaHIsIGxlYWRpbmdDaGFyLCB3aGl0ZXNwYWNlQ2hhcikge1xuICAgIGlmIChsZWFkaW5nQ2hhcikge1xuICAgICAgY2hyID0gcmVnZXhwRXNjYXBlc1tjaHJdO1xuICAgIH0gZWxzZSBpZiAod2hpdGVzcGFjZUNoYXIpIHtcbiAgICAgIGNociA9IHN0cmluZ0VzY2FwZXNbY2hyXTtcbiAgICB9XG4gICAgcmV0dXJuICdcXFxcJyArIGNocjtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbY2hyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgTmFOYCBpcyBmb3VuZCBpbiBgYXJyYXlgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIGBOYU5gLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBpbmRleE9mTmFOKGFycmF5LCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDAgOiAtMSk7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgdmFyIG90aGVyID0gYXJyYXlbaW5kZXhdO1xuICAgICAgaWYgKG90aGVyICE9PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgdHJpbW1lZExlZnRJbmRleGAgYW5kIGB0cmltbWVkUmlnaHRJbmRleGAgdG8gZGV0ZXJtaW5lIGlmIGFcbiAgICogY2hhcmFjdGVyIGNvZGUgaXMgd2hpdGVzcGFjZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNoYXJDb2RlIFRoZSBjaGFyYWN0ZXIgY29kZSB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGNoYXJDb2RlYCBpcyB3aGl0ZXNwYWNlLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBpc1NwYWNlKGNoYXJDb2RlKSB7XG4gICAgcmV0dXJuICgoY2hhckNvZGUgPD0gMTYwICYmIChjaGFyQ29kZSA+PSA5ICYmIGNoYXJDb2RlIDw9IDEzKSB8fCBjaGFyQ29kZSA9PSAzMiB8fCBjaGFyQ29kZSA9PSAxNjApIHx8IGNoYXJDb2RlID09IDU3NjAgfHwgY2hhckNvZGUgPT0gNjE1OCB8fFxuICAgICAgKGNoYXJDb2RlID49IDgxOTIgJiYgKGNoYXJDb2RlIDw9IDgyMDIgfHwgY2hhckNvZGUgPT0gODIzMiB8fCBjaGFyQ29kZSA9PSA4MjMzIHx8IGNoYXJDb2RlID09IDgyMzkgfHwgY2hhckNvZGUgPT0gODI4NyB8fCBjaGFyQ29kZSA9PSAxMjI4OCB8fCBjaGFyQ29kZSA9PSA2NTI3OSkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgYHBsYWNlaG9sZGVyYCBlbGVtZW50cyBpbiBgYXJyYXlgIHdpdGggYW4gaW50ZXJuYWwgcGxhY2Vob2xkZXJcbiAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlaXIgaW5kZXhlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdG8gcmVwbGFjZS5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc0luZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHBsYWNlaG9sZGVyKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IFBMQUNFSE9MREVSO1xuICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxYCBvcHRpbWl6ZWQgZm9yIHNvcnRlZCBhcnJheXMgd2l0aG91dCBzdXBwb3J0XG4gICAqIGZvciBjYWxsYmFjayBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBzb3J0ZWRVbmlxKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBzZWVuLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc0luZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBhcnJheSkgOiB2YWx1ZTtcblxuICAgICAgaWYgKCFpbmRleCB8fCBzZWVuICE9PSBjb21wdXRlZCkge1xuICAgICAgICBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1MZWZ0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBub24td2hpdGVzcGFjZVxuICAgKiBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gdHJpbW1lZExlZnRJbmRleChzdHJpbmcpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGlzU3BhY2Uoc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpKSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbVJpZ2h0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlXG4gICAqIGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIHRyaW1tZWRSaWdodEluZGV4KHN0cmluZykge1xuICAgIHZhciBpbmRleCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaW5kZXgtLSAmJiBpc1NwYWNlKHN0cmluZy5jaGFyQ29kZUF0KGluZGV4KSkpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udW5lc2NhcGVgIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byB1bmVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIHVuZXNjYXBlSHRtbENoYXIoY2hyKSB7XG4gICAgcmV0dXJuIGh0bWxVbmVzY2FwZXNbY2hyXTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdXNpbmcgdGhlIGdpdmVuIGBjb250ZXh0YCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0PXJvb3RdIFRoZSBjb250ZXh0IG9iamVjdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGEgbmV3IGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLm1peGluKHsgJ2Zvbyc6IF8uY29uc3RhbnQoJ2ZvbycpIH0pO1xuICAgKlxuICAgKiB2YXIgbG9kYXNoID0gXy5ydW5JbkNvbnRleHQoKTtcbiAgICogbG9kYXNoLm1peGluKHsgJ2Jhcic6IGxvZGFzaC5jb25zdGFudCgnYmFyJykgfSk7XG4gICAqXG4gICAqIF8uaXNGdW5jdGlvbihfLmZvbyk7XG4gICAqIC8vID0+IHRydWVcbiAgICogXy5pc0Z1bmN0aW9uKF8uYmFyKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLmZvbyk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5iYXIpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIC8vIHVzaW5nIGBjb250ZXh0YCB0byBtb2NrIGBEYXRlI2dldFRpbWVgIHVzZSBpbiBgXy5ub3dgXG4gICAqIHZhciBtb2NrID0gXy5ydW5JbkNvbnRleHQoe1xuICAgKiAgICdEYXRlJzogZnVuY3Rpb24oKSB7XG4gICAqICAgICByZXR1cm4geyAnZ2V0VGltZSc6IGdldFRpbWVNb2NrIH07XG4gICAqICAgfVxuICAgKiB9KTtcbiAgICpcbiAgICogLy8gb3IgY3JlYXRpbmcgYSBzdXBlZC11cCBgZGVmZXJgIGluIE5vZGUuanNcbiAgICogdmFyIGRlZmVyID0gXy5ydW5JbkNvbnRleHQoeyAnc2V0VGltZW91dCc6IHNldEltbWVkaWF0ZSB9KS5kZWZlcjtcbiAgICovXG4gIGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0KSB7XG4gICAgLy8gQXZvaWQgaXNzdWVzIHdpdGggc29tZSBFUzMgZW52aXJvbm1lbnRzIHRoYXQgYXR0ZW1wdCB0byB1c2UgdmFsdWVzLCBuYW1lZFxuICAgIC8vIGFmdGVyIGJ1aWx0LWluIGNvbnN0cnVjdG9ycyBsaWtlIGBPYmplY3RgLCBmb3IgdGhlIGNyZWF0aW9uIG9mIGxpdGVyYWxzLlxuICAgIC8vIEVTNSBjbGVhcnMgdGhpcyB1cCBieSBzdGF0aW5nIHRoYXQgbGl0ZXJhbHMgbXVzdCB1c2UgYnVpbHQtaW4gY29uc3RydWN0b3JzLlxuICAgIC8vIFNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI3gxMS4xLjUgZm9yIG1vcmUgZGV0YWlscy5cbiAgICBjb250ZXh0ID0gY29udGV4dCA/IF8uZGVmYXVsdHMocm9vdC5PYmplY3QoKSwgY29udGV4dCwgXy5waWNrKHJvb3QsIGNvbnRleHRQcm9wcykpIDogcm9vdDtcblxuICAgIC8qKiBOYXRpdmUgY29uc3RydWN0b3IgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgQXJyYXkgPSBjb250ZXh0LkFycmF5LFxuICAgICAgICBEYXRlID0gY29udGV4dC5EYXRlLFxuICAgICAgICBFcnJvciA9IGNvbnRleHQuRXJyb3IsXG4gICAgICAgIEZ1bmN0aW9uID0gY29udGV4dC5GdW5jdGlvbixcbiAgICAgICAgTWF0aCA9IGNvbnRleHQuTWF0aCxcbiAgICAgICAgTnVtYmVyID0gY29udGV4dC5OdW1iZXIsXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHQuT2JqZWN0LFxuICAgICAgICBSZWdFeHAgPSBjb250ZXh0LlJlZ0V4cCxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dC5TdHJpbmcsXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHQuVHlwZUVycm9yO1xuXG4gICAgLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICAgICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICBzdHJpbmdQcm90byA9IFN0cmluZy5wcm90b3R5cGU7XG5cbiAgICAvKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG4gICAgdmFyIGZuVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbiAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIC8qKiBVc2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMuICovXG4gICAgdmFyIGlkQ291bnRlciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICAgICAqIG9mIHZhbHVlcy5cbiAgICAgKi9cbiAgICB2YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuICAgIC8qKiBVc2VkIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIGBfYCByZWZlcmVuY2UgaW4gYF8ubm9Db25mbGljdGAuICovXG4gICAgdmFyIG9sZERhc2ggPSByb290Ll87XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xuICAgIHZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gICAgICBmblRvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLCAnXFxcXCQmJylcbiAgICAgIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuICAgICk7XG5cbiAgICAvKiogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBBcnJheUJ1ZmZlciA9IGNvbnRleHQuQXJyYXlCdWZmZXIsXG4gICAgICAgIGNsZWFyVGltZW91dCA9IGNvbnRleHQuY2xlYXJUaW1lb3V0LFxuICAgICAgICBwYXJzZUZsb2F0ID0gY29udGV4dC5wYXJzZUZsb2F0LFxuICAgICAgICBwb3cgPSBNYXRoLnBvdyxcbiAgICAgICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICAgICAgU2V0ID0gZ2V0TmF0aXZlKGNvbnRleHQsICdTZXQnKSxcbiAgICAgICAgc2V0VGltZW91dCA9IGNvbnRleHQuc2V0VGltZW91dCxcbiAgICAgICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgICAgIFVpbnQ4QXJyYXkgPSBjb250ZXh0LlVpbnQ4QXJyYXksXG4gICAgICAgIFdlYWtNYXAgPSBnZXROYXRpdmUoY29udGV4dCwgJ1dlYWtNYXAnKTtcblxuICAgIC8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG4gICAgdmFyIG5hdGl2ZUNlaWwgPSBNYXRoLmNlaWwsXG4gICAgICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKSxcbiAgICAgICAgbmF0aXZlRmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICBuYXRpdmVJc0FycmF5ID0gZ2V0TmF0aXZlKEFycmF5LCAnaXNBcnJheScpLFxuICAgICAgICBuYXRpdmVJc0Zpbml0ZSA9IGNvbnRleHQuaXNGaW5pdGUsXG4gICAgICAgIG5hdGl2ZUtleXMgPSBnZXROYXRpdmUoT2JqZWN0LCAna2V5cycpLFxuICAgICAgICBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICAgICAgbmF0aXZlTWluID0gTWF0aC5taW4sXG4gICAgICAgIG5hdGl2ZU5vdyA9IGdldE5hdGl2ZShEYXRlLCAnbm93JyksXG4gICAgICAgIG5hdGl2ZVBhcnNlSW50ID0gY29udGV4dC5wYXJzZUludCxcbiAgICAgICAgbmF0aXZlUmFuZG9tID0gTWF0aC5yYW5kb207XG5cbiAgICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciBgLUluZmluaXR5YCBhbmQgYEluZmluaXR5YC4gKi9cbiAgICB2YXIgTkVHQVRJVkVfSU5GSU5JVFkgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG4gICAgICAgIFBPU0lUSVZFX0lORklOSVRZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG4gICAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdGhlIG1heGltdW0gbGVuZ3RoIGFuZCBpbmRleCBvZiBhbiBhcnJheS4gKi9cbiAgICB2YXIgTUFYX0FSUkFZX0xFTkdUSCA9IDQyOTQ5NjcyOTUsXG4gICAgICAgIE1BWF9BUlJBWV9JTkRFWCA9IE1BWF9BUlJBWV9MRU5HVEggLSAxLFxuICAgICAgICBIQUxGX01BWF9BUlJBWV9MRU5HVEggPSBNQVhfQVJSQVlfTEVOR1RIID4+PiAxO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCBhcyB0aGUgW21heGltdW0gbGVuZ3RoXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIubWF4X3NhZmVfaW50ZWdlcilcbiAgICAgKiBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxuICAgICAqL1xuICAgIHZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuICAgIC8qKiBVc2VkIHRvIHN0b3JlIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xuICAgIHZhciBtZXRhTWFwID0gV2Vha01hcCAmJiBuZXcgV2Vha01hcDtcblxuICAgIC8qKiBVc2VkIHRvIGxvb2t1cCB1bm1pbmlmaWVkIGZ1bmN0aW9uIG5hbWVzLiAqL1xuICAgIHZhciByZWFsTmFtZXMgPSB7fTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgaW1wbGljaXQgY2hhaW5pbmcuXG4gICAgICogTWV0aG9kcyB0aGF0IG9wZXJhdGUgb24gYW5kIHJldHVybiBhcnJheXMsIGNvbGxlY3Rpb25zLCBhbmQgZnVuY3Rpb25zIGNhblxuICAgICAqIGJlIGNoYWluZWQgdG9nZXRoZXIuIE1ldGhvZHMgdGhhdCByZXRyaWV2ZSBhIHNpbmdsZSB2YWx1ZSBvciBtYXkgcmV0dXJuIGFcbiAgICAgKiBwcmltaXRpdmUgdmFsdWUgd2lsbCBhdXRvbWF0aWNhbGx5IGVuZCB0aGUgY2hhaW4gcmV0dXJuaW5nIHRoZSB1bndyYXBwZWRcbiAgICAgKiB2YWx1ZS4gRXhwbGljaXQgY2hhaW5pbmcgbWF5IGJlIGVuYWJsZWQgdXNpbmcgYF8uY2hhaW5gLiBUaGUgZXhlY3V0aW9uIG9mXG4gICAgICogY2hhaW5lZCBtZXRob2RzIGlzIGxhenksIHRoYXQgaXMsIGV4ZWN1dGlvbiBpcyBkZWZlcnJlZCB1bnRpbCBgXyN2YWx1ZWBcbiAgICAgKiBpcyBpbXBsaWNpdGx5IG9yIGV4cGxpY2l0bHkgY2FsbGVkLlxuICAgICAqXG4gICAgICogTGF6eSBldmFsdWF0aW9uIGFsbG93cyBzZXZlcmFsIG1ldGhvZHMgdG8gc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24uIFNob3J0Y3V0XG4gICAgICogZnVzaW9uIGlzIGFuIG9wdGltaXphdGlvbiBzdHJhdGVneSB3aGljaCBtZXJnZSBpdGVyYXRlZSBjYWxsczsgdGhpcyBjYW4gaGVscFxuICAgICAqIHRvIGF2b2lkIHRoZSBjcmVhdGlvbiBvZiBpbnRlcm1lZGlhdGUgZGF0YSBzdHJ1Y3R1cmVzIGFuZCBncmVhdGx5IHJlZHVjZSB0aGVcbiAgICAgKiBudW1iZXIgb2YgaXRlcmF0ZWUgZXhlY3V0aW9ucy5cbiAgICAgKlxuICAgICAqIENoYWluaW5nIGlzIHN1cHBvcnRlZCBpbiBjdXN0b20gYnVpbGRzIGFzIGxvbmcgYXMgdGhlIGBfI3ZhbHVlYCBtZXRob2QgaXNcbiAgICAgKiBkaXJlY3RseSBvciBpbmRpcmVjdGx5IGluY2x1ZGVkIGluIHRoZSBidWlsZC5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uIHRvIGxvZGFzaCBtZXRob2RzLCB3cmFwcGVycyBoYXZlIGBBcnJheWAgYW5kIGBTdHJpbmdgIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgQXJyYXlgIG1ldGhvZHMgYXJlOlxuICAgICAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGByZXZlcnNlYCwgYHNoaWZ0YCwgYHNsaWNlYCwgYHNvcnRgLFxuICAgICAqIGBzcGxpY2VgLCBhbmQgYHVuc2hpZnRgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgU3RyaW5nYCBtZXRob2RzIGFyZTpcbiAgICAgKiBgcmVwbGFjZWAgYW5kIGBzcGxpdGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbiBhcmU6XG4gICAgICogYGNvbXBhY3RgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZHJvcFJpZ2h0V2hpbGVgLCBgZHJvcFdoaWxlYCwgYGZpbHRlcmAsXG4gICAgICogYGZpcnN0YCwgYGluaXRpYWxgLCBgbGFzdGAsIGBtYXBgLCBgcGx1Y2tgLCBgcmVqZWN0YCwgYHJlc3RgLCBgcmV2ZXJzZWAsXG4gICAgICogYHNsaWNlYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCwgYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGB0b0FycmF5YCxcbiAgICAgKiBhbmQgYHdoZXJlYFxuICAgICAqXG4gICAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhZnRlcmAsIGBhcnlgLCBgYXNzaWduYCwgYGF0YCwgYGJlZm9yZWAsIGBiaW5kYCwgYGJpbmRBbGxgLCBgYmluZEtleWAsXG4gICAgICogYGNhbGxiYWNrYCwgYGNoYWluYCwgYGNodW5rYCwgYGNvbW1pdGAsIGBjb21wYWN0YCwgYGNvbmNhdGAsIGBjb25zdGFudGAsXG4gICAgICogYGNvdW50QnlgLCBgY3JlYXRlYCwgYGN1cnJ5YCwgYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsXG4gICAgICogYGRlZmVyYCwgYGRlbGF5YCwgYGRpZmZlcmVuY2VgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZHJvcFJpZ2h0V2hpbGVgLFxuICAgICAqIGBkcm9wV2hpbGVgLCBgZmlsbGAsIGBmaWx0ZXJgLCBgZmxhdHRlbmAsIGBmbGF0dGVuRGVlcGAsIGBmbG93YCwgYGZsb3dSaWdodGAsXG4gICAgICogYGZvckVhY2hgLCBgZm9yRWFjaFJpZ2h0YCwgYGZvckluYCwgYGZvckluUmlnaHRgLCBgZm9yT3duYCwgYGZvck93blJpZ2h0YCxcbiAgICAgKiBgZnVuY3Rpb25zYCwgYGdyb3VwQnlgLCBgaW5kZXhCeWAsIGBpbml0aWFsYCwgYGludGVyc2VjdGlvbmAsIGBpbnZlcnRgLFxuICAgICAqIGBpbnZva2VgLCBga2V5c2AsIGBrZXlzSW5gLCBgbWFwYCwgYG1hcEtleXNgLCBgbWFwVmFsdWVzYCwgYG1hdGNoZXNgLFxuICAgICAqIGBtYXRjaGVzUHJvcGVydHlgLCBgbWVtb2l6ZWAsIGBtZXJnZWAsIGBtZXRob2RgLCBgbWV0aG9kT2ZgLCBgbWl4aW5gLFxuICAgICAqIGBtb2RBcmdzYCwgYG5lZ2F0ZWAsIGBvbWl0YCwgYG9uY2VgLCBgcGFpcnNgLCBgcGFydGlhbGAsIGBwYXJ0aWFsUmlnaHRgLFxuICAgICAqIGBwYXJ0aXRpb25gLCBgcGlja2AsIGBwbGFudGAsIGBwbHVja2AsIGBwcm9wZXJ0eWAsIGBwcm9wZXJ0eU9mYCwgYHB1bGxgLFxuICAgICAqIGBwdWxsQXRgLCBgcHVzaGAsIGByYW5nZWAsIGByZWFyZ2AsIGByZWplY3RgLCBgcmVtb3ZlYCwgYHJlc3RgLCBgcmVzdFBhcmFtYCxcbiAgICAgKiBgcmV2ZXJzZWAsIGBzZXRgLCBgc2h1ZmZsZWAsIGBzbGljZWAsIGBzb3J0YCwgYHNvcnRCeWAsIGBzb3J0QnlBbGxgLFxuICAgICAqIGBzb3J0QnlPcmRlcmAsIGBzcGxpY2VgLCBgc3ByZWFkYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCwgYHRha2VSaWdodFdoaWxlYCxcbiAgICAgKiBgdGFrZVdoaWxlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aHJ1YCwgYHRpbWVzYCwgYHRvQXJyYXlgLCBgdG9QbGFpbk9iamVjdGAsXG4gICAgICogYHRyYW5zZm9ybWAsIGB1bmlvbmAsIGB1bmlxYCwgYHVuc2hpZnRgLCBgdW56aXBgLCBgdW56aXBXaXRoYCwgYHZhbHVlc2AsXG4gICAgICogYHZhbHVlc0luYCwgYHdoZXJlYCwgYHdpdGhvdXRgLCBgd3JhcGAsIGB4b3JgLCBgemlwYCwgYHppcE9iamVjdGAsIGB6aXBXaXRoYFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IGFyZSAqKm5vdCoqIGNoYWluYWJsZSBieSBkZWZhdWx0IGFyZTpcbiAgICAgKiBgYWRkYCwgYGF0dGVtcHRgLCBgY2FtZWxDYXNlYCwgYGNhcGl0YWxpemVgLCBgY2VpbGAsIGBjbG9uZWAsIGBjbG9uZURlZXBgLFxuICAgICAqIGBkZWJ1cnJgLCBgZW5kc1dpdGhgLCBgZXNjYXBlYCwgYGVzY2FwZVJlZ0V4cGAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsXG4gICAgICogYGZpbmRLZXlgLCBgZmluZExhc3RgLCBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBmaW5kV2hlcmVgLCBgZmlyc3RgLFxuICAgICAqIGBmbG9vcmAsIGBnZXRgLCBgZ3RgLCBgZ3RlYCwgYGhhc2AsIGBpZGVudGl0eWAsIGBpbmNsdWRlc2AsIGBpbmRleE9mYCxcbiAgICAgKiBgaW5SYW5nZWAsIGBpc0FyZ3VtZW50c2AsIGBpc0FycmF5YCwgYGlzQm9vbGVhbmAsIGBpc0RhdGVgLCBgaXNFbGVtZW50YCxcbiAgICAgKiBgaXNFbXB0eWAsIGBpc0VxdWFsYCwgYGlzRXJyb3JgLCBgaXNGaW5pdGVgIGBpc0Z1bmN0aW9uYCwgYGlzTWF0Y2hgLFxuICAgICAqIGBpc05hdGl2ZWAsIGBpc05hTmAsIGBpc051bGxgLCBgaXNOdW1iZXJgLCBgaXNPYmplY3RgLCBgaXNQbGFpbk9iamVjdGAsXG4gICAgICogYGlzUmVnRXhwYCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGlzVHlwZWRBcnJheWAsIGBqb2luYCwgYGtlYmFiQ2FzZWAsXG4gICAgICogYGxhc3RgLCBgbGFzdEluZGV4T2ZgLCBgbHRgLCBgbHRlYCwgYG1heGAsIGBtaW5gLCBgbm9Db25mbGljdGAsIGBub29wYCxcbiAgICAgKiBgbm93YCwgYHBhZGAsIGBwYWRMZWZ0YCwgYHBhZFJpZ2h0YCwgYHBhcnNlSW50YCwgYHBvcGAsIGByYW5kb21gLCBgcmVkdWNlYCxcbiAgICAgKiBgcmVkdWNlUmlnaHRgLCBgcmVwZWF0YCwgYHJlc3VsdGAsIGByb3VuZGAsIGBydW5JbkNvbnRleHRgLCBgc2hpZnRgLCBgc2l6ZWAsXG4gICAgICogYHNuYWtlQ2FzZWAsIGBzb21lYCwgYHNvcnRlZEluZGV4YCwgYHNvcnRlZExhc3RJbmRleGAsIGBzdGFydENhc2VgLFxuICAgICAqIGBzdGFydHNXaXRoYCwgYHN1bWAsIGB0ZW1wbGF0ZWAsIGB0cmltYCwgYHRyaW1MZWZ0YCwgYHRyaW1SaWdodGAsIGB0cnVuY2AsXG4gICAgICogYHVuZXNjYXBlYCwgYHVuaXF1ZUlkYCwgYHZhbHVlYCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZCBgc2FtcGxlYCB3aWxsIHJldHVybiBhIHdyYXBwZWQgdmFsdWUgd2hlbiBgbmAgaXMgcHJvdmlkZWQsXG4gICAgICogb3RoZXJ3aXNlIGFuIHVud3JhcHBlZCB2YWx1ZSBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBuYW1lIF9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICAgICAqXG4gICAgICogLy8gcmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWVcbiAgICAgKiB3cmFwcGVkLnJlZHVjZShmdW5jdGlvbih0b3RhbCwgbikge1xuICAgICAqICAgcmV0dXJuIHRvdGFsICsgbjtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiAvLyByZXR1cm5zIGEgd3JhcHBlZCB2YWx1ZVxuICAgICAqIHZhciBzcXVhcmVzID0gd3JhcHBlZC5tYXAoZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcy52YWx1ZSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9kYXNoKHZhbHVlKSB7XG4gICAgICBpZiAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMb2Rhc2hXcmFwcGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnX19jaGFpbl9fJykgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fd3JhcHBlZF9fJykpIHtcbiAgICAgICAgICByZXR1cm4gd3JhcHBlckNsb25lKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gd2hvc2UgcHJvdG90eXBlIGFsbCBjaGFpbmluZyB3cmFwcGVycyBpbmhlcml0IGZyb20uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VMb2Rhc2goKSB7XG4gICAgICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGNvbnN0cnVjdG9yIGZvciBjcmVhdGluZyBgbG9kYXNoYCB3cmFwcGVyIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY2hhaW5BbGxdIEVuYWJsZSBjaGFpbmluZyBmb3IgYWxsIHdyYXBwZXIgbWV0aG9kcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYWN0aW9ucz1bXV0gQWN0aW9ucyB0byBwZWZvcm0gdG8gcmVzb2x2ZSB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvZGFzaFdyYXBwZXIodmFsdWUsIGNoYWluQWxsLCBhY3Rpb25zKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gYWN0aW9ucyB8fCBbXTtcbiAgICAgIHRoaXMuX19jaGFpbl9fID0gISFjaGFpbkFsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgZW52aXJvbm1lbnQgZmVhdHVyZSBmbGFncy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIHZhciBzdXBwb3J0ID0gbG9kYXNoLnN1cHBvcnQgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgbG9kYXNoIGFyZSBsaWtlIHRob3NlIGluXG4gICAgICogZW1iZWRkZWQgUnVieSAoRVJCKS4gQ2hhbmdlIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlXG4gICAgICogYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnZXNjYXBlJzogcmVFc2NhcGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdldmFsdWF0ZSc6IHJlRXZhbHVhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAgICovXG4gICAgICAndmFyaWFibGUnOiAnJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgT2JqZWN0XG4gICAgICAgKi9cbiAgICAgICdpbXBvcnRzJzoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgJ18nOiBsb2Rhc2hcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGxhenkgd3JhcHBlciBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgbGF6eSBldmFsdWF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExhenlXcmFwcGVyKHZhbHVlKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gICAgICB0aGlzLl9fZGlyX18gPSAxO1xuICAgICAgdGhpcy5fX2ZpbHRlcmVkX18gPSBmYWxzZTtcbiAgICAgIHRoaXMuX19pdGVyYXRlZXNfXyA9IFtdO1xuICAgICAgdGhpcy5fX3Rha2VDb3VudF9fID0gUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB0aGlzLl9fdmlld3NfXyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgbGF6eSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xvbmVcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgYExhenlXcmFwcGVyYCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eUNsb25lKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzLl9fd3JhcHBlZF9fKTtcbiAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXyA9IGFycmF5Q29weSh0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgIHJlc3VsdC5fX2Rpcl9fID0gdGhpcy5fX2Rpcl9fO1xuICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHRoaXMuX19maWx0ZXJlZF9fO1xuICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18gPSBhcnJheUNvcHkodGhpcy5fX2l0ZXJhdGVlc19fKTtcbiAgICAgIHJlc3VsdC5fX3Rha2VDb3VudF9fID0gdGhpcy5fX3Rha2VDb3VudF9fO1xuICAgICAgcmVzdWx0Ll9fdmlld3NfXyA9IGFycmF5Q29weSh0aGlzLl9fdmlld3NfXyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIHRoZSBkaXJlY3Rpb24gb2YgbGF6eSBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHJldmVyc2VcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgcmV2ZXJzZWQgYExhenlXcmFwcGVyYCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eVJldmVyc2UoKSB7XG4gICAgICBpZiAodGhpcy5fX2ZpbHRlcmVkX18pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgcmVzdWx0Ll9fZGlyX18gPSAtMTtcbiAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJlc3VsdC5fX2Rpcl9fICo9IC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgdW53cmFwcGVkIHZhbHVlIGZyb20gaXRzIGxhenkgd3JhcHBlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgdmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlWYWx1ZSgpIHtcbiAgICAgIHZhciBhcnJheSA9IHRoaXMuX193cmFwcGVkX18udmFsdWUoKSxcbiAgICAgICAgICBkaXIgPSB0aGlzLl9fZGlyX18sXG4gICAgICAgICAgaXNBcnIgPSBpc0FycmF5KGFycmF5KSxcbiAgICAgICAgICBpc1JpZ2h0ID0gZGlyIDwgMCxcbiAgICAgICAgICBhcnJMZW5ndGggPSBpc0FyciA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgdmlldyA9IGdldFZpZXcoMCwgYXJyTGVuZ3RoLCB0aGlzLl9fdmlld3NfXyksXG4gICAgICAgICAgc3RhcnQgPSB2aWV3LnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IHZpZXcuZW5kLFxuICAgICAgICAgIGxlbmd0aCA9IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgIGluZGV4ID0gaXNSaWdodCA/IGVuZCA6IChzdGFydCAtIDEpLFxuICAgICAgICAgIGl0ZXJhdGVlcyA9IHRoaXMuX19pdGVyYXRlZXNfXyxcbiAgICAgICAgICBpdGVyTGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgdGFrZUNvdW50ID0gbmF0aXZlTWluKGxlbmd0aCwgdGhpcy5fX3Rha2VDb3VudF9fKTtcblxuICAgICAgaWYgKCFpc0FyciB8fCBhcnJMZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIHx8IChhcnJMZW5ndGggPT0gbGVuZ3RoICYmIHRha2VDb3VudCA9PSBsZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKChpc1JpZ2h0ICYmIGlzQXJyKSA/IGFycmF5LnJldmVyc2UoKSA6IGFycmF5LCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAobGVuZ3RoLS0gJiYgcmVzSW5kZXggPCB0YWtlQ291bnQpIHtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuXG4gICAgICAgIHZhciBpdGVySW5kZXggPSAtMSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIHdoaWxlICgrK2l0ZXJJbmRleCA8IGl0ZXJMZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGl0ZXJhdGVlc1tpdGVySW5kZXhdLFxuICAgICAgICAgICAgICBpdGVyYXRlZSA9IGRhdGEuaXRlcmF0ZWUsXG4gICAgICAgICAgICAgIHR5cGUgPSBkYXRhLnR5cGUsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9NQVBfRkxBRykge1xuICAgICAgICAgICAgdmFsdWUgPSBjb21wdXRlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFjb21wdXRlZCkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRykge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXkvdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbmFtZSBDYWNoZVxuICAgICAqIEBtZW1iZXJPZiBfLm1lbW9pemVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNYXBDYWNoZSgpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBfLm1lbW9pemUuQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkIHN1Y2Nlc3NmdWxseSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcERlbGV0ZShrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY2FjaGVkIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIF8ubWVtb2l6ZS5DYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjYWNoZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwR2V0KGtleSkge1xuICAgICAgcmV0dXJuIGtleSA9PSAnX19wcm90b19fJyA/IHVuZGVmaW5lZCA6IHRoaXMuX19kYXRhX19ba2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBjYWNoZWQgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIF8ubWVtb2l6ZS5DYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBIYXMoa2V5KSB7XG4gICAgICByZXR1cm4ga2V5ICE9ICdfX3Byb3RvX18nICYmIGhhc093blByb3BlcnR5LmNhbGwodGhpcy5fX2RhdGFfXywga2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGB2YWx1ZWAgdG8gYGtleWAgb2YgdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgXy5tZW1vaXplLkNhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXkgIT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFfX1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSB2YWx1ZXMgPyB2YWx1ZXMubGVuZ3RoIDogMDtcblxuICAgICAgdGhpcy5kYXRhID0geyAnaGFzaCc6IG5hdGl2ZUNyZWF0ZShudWxsKSwgJ3NldCc6IG5ldyBTZXQgfTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB0aGlzLnB1c2godmFsdWVzW2xlbmd0aF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjYWNoZWAgbWltaWNraW5nIHRoZSByZXR1cm4gc2lnbmF0dXJlIG9mXG4gICAgICogYF8uaW5kZXhPZmAgYnkgcmV0dXJuaW5nIGAwYCBpZiB0aGUgdmFsdWUgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGAwYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGAtMWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSBjYWNoZS5kYXRhLFxuICAgICAgICAgIHJlc3VsdCA9ICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNPYmplY3QodmFsdWUpKSA/IGRhdGEuc2V0Lmhhcyh2YWx1ZSkgOiBkYXRhLmhhc2hbdmFsdWVdO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID8gMCA6IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYHZhbHVlYCB0byB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHB1c2hcbiAgICAgKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWNoZVB1c2godmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgZGF0YS5zZXQuYWRkKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEuaGFzaFt2YWx1ZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgam9pbmluZyBgYXJyYXlgIHdpdGggYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGpvaW4uXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGpvaW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgY29uY2F0ZW5hdGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5Q29uY2F0KGFycmF5LCBvdGhlcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIG90aEluZGV4ID0gLTEsXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCArIG90aExlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtpbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytvdGhJbmRleCA8IG90aExlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXgrK10gPSBvdGhlcltvdGhJbmRleF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheUNvcHkoc291cmNlLCBhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICAgICAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgICAqIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlFYWNoUmlnaHQoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmV2ZXJ5YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5RXZlcnkoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoIXByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUV4dHJlbXVtYCBmb3IgYXJyYXlzIHdoaWNoIGludm9rZXMgYGl0ZXJhdGVlYFxuICAgICAqIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgZnVuY3Rpb24gdXNlZCB0byBjb21wYXJlIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IGV4VmFsdWUgVGhlIGluaXRpYWwgZXh0cmVtdW0gdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5RXh0cmVtdW0oYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yLCBleFZhbHVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgY29tcHV0ZWQgPSBleFZhbHVlLFxuICAgICAgICAgIHJlc3VsdCA9IGNvbXB1dGVkO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjdXJyZW50ID0gK2l0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICBpZiAoY29tcGFyYXRvcihjdXJyZW50LCBjb21wdXRlZCkpIHtcbiAgICAgICAgICBjb21wdXRlZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0RnJvbUFycmF5XSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWBcbiAgICAgKiAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRGcm9tQXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKGluaXRGcm9tQXJyYXkgJiYgbGVuZ3RoKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZVJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICAgKiBjYWxsYmFjayBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0RnJvbUFycmF5XSBTcGVjaWZ5IHVzaW5nIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YFxuICAgICAqICBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlSZWR1Y2VSaWdodChhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0RnJvbUFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGluaXRGcm9tQXJyYXkgJiYgbGVuZ3RoKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbLS1sZW5ndGhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnN1bWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U3VtKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSAwO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgcmVzdWx0ICs9ICtpdGVyYXRlZShhcnJheVtsZW5ndGhdKSB8fCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLmRlZmF1bHRzYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbmAgdXNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG9iamVjdFZhbHVlIFRoZSBkZXN0aW5hdGlvbiBvYmplY3QgcHJvcGVydHkgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2VWYWx1ZSBUaGUgc291cmNlIG9iamVjdCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzaWduRGVmYXVsdHMob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0VmFsdWUgPT09IHVuZGVmaW5lZCA/IHNvdXJjZVZhbHVlIDogb2JqZWN0VmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy50ZW1wbGF0ZWAgdG8gY3VzdG9taXplIGl0cyBgXy5hc3NpZ25gIHVzZS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnbkRlZmF1bHRzYCBleGNlcHQgdGhhdCBpdCBpZ25vcmVzXG4gICAgICogaW5oZXJpdGVkIHByb3BlcnR5IHZhbHVlcyB3aGVuIGNoZWNraW5nIGlmIGEgcHJvcGVydHkgaXMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0VmFsdWUgVGhlIGRlc3RpbmF0aW9uIG9iamVjdCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZVZhbHVlIFRoZSBzb3VyY2Ugb2JqZWN0IHByb3BlcnR5IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIG9iamVjdCBhbmQgc291cmNlIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbiB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnbk93bkRlZmF1bHRzKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgIHJldHVybiAob2JqZWN0VmFsdWUgPT09IHVuZGVmaW5lZCB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpXG4gICAgICAgID8gc291cmNlVmFsdWVcbiAgICAgICAgOiBvYmplY3RWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uYXNzaWduYCBmb3IgY3VzdG9taXppbmcgYXNzaWduZWQgdmFsdWVzIHdpdGhvdXRcbiAgICAgKiBzdXBwb3J0IGZvciBhcmd1bWVudCBqdWdnbGluZywgbXVsdGlwbGUgc291cmNlcywgYW5kIGB0aGlzYCBiaW5kaW5nIGBjdXN0b21pemVyYFxuICAgICAqIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnbldpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhzb3VyY2UpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICByZXN1bHQgPSBjdXN0b21pemVyKHZhbHVlLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSk7XG5cbiAgICAgICAgaWYgKChyZXN1bHQgPT09IHJlc3VsdCA/IChyZXN1bHQgIT09IHZhbHVlKSA6ICh2YWx1ZSA9PT0gdmFsdWUpKSB8fFxuICAgICAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgICAgICBvYmplY3Rba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmcsXG4gICAgICogbXVsdGlwbGUgc291cmNlcywgYW5kIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHNvdXJjZSA9PSBudWxsXG4gICAgICAgID8gb2JqZWN0XG4gICAgICAgIDogYmFzZUNvcHkoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXRgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RyaW5nIGNvbGxlY3Rpb25zXG4gICAgICogYW5kIGluZGl2aWR1YWwga2V5IGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW118c3RyaW5nW119IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyBvciBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGlja2VkIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBdChjb2xsZWN0aW9uLCBwcm9wcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNOaWwgPSBjb2xsZWN0aW9uID09IG51bGwsXG4gICAgICAgICAgaXNBcnIgPSAhaXNOaWwgJiYgaXNBcnJheUxpa2UoY29sbGVjdGlvbiksXG4gICAgICAgICAgbGVuZ3RoID0gaXNBcnIgPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkocHJvcHNMZW5ndGgpO1xuXG4gICAgICB3aGlsZSgrK2luZGV4IDwgcHJvcHNMZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGlzSW5kZXgoa2V5LCBsZW5ndGgpID8gY29sbGVjdGlvbltrZXldIDogdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBpc05pbCA/IHVuZGVmaW5lZCA6IGNvbGxlY3Rpb25ba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBjb3B5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDb3B5KHNvdXJjZSwgcHJvcHMsIG9iamVjdCkge1xuICAgICAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgb2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2FsbGJhY2tgIHdoaWNoIHN1cHBvcnRzIHNwZWNpZnlpbmcgdGhlXG4gICAgICogbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcmdDb3VudF0gVGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGZ1bmM7XG4gICAgICBpZiAodHlwZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0aGlzQXJnID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IGZ1bmNcbiAgICAgICAgICA6IGJpbmRDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCk7XG4gICAgICB9XG4gICAgICBpZiAoZnVuYyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBiYXNlTWF0Y2hlcyhmdW5jKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzQXJnID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBwcm9wZXJ0eShmdW5jKVxuICAgICAgICA6IGJhc2VNYXRjaGVzUHJvcGVydHkoZnVuYywgdGhpc0FyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmdcbiAgICAgKiBhbmQgYHRoaXNgIGJpbmRpbmcgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IGB2YWx1ZWAgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgY2xvbmVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCkgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgIHJldHVybiBhcnJheUNvcHkodmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0YWcgPSBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnO1xuXG4gICAgICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVPYmplY3QoaXNGdW5jID8ge30gOiB2YWx1ZSk7XG4gICAgICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY2xvbmVhYmxlVGFnc1t0YWddXG4gICAgICAgICAgICA/IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcClcbiAgICAgICAgICAgIDogKG9iamVjdCA/IHZhbHVlIDoge30pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBbXSk7XG4gICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IFtdKTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBZGQgdGhlIHNvdXJjZSB2YWx1ZSB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMgYW5kIGFzc29jaWF0ZSBpdCB3aXRoIGl0cyBjbG9uZS5cbiAgICAgIHN0YWNrQS5wdXNoKHZhbHVlKTtcbiAgICAgIHN0YWNrQi5wdXNoKHJlc3VsdCk7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAoaXNBcnIgPyBhcnJheUVhY2ggOiBiYXNlRm9yT3duKSh2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGJhc2VDbG9uZShzdWJWYWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICAgICAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgICAgICBpZiAoaXNPYmplY3QocHJvdG90eXBlKSkge1xuICAgICAgICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0IHx8IHt9O1xuICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZGVsYXlgIGFuZCBgXy5kZWZlcmAgd2hpY2ggYWNjZXB0cyBhbiBpbmRleFxuICAgICAqIG9mIHdoZXJlIHRvIHNsaWNlIHRoZSBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgVGhlIGFyZ3VtZW50cyBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGVsYXkoZnVuYywgd2FpdCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgd2FpdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZGlmZmVyZW5jZWAgd2hpY2ggYWNjZXB0cyBhIHNpbmdsZSBhcnJheVxuICAgICAqIG9mIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBpc0NvbW1vbiA9IGluZGV4T2YgPT0gYmFzZUluZGV4T2YsXG4gICAgICAgICAgY2FjaGUgPSAoaXNDb21tb24gJiYgdmFsdWVzLmxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSA/IGNyZWF0ZUNhY2hlKHZhbHVlcykgOiBudWxsLFxuICAgICAgICAgIHZhbHVlc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICBpbmRleE9mID0gY2FjaGVJbmRleE9mO1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMgPSBjYWNoZTtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiB2YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICB2YXIgdmFsdWVzSW5kZXggPSB2YWx1ZXNMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHZhbHVlc0luZGV4LS0pIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXNbdmFsdWVzSW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluZGV4T2YodmFsdWVzLCB2YWx1ZSwgMCkgPCAwKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hSaWdodGAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaFJpZ2h0ID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93blJpZ2h0LCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmV2ZXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFdmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9ICEhcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZXh0cmVtdW0gdmFsdWUgb2YgYGNvbGxlY3Rpb25gIGludm9raW5nIGBpdGVyYXRlZWAgZm9yIGVhY2ggdmFsdWVcbiAgICAgKiBpbiBgY29sbGVjdGlvbmAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaCB0aGUgdmFsdWUgaXMgcmFua2VkLlxuICAgICAqIFRoZSBgaXRlcmF0ZWVgIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGZ1bmN0aW9uIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBleFZhbHVlIFRoZSBpbml0aWFsIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRXh0cmVtdW0oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IsIGV4VmFsdWUpIHtcbiAgICAgIHZhciBjb21wdXRlZCA9IGV4VmFsdWUsXG4gICAgICAgICAgcmVzdWx0ID0gY29tcHV0ZWQ7XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICB2YXIgY3VycmVudCA9ICtpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICBpZiAoY29tcGFyYXRvcihjdXJyZW50LCBjb21wdXRlZCkgfHwgKGN1cnJlbnQgPT09IGV4VmFsdWUgJiYgY3VycmVudCA9PT0gcmVzdWx0KSkge1xuICAgICAgICAgIGNvbXB1dGVkID0gY3VycmVudDtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbGxgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6ICgrc3RhcnQgfHwgMCk7XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gICAgICB9XG4gICAgICBlbmQgPSAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gbGVuZ3RoKSA/IGxlbmd0aCA6ICgrZW5kIHx8IDApO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6IChlbmQgPj4+IDApO1xuICAgICAgc3RhcnQgPj4+PSAwO1xuXG4gICAgICB3aGlsZSAoc3RhcnQgPCBsZW5ndGgpIHtcbiAgICAgICAgYXJyYXlbc3RhcnQrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWx0ZXJgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRgLCBgXy5maW5kTGFzdGAsIGBfLmZpbmRLZXlgLCBhbmQgYF8uZmluZExhc3RLZXlgLFxuICAgICAqIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcsIHdoaWNoIGl0ZXJhdGVzXG4gICAgICogb3ZlciBgY29sbGVjdGlvbmAgdXNpbmcgdGhlIHByb3ZpZGVkIGBlYWNoRnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0S2V5XSBTcGVjaWZ5IHJldHVybmluZyB0aGUga2V5IG9mIHRoZSBmb3VuZCBlbGVtZW50XG4gICAgICogIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50IG9yIGl0cyBrZXksIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbmQoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBlYWNoRnVuYywgcmV0S2V5KSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmV0S2V5ID8ga2V5IDogdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBhZGRlZCBzdXBwb3J0IGZvciByZXN0cmljdGluZ1xuICAgICAqIGZsYXR0ZW5pbmcgYW5kIHNwZWNpZnlpbmcgdGhlIHN0YXJ0IGluZGV4LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IGZsYXR0ZW5pbmcgdG8gYXJyYXlzLWxpa2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBpc0RlZXAsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgICAgIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAgICAgICAoaXNTdHJpY3QgfHwgaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgaXNEZWVwLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvckluYCBhbmQgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzXG4gICAgICogb3ZlciBgb2JqZWN0YCBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgaW52b2tpbmcgYGl0ZXJhdGVlYCBmb3JcbiAgICAgKiBlYWNoIHByb3BlcnR5LiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHlcbiAgICAgKiByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUZvcmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzXG4gICAgICogaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yUmlnaHQgPSBjcmVhdGVCYXNlRm9yKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9ySW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvckluKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duUmlnaHRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRm9yUmlnaHQob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZnVuY3Rpb25zYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5IG9mXG4gICAgICogYG9iamVjdGAgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZmlsdGVyZWQgZnJvbSB0aG9zZSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGZpbHRlci5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRnVuY3Rpb25zKG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihvYmplY3Rba2V5XSkpIHtcbiAgICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBzdHJpbmcgcGF0aHNcbiAgICAgKiBhbmQgZGVmYXVsdCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXRoS2V5XSBUaGUga2V5IHJlcHJlc2VudGF0aW9uIG9mIHBhdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoLCBwYXRoS2V5KSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHBhdGhLZXkgIT09IHVuZGVmaW5lZCAmJiBwYXRoS2V5IGluIHRvT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcGF0aCA9IFtwYXRoS2V5XTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBvYmplY3QgPSBvYmplY3RbcGF0aFtpbmRleCsrXV07XG4gICAgICB9XG4gICAgICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2l0aG91dCBzdXBwb3J0IGZvciBgdGhpc2AgYmluZGluZ1xuICAgICAqIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTG9vc2VdIFNwZWNpZnkgcGVyZm9ybWluZyBwYXJ0aWFsIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0FdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0JdIFRyYWNrcyB0cmF2ZXJzZWQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdCh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJhc2VJc0VxdWFsLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgICAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAgICAgKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0xvb3NlXSBTcGVjaWZ5IHBlcmZvcm1pbmcgcGFydGlhbCBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBUcmFja3MgdHJhdmVyc2VkIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICAgICAgb2JqVGFnID0gYXJyYXlUYWcsXG4gICAgICAgICAgb3RoVGFnID0gYXJyYXlUYWc7XG5cbiAgICAgIGlmICghb2JqSXNBcnIpIHtcbiAgICAgICAgb2JqVGFnID0gb2JqVG9TdHJpbmcuY2FsbChvYmplY3QpO1xuICAgICAgICBpZiAob2JqVGFnID09IGFyZ3NUYWcpIHtcbiAgICAgICAgICBvYmpUYWcgPSBvYmplY3RUYWc7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqVGFnICE9IG9iamVjdFRhZykge1xuICAgICAgICAgIG9iaklzQXJyID0gaXNUeXBlZEFycmF5KG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghb3RoSXNBcnIpIHtcbiAgICAgICAgb3RoVGFnID0gb2JqVG9TdHJpbmcuY2FsbChvdGhlcik7XG4gICAgICAgIGlmIChvdGhUYWcgPT0gYXJnc1RhZykge1xuICAgICAgICAgIG90aFRhZyA9IG9iamVjdFRhZztcbiAgICAgICAgfSBlbHNlIGlmIChvdGhUYWcgIT0gb2JqZWN0VGFnKSB7XG4gICAgICAgICAgb3RoSXNBcnIgPSBpc1R5cGVkQXJyYXkob3RoZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gICAgICBpZiAoaXNTYW1lVGFnICYmICEob2JqSXNBcnIgfHwgb2JqSXNPYmopKSB7XG4gICAgICAgIHJldHVybiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZyk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzTG9vc2UpIHtcbiAgICAgICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCwgb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaXNTYW1lVGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIC8vIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGRldGVjdGluZyBjaXJjdWxhciByZWZlcmVuY2VzIHNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI0pPLlxuICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBbXSk7XG4gICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IFtdKTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXSA9PSBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQWRkIGBvYmplY3RgIGFuZCBgb3RoZXJgIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgIHN0YWNrQS5wdXNoKG9iamVjdCk7XG4gICAgICBzdGFja0IucHVzaChvdGhlcik7XG5cbiAgICAgIHZhciByZXN1bHQgPSAob2JqSXNBcnIgPyBlcXVhbEFycmF5cyA6IGVxdWFsT2JqZWN0cykob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQik7XG5cbiAgICAgIHN0YWNrQS5wb3AoKTtcbiAgICAgIHN0YWNrQi5wb3AoKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVyeSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gICAgICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSB0b09iamVjdChvYmplY3QpO1xuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICAgICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXkpIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBjdXN0b21pemVyLCB0cnVlKSA6IHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICogYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lcyBub3QgY2xvbmUgYHNvdXJjZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gICAgICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gICAgICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgICAgICB2YXIga2V5ID0gbWF0Y2hEYXRhWzBdWzBdLFxuICAgICAgICAgICAgdmFsdWUgPSBtYXRjaERhdGFbMF1bMV07XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHZhbHVlICYmICh2YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gdG9PYmplY3Qob2JqZWN0KSkpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUlzTWF0Y2gob2JqZWN0LCBtYXRjaERhdGEpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXMgbm90IGNsb25lIGBzcmNWYWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHBhdGgpLFxuICAgICAgICAgIGlzQ29tbW9uID0gaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSxcbiAgICAgICAgICBwYXRoS2V5ID0gKHBhdGggKyAnJyk7XG5cbiAgICAgIHBhdGggPSB0b1BhdGgocGF0aCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5ID0gcGF0aEtleTtcbiAgICAgICAgb2JqZWN0ID0gdG9PYmplY3Qob2JqZWN0KTtcbiAgICAgICAgaWYgKChpc0FyciB8fCAhaXNDb21tb24pICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgICBvYmplY3QgPSBwYXRoLmxlbmd0aCA9PSAxID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuICAgICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXkgPSBsYXN0KHBhdGgpO1xuICAgICAgICAgIG9iamVjdCA9IHRvT2JqZWN0KG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZVxuICAgICAgICAgID8gKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBvYmplY3QpKVxuICAgICAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9iamVjdFtrZXldLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhcmd1bWVudCBqdWdnbGluZyxcbiAgICAgKiBtdWx0aXBsZSBzb3VyY2VzLCBhbmQgYHRoaXNgIGJpbmRpbmcgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgdmFsdWVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuICAgICAgdmFyIGlzU3JjQXJyID0gaXNBcnJheUxpa2Uoc291cmNlKSAmJiAoaXNBcnJheShzb3VyY2UpIHx8IGlzVHlwZWRBcnJheShzb3VyY2UpKSxcbiAgICAgICAgICBwcm9wcyA9IGlzU3JjQXJyID8gdW5kZWZpbmVkIDoga2V5cyhzb3VyY2UpO1xuXG4gICAgICBhcnJheUVhY2gocHJvcHMgfHwgc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgIGtleSA9IHNyY1ZhbHVlO1xuICAgICAgICAgIHNyY1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT2JqZWN0TGlrZShzcmNWYWx1ZSkpIHtcbiAgICAgICAgICBzdGFja0EgfHwgKHN0YWNrQSA9IFtdKTtcbiAgICAgICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IFtdKTtcbiAgICAgICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgICByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBpc0NvbW1vbiA9IHJlc3VsdCA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzcmNWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKChyZXN1bHQgIT09IHVuZGVmaW5lZCB8fCAoaXNTcmNBcnIgJiYgIShrZXkgaW4gb2JqZWN0KSkpICYmXG4gICAgICAgICAgICAgIChpc0NvbW1vbiB8fCAocmVzdWx0ID09PSByZXN1bHQgPyAocmVzdWx0ICE9PSB2YWx1ZSkgOiAodmFsdWUgPT09IHZhbHVlKSkpKSB7XG4gICAgICAgICAgICBvYmplY3Rba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgICAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgdmFsdWVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoLFxuICAgICAgICAgIHNyY1ZhbHVlID0gc291cmNlW2tleV07XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gc3JjVmFsdWUpIHtcbiAgICAgICAgICBvYmplY3Rba2V5XSA9IHN0YWNrQltsZW5ndGhdO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIodmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBpc0NvbW1vbiA9IHJlc3VsdCA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgcmVzdWx0ID0gc3JjVmFsdWU7XG4gICAgICAgIGlmIChpc0FycmF5TGlrZShzcmNWYWx1ZSkgJiYgKGlzQXJyYXkoc3JjVmFsdWUpIHx8IGlzVHlwZWRBcnJheShzcmNWYWx1ZSkpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgIDogKGlzQXJyYXlMaWtlKHZhbHVlKSA/IGFycmF5Q29weSh2YWx1ZSkgOiBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gaXNBcmd1bWVudHModmFsdWUpXG4gICAgICAgICAgICA/IHRvUGxhaW5PYmplY3QodmFsdWUpXG4gICAgICAgICAgICA6IChpc1BsYWluT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDoge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEFkZCB0aGUgc291cmNlIHZhbHVlIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgYXNzb2NpYXRlXG4gICAgICAvLyBpdCB3aXRoIGl0cyBtZXJnZWQgdmFsdWUuXG4gICAgICBzdGFja0EucHVzaChzcmNWYWx1ZSk7XG4gICAgICBzdGFja0IucHVzaChyZXN1bHQpO1xuXG4gICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIG9iamVjdFtrZXldID0gbWVyZ2VGdW5jKHJlc3VsdCwgc3JjVmFsdWUsIGN1c3RvbWl6ZXIsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0ID09PSByZXN1bHQgPyAocmVzdWx0ICE9PSB2YWx1ZSkgOiAodmFsdWUgPT09IHZhbHVlKSkge1xuICAgICAgICBvYmplY3Rba2V5XSA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgICAgIHZhciBwYXRoS2V5ID0gKHBhdGggKyAnJyk7XG4gICAgICBwYXRoID0gdG9QYXRoKHBhdGgpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgsIHBhdGhLZXkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wdWxsQXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIGluZGV4IGFyZ3VtZW50cyBhbmQgY2FwdHVyaW5nIHRoZSByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGluZGV4ZXMgVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGluZGV4ZXMubGVuZ3RoIDogMDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgICAgIGlmIChpbmRleCAhPSBwcmV2aW91cyAmJiBpc0luZGV4KGluZGV4KSkge1xuICAgICAgICAgIHZhciBwcmV2aW91cyA9IGluZGV4O1xuICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5kb21gIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmdcbiAgICAgKiBhbmQgcmV0dXJuaW5nIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSYW5kb20obWluLCBtYXgpIHtcbiAgICAgIHJldHVybiBtaW4gKyBuYXRpdmVGbG9vcihuYXRpdmVSYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVkdWNlYCBhbmQgYF8ucmVkdWNlUmlnaHRgIHdpdGhvdXQgc3VwcG9ydFxuICAgICAqIGZvciBjYWxsYmFjayBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmBcbiAgICAgKiB1c2luZyB0aGUgcHJvdmlkZWQgYGVhY2hGdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbml0RnJvbUNvbGxlY3Rpb24gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3Qgb3IgbGFzdCBlbGVtZW50XG4gICAgICogIG9mIGBjb2xsZWN0aW9uYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRGcm9tQ29sbGVjdGlvbiwgZWFjaEZ1bmMpIHtcbiAgICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBhY2N1bXVsYXRvciA9IGluaXRGcm9tQ29sbGVjdGlvblxuICAgICAgICAgID8gKGluaXRGcm9tQ29sbGVjdGlvbiA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgICAgICA6IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldERhdGFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3AgZGV0ZWN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGJhc2VTZXREYXRhID0gIW1ldGFNYXAgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIGRhdGEpIHtcbiAgICAgIG1ldGFNYXAuc2V0KGZ1bmMsIGRhdGEpO1xuICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogKCtzdGFydCB8fCAwKTtcbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiBsZW5ndGgpID8gbGVuZ3RoIDogKCtlbmQgfHwgMCk7XG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICBlbmQgKz0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApO1xuICAgICAgc3RhcnQgPj4+PSAwO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtpbmRleCArIHN0YXJ0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29tZWAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICogYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9IHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gIXJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeWAgd2hpY2ggdXNlcyBgY29tcGFyZXJgIHRvIGRlZmluZVxuICAgICAqIHRoZSBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpclxuICAgICAqIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc29ydC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBUaGUgZnVuY3Rpb24gdG8gZGVmaW5lIHNvcnQgb3JkZXIuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGFycmF5LnNvcnQoY29tcGFyZXIpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGFycmF5W2xlbmd0aF0gPSBhcnJheVtsZW5ndGhdLnZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeU9yZGVyYCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IGl0ZXJhdGVlcyBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHBhcmFtIHtib29sZWFuW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0QnlPcmRlcihjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycykge1xuICAgICAgdmFyIGNhbGxiYWNrID0gZ2V0Q2FsbGJhY2soKSxcbiAgICAgICAgICBpbmRleCA9IC0xO1xuXG4gICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7IHJldHVybiBjYWxsYmFjayhpdGVyYXRlZSk7IH0pO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZU1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7IHJldHVybiBpdGVyYXRlZSh2YWx1ZSk7IH0pO1xuICAgICAgICByZXR1cm4geyAnY3JpdGVyaWEnOiBjcml0ZXJpYSwgJ2luZGV4JzogKytpbmRleCwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc3VtYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgKiBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVN1bShjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0ICs9ICtpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHx8IDA7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcWAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICogYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpc0NvbW1vbiA9IGluZGV4T2YgPT0gYmFzZUluZGV4T2YsXG4gICAgICAgICAgaXNMYXJnZSA9IGlzQ29tbW9uICYmIGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFLFxuICAgICAgICAgIHNlZW4gPSBpc0xhcmdlID8gY3JlYXRlQ2FjaGUoKSA6IG51bGwsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgIGluZGV4T2YgPSBjYWNoZUluZGV4T2Y7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc0xhcmdlID0gZmFsc2U7XG4gICAgICAgIHNlZW4gPSBpdGVyYXRlZSA/IFtdIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBhcnJheSkgOiB2YWx1ZTtcblxuICAgICAgICBpZiAoaXNDb21tb24gJiYgdmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xuICAgICAgICAgICAgaWYgKHNlZW5bc2VlbkluZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluZGV4T2Yoc2VlbiwgY29tcHV0ZWQsIDApIDwgMCkge1xuICAgICAgICAgIGlmIChpdGVyYXRlZSB8fCBpc0xhcmdlKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAgICAgKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAgICAgKiBvZiBgcHJvcHNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gb2JqZWN0W3Byb3BzW2luZGV4XV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRyb3BSaWdodFdoaWxlYCwgYF8uZHJvcFdoaWxlYCwgYF8udGFrZVJpZ2h0V2hpbGVgLFxuICAgICAqIGFuZCBgXy50YWtlV2hpbGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0Ryb3BdIFNwZWNpZnkgZHJvcHBpbmcgZWxlbWVudHMgaW5zdGVhZCBvZiB0YWtpbmcgdGhlbS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUsIGlzRHJvcCwgZnJvbVJpZ2h0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTE7XG5cbiAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpICYmIHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHt9XG4gICAgICByZXR1cm4gaXNEcm9wXG4gICAgICAgID8gYmFzZVNsaWNlKGFycmF5LCAoZnJvbVJpZ2h0ID8gMCA6IGluZGV4KSwgKGZyb21SaWdodCA/IGluZGV4ICsgMSA6IGxlbmd0aCkpXG4gICAgICAgIDogYmFzZVNsaWNlKGFycmF5LCAoZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogMCksIChmcm9tUmlnaHQgPyBsZW5ndGggOiBpbmRleCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGB3cmFwcGVyVmFsdWVgIHdoaWNoIHJldHVybnMgdGhlIHJlc3VsdCBvZlxuICAgICAqIHBlcmZvcm1pbmcgYSBzZXF1ZW5jZSBvZiBhY3Rpb25zIG9uIHRoZSB1bndyYXBwZWQgYHZhbHVlYCwgd2hlcmUgZWFjaFxuICAgICAqIHN1Y2Nlc3NpdmUgYWN0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYWN0aW9ucyBBY3Rpb25zIHRvIHBlZm9ybSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VXcmFwcGVyVmFsdWUodmFsdWUsIGFjdGlvbnMpIHtcbiAgICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcbiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQudmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFjdGlvbnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgYWN0aW9uID0gYWN0aW9uc1tpbmRleF07XG4gICAgICAgIHJlc3VsdCA9IGFjdGlvbi5mdW5jLmFwcGx5KGFjdGlvbi50aGlzQXJnLCBhcnJheVB1c2goW3Jlc3VsdF0sIGFjdGlvbi5hcmdzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBvZiBgYXJyYXlgIHRvIGRldGVybWluZSB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYFxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmFyeUluZGV4KGFycmF5LCB2YWx1ZSwgcmV0SGlnaGVzdCkge1xuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogbG93O1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID09PSB2YWx1ZSAmJiBoaWdoIDw9IEhBTEZfTUFYX0FSUkFZX0xFTkdUSCkge1xuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDEsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gYXJyYXlbbWlkXTtcblxuICAgICAgICAgIGlmICgocmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSkpICYmIGNvbXB1dGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlnaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiaW5hcnlJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaWRlbnRpdHksIHJldEhpZ2hlc3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmluYXJ5SW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGludm9rZXMgYGl0ZXJhdGVlYCBmb3JcbiAgICAgKiBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyIHNvcnQgcmFua2luZy4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5hcnlJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUsIHJldEhpZ2hlc3QpIHtcbiAgICAgIHZhbHVlID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHZhbElzTmFOID0gdmFsdWUgIT09IHZhbHVlLFxuICAgICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICAgIHZhbElzVW5kZWYgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICB2YXIgbWlkID0gbmF0aXZlRmxvb3IoKGxvdyArIGhpZ2gpIC8gMiksXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKGFycmF5W21pZF0pLFxuICAgICAgICAgICAgaXNEZWYgPSBjb21wdXRlZCAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgaXNSZWZsZXhpdmUgPSBjb21wdXRlZCA9PT0gY29tcHV0ZWQ7XG5cbiAgICAgICAgaWYgKHZhbElzTmFOKSB7XG4gICAgICAgICAgdmFyIHNldExvdyA9IGlzUmVmbGV4aXZlIHx8IHJldEhpZ2hlc3Q7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNOdWxsKSB7XG4gICAgICAgICAgc2V0TG93ID0gaXNSZWZsZXhpdmUgJiYgaXNEZWYgJiYgKHJldEhpZ2hlc3QgfHwgY29tcHV0ZWQgIT0gbnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNVbmRlZikge1xuICAgICAgICAgIHNldExvdyA9IGlzUmVmbGV4aXZlICYmIChyZXRIaWdoZXN0IHx8IGlzRGVmKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wdXRlZCA9PSBudWxsKSB7XG4gICAgICAgICAgc2V0TG93ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0TG93ID0gcmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldExvdykge1xuICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZU1pbihoaWdoLCBNQVhfQVJSQVlfSU5ERVgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUNhbGxiYWNrYCB3aGljaCBvbmx5IHN1cHBvcnRzIGB0aGlzYCBiaW5kaW5nXG4gICAgICogYW5kIHNwZWNpZnlpbmcgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcmdDb3VudF0gVGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzQXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGFyZ0NvdW50KSB7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgNTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlciwga2V5LCBvYmplY3QsIHNvdXJjZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUsIG90aGVyLCBrZXksIG9iamVjdCwgc291cmNlKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBnaXZlbiBhcnJheSBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBidWZmZXJDbG9uZShidWZmZXIpIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyLmJ5dGVMZW5ndGgpLFxuICAgICAgICAgIHZpZXcgPSBuZXcgVWludDhBcnJheShyZXN1bHQpO1xuXG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWZmZXIpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMsXG4gICAgICogcGxhY2Vob2xkZXJzLCBhbmQgcHJvdmlkZWQgYXJndW1lbnRzIGludG8gYSBzaW5nbGUgYXJyYXkgb2YgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzKSB7XG4gICAgICB2YXIgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlZnRMZW5ndGggKyBhcmdzTGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtob2xkZXJzW2FyZ3NJbmRleF1dID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4KytdID0gYXJnc1thcmdzSW5kZXgrK107XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgY29tcG9zZUFyZ3NgIGV4Y2VwdCB0aGF0IHRoZSBhcmd1bWVudHMgY29tcG9zaXRpb25cbiAgICAgKiBpcyB0YWlsb3JlZCBmb3IgYF8ucGFydGlhbFJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHMsIGhvbGRlcnMpIHtcbiAgICAgIHZhciBob2xkZXJzSW5kZXggPSAtMSxcbiAgICAgICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxuICAgICAgICAgIHJpZ2h0SW5kZXggPSAtMSxcbiAgICAgICAgICByaWdodExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShhcmdzTGVuZ3RoICsgcmlnaHRMZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFthcmdzSW5kZXhdID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgfVxuICAgICAgdmFyIG9mZnNldCA9IGFyZ3NJbmRleDtcbiAgICAgIHdoaWxlICgrK3JpZ2h0SW5kZXggPCByaWdodExlbmd0aCkge1xuICAgICAgICByZXN1bHRbb2Zmc2V0ICsgcmlnaHRJbmRleF0gPSBwYXJ0aWFsc1tyaWdodEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2hvbGRlcnNJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W29mZnNldCArIGhvbGRlcnNbaG9sZGVyc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmNvdW50QnlgLCBgXy5ncm91cEJ5YCwgYF8uaW5kZXhCeWAsIG9yIGBfLnBhcnRpdGlvbmAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGtleXMgYW5kIHZhbHVlcyBvZiB0aGUgYWNjdW11bGF0b3Igb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpbml0aWFsaXplcl0gVGhlIGZ1bmN0aW9uIHRvIGluaXRpYWxpemUgdGhlIGFjY3VtdWxhdG9yIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3Ioc2V0dGVyLCBpbml0aWFsaXplcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBpbml0aWFsaXplciA/IGluaXRpYWxpemVyKCkgOiB7fTtcbiAgICAgICAgaXRlcmF0ZWUgPSBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG5cbiAgICAgICAgaWYgKGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgICBzZXR0ZXIocmVzdWx0LCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSwgY29sbGVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIHNldHRlcihyZXN1bHQsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSwgY29sbGVjdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmFzc2lnbmAsIGBfLmRlZmF1bHRzYCwgb3IgYF8ubWVyZ2VgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICAgICAgcmV0dXJuIHJlc3RQYXJhbShmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAyID8gc291cmNlc1tsZW5ndGggLSAyXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0aGlzQXJnID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjdXN0b21pemVyID0gYmluZENhbGxiYWNrKGN1c3RvbWl6ZXIsIHRoaXNBcmcsIDUpO1xuICAgICAgICAgIGxlbmd0aCAtPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgdGhpc0FyZyA9PSAnZnVuY3Rpb24nID8gdGhpc0FyZyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBsZW5ndGggLT0gKGN1c3RvbWl6ZXIgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBnZXRMZW5ndGgoY29sbGVjdGlvbikgOiAwO1xuICAgICAgICBpZiAoIWlzTGVuZ3RoKGxlbmd0aCkpIHtcbiAgICAgICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICAgICAgaXRlcmFibGUgPSB0b09iamVjdChjb2xsZWN0aW9uKTtcblxuICAgICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBgXy5mb3JJbmAgb3IgYF8uZm9ySW5SaWdodGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgICAgICB2YXIgaXRlcmFibGUgPSB0b09iamVjdChvYmplY3QpLFxuICAgICAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMTtcblxuICAgICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCBhbmQgaW52b2tlcyBpdCB3aXRoIHRoZSBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJpbmRXcmFwcGVyKGZ1bmMsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBDdG9yID0gY3JlYXRlQ3RvcldyYXBwZXIoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBTZXRgIGNhY2hlIG9iamVjdCB0byBvcHRpbWl6ZSBsaW5lYXIgc2VhcmNoZXMgb2YgbGFyZ2UgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICAgICAqIEByZXR1cm5zIHtudWxsfE9iamVjdH0gUmV0dXJucyB0aGUgbmV3IGNhY2hlIG9iamVjdCBpZiBgU2V0YCBpcyBzdXBwb3J0ZWQsIGVsc2UgYG51bGxgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhY2hlKHZhbHVlcykge1xuICAgICAgcmV0dXJuIChuYXRpdmVDcmVhdGUgJiYgU2V0KSA/IG5ldyBTZXRDYWNoZSh2YWx1ZXMpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBjb21wb3VuZCB3b3JkcyBvdXQgb2YgdGhlIHdvcmRzIGluIGFcbiAgICAgKiBnaXZlbiBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lIGVhY2ggd29yZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3VuZGVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvdW5kZXIoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBhcnJheSA9IHdvcmRzKGRlYnVycihzdHJpbmcpKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2socmVzdWx0LCBhcnJheVtpbmRleF0sIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhbiBpbnN0YW5jZSBvZiBgQ3RvcmAgcmVnYXJkbGVzcyBvZlxuICAgICAqIHdoZXRoZXIgaXQgd2FzIGludm9rZWQgYXMgcGFydCBvZiBhIGBuZXdgIGV4cHJlc3Npb24gb3IgYnkgYGNhbGxgIG9yIGBhcHBseWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IEN0b3IgVGhlIGNvbnN0cnVjdG9yIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdG9yV3JhcHBlcihDdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFVzZSBhIGBzd2l0Y2hgIHN0YXRlbWVudCB0byB3b3JrIHdpdGggY2xhc3MgY29uc3RydWN0b3JzLlxuICAgICAgICAvLyBTZWUgaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtZWNtYXNjcmlwdC1mdW5jdGlvbi1vYmplY3RzLWNhbGwtdGhpc2FyZ3VtZW50LWFyZ3VtZW50c2xpc3RcbiAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQ3RvcjtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdKTtcbiAgICAgICAgICBjYXNlIDc6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdLCBhcmdzWzZdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKEN0b3IucHJvdG90eXBlKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IEN0b3IuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuXG4gICAgICAgIC8vIE1pbWljIHRoZSBjb25zdHJ1Y3RvcidzIGByZXR1cm5gIGJlaGF2aW9yLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTMuMi4yIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5jdXJyeWAgb3IgYF8uY3VycnlSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmxhZyBUaGUgY3VycnkgYml0IGZsYWcuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycnkgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3VycnkoZmxhZykge1xuICAgICAgZnVuY3Rpb24gY3VycnlGdW5jKGZ1bmMsIGFyaXR5LCBndWFyZCkge1xuICAgICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoZnVuYywgYXJpdHksIGd1YXJkKSkge1xuICAgICAgICAgIGFyaXR5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVXcmFwcGVyKGZ1bmMsIGZsYWcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSk7XG4gICAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IGN1cnJ5RnVuYy5wbGFjZWhvbGRlcjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyeUZ1bmM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmRlZmF1bHRzYCBvciBgXy5kZWZhdWx0c0RlZXBgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlZmF1bHRzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRzKGFzc2lnbmVyLCBjdXN0b21pemVyKSB7XG4gICAgICByZXR1cm4gcmVzdFBhcmFtKGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IGFyZ3NbMF07XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgYXJncy5wdXNoKGN1c3RvbWl6ZXIpO1xuICAgICAgICByZXR1cm4gYXNzaWduZXIuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5tYXhgIG9yIGBfLm1pbmAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGZ1bmN0aW9uIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBleFZhbHVlIFRoZSBpbml0aWFsIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGV4dHJlbXVtIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUV4dHJlbXVtKGNvbXBhcmF0b3IsIGV4VmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgICBpZiAodGhpc0FyZyAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykpIHtcbiAgICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpdGVyYXRlZSA9IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgaWYgKGl0ZXJhdGVlLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgY29sbGVjdGlvbiA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uIDogdG9JdGVyYWJsZShjb2xsZWN0aW9uKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gYXJyYXlFeHRyZW11bShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgY29tcGFyYXRvciwgZXhWYWx1ZSk7XG4gICAgICAgICAgaWYgKCEoY29sbGVjdGlvbi5sZW5ndGggJiYgcmVzdWx0ID09PSBleFZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VFeHRyZW11bShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgY29tcGFyYXRvciwgZXhWYWx1ZSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmluZChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICAgIGlmIChpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gYmFzZUZpbmRJbmRleChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21SaWdodCk7XG4gICAgICAgICAgcmV0dXJuIGluZGV4ID4gLTEgPyBjb2xsZWN0aW9uW2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZUZpbmQoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBlYWNoRnVuYyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5maW5kSW5kZXhgIG9yIGBfLmZpbmRMYXN0SW5kZXhgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpbmRJbmRleChmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbVJpZ2h0KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZpbmRLZXlgIG9yIGBfLmZpbmRMYXN0S2V5YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb2JqZWN0RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGFuIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpbmRLZXkob2JqZWN0RnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICAgIHJldHVybiBiYXNlRmluZChvYmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0RnVuYywgdHJ1ZSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5mbG93YCBvciBgXy5mbG93UmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmbG93IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZsb3coZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB3cmFwcGVyLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgICAgICBsZWZ0SW5kZXggPSAwLFxuICAgICAgICAgICAgZnVuY3MgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBmdW5jc1tsZWZ0SW5kZXgrK10gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghd3JhcHBlciAmJiBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS50aHJ1ICYmIGdldEZ1bmNOYW1lKGZ1bmMpID09ICd3cmFwcGVyJykge1xuICAgICAgICAgICAgd3JhcHBlciA9IG5ldyBMb2Rhc2hXcmFwcGVyKFtdLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSB3cmFwcGVyID8gLTEgOiBsZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgZnVuYyA9IGZ1bmNzW2luZGV4XTtcblxuICAgICAgICAgIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpLFxuICAgICAgICAgICAgICBkYXRhID0gZnVuY05hbWUgPT0gJ3dyYXBwZXInID8gZ2V0RGF0YShmdW5jKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChkYXRhICYmIGlzTGF6aWFibGUoZGF0YVswXSkgJiYgZGF0YVsxXSA9PSAoQVJZX0ZMQUcgfCBDVVJSWV9GTEFHIHwgUEFSVElBTF9GTEFHIHwgUkVBUkdfRkxBRykgJiYgIWRhdGFbNF0ubGVuZ3RoICYmIGRhdGFbOV0gPT0gMSkge1xuICAgICAgICAgICAgd3JhcHBlciA9IHdyYXBwZXJbZ2V0RnVuY05hbWUoZGF0YVswXSldLmFwcGx5KHdyYXBwZXIsIGRhdGFbM10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gKGZ1bmMubGVuZ3RoID09IDEgJiYgaXNMYXppYWJsZShmdW5jKSkgPyB3cmFwcGVyW2Z1bmNOYW1lXSgpIDogd3JhcHBlci50aHJ1KGZ1bmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIHZhbHVlID0gYXJnc1swXTtcblxuICAgICAgICAgIGlmICh3cmFwcGVyICYmIGFyZ3MubGVuZ3RoID09IDEgJiYgaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyLnBsYW50KHZhbHVlKS52YWx1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgICByZXN1bHQgPSBsZW5ndGggPyBmdW5jc1tpbmRleF0uYXBwbHkodGhpcywgYXJncykgOiB2YWx1ZTtcblxuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jc1tpbmRleF0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gZm9yIGBfLmZvckVhY2hgIG9yIGBfLmZvckVhY2hSaWdodGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFycmF5RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGFuIGFycmF5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGVhY2ggZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRm9yRWFjaChhcnJheUZ1bmMsIGVhY2hGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnID09PSB1bmRlZmluZWQgJiYgaXNBcnJheShjb2xsZWN0aW9uKSlcbiAgICAgICAgICA/IGFycmF5RnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSlcbiAgICAgICAgICA6IGVhY2hGdW5jKGNvbGxlY3Rpb24sIGJpbmRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMykpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gZm9yIGBfLmZvckluYCBvciBgXy5mb3JJblJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb2JqZWN0RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGFuIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBlYWNoIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZvckluKG9iamVjdEZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlcmF0ZWUgIT0gJ2Z1bmN0aW9uJyB8fCB0aGlzQXJnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpdGVyYXRlZSA9IGJpbmRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdEZ1bmMob2JqZWN0LCBpdGVyYXRlZSwga2V5c0luKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGZvciBgXy5mb3JPd25gIG9yIGBfLmZvck93blJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb2JqZWN0RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGFuIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBlYWNoIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZvck93bihvYmplY3RGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZXJhdGVlICE9ICdmdW5jdGlvbicgfHwgdGhpc0FyZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaXRlcmF0ZWUgPSBiaW5kQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3RGdW5jKG9iamVjdCwgaXRlcmF0ZWUpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gZm9yIGBfLm1hcEtleXNgIG9yIGBfLm1hcFZhbHVlc2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTWFwS2V5c10gU3BlY2lmeSBtYXBwaW5nIGtleXMgaW5zdGVhZCBvZiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWFwIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE1hcHBlcihpc01hcEtleXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaXRlcmF0ZWUgPSBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG5cbiAgICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICAgIHZhciBtYXBwZWQgPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpO1xuICAgICAgICAgIGtleSA9IGlzTWFwS2V5cyA/IG1hcHBlZCA6IGtleTtcbiAgICAgICAgICB2YWx1ZSA9IGlzTWFwS2V5cyA/IHZhbHVlIDogbWFwcGVkO1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gZm9yIGBfLnBhZExlZnRgIG9yIGBfLnBhZFJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IHBhZGRpbmcgZnJvbSB0aGUgcmlnaHQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhZERpcihmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgIHJldHVybiAoZnJvbVJpZ2h0ID8gc3RyaW5nIDogJycpICsgY3JlYXRlUGFkZGluZyhzdHJpbmcsIGxlbmd0aCwgY2hhcnMpICsgKGZyb21SaWdodCA/ICcnIDogc3RyaW5nKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLnBhcnRpYWxgIG9yIGBfLnBhcnRpYWxSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmxhZyBUaGUgcGFydGlhbCBiaXQgZmxhZy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhcnRpYWwoZmxhZykge1xuICAgICAgdmFyIHBhcnRpYWxGdW5jID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIHBhcnRpYWxGdW5jLnBsYWNlaG9sZGVyKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgZmxhZywgdW5kZWZpbmVkLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXJ0aWFsRnVuYztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gZm9yIGBfLnJlZHVjZWAgb3IgYF8ucmVkdWNlUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhcnJheUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhbiBhcnJheS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBlYWNoIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZShhcnJheUZ1bmMsIGVhY2hGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciBpbml0RnJvbUFycmF5ID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG4gICAgICAgIHJldHVybiAodHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgJiYgdGhpc0FyZyA9PT0gdW5kZWZpbmVkICYmIGlzQXJyYXkoY29sbGVjdGlvbikpXG4gICAgICAgICAgPyBhcnJheUZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0RnJvbUFycmF5KVxuICAgICAgICAgIDogYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgNCksIGFjY3VtdWxhdG9yLCBpbml0RnJvbUFycmF5LCBlYWNoRnVuYyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCBhbmQgaW52b2tlcyBpdCB3aXRoIG9wdGlvbmFsIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YsIHBhcnRpYWwgYXBwbGljYXRpb24sIGFuZCBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHJlZmVyZW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBmbGFncy4gU2VlIGBjcmVhdGVXcmFwcGVyYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNSaWdodF0gVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc1JpZ2h0XSBUaGUgYHBhcnRpYWxzUmlnaHRgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlSHlicmlkV3JhcHBlcihmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0FyeSA9IGJpdG1hc2sgJiBBUllfRkxBRyxcbiAgICAgICAgICBpc0JpbmQgPSBiaXRtYXNrICYgQklORF9GTEFHLFxuICAgICAgICAgIGlzQmluZEtleSA9IGJpdG1hc2sgJiBCSU5EX0tFWV9GTEFHLFxuICAgICAgICAgIGlzQ3VycnkgPSBiaXRtYXNrICYgQ1VSUllfRkxBRyxcbiAgICAgICAgICBpc0N1cnJ5Qm91bmQgPSBiaXRtYXNrICYgQ1VSUllfQk9VTkRfRkxBRyxcbiAgICAgICAgICBpc0N1cnJ5UmlnaHQgPSBiaXRtYXNrICYgQ1VSUllfUklHSFRfRkxBRyxcbiAgICAgICAgICBDdG9yID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogY3JlYXRlQ3RvcldyYXBwZXIoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIC8vIEF2b2lkIGBhcmd1bWVudHNgIG9iamVjdCB1c2UgZGlzcXVhbGlmeWluZyBvcHRpbWl6YXRpb25zIGJ5XG4gICAgICAgIC8vIGNvbnZlcnRpbmcgaXQgdG8gYW4gYXJyYXkgYmVmb3JlIHByb3ZpZGluZyBpdCB0byBvdGhlciBmdW5jdGlvbnMuXG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHMpIHtcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFsc1JpZ2h0KSB7XG4gICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDdXJyeSB8fCBpc0N1cnJ5UmlnaHQpIHtcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSB3cmFwcGVyLnBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICBhcmdzSG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcblxuICAgICAgICAgIGxlbmd0aCAtPSBhcmdzSG9sZGVycy5sZW5ndGg7XG4gICAgICAgICAgaWYgKGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgICB2YXIgbmV3QXJnUG9zID0gYXJnUG9zID8gYXJyYXlDb3B5KGFyZ1BvcykgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbmV3QXJpdHkgPSBuYXRpdmVNYXgoYXJpdHkgLSBsZW5ndGgsIDApLFxuICAgICAgICAgICAgICAgIG5ld3NIb2xkZXJzID0gaXNDdXJyeSA/IGFyZ3NIb2xkZXJzIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG5ld0hvbGRlcnNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBhcmdzSG9sZGVycyxcbiAgICAgICAgICAgICAgICBuZXdQYXJ0aWFscyA9IGlzQ3VycnkgPyBhcmdzIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG5ld1BhcnRpYWxzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogYXJncztcblxuICAgICAgICAgICAgYml0bWFzayB8PSAoaXNDdXJyeSA/IFBBUlRJQUxfRkxBRyA6IFBBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgICAgICAgICBiaXRtYXNrICY9IH4oaXNDdXJyeSA/IFBBUlRJQUxfUklHSFRfRkxBRyA6IFBBUlRJQUxfRkxBRyk7XG5cbiAgICAgICAgICAgIGlmICghaXNDdXJyeUJvdW5kKSB7XG4gICAgICAgICAgICAgIGJpdG1hc2sgJj0gfihCSU5EX0ZMQUcgfCBCSU5EX0tFWV9GTEFHKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXdEYXRhID0gW2Z1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIG5ld1BhcnRpYWxzLCBuZXdzSG9sZGVycywgbmV3UGFydGlhbHNSaWdodCwgbmV3SG9sZGVyc1JpZ2h0LCBuZXdBcmdQb3MsIGFyeSwgbmV3QXJpdHldLFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNyZWF0ZUh5YnJpZFdyYXBwZXIuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcblxuICAgICAgICAgICAgaWYgKGlzTGF6aWFibGUoZnVuYykpIHtcbiAgICAgICAgICAgICAgc2V0RGF0YShyZXN1bHQsIG5ld0RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcyxcbiAgICAgICAgICAgIGZuID0gaXNCaW5kS2V5ID8gdGhpc0JpbmRpbmdbZnVuY10gOiBmdW5jO1xuXG4gICAgICAgIGlmIChhcmdQb3MpIHtcbiAgICAgICAgICBhcmdzID0gcmVvcmRlcihhcmdzLCBhcmdQb3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FyeSAmJiBhcnkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGFyZ3MubGVuZ3RoID0gYXJ5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpIHtcbiAgICAgICAgICBmbiA9IEN0b3IgfHwgY3JlYXRlQ3RvcldyYXBwZXIoZnVuYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHBhZGRpbmcgcmVxdWlyZWQgZm9yIGBzdHJpbmdgIGJhc2VkIG9uIHRoZSBnaXZlbiBgbGVuZ3RoYC5cbiAgICAgKiBUaGUgYGNoYXJzYCBzdHJpbmcgaXMgdHJ1bmNhdGVkIGlmIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBleGNlZWRzIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY3JlYXRlIHBhZGRpbmcgZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkIGZvciBgc3RyaW5nYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYWRkaW5nKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgdmFyIHN0ckxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBsZW5ndGggPSArbGVuZ3RoO1xuXG4gICAgICBpZiAoc3RyTGVuZ3RoID49IGxlbmd0aCB8fCAhbmF0aXZlSXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICB2YXIgcGFkTGVuZ3RoID0gbGVuZ3RoIC0gc3RyTGVuZ3RoO1xuICAgICAgY2hhcnMgPSBjaGFycyA9PSBudWxsID8gJyAnIDogKGNoYXJzICsgJycpO1xuICAgICAgcmV0dXJuIHJlcGVhdChjaGFycywgbmF0aXZlQ2VpbChwYWRMZW5ndGggLyBjaGFycy5sZW5ndGgpKS5zbGljZSgwLCBwYWRMZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCBhbmQgaW52b2tlcyBpdCB3aXRoIHRoZSBvcHRpb25hbCBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogdGhlIHdyYXBwZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcHBlcmAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWFsV3JhcHBlcihmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBCSU5EX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGNyZWF0ZUN0b3JXcmFwcGVyKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICAvLyBBdm9pZCBgYXJndW1lbnRzYCBvYmplY3QgdXNlIGRpc3F1YWxpZnlpbmcgb3B0aW1pemF0aW9ucyBieVxuICAgICAgICAvLyBjb252ZXJ0aW5nIGl0IHRvIGFuIGFycmF5IGJlZm9yZSBwcm92aWRpbmcgaXQgYGZ1bmNgLlxuICAgICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZWZ0TGVuZ3RoICsgYXJnc0xlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4KytdID0gYXJndW1lbnRzWysrYXJnc0luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmNlaWxgLCBgXy5mbG9vcmAsIG9yIGBfLnJvdW5kYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBNYXRoYCBtZXRob2QgdG8gdXNlIHdoZW4gcm91bmRpbmcuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUm91bmQobWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBNYXRoW21ldGhvZE5hbWVdO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG51bWJlciwgcHJlY2lzaW9uKSB7XG4gICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gMCA6ICgrcHJlY2lzaW9uIHx8IDApO1xuICAgICAgICBpZiAocHJlY2lzaW9uKSB7XG4gICAgICAgICAgcHJlY2lzaW9uID0gcG93KDEwLCBwcmVjaXNpb24pO1xuICAgICAgICAgIHJldHVybiBmdW5jKG51bWJlciAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMobnVtYmVyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLnNvcnRlZEluZGV4YCBvciBgXy5zb3J0ZWRMYXN0SW5kZXhgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW5kZXggZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlU29ydGVkSW5kZXgocmV0SGlnaGVzdCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gZ2V0Q2FsbGJhY2soaXRlcmF0ZWUpO1xuICAgICAgICByZXR1cm4gKGl0ZXJhdGVlID09IG51bGwgJiYgY2FsbGJhY2sgPT09IGJhc2VDYWxsYmFjaylcbiAgICAgICAgICA/IGJpbmFyeUluZGV4KGFycmF5LCB2YWx1ZSwgcmV0SGlnaGVzdClcbiAgICAgICAgICA6IGJpbmFyeUluZGV4QnkoYXJyYXksIHZhbHVlLCBjYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMSksIHJldEhpZ2hlc3QpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBlaXRoZXIgY3VycmllcyBvciBpbnZva2VzIGBmdW5jYCB3aXRoIG9wdGlvbmFsXG4gICAgICogYHRoaXNgIGJpbmRpbmcgYW5kIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHJlZmVyZW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBmbGFncy5cbiAgICAgKiAgVGhlIGJpdG1hc2sgbWF5IGJlIGNvbXBvc2VkIG9mIHRoZSBmb2xsb3dpbmcgZmxhZ3M6XG4gICAgICogICAgIDEgLSBgXy5iaW5kYFxuICAgICAqICAgICAyIC0gYF8uYmluZEtleWBcbiAgICAgKiAgICAgNCAtIGBfLmN1cnJ5YCBvciBgXy5jdXJyeVJpZ2h0YCBvZiBhIGJvdW5kIGZ1bmN0aW9uXG4gICAgICogICAgIDggLSBgXy5jdXJyeWBcbiAgICAgKiAgICAxNiAtIGBfLmN1cnJ5UmlnaHRgXG4gICAgICogICAgMzIgLSBgXy5wYXJ0aWFsYFxuICAgICAqICAgIDY0IC0gYF8ucGFydGlhbFJpZ2h0YFxuICAgICAqICAgMTI4IC0gYF8ucmVhcmdgXG4gICAgICogICAyNTYgLSBgXy5hcnlgXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlV3JhcHBlcihmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNCaW5kS2V5ID0gYml0bWFzayAmIEJJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAoIWlzQmluZEtleSAmJiB0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBwYXJ0aWFscyA/IHBhcnRpYWxzLmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBiaXRtYXNrICY9IH4oUEFSVElBTF9GTEFHIHwgUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgbGVuZ3RoIC09IChob2xkZXJzID8gaG9sZGVycy5sZW5ndGggOiAwKTtcbiAgICAgIGlmIChiaXRtYXNrICYgUEFSVElBTF9SSUdIVF9GTEFHKSB7XG4gICAgICAgIHZhciBwYXJ0aWFsc1JpZ2h0ID0gcGFydGlhbHMsXG4gICAgICAgICAgICBob2xkZXJzUmlnaHQgPSBob2xkZXJzO1xuXG4gICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogZ2V0RGF0YShmdW5jKSxcbiAgICAgICAgICBuZXdEYXRhID0gW2Z1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eV07XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIG1lcmdlRGF0YShuZXdEYXRhLCBkYXRhKTtcbiAgICAgICAgYml0bWFzayA9IG5ld0RhdGFbMV07XG4gICAgICAgIGFyaXR5ID0gbmV3RGF0YVs5XTtcbiAgICAgIH1cbiAgICAgIG5ld0RhdGFbOV0gPSBhcml0eSA9PSBudWxsXG4gICAgICAgID8gKGlzQmluZEtleSA/IDAgOiBmdW5jLmxlbmd0aClcbiAgICAgICAgOiAobmF0aXZlTWF4KGFyaXR5IC0gbGVuZ3RoLCAwKSB8fCAwKTtcblxuICAgICAgaWYgKGJpdG1hc2sgPT0gQklORF9GTEFHKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVCaW5kV3JhcHBlcihuZXdEYXRhWzBdLCBuZXdEYXRhWzJdKTtcbiAgICAgIH0gZWxzZSBpZiAoKGJpdG1hc2sgPT0gUEFSVElBTF9GTEFHIHx8IGJpdG1hc2sgPT0gKEJJTkRfRkxBRyB8IFBBUlRJQUxfRkxBRykpICYmICFuZXdEYXRhWzRdLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVQYXJ0aWFsV3JhcHBlci5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlSHlicmlkV3JhcHBlci5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICAgICAgfVxuICAgICAgdmFyIHNldHRlciA9IGRhdGEgPyBiYXNlU2V0RGF0YSA6IHNldERhdGE7XG4gICAgICByZXR1cm4gc2V0dGVyKHJlc3VsdCwgbmV3RGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyBhcnJheXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNMb29zZV0gU3BlY2lmeSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQV0gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQl0gVHJhY2tzIHRyYXZlcnNlZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgICAgIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNMb29zZSAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdLFxuICAgICAgICAgICAgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIoaXNMb29zZSA/IG90aFZhbHVlIDogYXJyVmFsdWUsIGlzTG9vc2UgPyBhcnJWYWx1ZSA6IG90aFZhbHVlLCBpbmRleCkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBpZiAoaXNMb29zZSkge1xuICAgICAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gICAgICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcpIHtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtYmVycywgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzIGFuZCBib29sZWFuc1xuICAgICAgICAgIC8vIHRvIGAxYCBvciBgMGAgdHJlYXRpbmcgaW52YWxpZCBkYXRlcyBjb2VyY2VkIHRvIGBOYU5gIGFzIG5vdCBlcXVhbC5cbiAgICAgICAgICByZXR1cm4gK29iamVjdCA9PSArb3RoZXI7XG5cbiAgICAgICAgY2FzZSBlcnJvclRhZzpcbiAgICAgICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICAgIC8vIFRyZWF0IGBOYU5gIHZzLiBgTmFOYCBhcyBlcXVhbC5cbiAgICAgICAgICByZXR1cm4gKG9iamVjdCAhPSArb2JqZWN0KVxuICAgICAgICAgICAgPyBvdGhlciAhPSArb3RoZXJcbiAgICAgICAgICAgIDogb2JqZWN0ID09ICtvdGhlcjtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncyBwcmltaXRpdmVzIGFuZCBzdHJpbmdcbiAgICAgICAgICAvLyBvYmplY3RzIGFzIGVxdWFsLiBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMTAuNi40IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNMb29zZV0gU3BlY2lmeSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQV0gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQl0gVHJhY2tzIHRyYXZlcnNlZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIHZhciBvYmpQcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICAgICAgb3RoUHJvcHMgPSBrZXlzKG90aGVyKSxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgICAgIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc0xvb3NlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgIGlmICghKGlzTG9vc2UgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHNraXBDdG9yID0gaXNMb29zZTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAgICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV0sXG4gICAgICAgICAgICByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihpc0xvb3NlID8gb3RoVmFsdWUgOiBvYmpWYWx1ZSwgaXNMb29zZT8gb2JqVmFsdWUgOiBvdGhWYWx1ZSwga2V5KSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWQgPyBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikgOiByZXN1bHQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgICAgIH1cbiAgICAgIGlmICghc2tpcEN0b3IpIHtcbiAgICAgICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAgICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcHByb3ByaWF0ZSBcImNhbGxiYWNrXCIgZnVuY3Rpb24uIElmIHRoZSBgXy5jYWxsYmFja2AgbWV0aG9kIGlzXG4gICAgICogY3VzdG9taXplZCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGN1c3RvbSBtZXRob2QsIG90aGVyd2lzZSBpdCByZXR1cm5zXG4gICAgICogdGhlIGBiYXNlQ2FsbGJhY2tgIGZ1bmN0aW9uLiBJZiBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRoZSBjaG9zZW4gZnVuY3Rpb25cbiAgICAgKiBpcyBpbnZva2VkIHdpdGggdGhlbSBhbmQgaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjaG9zZW4gZnVuY3Rpb24gb3IgaXRzIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaC5jYWxsYmFjayB8fCBjYWxsYmFjaztcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gY2FsbGJhY2sgPyBiYXNlQ2FsbGJhY2sgOiByZXN1bHQ7XG4gICAgICByZXR1cm4gYXJnQ291bnQgPyByZXN1bHQoZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGdldERhdGEgPSAhbWV0YU1hcCA/IG5vb3AgOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICByZXR1cm4gbWV0YU1hcC5nZXQoZnVuYyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hbWUgb2YgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEZ1bmNOYW1lKGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBmdW5jLm5hbWUsXG4gICAgICAgICAgYXJyYXkgPSByZWFsTmFtZXNbcmVzdWx0XSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgZGF0YSA9IGFycmF5W2xlbmd0aF0sXG4gICAgICAgICAgICBvdGhlckZ1bmMgPSBkYXRhLmZ1bmM7XG4gICAgICAgIGlmIChvdGhlckZ1bmMgPT0gbnVsbCB8fCBvdGhlckZ1bmMgPT0gZnVuYykge1xuICAgICAgICAgIHJldHVybiBkYXRhLm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpbmRleE9mXCIgZnVuY3Rpb24uIElmIHRoZSBgXy5pbmRleE9mYCBtZXRob2QgaXNcbiAgICAgKiBjdXN0b21pemVkIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgY3VzdG9tIG1ldGhvZCwgb3RoZXJ3aXNlIGl0IHJldHVybnNcbiAgICAgKiB0aGUgYGJhc2VJbmRleE9mYCBmdW5jdGlvbi4gSWYgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0aGUgY2hvc2VuIGZ1bmN0aW9uXG4gICAgICogaXMgaW52b2tlZCB3aXRoIHRoZW0gYW5kIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxudW1iZXJ9IFJldHVybnMgdGhlIGNob3NlbiBmdW5jdGlvbiBvciBpdHMgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEluZGV4T2YoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2guaW5kZXhPZiB8fCBpbmRleE9mO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSBpbmRleE9mID8gYmFzZUluZGV4T2YgOiByZXN1bHQ7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbiA/IHJlc3VsdChjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSB2YWx1ZSBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYXZvaWQgYSBbSklUIGJ1Z10oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE0Mjc5MilcbiAgICAgKiB0aGF0IGFmZmVjdHMgU2FmYXJpIG9uIGF0IGxlYXN0IGlPUyA4LjEtOC4zIEFSTTY0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIFwibGVuZ3RoXCIgdmFsdWUuXG4gICAgICovXG4gICAgdmFyIGdldExlbmd0aCA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwcm9wZXJ5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBwYWlycyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICByZXN1bHRbbGVuZ3RoXVsyXSA9IGlzU3RyaWN0Q29tcGFyYWJsZShyZXN1bHRbbGVuZ3RoXVsxXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgICAgcmV0dXJuIGlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZpZXcsIGFwcGx5aW5nIGFueSBgdHJhbnNmb3Jtc2AgdG8gdGhlIGBzdGFydGAgYW5kIGBlbmRgIHBvc2l0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtcyBUaGUgdHJhbnNmb3JtYXRpb25zIHRvIGFwcGx5IHRvIHRoZSB2aWV3LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBzdGFydGAgYW5kIGBlbmRgXG4gICAgICogIHBvc2l0aW9ucyBvZiB0aGUgdmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRWaWV3KHN0YXJ0LCBlbmQsIHRyYW5zZm9ybXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRyYW5zZm9ybXNbaW5kZXhdLFxuICAgICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2Ryb3AnOiAgICAgIHN0YXJ0ICs9IHNpemU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Ryb3BSaWdodCc6IGVuZCAtPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlJzogICAgICBlbmQgPSBuYXRpdmVNaW4oZW5kLCBzdGFydCArIHNpemUpOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlUmlnaHQnOiBzdGFydCA9IG5hdGl2ZU1heChzdGFydCwgZW5kIC0gc2l6ZSk7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyAnc3RhcnQnOiBzdGFydCwgJ2VuZCc6IGVuZCB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAgICAgLy8gQWRkIGFycmF5IHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgICAgIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgICAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICBpZiAoISh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yKSkge1xuICAgICAgICBDdG9yID0gT2JqZWN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gICAgICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgcmV0dXJuIGJ1ZmZlckNsb25lKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgICAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IG9iamVjdC5idWZmZXI7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKGlzRGVlcCA/IGJ1ZmZlckNsb25lKGJ1ZmZlcikgOiBidWZmZXIsIG9iamVjdC5ieXRlT2Zmc2V0LCBvYmplY3QubGVuZ3RoKTtcblxuICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBDdG9yKG9iamVjdC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhvYmplY3QpKTtcbiAgICAgICAgICByZXN1bHQubGFzdEluZGV4ID0gb2JqZWN0Lmxhc3RJbmRleDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvbiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludm9rZVBhdGgob2JqZWN0LCBwYXRoLCBhcmdzKSB7XG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwgJiYgIWlzS2V5KHBhdGgsIG9iamVjdCkpIHtcbiAgICAgICAgcGF0aCA9IHRvUGF0aChwYXRoKTtcbiAgICAgICAgb2JqZWN0ID0gcGF0aC5sZW5ndGggPT0gMSA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBiYXNlU2xpY2UocGF0aCwgMCwgLTEpKTtcbiAgICAgICAgcGF0aCA9IGxhc3QocGF0aCk7XG4gICAgICB9XG4gICAgICB2YXIgZnVuYyA9IG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogb2JqZWN0W3BhdGhdO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGZ1bmMuYXBwbHkob2JqZWN0LCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKGdldExlbmd0aCh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgICAgIHZhbHVlID0gKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgPyArdmFsdWUgOiAtMTtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgICAgIHJldHVybiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KSkge1xuICAgICAgICB2YXIgb3RoZXIgPSBvYmplY3RbaW5kZXhdO1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gKHZhbHVlID09PSBvdGhlcikgOiAob3RoZXIgIT09IG90aGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICBpZiAoKHR5cGUgPT0gJ3N0cmluZycgJiYgcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSkgfHwgdHlwZSA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKTtcbiAgICAgIHJldHVybiByZXN1bHQgfHwgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIHRvT2JqZWN0KG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMYXppYWJsZShmdW5jKSB7XG4gICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKTtcbiAgICAgIGlmICghKGZ1bmNOYW1lIGluIExhenlXcmFwcGVyLnByb3RvdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIG90aGVyID0gbG9kYXNoW2Z1bmNOYW1lXTtcbiAgICAgIGlmIChmdW5jID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0gZ2V0RGF0YShvdGhlcik7XG4gICAgICByZXR1cm4gISFkYXRhICYmIGZ1bmMgPT09IGRhdGFbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2xlbmd0aCkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAgICAgKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgdGhlIGZ1bmN0aW9uIG1ldGFkYXRhIG9mIGBzb3VyY2VgIGludG8gYGRhdGFgLlxuICAgICAqXG4gICAgICogTWVyZ2luZyBtZXRhZGF0YSByZWR1Y2VzIHRoZSBudW1iZXIgb2Ygd3JhcHBlcnMgcmVxdWlyZWQgdG8gaW52b2tlIGEgZnVuY3Rpb24uXG4gICAgICogVGhpcyBpcyBwb3NzaWJsZSBiZWNhdXNlIG1ldGhvZHMgbGlrZSBgXy5iaW5kYCwgYF8uY3VycnlgLCBhbmQgYF8ucGFydGlhbGBcbiAgICAgKiBtYXkgYmUgYXBwbGllZCByZWdhcmRsZXNzIG9mIGV4ZWN1dGlvbiBvcmRlci4gTWV0aG9kcyBsaWtlIGBfLmFyeWAgYW5kIGBfLnJlYXJnYFxuICAgICAqIGF1Z21lbnQgZnVuY3Rpb24gYXJndW1lbnRzLCBtYWtpbmcgdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXJlIGV4ZWN1dGVkIGltcG9ydGFudCxcbiAgICAgKiBwcmV2ZW50aW5nIHRoZSBtZXJnaW5nIG9mIG1ldGFkYXRhLiBIb3dldmVyLCB3ZSBtYWtlIGFuIGV4Y2VwdGlvbiBmb3IgYSBzYWZlXG4gICAgICogY29tbW9uIGNhc2Ugd2hlcmUgY3VycmllZCBmdW5jdGlvbnMgaGF2ZSBgXy5hcnlgIGFuZCBvciBgXy5yZWFyZ2AgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YSBUaGUgZGVzdGluYXRpb24gbWV0YWRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBzb3VyY2UgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkYXRhYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZURhdGEoZGF0YSwgc291cmNlKSB7XG4gICAgICB2YXIgYml0bWFzayA9IGRhdGFbMV0sXG4gICAgICAgICAgc3JjQml0bWFzayA9IHNvdXJjZVsxXSxcbiAgICAgICAgICBuZXdCaXRtYXNrID0gYml0bWFzayB8IHNyY0JpdG1hc2ssXG4gICAgICAgICAgaXNDb21tb24gPSBuZXdCaXRtYXNrIDwgQVJZX0ZMQUc7XG5cbiAgICAgIHZhciBpc0NvbWJvID1cbiAgICAgICAgKHNyY0JpdG1hc2sgPT0gQVJZX0ZMQUcgJiYgYml0bWFzayA9PSBDVVJSWV9GTEFHKSB8fFxuICAgICAgICAoc3JjQml0bWFzayA9PSBBUllfRkxBRyAmJiBiaXRtYXNrID09IFJFQVJHX0ZMQUcgJiYgZGF0YVs3XS5sZW5ndGggPD0gc291cmNlWzhdKSB8fFxuICAgICAgICAoc3JjQml0bWFzayA9PSAoQVJZX0ZMQUcgfCBSRUFSR19GTEFHKSAmJiBiaXRtYXNrID09IENVUlJZX0ZMQUcpO1xuXG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIG1ldGFkYXRhIGNhbid0IGJlIG1lcmdlZC5cbiAgICAgIGlmICghKGlzQ29tbW9uIHx8IGlzQ29tYm8pKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgdGhpc0FyZ2AgaWYgYXZhaWxhYmxlLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBCSU5EX0ZMQUcpIHtcbiAgICAgICAgZGF0YVsyXSA9IHNvdXJjZVsyXTtcbiAgICAgICAgLy8gU2V0IHdoZW4gY3VycnlpbmcgYSBib3VuZCBmdW5jdGlvbi5cbiAgICAgICAgbmV3Qml0bWFzayB8PSAoYml0bWFzayAmIEJJTkRfRkxBRykgPyAwIDogQ1VSUllfQk9VTkRfRkxBRztcbiAgICAgIH1cbiAgICAgIC8vIENvbXBvc2UgcGFydGlhbCBhcmd1bWVudHMuXG4gICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbM107XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxzID0gZGF0YVszXTtcbiAgICAgICAgZGF0YVszXSA9IHBhcnRpYWxzID8gY29tcG9zZUFyZ3MocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNF0pIDogYXJyYXlDb3B5KHZhbHVlKTtcbiAgICAgICAgZGF0YVs0XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVszXSwgUExBQ0VIT0xERVIpIDogYXJyYXlDb3B5KHNvdXJjZVs0XSk7XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgcmlnaHQgYXJndW1lbnRzLlxuICAgICAgdmFsdWUgPSBzb3VyY2VbNV07XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcGFydGlhbHMgPSBkYXRhWzVdO1xuICAgICAgICBkYXRhWzVdID0gcGFydGlhbHMgPyBjb21wb3NlQXJnc1JpZ2h0KHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzZdKSA6IGFycmF5Q29weSh2YWx1ZSk7XG4gICAgICAgIGRhdGFbNl0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbNV0sIFBMQUNFSE9MREVSKSA6IGFycmF5Q29weShzb3VyY2VbNl0pO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJnUG9zYCBpZiBhdmFpbGFibGUuXG4gICAgICB2YWx1ZSA9IHNvdXJjZVs3XTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBkYXRhWzddID0gYXJyYXlDb3B5KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyeWAgaWYgaXQncyBzbWFsbGVyLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBBUllfRkxBRykge1xuICAgICAgICBkYXRhWzhdID0gZGF0YVs4XSA9PSBudWxsID8gc291cmNlWzhdIDogbmF0aXZlTWluKGRhdGFbOF0sIHNvdXJjZVs4XSk7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcml0eWAgaWYgb25lIGlzIG5vdCBwcm92aWRlZC5cbiAgICAgIGlmIChkYXRhWzldID09IG51bGwpIHtcbiAgICAgICAgZGF0YVs5XSA9IHNvdXJjZVs5XTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGZ1bmNgIGFuZCBtZXJnZSBiaXRtYXNrcy5cbiAgICAgIGRhdGFbMF0gPSBzb3VyY2VbMF07XG4gICAgICBkYXRhWzFdID0gbmV3Qml0bWFzaztcblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5kZWZhdWx0c0RlZXBgIHRvIGN1c3RvbWl6ZSBpdHMgYF8ubWVyZ2VgIHVzZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmplY3RWYWx1ZSBUaGUgZGVzdGluYXRpb24gb2JqZWN0IHByb3BlcnR5IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlVmFsdWUgVGhlIHNvdXJjZSBvYmplY3QgcHJvcGVydHkgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbiB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlRGVmYXVsdHMob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0VmFsdWUgPT09IHVuZGVmaW5lZCA/IHNvdXJjZVZhbHVlIDogbWVyZ2Uob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlLCBtZXJnZURlZmF1bHRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucGlja2Agd2hpY2ggcGlja3MgYG9iamVjdGAgcHJvcGVydGllcyBzcGVjaWZpZWRcbiAgICAgKiBieSBgcHJvcHNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGlja0J5QXJyYXkob2JqZWN0LCBwcm9wcykge1xuICAgICAgb2JqZWN0ID0gdG9PYmplY3Qob2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnBpY2tgIHdoaWNoIHBpY2tzIGBvYmplY3RgIHByb3BlcnRpZXMgYHByZWRpY2F0ZWBcbiAgICAgKiByZXR1cm5zIHRydXRoeSBmb3IuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwaWNrQnlDYWxsYmFjayhvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgYmFzZUZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGtleSwgb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW9yZGVyIGBhcnJheWAgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgaW5kZXhlcyB3aGVyZSB0aGUgZWxlbWVudCBhdFxuICAgICAqIHRoZSBmaXJzdCBpbmRleCBpcyBhc3NpZ25lZCBhcyB0aGUgZmlyc3QgZWxlbWVudCwgdGhlIGVsZW1lbnQgYXRcbiAgICAgKiB0aGUgc2Vjb25kIGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBzZWNvbmQgZWxlbWVudCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcmVvcmRlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbmRleGVzIFRoZSBhcnJhbmdlZCBhcnJheSBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlb3JkZXIoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKGluZGV4ZXMubGVuZ3RoLCBhcnJMZW5ndGgpLFxuICAgICAgICAgIG9sZEFycmF5ID0gYXJyYXlDb3B5KGFycmF5KTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICAgICAgYXJyYXlbbGVuZ3RoXSA9IGlzSW5kZXgoaW5kZXgsIGFyckxlbmd0aCkgPyBvbGRBcnJheVtpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIHRoaXMgZnVuY3Rpb24gYmVjb21lcyBob3QsIGkuZS4gaXMgaW52b2tlZCBhIGxvdCBpbiBhIHNob3J0XG4gICAgICogcGVyaW9kIG9mIHRpbWUsIGl0IHdpbGwgdHJpcCBpdHMgYnJlYWtlciBhbmQgdHJhbnNpdGlvbiB0byBhbiBpZGVudGl0eSBmdW5jdGlvblxuICAgICAqIHRvIGF2b2lkIGdhcmJhZ2UgY29sbGVjdGlvbiBwYXVzZXMgaW4gVjguIFNlZSBbVjggaXNzdWUgMjA3MF0oaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIwNzApXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBzZXREYXRhID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvdW50ID0gMCxcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHN0YW1wID0gbm93KCksXG4gICAgICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZVNldERhdGEoa2V5LCB2YWx1ZSk7XG4gICAgICB9O1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBBIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIGBPYmplY3Qua2V5c2Agd2hpY2ggY3JlYXRlcyBhbiBhcnJheSBvZiB0aGVcbiAgICAgKiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hpbUtleXMob2JqZWN0KSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzSW4ob2JqZWN0KSxcbiAgICAgICAgICBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wc0xlbmd0aCAmJiBvYmplY3QubGVuZ3RoO1xuXG4gICAgICB2YXIgYWxsb3dJbmRleGVzID0gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJlxuICAgICAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoKGFsbG93SW5kZXhlcyAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSkgfHwgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gYXJyYXktbGlrZSBvYmplY3QgaWYgaXQncyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgdGhlIGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSXRlcmFibGUodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXModmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDogT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIG9iamVjdCBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpID8gdmFsdWUgOiBPYmplY3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gcHJvcGVydHkgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvUGF0aCh2YWx1ZSkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGJhc2VUb1N0cmluZyh2YWx1ZSkucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3RyaW5nKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHdyYXBwZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gd3JhcHBlciBUaGUgd3JhcHBlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgd3JhcHBlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2xvbmUod3JhcHBlcikge1xuICAgICAgcmV0dXJuIHdyYXBwZXIgaW5zdGFuY2VvZiBMYXp5V3JhcHBlclxuICAgICAgICA/IHdyYXBwZXIuY2xvbmUoKVxuICAgICAgICA6IG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZXIuX193cmFwcGVkX18sIHdyYXBwZXIuX19jaGFpbl9fLCBhcnJheUNvcHkod3JhcHBlci5fX2FjdGlvbnNfXykpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byBncm91cHMgdGhlIGxlbmd0aCBvZiBgc2l6ZWAuXG4gICAgICogSWYgYGNvbGxlY3Rpb25gIGNhbid0IGJlIHNwbGl0IGV2ZW5seSwgdGhlIGZpbmFsIGNodW5rIHdpbGwgYmUgdGhlIHJlbWFpbmluZ1xuICAgICAqIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTFdIFRoZSBsZW5ndGggb2YgZWFjaCBjaHVuay5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBjb250YWluaW5nIGNodW5rcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMik7XG4gICAgICogLy8gPT4gW1snYScsICdiJ10sIFsnYycsICdkJ11dXG4gICAgICpcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAzKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InLCAnYyddLCBbJ2QnXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaHVuayhhcnJheSwgc2l6ZSwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzaXplLCBndWFyZCkgOiBzaXplID09IG51bGwpIHtcbiAgICAgICAgc2l6ZSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaXplID0gbmF0aXZlTWF4KG5hdGl2ZUZsb29yKHNpemUpIHx8IDEsIDEpO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzSW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShuYXRpdmVDZWlsKGxlbmd0aCAvIHNpemUpKTtcblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IGJhc2VTbGljZShhcnJheSwgaW5kZXgsIChpbmRleCArPSBzaXplKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZmFsc2V5IHZhbHVlcyByZW1vdmVkLiBUaGUgdmFsdWVzIGBmYWxzZWAsIGBudWxsYCxcbiAgICAgKiBgMGAsIGBcIlwiYCwgYHVuZGVmaW5lZGAsIGFuZCBgTmFOYCBhcmUgZmFsc2V5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvbXBhY3QoWzAsIDEsIGZhbHNlLCAyLCAnJywgM10pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXNJbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIGBhcnJheWAgdmFsdWVzIG5vdCBpbmNsdWRlZCBpbiB0aGUgb3RoZXJcbiAgICAgKiBwcm92aWRlZCBhcnJheXMgdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgYXJyYXlzIG9mIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlKFsxLCAyLCAzXSwgWzQsIDJdKTtcbiAgICAgKiAvLyA9PiBbMSwgM11cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZSA9IHJlc3RQYXJhbShmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gKGlzT2JqZWN0TGlrZShhcnJheSkgJiYgaXNBcnJheUxpa2UoYXJyYXkpKVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIGZhbHNlLCB0cnVlKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3AoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoYXJyYXksIG4sIGd1YXJkKSA6IG4gPT0gbnVsbCkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgZW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBuLCBndWFyZCkgOiBuID09IG51bGwpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9XG4gICAgICBuID0gbGVuZ3RoIC0gKCtuIHx8IDApO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZXhjbHVkaW5nIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgZW5kLlxuICAgICAqIEVsZW1lbnRzIGFyZSBkcm9wcGVkIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgbWF0Y2ggdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZShbMSwgMiwgM10sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuID4gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpLCB0cnVlLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wV2hpbGUoWzEsIDIsIDNdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiA8IDM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmRyb3BXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmRyb3BXaGlsZSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZHJvcFdoaWxlKHVzZXJzLCAnYWN0aXZlJyksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wV2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbGxzIGVsZW1lbnRzIG9mIGBhcnJheWAgd2l0aCBgdmFsdWVgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdFxuICAgICAqIGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfLmZpbGwoYXJyYXksICdhJyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdhJywgJ2EnXVxuICAgICAqXG4gICAgICogXy5maWxsKEFycmF5KDMpLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgMiwgMl1cbiAgICAgKlxuICAgICAqIF8uZmlsbChbNCwgNiwgOF0sICcqJywgMSwgMik7XG4gICAgICogLy8gPT4gWzQsICcqJywgOF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAmJiB0eXBlb2Ygc3RhcnQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIHZhbHVlLCBzdGFydCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLnVzZXIgPT0gJ2Jhcm5leSc7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICB2YXIgZmluZEluZGV4ID0gY3JlYXRlRmluZEluZGV4KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRJbmRleGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLnVzZXIgPT0gJ3BlYmJsZXMnO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIHZhciBmaW5kTGFzdEluZGV4ID0gY3JlYXRlRmluZEluZGV4KHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGhlYWRcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maXJzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uZmlyc3QoW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpcnN0KGFycmF5KSB7XG4gICAgICByZXR1cm4gYXJyYXkgPyBhcnJheVswXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbGF0dGVucyBhIG5lc3RlZCBhcnJheS4gSWYgYGlzRGVlcGAgaXMgYHRydWVgIHRoZSBhcnJheSBpcyByZWN1cnNpdmVseVxuICAgICAqIGZsYXR0ZW5lZCwgb3RoZXJ3aXNlIGl0IGlzIG9ubHkgZmxhdHRlbmVkIGEgc2luZ2xlIGxldmVsLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBmbGF0dGVuLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuKFsxLCBbMiwgMywgWzRdXV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbNF1dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBgaXNEZWVwYFxuICAgICAqIF8uZmxhdHRlbihbMSwgWzIsIDMsIFs0XV1dLCB0cnVlKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuKGFycmF5LCBpc0RlZXAsIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBpc0RlZXAsIGd1YXJkKSkge1xuICAgICAgICBpc0RlZXAgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgaXNEZWVwKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIGEgbmVzdGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHJlY3Vyc2l2ZWx5IGZsYXR0ZW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZWVwKFsxLCBbMiwgMywgWzRdXV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZWVwKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCB0cnVlKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgaW4gYGFycmF5YFxuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQgaXMgdXNlZCBhcyB0aGUgb2Zmc2V0XG4gICAgICogZnJvbSB0aGUgZW5kIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgc29ydGVkIHByb3ZpZGluZyBgdHJ1ZWAgZm9yIGBmcm9tSW5kZXhgXG4gICAgICogcGVyZm9ybXMgYSBmYXN0ZXIgYmluYXJ5IHNlYXJjaC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbSBvciBgdHJ1ZWBcbiAgICAgKiAgdG8gcGVyZm9ybSBhIGJpbmFyeSBzZWFyY2ggb24gYSBzb3J0ZWQgYXJyYXkuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYGZyb21JbmRleGBcbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiAvLyBwZXJmb3JtaW5nIGEgYmluYXJ5IHNlYXJjaFxuICAgICAqIF8uaW5kZXhPZihbMSwgMSwgMiwgMl0sIDIsIHRydWUpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggPT0gJ251bWJlcicpIHtcbiAgICAgICAgZnJvbUluZGV4ID0gZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApIDogZnJvbUluZGV4O1xuICAgICAgfSBlbHNlIGlmIChmcm9tSW5kZXgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYmluYXJ5SW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmXG4gICAgICAgICAgICAodmFsdWUgPT09IHZhbHVlID8gKHZhbHVlID09PSBhcnJheVtpbmRleF0pIDogKGFycmF5W2luZGV4XSAhPT0gYXJyYXlbaW5kZXhdKSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4IHx8IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluaXRpYWwoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0aWFsKGFycmF5KSB7XG4gICAgICByZXR1cm4gZHJvcFJpZ2h0KGFycmF5LCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgdGhhdCBhcmUgaW5jbHVkZWQgaW4gYWxsIG9mIHRoZSBwcm92aWRlZFxuICAgICAqIGFycmF5cyB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBzaGFyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogXy5pbnRlcnNlY3Rpb24oWzEsIDJdLCBbNCwgMl0sIFsyLCAxXSk7XG4gICAgICogLy8gPT4gWzJdXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbiA9IHJlc3RQYXJhbShmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBvdGhMZW5ndGggPSBhcnJheXMubGVuZ3RoLFxuICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoLFxuICAgICAgICAgIGNhY2hlcyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBpc0NvbW1vbiA9IGluZGV4T2YgPT0gYmFzZUluZGV4T2YsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlIChvdGhJbmRleC0tKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5c1tvdGhJbmRleF0gPSBpc0FycmF5TGlrZSh2YWx1ZSA9IGFycmF5c1tvdGhJbmRleF0pID8gdmFsdWUgOiBbXTtcbiAgICAgICAgY2FjaGVzW290aEluZGV4XSA9IChpc0NvbW1vbiAmJiB2YWx1ZS5sZW5ndGggPj0gMTIwKSA/IGNyZWF0ZUNhY2hlKG90aEluZGV4ICYmIHZhbHVlKSA6IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgYXJyYXkgPSBhcnJheXNbMF0sXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgc2VlbiA9IGNhY2hlc1swXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKChzZWVuID8gY2FjaGVJbmRleE9mKHNlZW4sIHZhbHVlKSA6IGluZGV4T2YocmVzdWx0LCB2YWx1ZSwgMCkpIDwgMCkge1xuICAgICAgICAgIHZhciBvdGhJbmRleCA9IG90aExlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoLS1vdGhJbmRleCkge1xuICAgICAgICAgICAgdmFyIGNhY2hlID0gY2FjaGVzW290aEluZGV4XTtcbiAgICAgICAgICAgIGlmICgoY2FjaGUgPyBjYWNoZUluZGV4T2YoY2FjaGUsIHZhbHVlKSA6IGluZGV4T2YoYXJyYXlzW290aEluZGV4XSwgdmFsdWUsIDApKSA8IDApIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBhcnJheWAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbVxuICAgICAqICBvciBgdHJ1ZWAgdG8gcGVyZm9ybSBhIGJpbmFyeSBzZWFyY2ggb24gYSBzb3J0ZWQgYXJyYXkuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGBmcm9tSW5kZXhgXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIsIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIHBlcmZvcm1pbmcgYSBiaW5hcnkgc2VhcmNoXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMSwgMiwgMl0sIDIsIHRydWUpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGluZGV4ID0gKGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKSA6IG5hdGl2ZU1pbihmcm9tSW5kZXggfHwgMCwgbGVuZ3RoIC0gMSkpICsgMTtcbiAgICAgIH0gZWxzZSBpZiAoZnJvbUluZGV4KSB7XG4gICAgICAgIGluZGV4ID0gYmluYXJ5SW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKSAtIDE7XG4gICAgICAgIHZhciBvdGhlciA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2YWx1ZSA/ICh2YWx1ZSA9PT0gb3RoZXIpIDogKG90aGVyICE9PSBvdGhlcikpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXhPZk5hTihhcnJheSwgaW5kZXgsIHRydWUpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBwcm92aWRlZCB2YWx1ZXMgZnJvbSBgYXJyYXlgIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLndpdGhvdXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCAxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8ucHVsbChhcnJheSwgMiwgMyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGwoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBhcnJheSA9IGFyZ3NbMF07XG5cbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZnJvbUluZGV4ID0gMCxcbiAgICAgICAgICAgIHZhbHVlID0gYXJnc1tpbmRleF07XG5cbiAgICAgICAgd2hpbGUgKChmcm9tSW5kZXggPSBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSkgPiAtMSkge1xuICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBmcm9tSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBlbGVtZW50cyBmcm9tIGBhcnJheWAgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gaW5kZXhlcyBhbmQgcmV0dXJuc1xuICAgICAqIGFuIGFycmF5IG9mIHRoZSByZW1vdmVkIGVsZW1lbnRzLiBJbmRleGVzIG1heSBiZSBzcGVjaWZpZWQgYXMgYW4gYXJyYXkgb2ZcbiAgICAgKiBpbmRleGVzIG9yIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5hdGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gW2luZGV4ZXNdIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZSxcbiAgICAgKiAgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgaW5kZXhlcyBvciBhcnJheXMgb2YgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbNSwgMTAsIDE1LCAyMF07XG4gICAgICogdmFyIGV2ZW5zID0gXy5wdWxsQXQoYXJyYXksIDEsIDMpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFs1LCAxNV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGV2ZW5zKTtcbiAgICAgKiAvLyA9PiBbMTAsIDIwXVxuICAgICAqL1xuICAgIHZhciBwdWxsQXQgPSByZXN0UGFyYW0oZnVuY3Rpb24oYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIGluZGV4ZXMgPSBiYXNlRmxhdHRlbihpbmRleGVzKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VBdChhcnJheSwgaW5kZXhlcyk7XG4gICAgICBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzLnNvcnQoYmFzZUNvbXBhcmVBc2NlbmRpbmcpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIGBhcnJheWAgdGhhdCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3JcbiAgICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmVtb3ZlZCBlbGVtZW50cy4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0b1xuICAgICAqIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmZpbHRlcmAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCA0XTtcbiAgICAgKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XG4gICAgICogLy8gPT4gWzIsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHRhaWxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN0KGFycmF5KSB7XG4gICAgICByZXR1cm4gZHJvcChhcnJheSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgdXNlZCBpbnN0ZWFkIG9mIGBBcnJheSNzbGljZWAgdG8gc3VwcG9ydCBub2RlXG4gICAgICogbGlzdHMgaW4gSUUgPCA5IGFuZCB0byBlbnN1cmUgZGVuc2UgYXJyYXlzIGFyZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCAmJiB0eXBlb2YgZW5kICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzdGFydCwgZW5kKSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSB0aGUgbG93ZXN0IGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkXG4gICAgICogYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLiBJZiBhbiBpdGVyYXRlZVxuICAgICAqIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIGl0IGlzIGludm9rZWQgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgXG4gICAgICogdG8gY29tcHV0ZSB0aGVpciBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbMzAsIDUwXSwgNDApO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWzQsIDQsIDUsIDVdLCA1KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiB2YXIgZGljdCA9IHsgJ2RhdGEnOiB7ICd0aGlydHknOiAzMCwgJ2ZvcnR5JzogNDAsICdmaWZ0eSc6IDUwIH0gfTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGFuIGl0ZXJhdGVlIGZ1bmN0aW9uXG4gICAgICogXy5zb3J0ZWRJbmRleChbJ3RoaXJ0eScsICdmaWZ0eSddLCAnZm9ydHknLCBmdW5jdGlvbih3b3JkKSB7XG4gICAgICogICByZXR1cm4gdGhpcy5kYXRhW3dvcmRdO1xuICAgICAqIH0sIGRpY3QpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb3J0ZWRJbmRleChbeyAneCc6IDMwIH0sIHsgJ3gnOiA1MCB9XSwgeyAneCc6IDQwIH0sICd4Jyk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIHZhciBzb3J0ZWRJbmRleCA9IGNyZWF0ZVNvcnRlZEluZGV4KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZEluZGV4YCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBoaWdoZXN0XG4gICAgICogaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvXG4gICAgICogbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4KFs0LCA0LCA1LCA1XSwgNSk7XG4gICAgICogLy8gPT4gNFxuICAgICAqL1xuICAgIHZhciBzb3J0ZWRMYXN0SW5kZXggPSBjcmVhdGVTb3J0ZWRJbmRleCh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBuLCBndWFyZCkgOiBuID09IG51bGwpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoYXJyYXksIG4sIGd1YXJkKSA6IG4gPT0gbnVsbCkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH1cbiAgICAgIG4gPSBsZW5ndGggLSAoK24gfHwgMCk7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGVuZC4gRWxlbWVudHMgYXJlXG4gICAgICogdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUoWzEsIDIsIDNdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiA+IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy50YWtlUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy50YWtlUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy4gRWxlbWVudHNcbiAgICAgKiBhcmUgdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZVdoaWxlKFsxLCAyLCAzXSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gPCAzO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2V9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VXaGlsZSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VXaGlsZSh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBmcm9tIGFsbCBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaW9uKFsxLCAyXSwgWzQsIDJdLCBbMiwgMV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCA0XVxuICAgICAqL1xuICAgIHZhciB1bmlvbiA9IHJlc3RQYXJhbShmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIGZhbHNlLCB0cnVlKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiBhbiBhcnJheSwgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucywgaW4gd2hpY2ggb25seSB0aGUgZmlyc3Qgb2NjdXJlbmNlIG9mIGVhY2ggZWxlbWVudFxuICAgICAqIGlzIGtlcHQuIFByb3ZpZGluZyBgdHJ1ZWAgZm9yIGBpc1NvcnRlZGAgcGVyZm9ybXMgYSBmYXN0ZXIgc2VhcmNoIGFsZ29yaXRobVxuICAgICAqIGZvciBzb3J0ZWQgYXJyYXlzLiBJZiBhbiBpdGVyYXRlZSBmdW5jdGlvbiBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkIGZvclxuICAgICAqIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaCB1bmlxdWVuZXNzXG4gICAgICogaXMgY29tcHV0ZWQuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgdW5pcXVlXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTb3J0ZWRdIFNwZWNpZnkgdGhlIGFycmF5IGlzIHNvcnRlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxKFsyLCAxLCAyXSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBgaXNTb3J0ZWRgXG4gICAgICogXy51bmlxKFsxLCAxLCAyXSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhbiBpdGVyYXRlZSBmdW5jdGlvblxuICAgICAqIF8udW5pcShbMSwgMi41LCAxLjUsIDJdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gdGhpcy5mbG9vcihuKTtcbiAgICAgKiB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiBbMSwgMi41XVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnVuaXEoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXEoYXJyYXksIGlzU29ydGVkLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NvcnRlZCAhPSBudWxsICYmIHR5cGVvZiBpc1NvcnRlZCAhPSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhpc0FyZyA9IGl0ZXJhdGVlO1xuICAgICAgICBpdGVyYXRlZSA9IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBpc1NvcnRlZCwgdGhpc0FyZykgPyB1bmRlZmluZWQgOiBpc1NvcnRlZDtcbiAgICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBjYWxsYmFjayA9IGdldENhbGxiYWNrKCk7XG4gICAgICBpZiAoIShpdGVyYXRlZSA9PSBudWxsICYmIGNhbGxiYWNrID09PSBiYXNlQ2FsbGJhY2spKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gY2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChpc1NvcnRlZCAmJiBnZXRJbmRleE9mKCkgPT0gYmFzZUluZGV4T2YpXG4gICAgICAgID8gc29ydGVkVW5pcShhcnJheSwgaXRlcmF0ZWUpXG4gICAgICAgIDogYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBhcnJheSBvZiBncm91cGVkXG4gICAgICogZWxlbWVudHMgYW5kIGNyZWF0ZXMgYW4gYXJyYXkgcmVncm91cGluZyB0aGUgZWxlbWVudHMgdG8gdGhlaXIgcHJlLXppcFxuICAgICAqIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsnZnJlZCcsICdiYXJuZXknXSwgWzMwLCA0MF0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2ZyZWQnLCAzMCwgdHJ1ZV0sIFsnYmFybmV5JywgNDAsIGZhbHNlXV1cbiAgICAgKlxuICAgICAqIF8udW56aXAoemlwcGVkKTtcbiAgICAgKiAvLyA9PiBbWydmcmVkJywgJ2Jhcm5leSddLCBbMzAsIDQwXSwgW3RydWUsIGZhbHNlXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnppcChhcnJheSkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSAwO1xuXG4gICAgICBhcnJheSA9IGFycmF5RmlsdGVyKGFycmF5LCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICBpZiAoaXNBcnJheUxpa2UoZ3JvdXApKSB7XG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGdyb3VwLmxlbmd0aCwgbGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheU1hcChhcnJheSwgYmFzZVByb3BlcnR5KGluZGV4KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gaXRlcmF0ZWUgdG8gc3BlY2lmeVxuICAgICAqIGhvdyByZWdyb3VwZWQgdmFsdWVzIHNob3VsZCBiZSBjb21iaW5lZC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGdyb3VwKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSByZWdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0pO1xuICAgICAqIC8vID0+IFtbMSwgMTAsIDEwMF0sIFsyLCAyMCwgMjAwXV1cbiAgICAgKlxuICAgICAqIF8udW56aXBXaXRoKHppcHBlZCwgXy5hZGQpO1xuICAgICAqIC8vID0+IFszLCAzMCwgMzAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuemlwV2l0aChhcnJheSwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gdW56aXAoYXJyYXkpO1xuICAgICAgaWYgKGl0ZXJhdGVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGl0ZXJhdGVlID0gYmluZENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCA0KTtcbiAgICAgIHJldHVybiBhcnJheU1hcChyZXN1bHQsIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIHJldHVybiBhcnJheVJlZHVjZShncm91cCwgaXRlcmF0ZWUsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgcHJvdmlkZWQgdmFsdWVzIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsdGVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53aXRob3V0KFsxLCAyLCAxLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICovXG4gICAgdmFyIHdpdGhvdXQgPSByZXN0UGFyYW0oZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlKGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgdGhhdCBpcyB0aGUgW3N5bW1ldHJpYyBkaWZmZXJlbmNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeW1tZXRyaWNfZGlmZmVyZW5jZSlcbiAgICAgKiBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3IoWzEsIDJdLCBbNCwgMl0pO1xuICAgICAqIC8vID0+IFsxLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHhvcigpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIGlmIChpc0FycmF5TGlrZShhcnJheSkpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0XG4gICAgICAgICAgICA/IGFycmF5UHVzaChiYXNlRGlmZmVyZW5jZShyZXN1bHQsIGFycmF5KSwgYmFzZURpZmZlcmVuY2UoYXJyYXksIHJlc3VsdCkpXG4gICAgICAgICAgICA6IGFycmF5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0ID8gYmFzZVVuaXEocmVzdWx0KSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cywgdGhlIGZpcnN0IG9mIHdoaWNoIGNvbnRhaW5zIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIHRoZSBzZWNvbmQgb2Ygd2hpY2ggY29udGFpbnMgdGhlIHNlY29uZCBlbGVtZW50c1xuICAgICAqIG9mIHRoZSBnaXZlbiBhcnJheXMsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcChbJ2ZyZWQnLCAnYmFybmV5J10sIFszMCwgNDBdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydmcmVkJywgMzAsIHRydWVdLCBbJ2Jhcm5leScsIDQwLCBmYWxzZV1dXG4gICAgICovXG4gICAgdmFyIHppcCA9IHJlc3RQYXJhbSh1bnppcCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy5wYWlyc2A7IHRoaXMgbWV0aG9kIHJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkIGZyb20gYXJyYXlzXG4gICAgICogb2YgcHJvcGVydHkgbmFtZXMgYW5kIHZhbHVlcy4gUHJvdmlkZSBlaXRoZXIgYSBzaW5nbGUgdHdvIGRpbWVuc2lvbmFsIGFycmF5LFxuICAgICAqIGUuZy4gYFtba2V5MSwgdmFsdWUxXSwgW2tleTIsIHZhbHVlMl1dYCBvciB0d28gYXJyYXlzLCBvbmUgb2YgcHJvcGVydHkgbmFtZXNcbiAgICAgKiBhbmQgb25lIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIG9iamVjdFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0KFtbJ2ZyZWQnLCAzMF0sIFsnYmFybmV5JywgNDBdXSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDMwLCAnYmFybmV5JzogNDAgfVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3QoWydmcmVkJywgJ2Jhcm5leSddLCBbMzAsIDQwXSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDMwLCAnYmFybmV5JzogNDAgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcE9iamVjdChwcm9wcywgdmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcyA/IHByb3BzLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIGlmIChsZW5ndGggJiYgIXZhbHVlcyAmJiAhaXNBcnJheShwcm9wc1swXSkpIHtcbiAgICAgICAgdmFsdWVzID0gW107XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSkge1xuICAgICAgICAgIHJlc3VsdFtrZXlbMF1dID0ga2V5WzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGFuIGl0ZXJhdGVlIHRvIHNwZWNpZnlcbiAgICAgKiBob3cgZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOiAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgZ3JvdXApLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZ3JvdXBlZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBXaXRoKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0sIF8uYWRkKTtcbiAgICAgKiAvLyA9PiBbMTExLCAyMjJdXG4gICAgICovXG4gICAgdmFyIHppcFdpdGggPSByZXN0UGFyYW0oZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgICAgICBpdGVyYXRlZSA9IGxlbmd0aCA+IDIgPyBhcnJheXNbbGVuZ3RoIC0gMl0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgdGhpc0FyZyA9IGxlbmd0aCA+IDEgPyBhcnJheXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChsZW5ndGggPiAyICYmIHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGxlbmd0aCAtPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0ZWUgPSAobGVuZ3RoID4gMSAmJiB0eXBlb2YgdGhpc0FyZyA9PSAnZnVuY3Rpb24nKSA/ICgtLWxlbmd0aCwgdGhpc0FyZykgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXNBcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBhcnJheXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgcmV0dXJuIHVuemlwV2l0aChhcnJheXMsIGl0ZXJhdGVlLCB0aGlzQXJnKTtcbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3QgdGhhdCB3cmFwcyBgdmFsdWVgIHdpdGggZXhwbGljaXQgbWV0aG9kXG4gICAgICogY2hhaW5pbmcgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciB5b3VuZ2VzdCA9IF8uY2hhaW4odXNlcnMpXG4gICAgICogICAuc29ydEJ5KCdhZ2UnKVxuICAgICAqICAgLm1hcChmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgICAgcmV0dXJuIGNoci51c2VyICsgJyBpcyAnICsgY2hyLmFnZTtcbiAgICAgKiAgIH0pXG4gICAgICogICAuZmlyc3QoKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMgaXMgMSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGFpbih2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaCh2YWx1ZSk7XG4gICAgICByZXN1bHQuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBgaW50ZXJjZXB0b3JgIGFuZCByZXR1cm5zIGB2YWx1ZWAuIFRoZSBpbnRlcmNlcHRvciBpc1xuICAgICAqIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS4gVGhlIHB1cnBvc2Ugb2ZcbiAgICAgKiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4gaW4gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zXG4gICAgICogb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKVxuICAgICAqICAudGFwKGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICogICAgYXJyYXkucG9wKCk7XG4gICAgICogIH0pXG4gICAgICogIC5yZXZlcnNlKClcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFwKHZhbHVlLCBpbnRlcmNlcHRvciwgdGhpc0FyZykge1xuICAgICAgaW50ZXJjZXB0b3IuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy50YXBgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKCcgIGFiYyAgJylcbiAgICAgKiAgLmNoYWluKClcbiAgICAgKiAgLnRyaW0oKVxuICAgICAqICAudGhydShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAqICB9KVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2FiYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhydSh2YWx1ZSwgaW50ZXJjZXB0b3IsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBpbnRlcmNlcHRvci5jYWxsKHRoaXNBcmcsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGV4cGxpY2l0IG1ldGhvZCBjaGFpbmluZyBvbiB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjaGFpblxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGhvdXQgZXhwbGljaXQgY2hhaW5pbmdcbiAgICAgKiBfKHVzZXJzKS5maXJzdCgpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKlxuICAgICAqIC8vIHdpdGggZXhwbGljaXQgY2hhaW5pbmdcbiAgICAgKiBfKHVzZXJzKS5jaGFpbigpXG4gICAgICogICAuZmlyc3QoKVxuICAgICAqICAgLnBpY2soJ3VzZXInKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2hhaW4oKSB7XG4gICAgICByZXR1cm4gY2hhaW4odGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluZWQgc2VxdWVuY2UgYW5kIHJldHVybnMgdGhlIHdyYXBwZWQgcmVzdWx0LlxuICAgICAqXG4gICAgICogQG5hbWUgY29tbWl0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDJdO1xuICAgICAqIHZhciB3cmFwcGVkID0gXyhhcnJheSkucHVzaCgzKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQgPSB3cmFwcGVkLmNvbW1pdCgpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubGFzdCgpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ29tbWl0KCkge1xuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHRoaXMudmFsdWUoKSwgdGhpcy5fX2NoYWluX18pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgam9pbmluZyBhIHdyYXBwZWQgYXJyYXkgd2l0aCBhbnkgYWRkaXRpb25hbCBhcnJheXNcbiAgICAgKiBhbmQvb3IgdmFsdWVzLlxuICAgICAqXG4gICAgICogQG5hbWUgY29uY2F0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY29uY2F0ZW5hdGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgY29uY2F0ZW5hdGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMV07XG4gICAgICogdmFyIHdyYXBwZWQgPSBfKGFycmF5KS5jb25jYXQoMiwgWzNdLCBbWzRdXSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyh3cmFwcGVkLnZhbHVlKCkpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbNF1dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICovXG4gICAgdmFyIHdyYXBwZXJDb25jYXQgPSByZXN0UGFyYW0oZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICB2YWx1ZXMgPSBiYXNlRmxhdHRlbih2YWx1ZXMpO1xuICAgICAgcmV0dXJuIHRoaXMudGhydShmdW5jdGlvbihhcnJheSkge1xuICAgICAgICByZXR1cm4gYXJyYXlDb25jYXQoaXNBcnJheShhcnJheSkgPyBhcnJheSA6IFt0b09iamVjdChhcnJheSldLCB2YWx1ZXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGNoYWluZWQgc2VxdWVuY2UgcGxhbnRpbmcgYHZhbHVlYCBhcyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHBsYW50XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDJdO1xuICAgICAqIHZhciB3cmFwcGVkID0gXyhhcnJheSkubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gTWF0aC5wb3codmFsdWUsIDIpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIG90aGVyID0gWzMsIDRdO1xuICAgICAqIHZhciBvdGhlcldyYXBwZWQgPSB3cmFwcGVkLnBsYW50KG90aGVyKTtcbiAgICAgKlxuICAgICAqIG90aGVyV3JhcHBlZC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFs5LCAxNl1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMSwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyUGxhbnQodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgcGFyZW50ID0gdGhpcztcblxuICAgICAgd2hpbGUgKHBhcmVudCBpbnN0YW5jZW9mIGJhc2VMb2Rhc2gpIHtcbiAgICAgICAgdmFyIGNsb25lID0gd3JhcHBlckNsb25lKHBhcmVudCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IGNsb25lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IGNsb25lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2aW91cyA9IGNsb25lO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX193cmFwcGVkX187XG4gICAgICB9XG4gICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyB0aGUgd3JhcHBlZCBhcnJheSBzbyB0aGUgZmlyc3QgZWxlbWVudCBiZWNvbWVzIHRoZSBsYXN0LCB0aGVcbiAgICAgKiBzZWNvbmQgZWxlbWVudCBiZWNvbWVzIHRoZSBzZWNvbmQgdG8gbGFzdCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgdGhlIHdyYXBwZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAbmFtZSByZXZlcnNlXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgcmV2ZXJzZWQgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXyhhcnJheSkucmV2ZXJzZSgpLnZhbHVlKClcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyUmV2ZXJzZSgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX187XG5cbiAgICAgIHZhciBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAod3JhcHBlZCAmJiB3cmFwcGVkLl9fZGlyX18gPCAwKSA/IHZhbHVlIDogdmFsdWUucmV2ZXJzZSgpO1xuICAgICAgfTtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHZhciB3cmFwcGVkID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCkge1xuICAgICAgICAgIHdyYXBwZWQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgd3JhcHBlZCA9IHdyYXBwZWQucmV2ZXJzZSgpO1xuICAgICAgICB3cmFwcGVkLl9fYWN0aW9uc19fLnB1c2goeyAnZnVuYyc6IHRocnUsICdhcmdzJzogW2ludGVyY2VwdG9yXSwgJ3RoaXNBcmcnOiB1bmRlZmluZWQgfSk7XG4gICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVkLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyB0aGUgcmVzdWx0IG9mIGNvZXJjaW5nIHRoZSB1bndyYXBwZWQgdmFsdWUgdG8gYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAbmFtZSB0b1N0cmluZ1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29lcmNlZCBzdHJpbmcgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS50b1N0cmluZygpO1xuICAgICAqIC8vID0+ICcxLDIsMydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gKHRoaXMudmFsdWUoKSArICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW5lZCBzZXF1ZW5jZSB0byBleHRyYWN0IHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHJ1biwgdG9KU09OLCB2YWx1ZU9mXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclZhbHVlKCkge1xuICAgICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUodGhpcy5fX3dyYXBwZWRfXywgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBrZXlzLCBvciBpbmRleGVzLFxuICAgICAqIG9mIGBjb2xsZWN0aW9uYC4gS2V5cyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5c1xuICAgICAqIG9mIGtleXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdfHN0cmluZ3xzdHJpbmdbXSl9IFtwcm9wc10gVGhlIHByb3BlcnR5IG5hbWVzXG4gICAgICogIG9yIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcGljaywgc3BlY2lmaWVkIGluZGl2aWR1YWxseSBvciBpbiBhcnJheXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGlja2VkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmF0KFsnYScsICdiJywgJ2MnXSwgWzAsIDJdKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYyddXG4gICAgICpcbiAgICAgKiBfLmF0KFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddLCAwLCAyKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICB2YXIgYXQgPSByZXN0UGFyYW0oZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJvcHMpIHtcbiAgICAgIHJldHVybiBiYXNlQXQoY29sbGVjdGlvbiwgYmFzZUZsYXR0ZW4ocHJvcHMpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhyb3VnaCBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZVxuICAgICAqIG9mIGVhY2gga2V5IGlzIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGtleSB3YXMgcmV0dXJuZWQgYnkgYGl0ZXJhdGVlYC5cbiAgICAgKiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs0LjMsIDYuMSwgNi40XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIE1hdGguZmxvb3Iobik7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWzQuMywgNi4xLCA2LjRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gdGhpcy5mbG9vcihuKTtcbiAgICAgKiB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogMSwgJzYnOiAyIH1cbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiAyLCAnNSc6IDEgfVxuICAgICAqL1xuICAgIHZhciBjb3VudEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpID8gKytyZXN1bHRba2V5XSA6IChyZXN1bHRba2V5XSA9IDEpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFsbCoqIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBUaGUgcHJlZGljYXRlIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBhbGxcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXZlcnkoW3RydWUsIDEsIG51bGwsICd5ZXMnXSwgQm9vbGVhbik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ldmVyeSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZXZlcnkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFdmVyeSA6IGJhc2VFdmVyeTtcbiAgICAgIGlmICh0aGlzQXJnICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgdGhpc0FyZykpIHtcbiAgICAgICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT0gJ2Z1bmN0aW9uJyB8fCB0aGlzQXJnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAgICAgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHNlbGVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKFs0LCA1LCA2XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzQsIDZdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmZpbHRlcih1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnLCBmYWxzZSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmZpbHRlcih1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5J11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50XG4gICAgICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBkZXRlY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5yZXN1bHQoXy5maW5kKHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnJlc3VsdChfLmZpbmQodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5yZXN1bHQoXy5maW5kKHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpLCAndXNlcicpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnJlc3VsdChfLmZpbmQodXNlcnMsICdhY3RpdmUnKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqL1xuICAgIHZhciBmaW5kID0gY3JlYXRlRmluZChiYXNlRWFjaCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0KFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIHZhciBmaW5kTGFzdCA9IGNyZWF0ZUZpbmQoYmFzZUVhY2hSaWdodCwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgYW5kIHRoZVxuICAgICAqIHNvdXJjZSBvYmplY3QsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGhhcyBlcXVpdmFsZW50IHByb3BlcnR5XG4gICAgICogdmFsdWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGJvb2xlYW5zLCBgRGF0ZWAgb2JqZWN0cyxcbiAgICAgKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBhbmQgc3RyaW5ncy4gT2JqZWN0cyBhcmUgY29tcGFyZWQgYnlcbiAgICAgKiB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRm9yIGNvbXBhcmluZyBhIHNpbmdsZVxuICAgICAqIG93biBvciBpbmhlcml0ZWQgcHJvcGVydHkgdmFsdWUgc2VlIGBfLm1hdGNoZXNQcm9wZXJ0eWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChfLmZpbmRXaGVyZSh1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChfLmZpbmRXaGVyZSh1c2VycywgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kV2hlcmUoY29sbGVjdGlvbiwgc291cmNlKSB7XG4gICAgICByZXR1cm4gZmluZChjb2xsZWN0aW9uLCBiYXNlTWF0Y2hlcyhzb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBpbnZva2luZyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXG4gICAgICogVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseVxuICAgICAqIGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgXCJsZW5ndGhcIiBwcm9wZXJ0eVxuICAgICAqIGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciBgXy5mb3JJbmAgb3IgYF8uZm9yT3duYFxuICAgICAqIG1heSBiZSB1c2VkIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGVhY2hcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyXSkuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhuKTtcbiAgICAgKiB9KS52YWx1ZSgpO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCB2YWx1ZSBmcm9tIGxlZnQgdG8gcmlnaHQgYW5kIHJldHVybnMgdGhlIGFycmF5XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbihuLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKG4sIGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyBlYWNoIHZhbHVlLWtleSBwYWlyIGFuZCByZXR1cm5zIHRoZSBvYmplY3QgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgZm9yRWFjaCA9IGNyZWF0ZUZvckVhY2goYXJyYXlFYWNoLCBiYXNlRWFjaCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckVhY2hgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGVhY2hSaWdodFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDJdKS5mb3JFYWNoUmlnaHQoZnVuY3Rpb24obikge1xuICAgICAqICAgY29uc29sZS5sb2cobik7XG4gICAgICogfSkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBsb2dzIGVhY2ggdmFsdWUgZnJvbSByaWdodCB0byBsZWZ0IGFuZCByZXR1cm5zIHRoZSBhcnJheVxuICAgICAqL1xuICAgIHZhciBmb3JFYWNoUmlnaHQgPSBjcmVhdGVGb3JFYWNoKGFycmF5RWFjaFJpZ2h0LCBiYXNlRWFjaFJpZ2h0KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhyb3VnaCBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZVxuICAgICAqIG9mIGVhY2gga2V5IGlzIGFuIGFycmF5IG9mIHRoZSBlbGVtZW50cyByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUga2V5LlxuICAgICAqIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmdyb3VwQnkoWzQuMiwgNi4xLCA2LjRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gTWF0aC5mbG9vcihuKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi40XSB9XG4gICAgICpcbiAgICAgKiBfLmdyb3VwQnkoWzQuMiwgNi4xLCA2LjRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gdGhpcy5mbG9vcihuKTtcbiAgICAgKiB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi40XSB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZ3JvdXBCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiBbJ29uZScsICd0d28nXSwgJzUnOiBbJ3RocmVlJ10gfVxuICAgICAqL1xuICAgIHZhciBncm91cEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gW3ZhbHVlXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjb2xsZWN0aW9uYCB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQgaXMgdXNlZCBhcyB0aGUgb2Zmc2V0XG4gICAgICogZnJvbSB0aGUgZW5kIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBjb250YWlucywgaW5jbHVkZVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLnJlZHVjZWAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgbWF0Y2hpbmcgZWxlbWVudCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9LCAnZnJlZCcpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoJ3BlYmJsZXMnLCAnZWInKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5jbHVkZXMoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgsIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGdldExlbmd0aChjb2xsZWN0aW9uKSA6IDA7XG4gICAgICBpZiAoIWlzTGVuZ3RoKGxlbmd0aCkpIHtcbiAgICAgICAgY29sbGVjdGlvbiA9IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGZyb21JbmRleCAhPSAnbnVtYmVyJyB8fCAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwodGFyZ2V0LCBmcm9tSW5kZXgsIGd1YXJkKSkpIHtcbiAgICAgICAgZnJvbUluZGV4ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyb21JbmRleCA9IGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKSA6IChmcm9tSW5kZXggfHwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHR5cGVvZiBjb2xsZWN0aW9uID09ICdzdHJpbmcnIHx8ICFpc0FycmF5KGNvbGxlY3Rpb24pICYmIGlzU3RyaW5nKGNvbGxlY3Rpb24pKVxuICAgICAgICA/IChmcm9tSW5kZXggPD0gbGVuZ3RoICYmIGNvbGxlY3Rpb24uaW5kZXhPZih0YXJnZXQsIGZyb21JbmRleCkgPiAtMSlcbiAgICAgICAgOiAoISFsZW5ndGggJiYgZ2V0SW5kZXhPZihjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkgPiAtMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJvdWdoIGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG4gICAgICogb2YgZWFjaCBrZXkgaXMgdGhlIGxhc3QgZWxlbWVudCByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUga2V5LiBUaGVcbiAgICAgKiBpdGVyYXRlZSBmdW5jdGlvbiBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGtleURhdGEgPSBbXG4gICAgICogICB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSxcbiAgICAgKiAgIHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5pbmRleEJ5KGtleURhdGEsICdkaXInKTtcbiAgICAgKiAvLyA9PiB7ICdsZWZ0JzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdyaWdodCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5pbmRleEJ5KGtleURhdGEsIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAqICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUob2JqZWN0LmNvZGUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ2QnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKlxuICAgICAqIF8uaW5kZXhCeShrZXlEYXRhLCBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgKiAgIHJldHVybiB0aGlzLmZyb21DaGFyQ29kZShvYmplY3QuY29kZSk7XG4gICAgICogfSwgU3RyaW5nKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICovXG4gICAgdmFyIGluZGV4QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nXG4gICAgICogYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogYXJlIHByb3ZpZGVkIHRvIGVhY2ggaW52b2tlZCBtZXRob2QuIElmIGBtZXRob2ROYW1lYCBpcyBhIGZ1bmN0aW9uIGl0IGlzXG4gICAgICogaW52b2tlZCBmb3IsIGFuZCBgdGhpc2AgYm91bmQgdG8sIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbnxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2Ugb3JcbiAgICAgKiAgdGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludm9rZShbWzUsIDEsIDddLCBbMywgMiwgMV1dLCAnc29ydCcpO1xuICAgICAqIC8vID0+IFtbMSwgNSwgN10sIFsxLCAyLCAzXV1cbiAgICAgKlxuICAgICAqIF8uaW52b2tlKFsxMjMsIDQ1Nl0sIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsICcnKTtcbiAgICAgKiAvLyA9PiBbWycxJywgJzInLCAnMyddLCBbJzQnLCAnNScsICc2J11dXG4gICAgICovXG4gICAgdmFyIGludm9rZSA9IHJlc3RQYXJhbShmdW5jdGlvbihjb2xsZWN0aW9uLCBwYXRoLCBhcmdzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpc0Z1bmMgPSB0eXBlb2YgcGF0aCA9PSAnZnVuY3Rpb24nLFxuICAgICAgICAgIGlzUHJvcCA9IGlzS2V5KHBhdGgpLFxuICAgICAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBmdW5jID0gaXNGdW5jID8gcGF0aCA6ICgoaXNQcm9wICYmIHZhbHVlICE9IG51bGwpID8gdmFsdWVbcGF0aF0gOiB1bmRlZmluZWQpO1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBmdW5jID8gZnVuYy5hcHBseSh2YWx1ZSwgYXJncykgOiBpbnZva2VQYXRoKHZhbHVlLCBwYXRoLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJvdWdoXG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICAgICAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxuICAgICAqXG4gICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gICAgICogYGFyeWAsIGBjYWxsYmFja2AsIGBjaHVua2AsIGBjbG9uZWAsIGBjcmVhdGVgLCBgY3VycnlgLCBgY3VycnlSaWdodGAsXG4gICAgICogYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGV2ZXJ5YCwgYGZpbGxgLCBgZmxhdHRlbmAsIGBpbnZlcnRgLCBgbWF4YCwgYG1pbmAsXG4gICAgICogYHBhcnNlSW50YCwgYHNsaWNlYCwgYHNvcnRCeWAsIGB0YWtlYCwgYHRha2VSaWdodGAsIGB0ZW1wbGF0ZWAsIGB0cmltYCxcbiAgICAgKiBgdHJpbUxlZnRgLCBgdHJpbVJpZ2h0YCwgYHRydW5jYCwgYHJhbmRvbWAsIGByYW5nZWAsIGBzYW1wbGVgLCBgc29tZWAsXG4gICAgICogYHN1bWAsIGB1bmlxYCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBjb2xsZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiB0aW1lc1RocmVlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogMztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1hcChbMSwgMl0sIHRpbWVzVGhyZWUpO1xuICAgICAqIC8vID0+IFszLCA2XVxuICAgICAqXG4gICAgICogXy5tYXAoeyAnYSc6IDEsICdiJzogMiB9LCB0aW1lc1RocmVlKTtcbiAgICAgKiAvLyA9PiBbMywgNl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXAodXNlcnMsICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheU1hcCA6IGJhc2VNYXA7XG4gICAgICBpdGVyYXRlZSA9IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gdHdvIGdyb3VwcywgdGhlIGZpcnN0IG9mIHdoaWNoXG4gICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLCB3aGlsZSB0aGUgc2Vjb25kIG9mIHdoaWNoXG4gICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGJvdW5kXG4gICAgICogdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhcnRpdGlvbihbMSwgMiwgM10sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMjtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbWzEsIDNdLCBbMl1dXG4gICAgICpcbiAgICAgKiBfLnBhcnRpdGlvbihbMS4yLCAyLjMsIDMuNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiB0aGlzLmZsb29yKG4pICUgMjtcbiAgICAgKiB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiBbWzEuMiwgMy40XSwgWzIuM11dXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgbWFwcGVyID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgKiAgIHJldHVybiBfLnBsdWNrKGFycmF5LCAndXNlcicpO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXAoXy5wYXJ0aXRpb24odXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiBmYWxzZSB9KSwgbWFwcGVyKTtcbiAgICAgKiAvLyA9PiBbWydwZWJibGVzJ10sIFsnYmFybmV5JywgJ2ZyZWQnXV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwKF8ucGFydGl0aW9uKHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpLCBtYXBwZXIpO1xuICAgICAqIC8vID0+IFtbJ2Jhcm5leScsICdwZWJibGVzJ10sIFsnZnJlZCddXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcChfLnBhcnRpdGlvbih1c2VycywgJ2FjdGl2ZScpLCBtYXBwZXIpO1xuICAgICAqIC8vID0+IFtbJ2ZyZWQnXSwgWydiYXJuZXknLCAncGViYmxlcyddXVxuICAgICAqL1xuICAgIHZhciBwYXJ0aXRpb24gPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0W2tleSA/IDAgOiAxXS5wdXNoKHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbigpIHsgcmV0dXJuIFtbXSwgW11dOyB9KTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIGBwYXRoYCBmcm9tIGFsbCBlbGVtZW50cyBpbiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHBsdWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnBsdWNrKHVzZXJzLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJJbmRleCA9IF8uaW5kZXhCeSh1c2VycywgJ3VzZXInKTtcbiAgICAgKiBfLnBsdWNrKHVzZXJJbmRleCwgJ2FnZScpO1xuICAgICAqIC8vID0+IFszNiwgNDBdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGx1Y2soY29sbGVjdGlvbiwgcGF0aCkge1xuICAgICAgcmV0dXJuIG1hcChjb2xsZWN0aW9uLCBwcm9wZXJ0eShwYXRoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVkdWNlcyBgY29sbGVjdGlvbmAgdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocm91Z2ggYGl0ZXJhdGVlYCwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gICAgICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy4gSWYgYGFjY3VtdWxhdG9yYFxuICAgICAqIGlzIG5vdCBwcm92aWRlZCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbFxuICAgICAqIHZhbHVlLiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czpcbiAgICAgKiAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gICAgICogYF8ucmVkdWNlYCwgYF8ucmVkdWNlUmlnaHRgLCBhbmQgYF8udHJhbnNmb3JtYC5cbiAgICAgKlxuICAgICAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhc3NpZ25gLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGluY2x1ZGVzYCwgYG1lcmdlYCwgYHNvcnRCeUFsbGAsXG4gICAgICogYW5kIGBzb3J0QnlPcmRlcmBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBmb2xkbCwgaW5qZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlKFsxLCAyXSwgZnVuY3Rpb24odG90YWwsIG4pIHtcbiAgICAgKiAgIHJldHVybiB0b3RhbCArIG47XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5yZWR1Y2UoeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbihyZXN1bHQsIG4sIGtleSkge1xuICAgICAqICAgcmVzdWx0W2tleV0gPSBuICogMztcbiAgICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciByZWR1Y2UgPSBjcmVhdGVSZWR1Y2UoYXJyYXlSZWR1Y2UsIGJhc2VFYWNoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmVkdWNlYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBmb2xkclxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbWzAsIDFdLCBbMiwgM10sIFs0LCA1XV07XG4gICAgICpcbiAgICAgKiBfLnJlZHVjZVJpZ2h0KGFycmF5LCBmdW5jdGlvbihmbGF0dGVuZWQsIG90aGVyKSB7XG4gICAgICogICByZXR1cm4gZmxhdHRlbmVkLmNvbmNhdChvdGhlcik7XG4gICAgICogfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA1LCAyLCAzLCAwLCAxXVxuICAgICAqL1xuICAgIHZhciByZWR1Y2VSaWdodCA9IGNyZWF0ZVJlZHVjZShhcnJheVJlZHVjZVJpZ2h0LCBiYXNlRWFjaFJpZ2h0KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5maWx0ZXJgOyB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmBcbiAgICAgKiB0aGF0IGBwcmVkaWNhdGVgIGRvZXMgKipub3QqKiByZXR1cm4gdHJ1dGh5IGZvci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVqZWN0KFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnJlamVjdCh1c2VycywgeyAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5yZWplY3QodXNlcnMsICdhY3RpdmUnLCBmYWxzZSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnJlamVjdCh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5J11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWplY3QoY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAhcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgcmFuZG9tIGVsZW1lbnQgb3IgYG5gIHJhbmRvbSBlbGVtZW50cyBmcm9tIGEgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW25dIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gc2FtcGxlKHMpLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSwgMik7XG4gICAgICogLy8gPT4gWzMsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FtcGxlKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBuLCBndWFyZCkgOiBuID09IG51bGwpIHtcbiAgICAgICAgY29sbGVjdGlvbiA9IHRvSXRlcmFibGUoY29sbGVjdGlvbik7XG4gICAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCA+IDAgPyBjb2xsZWN0aW9uW2Jhc2VSYW5kb20oMCwgbGVuZ3RoIC0gMSldIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gdG9BcnJheShjb2xsZWN0aW9uKSxcbiAgICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgICAgIG4gPSBuYXRpdmVNaW4obiA8IDAgPyAwIDogKCtuIHx8IDApLCBsZW5ndGgpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICAgIHZhciByYW5kID0gYmFzZVJhbmRvbShpbmRleCwgbGFzdEluZGV4KSxcbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0W3JhbmRdO1xuXG4gICAgICAgIHJlc3VsdFtyYW5kXSA9IHJlc3VsdFtpbmRleF07XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5sZW5ndGggPSBuO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZVxuICAgICAqIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaHVmZmxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gWzQsIDEsIDMsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gc2FtcGxlKGNvbGxlY3Rpb24sIFBPU0lUSVZFX0lORklOSVRZKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzaXplIG9mIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgaXRzIGxlbmd0aCBmb3IgYXJyYXktbGlrZVxuICAgICAqIHZhbHVlcyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgZm9yIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNpemUgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNpemUoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnNpemUoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNpemUoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiA3XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGdldExlbmd0aChjb2xsZWN0aW9uKSA6IDA7XG4gICAgICByZXR1cm4gaXNMZW5ndGgobGVuZ3RoKSA/IGxlbmd0aCA6IGtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbnkqKiBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBUaGUgZnVuY3Rpb24gcmV0dXJucyBhcyBzb29uIGFzIGl0IGZpbmRzIGEgcGFzc2luZyB2YWx1ZSBhbmQgZG9lcyBub3QgaXRlcmF0ZVxuICAgICAqIG92ZXIgdGhlIGVudGlyZSBjb2xsZWN0aW9uLiBUaGUgcHJlZGljYXRlIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBhbnlcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvbWUoW251bGwsIDAsICd5ZXMnLCBmYWxzZV0sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc29tZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc29tZSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc29tZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTb21lIDogYmFzZVNvbWU7XG4gICAgICBpZiAodGhpc0FyZyAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9ICdmdW5jdGlvbicgfHwgdGhpc0FyZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhyb3VnaCBgaXRlcmF0ZWVgLiBUaGlzIG1ldGhvZCBwZXJmb3Jtc1xuICAgICAqIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgc29ydCBvcmRlciBvZiBlcXVhbCBlbGVtZW50cy5cbiAgICAgKiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeShbMSwgMiwgM10sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBNYXRoLnNpbihuKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMywgMSwgMl1cbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIHRoaXMuc2luKG4pO1xuICAgICAqIH0sIE1hdGgpO1xuICAgICAqIC8vID0+IFszLCAxLCAyXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJyB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uc29ydEJ5KHVzZXJzLCAndXNlcicpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydEJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzQXJnICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgaXRlcmF0ZWUgPSBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgJ2NyaXRlcmlhJzogaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbiksICdpbmRleCc6ICsraW5kZXgsICd2YWx1ZSc6IHZhbHVlIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgY29tcGFyZUFzY2VuZGluZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0QnlgIGV4Y2VwdCB0aGF0IGl0IGNhbiBzb3J0IGJ5IG11bHRpcGxlIGl0ZXJhdGVlc1xuICAgICAqIG9yIHByb3BlcnR5IG5hbWVzLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBhbiBpdGVyYXRlZSB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYW4gaXRlcmF0ZWUgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW118T2JqZWN0fE9iamVjdFtdfHN0cmluZ3xzdHJpbmdbXSl9IGl0ZXJhdGVlc1xuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnksIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIHZhbHVlcyBvciBhcnJheXMgb2YgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MiB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1hcChfLnNvcnRCeUFsbCh1c2VycywgWyd1c2VyJywgJ2FnZSddKSwgXy52YWx1ZXMpO1xuICAgICAqIC8vID0+IFtbJ2Jhcm5leScsIDM0XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQyXSwgWydmcmVkJywgNDhdXVxuICAgICAqXG4gICAgICogXy5tYXAoXy5zb3J0QnlBbGwodXNlcnMsICd1c2VyJywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gTWF0aC5mbG9vcihjaHIuYWdlIC8gMTApO1xuICAgICAqIH0pLCBfLnZhbHVlcyk7XG4gICAgICogLy8gPT4gW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCA0Ml1dXG4gICAgICovXG4gICAgdmFyIHNvcnRCeUFsbCA9IHJlc3RQYXJhbShmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZXMpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGd1YXJkID0gaXRlcmF0ZWVzWzJdO1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdLCBndWFyZCkpIHtcbiAgICAgICAgaXRlcmF0ZWVzLmxlbmd0aCA9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNvcnRCeU9yZGVyKGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKGl0ZXJhdGVlcyksIFtdKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydEJ5QWxsYCBleGNlcHQgdGhhdCBpdCBhbGxvd3Mgc3BlY2lmeWluZyB0aGVcbiAgICAgKiBzb3J0IG9yZGVycyBvZiB0aGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGxcbiAgICAgKiB2YWx1ZXMgYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSwgYSB2YWx1ZSBpcyBzb3J0ZWQgaW5cbiAgICAgKiBhc2NlbmRpbmcgb3JkZXIgaWYgaXRzIGNvcnJlc3BvbmRpbmcgb3JkZXIgaXMgXCJhc2NcIiwgYW5kIGRlc2NlbmRpbmcgaWYgXCJkZXNjXCIuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGFuIGl0ZXJhdGVlIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBhbiBpdGVyYXRlZSB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBpdGVyYXRlZXMgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbltdfSBbb3JkZXJzXSBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLnJlZHVjZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQyIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHNvcnQgYnkgYHVzZXJgIGluIGFzY2VuZGluZyBvcmRlciBhbmQgYnkgYGFnZWAgaW4gZGVzY2VuZGluZyBvcmRlclxuICAgICAqIF8ubWFwKF8uc29ydEJ5T3JkZXIodXNlcnMsIFsndXNlcicsICdhZ2UnXSwgWydhc2MnLCAnZGVzYyddKSwgXy52YWx1ZXMpO1xuICAgICAqIC8vID0+IFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgNDJdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRCeU9yZGVyKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzLCBndWFyZCkge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoaXRlcmF0ZWVzLCBvcmRlcnMsIGd1YXJkKSkge1xuICAgICAgICBvcmRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXJyYXkoaXRlcmF0ZWVzKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBpdGVyYXRlZXMgPT0gbnVsbCA/IFtdIDogW2l0ZXJhdGVlc107XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXJyYXkob3JkZXJzKSkge1xuICAgICAgICBvcmRlcnMgPSBvcmRlcnMgPT0gbnVsbCA/IFtdIDogW29yZGVyc107XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNvcnRCeU9yZGVyKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgYW5kIHRoZVxuICAgICAqIHNvdXJjZSBvYmplY3QsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHMgdGhhdCBoYXZlIGVxdWl2YWxlbnRcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYm9vbGVhbnMsIGBEYXRlYCBvYmplY3RzLFxuICAgICAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIGFuZCBzdHJpbmdzLiBPYmplY3RzIGFyZSBjb21wYXJlZCBieVxuICAgICAqIHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGb3IgY29tcGFyaW5nIGEgc2luZ2xlXG4gICAgICogb3duIG9yIGluaGVyaXRlZCBwcm9wZXJ0eSB2YWx1ZSBzZWUgYF8ubWF0Y2hlc1Byb3BlcnR5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlLCAncGV0cyc6IFsnaG9wcHknXSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlLCAncGV0cyc6IFsnYmFieSBwdXNzJywgJ2Rpbm8nXSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucGx1Y2soXy53aGVyZSh1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiBfLnBsdWNrKF8ud2hlcmUodXNlcnMsIHsgJ3BldHMnOiBbJ2Rpbm8nXSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdoZXJlKGNvbGxlY3Rpb24sIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGZpbHRlcihjb2xsZWN0aW9uLCBiYXNlTWF0Y2hlcyhzb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBVbml4IGVwb2NoXG4gICAgICogKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRGF0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICAgICAqIH0sIF8ubm93KCkpO1xuICAgICAqIC8vID0+IGxvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGZ1bmN0aW9uIHRvIGJlIGludm9rZWRcbiAgICAgKi9cbiAgICB2YXIgbm93ID0gbmF0aXZlTm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uYmVmb3JlYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIGBmdW5jYCBvbmNlIGl0IGlzIGNhbGxlZCBgbmAgb3IgbW9yZSB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYmVmb3JlIGBmdW5jYCBpcyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXZlcyA9IFsncHJvZmlsZScsICdzZXR0aW5ncyddO1xuICAgICAqXG4gICAgICogdmFyIGRvbmUgPSBfLmFmdGVyKHNhdmVzLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnZG9uZSBzYXZpbmchJyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goc2F2ZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgKiAgIGFzeW5jU2F2ZSh7ICd0eXBlJzogdHlwZSwgJ2NvbXBsZXRlJzogZG9uZSB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdkb25lIHNhdmluZyEnIGFmdGVyIHRoZSB0d28gYXN5bmMgc2F2ZXMgaGF2ZSBjb21wbGV0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZnRlcihuLCBmdW5jKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAodHlwZW9mIG4gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciB0ZW1wID0gbjtcbiAgICAgICAgICBuID0gZnVuYztcbiAgICAgICAgICBmdW5jID0gdGVtcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG4gPSBuYXRpdmVJc0Zpbml0ZShuID0gK24pID8gbiA6IDA7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPCAxKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHVwIHRvIGBuYCBhcmd1bWVudHMgaWdub3JpbmcgYW55XG4gICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBjYXAuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8uYXJ5KHBhcnNlSW50LCAxKSk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFyeShmdW5jLCBuLCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGZ1bmMsIG4sIGd1YXJkKSkge1xuICAgICAgICBuID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgbiA9IChmdW5jICYmIG4gPT0gbnVsbCkgPyBmdW5jLmxlbmd0aCA6IG5hdGl2ZU1heCgrbiB8fCAwLCAwKTtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGZ1bmMsIEFSWV9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzXG4gICAgICogb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIHdoaWxlIGl0IGlzIGNhbGxlZCBsZXNzIHRoYW4gYG5gIHRpbWVzLiBTdWJzZXF1ZW50XG4gICAgICogY2FsbHMgdG8gdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGF0IHdoaWNoIGBmdW5jYCBpcyBubyBsb25nZXIgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBqUXVlcnkoJyNhZGQnKS5vbignY2xpY2snLCBfLmJlZm9yZSg1LCBhZGRDb250YWN0VG9MaXN0KSk7XG4gICAgICogLy8gPT4gYWxsb3dzIGFkZGluZyB1cCB0byA0IGNvbnRhY3RzIHRvIHRoZSBsaXN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gYmVmb3JlKG4sIGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAodHlwZW9mIG4gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciB0ZW1wID0gbjtcbiAgICAgICAgICBuID0gZnVuYztcbiAgICAgICAgICBmdW5jID0gdGVtcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA+IDApIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPD0gMSkge1xuICAgICAgICAgIGZ1bmMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgXG4gICAgICogYW5kIHByZXBlbmRzIGFueSBhZGRpdGlvbmFsIGBfLmJpbmRgIGFyZ3VtZW50cyB0byB0aG9zZSBwcm92aWRlZCB0byB0aGVcbiAgICAgKiBib3VuZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgbmF0aXZlIGBGdW5jdGlvbiNiaW5kYCB0aGlzIG1ldGhvZCBkb2VzIG5vdCBzZXQgdGhlIFwibGVuZ3RoXCJcbiAgICAgKiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsICdoaScpO1xuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgcGxhY2Vob2xkZXJzXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqL1xuICAgIHZhciBiaW5kID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGZ1bmMsIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IEJJTkRfRkxBRztcbiAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgYmluZC5wbGFjZWhvbGRlcik7XG4gICAgICAgIGJpdG1hc2sgfD0gUEFSVElBTF9GTEFHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQmluZHMgbWV0aG9kcyBvZiBhbiBvYmplY3QgdG8gdGhlIG9iamVjdCBpdHNlbGYsIG92ZXJ3cml0aW5nIHRoZSBleGlzdGluZ1xuICAgICAqIG1ldGhvZC4gTWV0aG9kIG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzXG4gICAgICogb2YgbWV0aG9kIG5hbWVzLiBJZiBubyBtZXRob2QgbmFtZXMgYXJlIHByb3ZpZGVkIGFsbCBlbnVtZXJhYmxlIGZ1bmN0aW9uXG4gICAgICogcHJvcGVydGllcywgb3duIGFuZCBpbmhlcml0ZWQsIG9mIGBvYmplY3RgIGFyZSBib3VuZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgYm91bmQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJpbmQgYW5kIGFzc2lnbiB0aGUgYm91bmQgbWV0aG9kcyB0by5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbbWV0aG9kTmFtZXNdIFRoZSBvYmplY3QgbWV0aG9kIG5hbWVzIHRvIGJpbmQsXG4gICAgICogIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIG1ldGhvZCBuYW1lcyBvciBhcnJheXMgb2YgbWV0aG9kIG5hbWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB2aWV3ID0ge1xuICAgICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgICAqICAgJ29uQ2xpY2snOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ2NsaWNrZWQgJyArIHRoaXMubGFiZWwpO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmJpbmRBbGwodmlldyk7XG4gICAgICogalF1ZXJ5KCcjZG9jcycpLm9uKCdjbGljaycsIHZpZXcub25DbGljayk7XG4gICAgICogLy8gPT4gbG9ncyAnY2xpY2tlZCBkb2NzJyB3aGVuIHRoZSBlbGVtZW50IGlzIGNsaWNrZWRcbiAgICAgKi9cbiAgICB2YXIgYmluZEFsbCA9IHJlc3RQYXJhbShmdW5jdGlvbihvYmplY3QsIG1ldGhvZE5hbWVzKSB7XG4gICAgICBtZXRob2ROYW1lcyA9IG1ldGhvZE5hbWVzLmxlbmd0aCA/IGJhc2VGbGF0dGVuKG1ldGhvZE5hbWVzKSA6IGZ1bmN0aW9ucyhvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBtZXRob2ROYW1lcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBtZXRob2ROYW1lc1tpbmRleF07XG4gICAgICAgIG9iamVjdFtrZXldID0gY3JlYXRlV3JhcHBlcihvYmplY3Rba2V5XSwgQklORF9GTEFHLCBvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgb2JqZWN0W2tleV1gIGFuZCBwcmVwZW5kc1xuICAgICAqIGFueSBhZGRpdGlvbmFsIGBfLmJpbmRLZXlgIGFyZ3VtZW50cyB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgYm91bmQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYF8uYmluZGAgYnkgYWxsb3dpbmcgYm91bmQgZnVuY3Rpb25zIHRvIHJlZmVyZW5jZVxuICAgICAqIG1ldGhvZHMgdGhhdCBtYXkgYmUgcmVkZWZpbmVkIG9yIGRvbid0IHlldCBleGlzdC5cbiAgICAgKiBTZWUgW1BldGVyIE1pY2hhdXgncyBhcnRpY2xlXShodHRwOi8vcGV0ZXIubWljaGF1eC5jYS9hcnRpY2xlcy9sYXp5LWZ1bmN0aW9uLWRlZmluaXRpb24tcGF0dGVybilcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogVGhlIGBfLmJpbmRLZXkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRoZSBtZXRob2QgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICd1c2VyJzogJ2ZyZWQnLFxuICAgICAqICAgJ2dyZWV0JzogZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCAnaGknKTtcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKlxuICAgICAqIG9iamVjdC5ncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJ3lhICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHBsYWNlaG9sZGVyc1xuICAgICAqIHZhciBib3VuZCA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICovXG4gICAgdmFyIGJpbmRLZXkgPSByZXN0UGFyYW0oZnVuY3Rpb24ob2JqZWN0LCBrZXksIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IEJJTkRfRkxBRyB8IEJJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGJpbmRLZXkucGxhY2Vob2xkZXIpO1xuICAgICAgICBiaXRtYXNrIHw9IFBBUlRJQUxfRkxBRztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGtleSwgYml0bWFzaywgb2JqZWN0LCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBvciBtb3JlIGFyZ3VtZW50cyBvZiBgZnVuY2AgdGhhdCB3aGVuXG4gICAgICogY2FsbGVkIGVpdGhlciBpbnZva2VzIGBmdW5jYCByZXR1cm5pbmcgaXRzIHJlc3VsdCwgaWYgYWxsIGBmdW5jYCBhcmd1bWVudHNcbiAgICAgKiBoYXZlIGJlZW4gcHJvdmlkZWQsIG9yIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIG9yIG1vcmUgb2YgdGhlXG4gICAgICogcmVtYWluaW5nIGBmdW5jYCBhcmd1bWVudHMsIGFuZCBzbyBvbi4gVGhlIGFyaXR5IG9mIGBmdW5jYCBtYXkgYmUgc3BlY2lmaWVkXG4gICAgICogaWYgYGZ1bmMubGVuZ3RoYCBpcyBub3Qgc3VmZmljaWVudC5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5jdXJyeS5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAgICAgKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lcyBub3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEpKDIpKDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyKSgzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBwbGFjZWhvbGRlcnNcbiAgICAgKiBjdXJyaWVkKDEpKF8sIDMpKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIHZhciBjdXJyeSA9IGNyZWF0ZUN1cnJ5KENVUlJZX0ZMQUcpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jdXJyeWAgZXhjZXB0IHRoYXQgYXJndW1lbnRzIGFyZSBhcHBsaWVkIHRvIGBmdW5jYFxuICAgICAqIGluIHRoZSBtYW5uZXIgb2YgYF8ucGFydGlhbFJpZ2h0YCBpbnN0ZWFkIG9mIGBfLnBhcnRpYWxgLlxuICAgICAqXG4gICAgICogVGhlIGBfLmN1cnJ5UmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFiYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeVJpZ2h0KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDMpKDIpKDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgyLCAzKSgxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBwbGFjZWhvbGRlcnNcbiAgICAgKiBjdXJyaWVkKDMpKDEsIF8pKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIHZhciBjdXJyeVJpZ2h0ID0gY3JlYXRlQ3VycnkoQ1VSUllfUklHSFRfRkxBRyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAgICAgKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAgICAgKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gICAgICogZGVsYXllZCBpbnZvY2F0aW9ucy4gUHJvdmlkZSBhbiBvcHRpb25zIG9iamVjdCB0byBpbmRpY2F0ZSB0aGF0IGBmdW5jYFxuICAgICAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3RcbiAgICAgKiBgZnVuY2AgaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXMgaW52b2tlZFxuICAgICAqIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gaXNcbiAgICAgKiBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cDovL2RydXBhbG1vdGlvbi5jb20vYXJ0aWNsZS9kZWJvdW5jZS1hbmQtdGhyb3R0bGUtdmlzdWFsLWV4cGxhbmF0aW9uKVxuICAgICAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXSBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nXG4gICAgICogIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmVcbiAgICAgKiAgZGVsYXllZCBiZWZvcmUgaXQgaXMgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nXG4gICAgICogIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBhdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4XG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAgICAgKlxuICAgICAqIC8vIGludm9rZSBgc2VuZE1haWxgIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHNcbiAgICAgKiBqUXVlcnkoJyNwb3N0Ym94Jykub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gICAgICogICAnbGVhZGluZyc6IHRydWUsXG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pKTtcbiAgICAgKlxuICAgICAqIC8vIGVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHNcbiAgICAgKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gICAgICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHtcbiAgICAgKiAgICdtYXhXYWl0JzogMTAwMFxuICAgICAqIH0pKTtcbiAgICAgKlxuICAgICAqIC8vIGNhbmNlbCBhIGRlYm91bmNlZCBjYWxsXG4gICAgICogdmFyIHRvZG9DaGFuZ2VzID0gXy5kZWJvdW5jZShiYXRjaExvZywgMTAwMCk7XG4gICAgICogT2JqZWN0Lm9ic2VydmUobW9kZWxzLnRvZG8sIHRvZG9DaGFuZ2VzKTtcbiAgICAgKlxuICAgICAqIE9iamVjdC5vYnNlcnZlKG1vZGVscywgZnVuY3Rpb24oY2hhbmdlcykge1xuICAgICAqICAgaWYgKF8uZmluZChjaGFuZ2VzLCB7ICd1c2VyJzogJ3RvZG8nLCAndHlwZSc6ICdkZWxldGUnfSkpIHtcbiAgICAgKiAgICAgdG9kb0NoYW5nZXMuY2FuY2VsKCk7XG4gICAgICogICB9XG4gICAgICogfSwgWydkZWxldGUnXSk7XG4gICAgICpcbiAgICAgKiAvLyAuLi5hdCBzb21lIHBvaW50IGBtb2RlbHMudG9kb2AgaXMgY2hhbmdlZFxuICAgICAqIG1vZGVscy50b2RvLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICpcbiAgICAgKiAvLyAuLi5iZWZvcmUgMSBzZWNvbmQgaGFzIHBhc3NlZCBgbW9kZWxzLnRvZG9gIGlzIGRlbGV0ZWRcbiAgICAgKiAvLyB3aGljaCBjYW5jZWxzIHRoZSBkZWJvdW5jZWQgYHRvZG9DaGFuZ2VzYCBjYWxsXG4gICAgICogZGVsZXRlIG1vZGVscy50b2RvO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhcmdzLFxuICAgICAgICAgIG1heFRpbWVvdXRJZCxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgc3RhbXAsXG4gICAgICAgICAgdGhpc0FyZyxcbiAgICAgICAgICB0aW1lb3V0SWQsXG4gICAgICAgICAgdHJhaWxpbmdDYWxsLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwLFxuICAgICAgICAgIG1heFdhaXQgPSBmYWxzZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHdhaXQgPSB3YWl0IDwgMCA/IDAgOiAoK3dhaXQgfHwgMCk7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgbGVhZGluZyA9IHRydWU7XG4gICAgICAgIHRyYWlsaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICAgICAgbWF4V2FpdCA9ICdtYXhXYWl0JyBpbiBvcHRpb25zICYmIG5hdGl2ZU1heCgrb3B0aW9ucy5tYXhXYWl0IHx8IDAsIHdhaXQpO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdENhbGxlZCA9IDA7XG4gICAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY29tcGxldGUoaXNDYWxsZWQsIGlkKSB7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4VGltZW91dElkID0gdGltZW91dElkID0gdHJhaWxpbmdDYWxsID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gbm93KCk7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICBpZiAoIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGVsYXllZCgpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93KCkgLSBzdGFtcCk7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgICAgY29tcGxldGUodHJhaWxpbmdDYWxsLCBtYXhUaW1lb3V0SWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZGVsYXllZCwgcmVtYWluaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtYXhEZWxheWVkKCkge1xuICAgICAgICBjb21wbGV0ZSh0cmFpbGluZywgdGltZW91dElkKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzdGFtcCA9IG5vdygpO1xuICAgICAgICB0aGlzQXJnID0gdGhpcztcbiAgICAgICAgdHJhaWxpbmdDYWxsID0gdHJhaWxpbmcgJiYgKHRpbWVvdXRJZCB8fCAhbGVhZGluZyk7XG5cbiAgICAgICAgaWYgKG1heFdhaXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIGxlYWRpbmdDYWxsID0gbGVhZGluZyAmJiAhdGltZW91dElkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghbWF4VGltZW91dElkICYmICFsZWFkaW5nKSB7XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZW1haW5pbmcgPSBtYXhXYWl0IC0gKHN0YW1wIC0gbGFzdENhbGxlZCksXG4gICAgICAgICAgICAgIGlzQ2FsbGVkID0gcmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gbWF4V2FpdDtcblxuICAgICAgICAgIGlmIChpc0NhbGxlZCkge1xuICAgICAgICAgICAgaWYgKG1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgICBtYXhUaW1lb3V0SWQgPSBjbGVhclRpbWVvdXQobWF4VGltZW91dElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKCFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIG1heFRpbWVvdXRJZCA9IHNldFRpbWVvdXQobWF4RGVsYXllZCwgcmVtYWluaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2FsbGVkICYmIHRpbWVvdXRJZCkge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aW1lb3V0SWQgJiYgd2FpdCAhPT0gbWF4V2FpdCkge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZGVsYXllZCwgd2FpdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlYWRpbmdDYWxsKSB7XG4gICAgICAgICAgaXNDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2FsbGVkICYmICF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICAgICAgcmV0dXJuIGRlYm91bmNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZlcnMgaW52b2tpbmcgdGhlIGBmdW5jYCB1bnRpbCB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhcyBjbGVhcmVkLiBBbnlcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQgaXMgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlZmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAqIH0sICdkZWZlcnJlZCcpO1xuICAgICAqIC8vIGxvZ3MgJ2RlZmVycmVkJyBhZnRlciBvbmUgb3IgbW9yZSBtaWxsaXNlY29uZHNcbiAgICAgKi9cbiAgICB2YXIgZGVmZXIgPSByZXN0UGFyYW0oZnVuY3Rpb24oZnVuYywgYXJncykge1xuICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCAxLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgYGZ1bmNgIGFmdGVyIGB3YWl0YCBtaWxsaXNlY29uZHMuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWxheShmdW5jdGlvbih0ZXh0KSB7XG4gICAgICogICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgKiB9LCAxMDAwLCAnbGF0ZXInKTtcbiAgICAgKiAvLyA9PiBsb2dzICdsYXRlcicgYWZ0ZXIgb25lIHNlY29uZFxuICAgICAqL1xuICAgIHZhciBkZWxheSA9IHJlc3RQYXJhbShmdW5jdGlvbihmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIHdhaXQsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBwcm92aWRlZFxuICAgICAqIGZ1bmN0aW9ucyB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hlcmUgZWFjaFxuICAgICAqIHN1Y2Nlc3NpdmUgaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IFtmdW5jc10gRnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93KF8uYWRkLCBzcXVhcmUpO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgdmFyIGZsb3cgPSBjcmVhdGVGbG93KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsb3dgIGV4Y2VwdCB0aGF0IGl0IGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0XG4gICAgICogaW52b2tlcyB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBiYWNrZmxvdywgY29tcG9zZVxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IFtmdW5jc10gRnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93UmlnaHQoc3F1YXJlLCBfLmFkZCk7XG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKi9cbiAgICB2YXIgZmxvd1JpZ2h0ID0gY3JlYXRlRmxvdyh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gICAgICogcHJvdmlkZWQgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gICAgICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIGNvZXJjZWQgdG8gYSBzdHJpbmcgYW5kIHVzZWQgYXMgdGhlXG4gICAgICogY2FjaGUga2V5LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkXG4gICAgICogZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gICAgICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gICAgICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGUgW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAgICAgKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXppbmcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1cHBlckNhc2UgPSBfLm1lbW9pemUoZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICogICByZXR1cm4gc3RyaW5nLnRvVXBwZXJDYXNlKCk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB1cHBlckNhc2UoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnRlJFRCdcbiAgICAgKlxuICAgICAqIC8vIG1vZGlmeWluZyB0aGUgcmVzdWx0IGNhY2hlXG4gICAgICogdXBwZXJDYXNlLmNhY2hlLnNldCgnZnJlZCcsICdCQVJORVknKTtcbiAgICAgKiB1cHBlckNhc2UoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnQkFSTkVZJ1xuICAgICAqXG4gICAgICogLy8gcmVwbGFjaW5nIGBfLm1lbW9pemUuQ2FjaGVgXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICd1c2VyJzogJ2Jhcm5leScgfTtcbiAgICAgKiB2YXIgaWRlbnRpdHkgPSBfLm1lbW9pemUoXy5pZGVudGl0eSk7XG4gICAgICpcbiAgICAgKiBpZGVudGl0eShvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqIGlkZW50aXR5KG90aGVyKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKlxuICAgICAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gICAgICogdmFyIGlkZW50aXR5ID0gXy5tZW1vaXplKF8uaWRlbnRpdHkpO1xuICAgICAqXG4gICAgICogaWRlbnRpdHkob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBpZGVudGl0eShvdGhlcik7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgICAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBtZW1vaXplZC5jYWNoZSA9IG5ldyBtZW1vaXplLkNhY2hlO1xuICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJ1bnMgZWFjaCBhcmd1bWVudCB0aHJvdWdoIGEgY29ycmVzcG9uZGluZ1xuICAgICAqIHRyYW5zZm9ybSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFt0cmFuc2Zvcm1zXSBUaGUgZnVuY3Rpb25zIHRvIHRyYW5zZm9ybVxuICAgICAqIGFyZ3VtZW50cywgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgZnVuY3Rpb25zIG9yIGFycmF5cyBvZiBmdW5jdGlvbnMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGRvdWJsZWQobikge1xuICAgICAqICAgcmV0dXJuIG4gKiAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG1vZGRlZCA9IF8ubW9kQXJncyhmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICByZXR1cm4gW3gsIHldO1xuICAgICAqIH0sIHNxdWFyZSwgZG91YmxlZCk7XG4gICAgICpcbiAgICAgKiBtb2RkZWQoMSwgMik7XG4gICAgICogLy8gPT4gWzEsIDRdXG4gICAgICpcbiAgICAgKiBtb2RkZWQoNSwgMTApO1xuICAgICAqIC8vID0+IFsyNSwgMjBdXG4gICAgICovXG4gICAgdmFyIG1vZEFyZ3MgPSByZXN0UGFyYW0oZnVuY3Rpb24oZnVuYywgdHJhbnNmb3Jtcykge1xuICAgICAgdHJhbnNmb3JtcyA9IGJhc2VGbGF0dGVuKHRyYW5zZm9ybXMpO1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgIWFycmF5RXZlcnkodHJhbnNmb3JtcywgYmFzZUlzRnVuY3Rpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcbiAgICAgIHJldHVybiByZXN0UGFyYW0oZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgaW5kZXggPSBuYXRpdmVNaW4oYXJncy5sZW5ndGgsIGxlbmd0aCk7XG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSB0cmFuc2Zvcm1zW2luZGV4XShhcmdzW2luZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG5lZ2F0ZXMgdGhlIHJlc3VsdCBvZiB0aGUgcHJlZGljYXRlIGBmdW5jYC4gVGhlXG4gICAgICogYGZ1bmNgIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG5lZ2F0ZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNFdmVuKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKFsxLCAyLCAzLCA0LCA1LCA2XSwgXy5uZWdhdGUoaXNFdmVuKSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmVnYXRlKHByZWRpY2F0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHJlc3RyaWN0ZWQgdG8gaW52b2tpbmcgYGZ1bmNgIG9uY2UuIFJlcGVhdCBjYWxsc1xuICAgICAqIHRvIHRoZSBmdW5jdGlvbiByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBjYWxsLiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGluaXRpYWxpemUgPSBfLm9uY2UoY3JlYXRlQXBwbGljYXRpb24pO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogLy8gYGluaXRpYWxpemVgIGludm9rZXMgYGNyZWF0ZUFwcGxpY2F0aW9uYCBvbmNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25jZShmdW5jKSB7XG4gICAgICByZXR1cm4gYmVmb3JlKDIsIGZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYHBhcnRpYWxgIGFyZ3VtZW50cyBwcmVwZW5kZWRcbiAgICAgKiB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmJpbmRgIGV4Y2VwdFxuICAgICAqIGl0IGRvZXMgKipub3QqKiBhbHRlciB0aGUgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBUaGUgYF8ucGFydGlhbC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lcyBub3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIHBhcnRpYWxseVxuICAgICAqIGFwcGxpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcsIG5hbWUpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsKGdyZWV0LCAnaGVsbG8nKTtcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBwbGFjZWhvbGRlcnNcbiAgICAgKiB2YXIgZ3JlZXRGcmVkID0gXy5wYXJ0aWFsKGdyZWV0LCBfLCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbCA9IGNyZWF0ZVBhcnRpYWwoUEFSVElBTF9GTEFHKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucGFydGlhbGAgZXhjZXB0IHRoYXQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzXG4gICAgICogYXJlIGFwcGVuZGVkIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGUgYF8ucGFydGlhbFJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgcGFydGlhbGx5XG4gICAgICogYXBwbGllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgbmFtZSkge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHBsYWNlaG9sZGVyc1xuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsUmlnaHQoZ3JlZXQsICdoZWxsbycsIF8pO1xuICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbFJpZ2h0ID0gY3JlYXRlUGFydGlhbChQQVJUSUFMX1JJR0hUX0ZMQUcpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBhcmd1bWVudHMgYXJyYW5nZWQgYWNjb3JkaW5nXG4gICAgICogdG8gdGhlIHNwZWNpZmllZCBpbmRleGVzIHdoZXJlIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgZmlyc3QgaW5kZXggaXNcbiAgICAgKiBwcm92aWRlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgc2Vjb25kIGluZGV4IGlzXG4gICAgICogcHJvdmlkZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVhcnJhbmdlIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJndW1lbnQgaW5kZXhlcyxcbiAgICAgKiAgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgaW5kZXhlcyBvciBhcnJheXMgb2YgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHJlYXJnZWQgPSBfLnJlYXJnKGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfSwgMiwgMCwgMSk7XG4gICAgICpcbiAgICAgKiByZWFyZ2VkKCdiJywgJ2MnLCAnYScpXG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICpcbiAgICAgKiB2YXIgbWFwID0gXy5yZWFyZyhfLm1hcCwgWzEsIDBdKTtcbiAgICAgKiBtYXAoZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gKiAzO1xuICAgICAqIH0sIFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzMsIDYsIDldXG4gICAgICovXG4gICAgdmFyIHJlYXJnID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGZ1bmMsIGluZGV4ZXMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGZ1bmMsIFJFQVJHX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGJhc2VGbGF0dGVuKGluZGV4ZXMpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24gYW5kIGFyZ3VtZW50cyBmcm9tIGBzdGFydGAgYW5kIGJleW9uZCBwcm92aWRlZCBhcyBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGUgW3Jlc3QgcGFyYW1ldGVyXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9GdW5jdGlvbnMvcmVzdF9wYXJhbWV0ZXJzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F5ID0gXy5yZXN0UGFyYW0oZnVuY3Rpb24od2hhdCwgbmFtZXMpIHtcbiAgICAgKiAgIHJldHVybiB3aGF0ICsgJyAnICsgXy5pbml0aWFsKG5hbWVzKS5qb2luKCcsICcpICtcbiAgICAgKiAgICAgKF8uc2l6ZShuYW1lcykgPiAxID8gJywgJiAnIDogJycpICsgXy5sYXN0KG5hbWVzKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNheSgnaGVsbG8nLCAnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcycpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN0UGFyYW0oZnVuYywgc3RhcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6ICgrc3RhcnQgfHwgMCksIDApO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgICAgICByZXN0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHJlc3RbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHN0YXJ0KSB7XG4gICAgICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIHJlc3QpO1xuICAgICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmdzWzBdLCByZXN0KTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSwgcmVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHJlc3Q7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIG90aGVyQXJncyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkXG4gICAgICogZnVuY3Rpb24gYW5kIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBtdWNoIGxpa2UgW2BGdW5jdGlvbiNhcHBseWBdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjMuNC4zKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGUgW3NwcmVhZCBvcGVyYXRvcl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL1NwcmVhZF9vcGVyYXRvcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBzcHJlYWQgYXJndW1lbnRzIG92ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXkgPSBfLnNwcmVhZChmdW5jdGlvbih3aG8sIHdoYXQpIHtcbiAgICAgKiAgIHJldHVybiB3aG8gKyAnIHNheXMgJyArIHdoYXQ7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzYXkoWydmcmVkJywgJ2hlbGxvJ10pO1xuICAgICAqIC8vID0+ICdmcmVkIHNheXMgaGVsbG8nXG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGEgUHJvbWlzZVxuICAgICAqIHZhciBudW1iZXJzID0gUHJvbWlzZS5hbGwoW1xuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDQwKSxcbiAgICAgKiAgIFByb21pc2UucmVzb2x2ZSgzNilcbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqIG51bWJlcnMudGhlbihfLnNwcmVhZChmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICByZXR1cm4geCArIHk7XG4gICAgICogfSkpO1xuICAgICAqIC8vID0+IGEgUHJvbWlzZSBvZiA3NlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNwcmVhZChmdW5jKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJyYXkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gICAgICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAgICAgKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgaW52b2NhdGlvbnMuIFByb3ZpZGUgYW4gb3B0aW9ucyBvYmplY3QgdG8gaW5kaWNhdGVcbiAgICAgKiB0aGF0IGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGVcbiAgICAgKiBgd2FpdGAgdGltZW91dC4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAgICAgKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGNhbGwuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzIGludm9rZWRcbiAgICAgKiBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGlzXG4gICAgICogaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHA6Ly9kcnVwYWxtb3Rpb24uY29tL2FydGljbGUvZGVib3VuY2UtYW5kLXRocm90dGxlLXZpc3VhbC1leHBsYW5hdGlvbilcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXSBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nXG4gICAgICogIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXSBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZ1xuICAgICAqICBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gYXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZ1xuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAgICAgKlxuICAgICAqIC8vIGludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzXG4gICAgICogalF1ZXJ5KCcuaW50ZXJhY3RpdmUnKS5vbignY2xpY2snLCBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwge1xuICAgICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgICAgKiB9KSk7XG4gICAgICpcbiAgICAgKiAvLyBjYW5jZWwgYSB0cmFpbGluZyB0aHJvdHRsZWQgY2FsbFxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICBsZWFkaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7ICdsZWFkaW5nJzogbGVhZGluZywgJ21heFdhaXQnOiArd2FpdCwgJ3RyYWlsaW5nJzogdHJhaWxpbmcgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgYHZhbHVlYCB0byB0aGUgd3JhcHBlciBmdW5jdGlvbiBhcyBpdHNcbiAgICAgKiBmaXJzdCBhcmd1bWVudC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBmdW5jdGlvbiBhcmVcbiAgICAgKiBhcHBlbmRlZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgd3JhcHBlciBmdW5jdGlvbi4gVGhlIHdyYXBwZXIgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcCA9IF8ud3JhcChfLmVzY2FwZSwgZnVuY3Rpb24oZnVuYywgdGV4dCkge1xuICAgICAqICAgcmV0dXJuICc8cD4nICsgZnVuYyh0ZXh0KSArICc8L3A+JztcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHAoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJzxwPmZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlczwvcD4nXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcCh2YWx1ZSwgd3JhcHBlcikge1xuICAgICAgd3JhcHBlciA9IHdyYXBwZXIgPT0gbnVsbCA/IGlkZW50aXR5IDogd3JhcHBlcjtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKHdyYXBwZXIsIFBBUlRJQUxfRkxBRywgdW5kZWZpbmVkLCBbdmFsdWVdLCBbXSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB2YWx1ZWAuIElmIGBpc0RlZXBgIGlzIGB0cnVlYCBuZXN0ZWQgb2JqZWN0cyBhcmUgY2xvbmVkLFxuICAgICAqIG90aGVyd2lzZSB0aGV5IGFyZSBhc3NpZ25lZCBieSByZWZlcmVuY2UuIElmIGBjdXN0b21pemVyYCBpcyBwcm92aWRlZCBpdCBpc1xuICAgICAqIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBjbG9uaW5nIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGJvdW5kIHRvXG4gICAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50OyAodmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3RdKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICAgICAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNpbnRlcm5hbC1zdHJ1Y3R1cmVkLWNsb25pbmctYWxnb3JpdGhtKS5cbiAgICAgKiBUaGUgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYW5kIG9iamVjdHMgY3JlYXRlZCBieVxuICAgICAqIGNvbnN0cnVjdG9ycyBvdGhlciB0aGFuIGBPYmplY3RgIGFyZSBjbG9uZWQgdG8gcGxhaW4gYE9iamVjdGAgb2JqZWN0cy4gQW5cbiAgICAgKiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoIGFzIGZ1bmN0aW9ucywgRE9NIG5vZGVzLFxuICAgICAqIE1hcHMsIFNldHMsIGFuZCBXZWFrTWFwcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBzaGFsbG93ID0gXy5jbG9uZSh1c2Vycyk7XG4gICAgICogc2hhbGxvd1swXSA9PT0gdXNlcnNbMF07XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lKHVzZXJzLCB0cnVlKTtcbiAgICAgKiBkZWVwWzBdID09PSB1c2Vyc1swXTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gICAgICogdmFyIGVsID0gXy5jbG9uZShkb2N1bWVudC5ib2R5LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdmFsdWUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGVsID09PSBkb2N1bWVudC5ib2R5XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKiBlbC5ub2RlTmFtZVxuICAgICAqIC8vID0+IEJPRFlcbiAgICAgKiBlbC5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmUodmFsdWUsIGlzRGVlcCwgY3VzdG9taXplciwgdGhpc0FyZykge1xuICAgICAgaWYgKGlzRGVlcCAmJiB0eXBlb2YgaXNEZWVwICE9ICdib29sZWFuJyAmJiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyKSkge1xuICAgICAgICBpc0RlZXAgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBpc0RlZXAgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzQXJnID0gY3VzdG9taXplcjtcbiAgICAgICAgY3VzdG9taXplciA9IGlzRGVlcDtcbiAgICAgICAgaXNEZWVwID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgMSkpXG4gICAgICAgIDogYmFzZUNsb25lKHZhbHVlLCBpc0RlZXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWVwIGNsb25lIG9mIGB2YWx1ZWAuIElmIGBjdXN0b21pemVyYCBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkXG4gICAgICogdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAgY2xvbmluZ1xuICAgICAqIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYFxuICAgICAqIGFuZCBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50OyAodmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3RdKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICAgICAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNpbnRlcm5hbC1zdHJ1Y3R1cmVkLWNsb25pbmctYWxnb3JpdGhtKS5cbiAgICAgKiBUaGUgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYW5kIG9iamVjdHMgY3JlYXRlZCBieVxuICAgICAqIGNvbnN0cnVjdG9ycyBvdGhlciB0aGFuIGBPYmplY3RgIGFyZSBjbG9uZWQgdG8gcGxhaW4gYE9iamVjdGAgb2JqZWN0cy4gQW5cbiAgICAgKiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoIGFzIGZ1bmN0aW9ucywgRE9NIG5vZGVzLFxuICAgICAqIE1hcHMsIFNldHMsIGFuZCBXZWFrTWFwcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcCh1c2Vycyk7XG4gICAgICogZGVlcFswXSA9PT0gdXNlcnNbMF07XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuICAgICAqIHZhciBlbCA9IF8uY2xvbmVEZWVwKGRvY3VtZW50LmJvZHksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBlbCA9PT0gZG9jdW1lbnQuYm9keVxuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogZWwubm9kZU5hbWVcbiAgICAgKiAvLyA9PiBCT0RZXG4gICAgICogZWwuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURlZXAodmFsdWUsIGN1c3RvbWl6ZXIsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nXG4gICAgICAgID8gYmFzZUNsb25lKHZhbHVlLCB0cnVlLCBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgMSkpXG4gICAgICAgIDogYmFzZUNsb25lKHZhbHVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3QoMywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndCgzLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5ndCgxLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGd0KHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID4gb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgxLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGd0ZSh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSBvdGhlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAgIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJiAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcnJheVRhZztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGJvb2xlYW4gcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4oZmFsc2UpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8IChpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGJvb2xUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRGF0ZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZShuZXcgRGF0ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUoJ01vbiBBcHJpbCAyMyAyMDEyJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGRhdGVUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudChkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudCgnPGJvZHk+Jyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiAhIXZhbHVlICYmIHZhbHVlLm5vZGVUeXBlID09PSAxICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGVtcHR5LiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgZW1wdHkgdW5sZXNzIGl0IGlzIGFuXG4gICAgICogYGFyZ3VtZW50c2Agb2JqZWN0LCBhcnJheSwgc3RyaW5nLCBvciBqUXVlcnktbGlrZSBjb2xsZWN0aW9uIHdpdGggYSBsZW5ndGhcbiAgICAgKiBncmVhdGVyIHRoYW4gYDBgIG9yIGFuIG9iamVjdCB3aXRoIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh0cnVlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh7ICdhJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNTdHJpbmcodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGlzRnVuY3Rpb24odmFsdWUuc3BsaWNlKSkpKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFrZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICAgICAqIGVxdWl2YWxlbnQuIElmIGBjdXN0b21pemVyYCBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLlxuICAgICAqIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgIGNvbXBhcmlzb25zIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2RcbiAgICAgKiBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIG90aGVyIFssIGluZGV4fGtleV0pLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGJvb2xlYW5zLCBgRGF0ZWAgb2JqZWN0cyxcbiAgICAgKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBhbmQgc3RyaW5ncy4gT2JqZWN0cyBhcmUgY29tcGFyZWQgYnlcbiAgICAgKiB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET00gbm9kZXNcbiAgICAgKiBhcmUgKipub3QqKiBzdXBwb3J0ZWQuIFByb3ZpZGUgYSBjdXN0b21pemVyIGZ1bmN0aW9uIHRvIGV4dGVuZCBzdXBwb3J0XG4gICAgICogZm9yIGNvbXBhcmluZyBvdGhlciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZXFcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICogdmFyIG90aGVyID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqXG4gICAgICogb2JqZWN0ID09IG90aGVyO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gICAgICogdmFyIGFycmF5ID0gWydoZWxsbycsICdnb29kYnllJ107XG4gICAgICogdmFyIG90aGVyID0gWydoaScsICdnb29kYnllJ107XG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwoYXJyYXksIG90aGVyLCBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgKiAgIGlmIChfLmV2ZXJ5KFt2YWx1ZSwgb3RoZXJdLCBSZWdFeHAucHJvdG90eXBlLnRlc3QsIC9eaCg/Oml8ZWxsbykkLykpIHtcbiAgICAgKiAgICAgcmV0dXJuIHRydWU7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyLCBjdXN0b21pemVyLCB0aGlzQXJnKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGJpbmRDYWxsYmFjayhjdXN0b21pemVyLCB0aGlzQXJnLCAzKSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgb3RoZXIpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuICByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgY3VzdG9taXplcikgOiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgRXJyb3JgLCBgRXZhbEVycm9yYCwgYFJhbmdlRXJyb3JgLCBgUmVmZXJlbmNlRXJyb3JgLFxuICAgICAqIGBTeW50YXhFcnJvcmAsIGBUeXBlRXJyb3JgLCBvciBgVVJJRXJyb3JgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gZXJyb3Igb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFcnJvcihuZXcgRXJyb3IpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFcnJvcihFcnJvcik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUubWVzc2FnZSA9PSAnc3RyaW5nJyAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBlcnJvclRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBwcmltaXRpdmUgbnVtYmVyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIFtgTnVtYmVyLmlzRmluaXRlYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzZmluaXRlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoMTApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoJzEwJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUodHJ1ZSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoT2JqZWN0KDEwKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGaW5pdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgbmF0aXZlSXNGaW5pdGUodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgICAgIC8vIGluIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSBhbmQgU2FmYXJpIHdoaWNoIHJldHVybiAnZnVuY3Rpb24nIGZvciByZWdleGVzXG4gICAgICAvLyBhbmQgU2FmYXJpIDggZXF1aXZhbGVudHMgd2hpY2ggcmV0dXJuICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcnMuXG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGZ1bmNUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAgICAgKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3Qoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGBvYmplY3RgIGFuZCBgc291cmNlYCB0byBkZXRlcm1pbmUgaWZcbiAgICAgKiBgb2JqZWN0YCBjb250YWlucyBlcXVpdmFsZW50IHByb3BlcnR5IHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIGlzIHByb3ZpZGVkXG4gICAgICogaXQgaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBjb21wYXJpc29ucyBhcmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmRcbiAgICAgKiB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgb3RoZXIsIGluZGV4fGtleSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIHByb3BlcnRpZXMgb2YgYXJyYXlzLCBib29sZWFucyxcbiAgICAgKiBgRGF0ZWAgb2JqZWN0cywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgYW5kIHN0cmluZ3MuIEZ1bmN0aW9uc1xuICAgICAqIGFuZCBET00gbm9kZXMgYXJlICoqbm90Kiogc3VwcG9ydGVkLiBQcm92aWRlIGEgY3VzdG9taXplciBmdW5jdGlvbiB0byBleHRlbmRcbiAgICAgKiBzdXBwb3J0IGZvciBjb21wYXJpbmcgb3RoZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9O1xuICAgICAqXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYWdlJzogNDAgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuICAgICAqIHZhciBvYmplY3QgPSB7ICdncmVldGluZyc6ICdoZWxsbycgfTtcbiAgICAgKiB2YXIgc291cmNlID0geyAnZ3JlZXRpbmcnOiAnaGknIH07XG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAqICAgcmV0dXJuIF8uZXZlcnkoW3ZhbHVlLCBvdGhlcl0sIFJlZ0V4cC5wcm90b3R5cGUudGVzdCwgL15oKD86aXxlbGxvKSQvKSB8fCB1bmRlZmluZWQ7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIsIHRoaXNBcmcpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gYmluZENhbGxiYWNrKGN1c3RvbWl6ZXIsIHRoaXNBcmcsIDMpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VJc01hdGNoKG9iamVjdCwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBOYU5gLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIG5vdCB0aGUgc2FtZSBhcyBbYGlzTmFOYF0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMS4yLjQpXG4gICAgICogd2hpY2ggcmV0dXJucyBgdHJ1ZWAgZm9yIGB1bmRlZmluZWRgIGFuZCBvdGhlciBub24tbnVtZXJpYyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4oTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKG5ldyBOdW1iZXIoTmFOKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuICAgICAgLy8gQW4gYE5hTmAgcHJpbWl0aXZlIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZi5cbiAgICAgIC8vIFBlcmZvcm0gdGhlIGB0b1N0cmluZ1RhZ2AgY2hlY2sgZmlyc3QgdG8gYXZvaWQgZXJyb3JzIHdpdGggc29tZSBob3N0IG9iamVjdHMgaW4gSUUuXG4gICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlICE9ICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShfKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlSXNOYXRpdmUudGVzdChmblRvU3RyaW5nLmNhbGwodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHJlSXNIb3N0Q3Rvci50ZXN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBudWxsYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbCh2b2lkIDApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBOdW1iZXJgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVG8gZXhjbHVkZSBgSW5maW5pdHlgLCBgLUluZmluaXR5YCwgYW5kIGBOYU5gLCB3aGljaCBhcmUgY2xhc3NpZmllZFxuICAgICAqIGFzIG51bWJlcnMsIHVzZSB0aGUgYF8uaXNGaW5pdGVgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcig4LjQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKCc4LjQnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IChpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IG51bWJlclRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICAgICAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBhc3N1bWVzIG9iamVjdHMgY3JlYXRlZCBieSB0aGUgYE9iamVjdGAgY29uc3RydWN0b3JcbiAgICAgKiBoYXZlIG5vIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICB2YXIgQ3RvcjtcblxuICAgICAgLy8gRXhpdCBlYXJseSBmb3Igbm9uIGBPYmplY3RgIG9iamVjdHMuXG4gICAgICBpZiAoIShpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IG9iamVjdFRhZyAmJiAhaXNBcmd1bWVudHModmFsdWUpKSB8fFxuICAgICAgICAgICghaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NvbnN0cnVjdG9yJykgJiYgKEN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvciwgdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhKEN0b3IgaW5zdGFuY2VvZiBDdG9yKSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIElFIDwgOSBpdGVyYXRlcyBpbmhlcml0ZWQgcHJvcGVydGllcyBiZWZvcmUgb3duIHByb3BlcnRpZXMuIElmIHRoZSBmaXJzdFxuICAgICAgLy8gaXRlcmF0ZWQgcHJvcGVydHkgaXMgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnR5IHRoZW4gdGhlcmUgYXJlIG5vIGluaGVyaXRlZFxuICAgICAgLy8gZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIC8vIEluIG1vc3QgZW52aXJvbm1lbnRzIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzIGFyZSBpdGVyYXRlZCBiZWZvcmVcbiAgICAgIC8vIGl0cyBpbmhlcml0ZWQgcHJvcGVydGllcy4gSWYgdGhlIGxhc3QgaXRlcmF0ZWQgcHJvcGVydHkgaXMgYW4gb2JqZWN0J3NcbiAgICAgIC8vIG93biBwcm9wZXJ0eSB0aGVuIHRoZXJlIGFyZSBubyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgYmFzZUZvckluKHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBSZWdFeHBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgvYWJjLyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgnL2FiYy8nKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUmVnRXhwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IHJlZ2V4cFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygnYWJjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IChpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN0cmluZ1RhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3Nbb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZChudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubHQoMSwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGx0KHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlIDwgb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgxLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgzLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgzLCAxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGx0ZSh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8PSBvdGhlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAoZnVuY3Rpb24oKSB7XG4gICAgICogICByZXR1cm4gXy50b0FycmF5KGFyZ3VtZW50cykuc2xpY2UoMSk7XG4gICAgICogfSgxLCAyLCAzKSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlID8gZ2V0TGVuZ3RoKHZhbHVlKSA6IDA7XG4gICAgICBpZiAoIWlzTGVuZ3RoKGxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlDb3B5KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGVcbiAgICAgKiBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUNvcHkodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0KHMpLCB0aGF0XG4gICAgICogZG9uJ3QgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlc1xuICAgICAqIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLiBJZiBgY3VzdG9taXplcmAgaXNcbiAgICAgKiBwcm92aWRlZCBpdCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uIGFuZFxuICAgICAqIHNvdXJjZSBwcm9wZXJ0aWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCBtZXJnaW5nIGlzIGhhbmRsZWRcbiAgICAgKiBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCBmaXZlIGFyZ3VtZW50czogKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdkYXRhJzogW3sgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICd1c2VyJzogJ2ZyZWQnIH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBhZ2VzID0ge1xuICAgICAqICAgJ2RhdGEnOiBbeyAnYWdlJzogMzYgfSwgeyAnYWdlJzogNDAgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZSh1c2VycywgYWdlcyk7XG4gICAgICogLy8gPT4geyAnZGF0YSc6IFt7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfV0gfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICdmcnVpdHMnOiBbJ2FwcGxlJ10sXG4gICAgICogICAndmVnZXRhYmxlcyc6IFsnYmVldCddXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBvdGhlciA9IHtcbiAgICAgKiAgICdmcnVpdHMnOiBbJ2JhbmFuYSddLFxuICAgICAqICAgJ3ZlZ2V0YWJsZXMnOiBbJ2NhcnJvdCddXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlciwgZnVuY3Rpb24oYSwgYikge1xuICAgICAqICAgaWYgKF8uaXNBcnJheShhKSkge1xuICAgICAqICAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnZnJ1aXRzJzogWydhcHBsZScsICdiYW5hbmEnXSwgJ3ZlZ2V0YWJsZXMnOiBbJ2JlZXQnLCAnY2Fycm90J10gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGJhc2VNZXJnZSk7XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAgICAgKiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICAgKiBJZiBgY3VzdG9taXplcmAgaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czpcbiAgICAgKiAob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgIGFuZCBpcyBiYXNlZCBvblxuICAgICAqIFtgT2JqZWN0LmFzc2lnbmBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5hc3NpZ24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGV4dGVuZFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAndXNlcic6ICdiYXJuZXknIH0sIHsgJ2FnZSc6IDQwIH0sIHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduLCBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKHZhbHVlKSA/IG90aGVyIDogdmFsdWU7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBkZWZhdWx0cyh7ICd1c2VyJzogJ2Jhcm5leScgfSwgeyAnYWdlJzogMzYgfSwgeyAndXNlcic6ICdmcmVkJyB9KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKSB7XG4gICAgICByZXR1cm4gY3VzdG9taXplclxuICAgICAgICA/IGFzc2lnbldpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpXG4gICAgICAgIDogYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGdpdmVuIGBwcm90b3R5cGVgIG9iamVjdC4gSWYgYVxuICAgICAqIGBwcm9wZXJ0aWVzYCBvYmplY3QgaXMgcHJvdmlkZWQgaXRzIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGFzc2lnbmVkXG4gICAgICogdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgKiAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwge1xuICAgICAqICAgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBDaXJjbGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgU2hhcGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMsIGd1YXJkKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHByb3RvdHlwZSwgcHJvcGVydGllcywgZ3VhcmQpKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcGVydGllcyA/IGJhc2VBc3NpZ24ocmVzdWx0LCBwcm9wZXJ0aWVzKSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAgICAgKiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC4gT25jZSBhXG4gICAgICogcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIHZhbHVlcyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRzKHsgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICdhZ2UnOiAzNiB9LCB7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHMgPSBjcmVhdGVEZWZhdWx0cyhhc3NpZ24sIGFzc2lnbkRlZmF1bHRzKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGVmYXVsdHNgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGFzc2lnbnNcbiAgICAgKiBkZWZhdWx0IHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0c0RlZXAoeyAndXNlcic6IHsgJ25hbWUnOiAnYmFybmV5JyB9IH0sIHsgJ3VzZXInOiB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogMzYgfSB9KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSB9XG4gICAgICpcbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHNEZWVwID0gY3JlYXRlRGVmYXVsdHMobWVyZ2UsIG1lcmdlRGVmYXVsdHMpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leScgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqL1xuICAgIHZhciBmaW5kS2V5ID0gY3JlYXRlRmluZEtleShiYXNlRm9yT3duKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEtleWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGEgY29sbGVjdGlvbiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA8IDQwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHJldHVybnMgYHBlYmJsZXNgIGFzc3VtaW5nIGBfLmZpbmRLZXlgIHJldHVybnMgYGJhcm5leWBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKi9cbiAgICB2YXIgZmluZExhc3RLZXkgPSBjcmVhdGVGaW5kS2V5KGJhc2VGb3JPd25SaWdodCk7XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3QgaW52b2tpbmdcbiAgICAgKiBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdFxuICAgICAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9ySW4obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdhJywgJ2InLCBhbmQgJ2MnIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIGZvckluID0gY3JlYXRlRm9ySW4oYmFzZUZvcik7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckluYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJblJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnYycsICdiJywgYW5kICdhJyBhc3N1bWluZyBgXy5mb3JJbiBgIGxvZ3MgJ2EnLCAnYicsIGFuZCAnYydcbiAgICAgKi9cbiAgICB2YXIgZm9ySW5SaWdodCA9IGNyZWF0ZUZvckluKGJhc2VGb3JSaWdodCk7XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IGludm9raW5nIGBpdGVyYXRlZWBcbiAgICAgKiBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uXG4gICAgICogZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93bihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ2EnIGFuZCAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgZm9yT3duID0gY3JlYXRlRm9yT3duKGJhc2VGb3JPd24pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JPd25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllcyBvZlxuICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93blJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnYicgYW5kICdhJyBhc3N1bWluZyBgXy5mb3JPd25gIGxvZ3MgJ2EnIGFuZCAnYidcbiAgICAgKi9cbiAgICB2YXIgZm9yT3duUmlnaHQgPSBjcmVhdGVGb3JPd24oYmFzZUZvck93blJpZ2h0KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZnJvbSBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLFxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkLCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBtZXRob2RzXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9ucyhfKTtcbiAgICAgKiAvLyA9PiBbJ2FmdGVyJywgJ2FyeScsICdhc3NpZ24nLCAuLi5dXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VGdW5jdGlvbnMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcHJvcGVydHkgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAgICAgKiBgdW5kZWZpbmVkYCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgdXNlZCBpbiBpdHMgcGxhY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGB1bmRlZmluZWRgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHRvUGF0aChwYXRoKSwgcGF0aCArICcnKTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogeyAnYic6IHsgJ2MnOiAzIH0gfSB9O1xuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgJ2EuYi5jJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCBbJ2EnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXMob2JqZWN0LCBwYXRoKSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwYXRoKTtcbiAgICAgIGlmICghcmVzdWx0ICYmICFpc0tleShwYXRoKSkge1xuICAgICAgICBwYXRoID0gdG9QYXRoKHBhdGgpO1xuICAgICAgICBvYmplY3QgPSBwYXRoLmxlbmd0aCA9PSAxID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuICAgICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aCA9IGxhc3QocGF0aCk7XG4gICAgICAgIHJlc3VsdCA9IGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwYXRoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQgfHwgKGlzTGVuZ3RoKG9iamVjdC5sZW5ndGgpICYmIGlzSW5kZXgocGF0aCwgb2JqZWN0Lmxlbmd0aCkgJiZcbiAgICAgICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGludmVydGVkIGtleXMgYW5kIHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKiBJZiBgb2JqZWN0YCBjb250YWlucyBkdXBsaWNhdGUgdmFsdWVzLCBzdWJzZXF1ZW50IHZhbHVlcyBvdmVyd3JpdGUgcHJvcGVydHlcbiAgICAgKiBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyB2YWx1ZXMgdW5sZXNzIGBtdWx0aVZhbHVlYCBpcyBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludmVydC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFttdWx0aVZhbHVlXSBBbGxvdyBtdWx0aXBsZSB2YWx1ZXMgcGVyIGtleS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmludmVydChvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzEnOiAnYycsICcyJzogJ2InIH1cbiAgICAgKlxuICAgICAqIC8vIHdpdGggYG11bHRpVmFsdWVgXG4gICAgICogXy5pbnZlcnQob2JqZWN0LCB0cnVlKTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52ZXJ0KG9iamVjdCwgbXVsdGlWYWx1ZSwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChvYmplY3QsIG11bHRpVmFsdWUsIGd1YXJkKSkge1xuICAgICAgICBtdWx0aVZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdLFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICBpZiAobXVsdGlWYWx1ZSkge1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgdmFsdWUpKSB7XG4gICAgICAgICAgICByZXN1bHRbdmFsdWVdLnB1c2goa2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W3ZhbHVlXSA9IFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbdmFsdWVdID0ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAgICAgKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5cyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLmtleXMoJ2hpJyk7XG4gICAgICogLy8gPT4gWycwJywgJzEnXVxuICAgICAqL1xuICAgIHZhciBrZXlzID0gIW5hdGl2ZUtleXMgPyBzaGltS2V5cyA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIEN0b3IgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmICgodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSA9PT0gb2JqZWN0KSB8fFxuICAgICAgICAgICh0eXBlb2Ygb2JqZWN0ICE9ICdmdW5jdGlvbicgJiYgaXNBcnJheUxpa2Uob2JqZWN0KSkpIHtcbiAgICAgICAgcmV0dXJuIHNoaW1LZXlzKG9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSA/IG5hdGl2ZUtleXMob2JqZWN0KSA6IFtdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmtleXNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7XG4gICAgICBsZW5ndGggPSAobGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiZcbiAgICAgICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKSAmJiBsZW5ndGgpIHx8IDA7XG5cbiAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNQcm90byA9IHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUgPT09IG9iamVjdCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgIHNraXBJbmRleGVzID0gbGVuZ3RoID4gMDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IChpbmRleCArICcnKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKCEoc2tpcEluZGV4ZXMgJiYgaXNJbmRleChrZXksIGxlbmd0aCkpICYmXG4gICAgICAgICAgICAhKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWFwVmFsdWVzYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGVcbiAgICAgKiBzYW1lIHZhbHVlcyBhcyBgb2JqZWN0YCBhbmQga2V5cyBnZW5lcmF0ZWQgYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlXG4gICAgICogcHJvcGVydHkgb2YgYG9iamVjdGAgdGhyb3VnaCBgaXRlcmF0ZWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXBLZXlzKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgcmV0dXJuIGtleSArIHZhbHVlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2ExJzogMSwgJ2IyJzogMiB9XG4gICAgICovXG4gICAgdmFyIG1hcEtleXMgPSBjcmVhdGVPYmplY3RNYXBwZXIodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamVjdGAgYW5kIHZhbHVlcyBnZW5lcmF0ZWQgYnlcbiAgICAgKiBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhyb3VnaCBgaXRlcmF0ZWVgLiBUaGVcbiAgICAgKiBpdGVyYXRlZSBmdW5jdGlvbiBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcFZhbHVlcyh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2IH1cbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdmcmVkJzogICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcFZhbHVlcyh1c2VycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgbWFwVmFsdWVzID0gY3JlYXRlT2JqZWN0TWFwcGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZVxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgb2JqZWN0YCB0aGF0IGFyZSBub3Qgb21pdHRlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwcmVkaWNhdGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlclxuICAgICAqICBpdGVyYXRpb24gb3IgcHJvcGVydHkgbmFtZXMgdG8gb21pdCwgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgcHJvcGVydHlcbiAgICAgKiAgbmFtZXMgb3IgYXJyYXlzIG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG4gICAgICpcbiAgICAgKiBfLm9taXQob2JqZWN0LCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG4gICAgICpcbiAgICAgKiBfLm9taXQob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKi9cbiAgICB2YXIgb21pdCA9IHJlc3RQYXJhbShmdW5jdGlvbihvYmplY3QsIHByb3BzKSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcm9wc1swXSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IGFycmF5TWFwKGJhc2VGbGF0dGVuKHByb3BzKSwgU3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHBpY2tCeUFycmF5KG9iamVjdCwgYmFzZURpZmZlcmVuY2Uoa2V5c0luKG9iamVjdCksIHByb3BzKSk7XG4gICAgICB9XG4gICAgICB2YXIgcHJlZGljYXRlID0gYmluZENhbGxiYWNrKHByb3BzWzBdLCBwcm9wc1sxXSwgMyk7XG4gICAgICByZXR1cm4gcGlja0J5Q2FsbGJhY2sob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUodmFsdWUsIGtleSwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHR3byBkaW1lbnNpb25hbCBhcnJheSBvZiB0aGUga2V5LXZhbHVlIHBhaXJzIGZvciBgb2JqZWN0YCxcbiAgICAgKiBlLmcuIGBbW2tleTEsIHZhbHVlMV0sIFtrZXkyLCB2YWx1ZTJdXWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWlycyh7ICdiYXJuZXknOiAzNiwgJ2ZyZWQnOiA0MCB9KTtcbiAgICAgKiAvLyA9PiBbWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQwXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWlycyhvYmplY3QpIHtcbiAgICAgIG9iamVjdCA9IHRvT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gW2tleSwgb2JqZWN0W2tleV1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIGBvYmplY3RgIHByb3BlcnRpZXMuIFByb3BlcnR5XG4gICAgICogbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXMgb2YgcHJvcGVydHlcbiAgICAgKiBuYW1lcy4gSWYgYHByZWRpY2F0ZWAgaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZCBmb3IgZWFjaCBwcm9wZXJ0eSBvZiBgb2JqZWN0YFxuICAgICAqIHBpY2tpbmcgdGhlIHByb3BlcnRpZXMgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwcmVkaWNhdGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlclxuICAgICAqICBpdGVyYXRpb24gb3IgcHJvcGVydHkgbmFtZXMgdG8gcGljaywgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgcHJvcGVydHlcbiAgICAgKiAgbmFtZXMgb3IgYXJyYXlzIG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG4gICAgICpcbiAgICAgKiBfLnBpY2sob2JqZWN0LCAndXNlcicpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqXG4gICAgICogXy5waWNrKG9iamVjdCwgXy5pc1N0cmluZyk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG4gICAgICovXG4gICAgdmFyIHBpY2sgPSByZXN0UGFyYW0oZnVuY3Rpb24ob2JqZWN0LCBwcm9wcykge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlb2YgcHJvcHNbMF0gPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBpY2tCeUNhbGxiYWNrKG9iamVjdCwgYmluZENhbGxiYWNrKHByb3BzWzBdLCBwcm9wc1sxXSwgMykpXG4gICAgICAgIDogcGlja0J5QXJyYXkob2JqZWN0LCBiYXNlRmxhdHRlbihwcm9wcykpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5nZXRgIGV4Y2VwdCB0aGF0IGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uXG4gICAgICogaXQgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBpdHMgcGFyZW50IG9iamVjdCBhbmQgaXRzIHJlc3VsdFxuICAgICAqIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gcmVzb2x2ZS5cbiAgICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBpZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXMgYHVuZGVmaW5lZGAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYzEnOiAzLCAnYzInOiBfLmNvbnN0YW50KDQpIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMScpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMicpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2EuYi5jJywgXy5jb25zdGFudCgnZGVmYXVsdCcpKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN1bHQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtwYXRoXTtcbiAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob2JqZWN0ICE9IG51bGwgJiYgIWlzS2V5KHBhdGgsIG9iamVjdCkpIHtcbiAgICAgICAgICBwYXRoID0gdG9QYXRoKHBhdGgpO1xuICAgICAgICAgIG9iamVjdCA9IHBhdGgubGVuZ3RoID09IDEgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgYmFzZVNsaWNlKHBhdGgsIDAsIC0xKSk7XG4gICAgICAgICAgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3RbbGFzdChwYXRoKV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihyZXN1bHQpID8gcmVzdWx0LmNhbGwob2JqZWN0KSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiBgcGF0aGAgb24gYG9iamVjdGAuIElmIGEgcG9ydGlvbiBvZiBgcGF0aGBcbiAgICAgKiBkb2VzIG5vdCBleGlzdCBpdCBpcyBjcmVhdGVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBhdWdtZW50LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnNldChvYmplY3QsICdhWzBdLmIuYycsIDQpO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5zZXQob2JqZWN0LCAneFswXS55LnonLCA1KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG4gICAgICB2YXIgcGF0aEtleSA9IChwYXRoICsgJycpO1xuICAgICAgcGF0aCA9IChvYmplY3RbcGF0aEtleV0gIT0gbnVsbCB8fCBpc0tleShwYXRoLCBvYmplY3QpKSA/IFtwYXRoS2V5XSA6IHRvUGF0aChwYXRoKTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcbiAgICAgICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgICAgIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwYXRoW2luZGV4XTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KG5lc3RlZCkpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICBuZXN0ZWRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmVzdGVkW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgbmVzdGVkW2tleV0gPSBpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gYF8ucmVkdWNlYDsgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBgb2JqZWN0YCB0byBhIG5ld1xuICAgICAqIGBhY2N1bXVsYXRvcmAgb2JqZWN0IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgcnVubmluZyBlYWNoIG9mIGl0cyBvd24gZW51bWVyYWJsZVxuICAgICAqIHByb3BlcnRpZXMgdGhyb3VnaCBgaXRlcmF0ZWVgLCB3aXRoIGVhY2ggaW52b2NhdGlvbiBwb3RlbnRpYWxseSBtdXRhdGluZ1xuICAgICAqIHRoZSBgYWNjdW11bGF0b3JgIG9iamVjdC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCBmb3VyIGFyZ3VtZW50czogKGFjY3VtdWxhdG9yLCB2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnNcbiAgICAgKiBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgY3VzdG9tIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmFuc2Zvcm0oWzIsIDMsIDRdLCBmdW5jdGlvbihyZXN1bHQsIG4pIHtcbiAgICAgKiAgIHJlc3VsdC5wdXNoKG4gKj0gbik7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbNCwgOV1cbiAgICAgKlxuICAgICAqIF8udHJhbnNmb3JtKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24ocmVzdWx0LCBuLCBrZXkpIHtcbiAgICAgKiAgIHJlc3VsdFtrZXldID0gbiAqIDM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDMsICdiJzogNiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKG9iamVjdCwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iamVjdCkgfHwgaXNUeXBlZEFycmF5KG9iamVjdCk7XG4gICAgICBpdGVyYXRlZSA9IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCA0KTtcblxuICAgICAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzQXJyIHx8IGlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yID0gaXNBcnJheShvYmplY3QpID8gbmV3IEN0b3IgOiBbXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBiYXNlQ3JlYXRlKGlzRnVuY3Rpb24oQ3RvcikgPyBDdG9yLnByb3RvdHlwZSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIChpc0FyciA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIG9iamVjdCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKCdoaScpO1xuICAgICAqIC8vID0+IFsnaCcsICdpJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSB2YWx1ZXNcbiAgICAgKiBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udmFsdWVzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZVZhbHVlcyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYG5gIGlzIGJldHdlZW4gYHN0YXJ0YCBhbmQgdXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBJZlxuICAgICAqIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQgaXQgaXMgc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgbmAgaXMgaW4gdGhlIHJhbmdlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgzLCAyLCA0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNCwgOCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDQsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMiwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgxLjIsIDIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg1LjIsIDQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5SYW5nZSh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgc3RhcnQgPSArc3RhcnQgfHwgMDtcbiAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gK2VuZCB8fCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID49IG5hdGl2ZU1pbihzdGFydCwgZW5kKSAmJiB2YWx1ZSA8IG5hdGl2ZU1heChzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBgbWluYCBhbmQgYG1heGAgKGluY2x1c2l2ZSkuIElmIG9ubHkgb25lXG4gICAgICogYXJndW1lbnQgaXMgcHJvdmlkZWQgYSBudW1iZXIgYmV0d2VlbiBgMGAgYW5kIHRoZSBnaXZlbiBudW1iZXIgaXMgcmV0dXJuZWQuXG4gICAgICogSWYgYGZsb2F0aW5nYCBpcyBgdHJ1ZWAsIG9yIGVpdGhlciBgbWluYCBvciBgbWF4YCBhcmUgZmxvYXRzLCBhIGZsb2F0aW5nLXBvaW50XG4gICAgICogbnVtYmVyIGlzIHJldHVybmVkIGluc3RlYWQgb2YgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21pbj0wXSBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21heD0xXSBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmbG9hdGluZ10gU3BlY2lmeSByZXR1cm5pbmcgYSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMCwgNSk7XG4gICAgICogLy8gPT4gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUpO1xuICAgICAqIC8vID0+IGFsc28gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUsIHRydWUpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMS4yLCA1LjIpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMS4yIGFuZCA1LjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kb20obWluLCBtYXgsIGZsb2F0aW5nKSB7XG4gICAgICBpZiAoZmxvYXRpbmcgJiYgaXNJdGVyYXRlZUNhbGwobWluLCBtYXgsIGZsb2F0aW5nKSkge1xuICAgICAgICBtYXggPSBmbG9hdGluZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciBub01pbiA9IG1pbiA9PSBudWxsLFxuICAgICAgICAgIG5vTWF4ID0gbWF4ID09IG51bGw7XG5cbiAgICAgIGlmIChmbG9hdGluZyA9PSBudWxsKSB7XG4gICAgICAgIGlmIChub01heCAmJiB0eXBlb2YgbWluID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gbWluO1xuICAgICAgICAgIG1pbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1heCA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IG1heDtcbiAgICAgICAgICBub01heCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub01pbiAmJiBub01heCkge1xuICAgICAgICBtYXggPSAxO1xuICAgICAgICBub01heCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgbWluID0gK21pbiB8fCAwO1xuICAgICAgaWYgKG5vTWF4KSB7XG4gICAgICAgIG1heCA9IG1pbjtcbiAgICAgICAgbWluID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heCA9ICttYXggfHwgMDtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyB8fCBtaW4gJSAxIHx8IG1heCAlIDEpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBuYXRpdmVSYW5kb20oKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1pbihtaW4gKyAocmFuZCAqIChtYXggLSBtaW4gKyBwYXJzZUZsb2F0KCcxZS0nICsgKChyYW5kICsgJycpLmxlbmd0aCAtIDEpKSkpLCBtYXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSYW5kb20obWluLCBtYXgpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtjYW1lbCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYW1lbENhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FtZWwgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnLS1mb28tYmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICovXG4gICAgdmFyIGNhbWVsQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgd29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAod29yZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHdvcmQuc2xpY2UoMSkpIDogd29yZCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDYXBpdGFsaXplcyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNhcGl0YWxpemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FwaXRhbGl6ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhcGl0YWxpemUoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gc3RyaW5nICYmIChzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlYnVycnMgYHN0cmluZ2AgYnkgY29udmVydGluZyBbbGF0aW4tMSBzdXBwbGVtZW50YXJ5IGxldHRlcnNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluLTFfU3VwcGxlbWVudF8oVW5pY29kZV9ibG9jaykjQ2hhcmFjdGVyX3RhYmxlKVxuICAgICAqIHRvIGJhc2ljIGxhdGluIGxldHRlcnMgYW5kIHJlbW92aW5nIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZGVidXJyLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWJ1cnIoJ2TDqWrDoCB2dScpO1xuICAgICAqIC8vID0+ICdkZWphIHZ1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYnVycihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIHN0cmluZyAmJiBzdHJpbmcucmVwbGFjZShyZUxhdGluMSwgZGVidXJyTGV0dGVyKS5yZXBsYWNlKHJlQ29tYm9NYXJrLCAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGVuZHMgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIFRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvc2l0aW9uPXN0cmluZy5sZW5ndGhdIFRoZSBwb3NpdGlvbiB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIGB0YXJnZXRgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InLCAyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5kc1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHRhcmdldCA9ICh0YXJnZXQgKyAnJyk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gbGVuZ3RoXG4gICAgICAgIDogbmF0aXZlTWluKHBvc2l0aW9uIDwgMCA/IDAgOiAoK3Bvc2l0aW9uIHx8IDApLCBsZW5ndGgpO1xuXG4gICAgICBwb3NpdGlvbiAtPSB0YXJnZXQubGVuZ3RoO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uID49IDAgJiYgc3RyaW5nLmluZGV4T2YodGFyZ2V0LCBwb3NpdGlvbikgPT0gcG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgXCImXCIsIFwiPFwiLCBcIj5cIiwgJ1wiJywgXCInXCIsIGFuZCBcIlxcYFwiLCBpbiBgc3RyaW5nYCB0b1xuICAgICAqIHRoZWlyIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbCBjaGFyYWN0ZXJzXG4gICAgICogdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICAgICAqIFwiPlwiIGFuZCBcIi9cIiBkb24ndCBuZWVkIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nXG4gICAgICogdW5sZXNzIHRoZXkncmUgcGFydCBvZiBhIHRhZyBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICogU2VlIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAgICAgKiAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIikgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEJhY2t0aWNrcyBhcmUgZXNjYXBlZCBiZWNhdXNlIGluIEludGVybmV0IEV4cGxvcmVyIDwgOSwgdGhleSBjYW4gYnJlYWsgb3V0XG4gICAgICogb2YgYXR0cmlidXRlIHZhbHVlcyBvciBIVE1MIGNvbW1lbnRzLiBTZWUgWyM1OV0oaHR0cHM6Ly9odG1sNXNlYy5vcmcvIzU5KSxcbiAgICAgKiBbIzEwMl0oaHR0cHM6Ly9odG1sNXNlYy5vcmcvIzEwMiksIFsjMTA4XShodHRwczovL2h0bWw1c2VjLm9yZy8jMTA4KSwgYW5kXG4gICAgICogWyMxMzNdKGh0dHBzOi8vaHRtbDVzZWMub3JnLyMxMzMpIG9mIHRoZSBbSFRNTDUgU2VjdXJpdHkgQ2hlYXRzaGVldF0oaHR0cHM6Ly9odG1sNXNlYy5vcmcvKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBXaGVuIHdvcmtpbmcgd2l0aCBIVE1MIHlvdSBzaG91bGQgYWx3YXlzIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZylcbiAgICAgKiB0byByZWR1Y2UgWFNTIHZlY3RvcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgICAgIC8vIFJlc2V0IGBsYXN0SW5kZXhgIGJlY2F1c2UgaW4gSUUgPCA5IGBTdHJpbmcjcmVwbGFjZWAgZG9lcyBub3QuXG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBlc2NhcGVIdG1sQ2hhcilcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXNjYXBlcyB0aGUgYFJlZ0V4cGAgc3BlY2lhbCBjaGFyYWN0ZXJzIFwiXFxcIiwgXCIvXCIsIFwiXlwiLCBcIiRcIiwgXCIuXCIsIFwifFwiLCBcIj9cIixcbiAgICAgKiBcIipcIiwgXCIrXCIsIFwiKFwiLCBcIilcIiwgXCJbXCIsIFwiXVwiLCBcIntcIiBhbmQgXCJ9XCIgaW4gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZVJlZ0V4cCgnW2xvZGFzaF0oaHR0cHM6Ly9sb2Rhc2guY29tLyknKTtcbiAgICAgKiAvLyA9PiAnXFxbbG9kYXNoXFxdXFwoaHR0cHM6XFwvXFwvbG9kYXNoXFwuY29tXFwvXFwpJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNSZWdFeHBDaGFycy50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVSZWdFeHBDaGFycywgZXNjYXBlUmVnRXhwQ2hhcilcbiAgICAgICAgOiAoc3RyaW5nIHx8ICcoPzopJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gW2tlYmFiIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1NwZWNpYWxfY2FzZV9zdHlsZXMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUga2ViYWIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICovXG4gICAgdmFyIGtlYmFiQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICctJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGVzIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLlxuICAgICAqIFBhZGRpbmcgY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgY2FuJ3QgYmUgZXZlbmx5IGRpdmlkZWQgYnkgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDgpO1xuICAgICAqIC8vID0+ICcgIGFiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1hYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9ICtsZW5ndGg7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgaWYgKHN0ckxlbmd0aCA+PSBsZW5ndGggfHwgIW5hdGl2ZUlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBtaWQgPSAobGVuZ3RoIC0gc3RyTGVuZ3RoKSAvIDIsXG4gICAgICAgICAgbGVmdExlbmd0aCA9IG5hdGl2ZUZsb29yKG1pZCksXG4gICAgICAgICAgcmlnaHRMZW5ndGggPSBuYXRpdmVDZWlsKG1pZCk7XG5cbiAgICAgIGNoYXJzID0gY3JlYXRlUGFkZGluZygnJywgcmlnaHRMZW5ndGgsIGNoYXJzKTtcbiAgICAgIHJldHVybiBjaGFycy5zbGljZSgwLCBsZWZ0TGVuZ3RoKSArIHN0cmluZyArIGNoYXJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgc2lkZSBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC4gUGFkZGluZ1xuICAgICAqIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGV4Y2VlZCBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZExlZnQoJ2FiYycsIDYpO1xuICAgICAqIC8vID0+ICcgICBhYmMnXG4gICAgICpcbiAgICAgKiBfLnBhZExlZnQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdfLV9hYmMnXG4gICAgICpcbiAgICAgKiBfLnBhZExlZnQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgdmFyIHBhZExlZnQgPSBjcmVhdGVQYWREaXIoKTtcblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIHJpZ2h0IHNpZGUgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRSaWdodCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJ2FiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkUmlnaHQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZFJpZ2h0KCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIHZhciBwYWRSaWdodCA9IGNyZWF0ZVBhZERpcih0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGludGVnZXIgb2YgdGhlIHNwZWNpZmllZCByYWRpeC4gSWYgYHJhZGl4YCBpc1xuICAgICAqIGB1bmRlZmluZWRgIG9yIGAwYCwgYSBgcmFkaXhgIG9mIGAxMGAgaXMgdXNlZCB1bmxlc3MgYHZhbHVlYCBpcyBhIGhleGFkZWNpbWFsLFxuICAgICAqIGluIHdoaWNoIGNhc2UgYSBgcmFkaXhgIG9mIGAxNmAgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBhbGlnbnMgd2l0aCB0aGUgW0VTNSBpbXBsZW1lbnRhdGlvbl0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyNFKVxuICAgICAqIG9mIGBwYXJzZUludGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpeF0gVGhlIHJhZGl4IHRvIGludGVycHJldCBgdmFsdWVgIGJ5LlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhcnNlSW50KCcwOCcpO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICcwOCcsICcxMCddLCBfLnBhcnNlSW50KTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VJbnQoc3RyaW5nLCByYWRpeCwgZ3VhcmQpIHtcbiAgICAgIC8vIEZpcmVmb3ggPCAyMSBhbmQgT3BlcmEgPCAxNSBmb2xsb3cgRVMzIGZvciBgcGFyc2VJbnRgLlxuICAgICAgLy8gQ2hyb21lIGZhaWxzIHRvIHRyaW0gbGVhZGluZyA8Qk9NPiB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMxMDkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgcmFkaXgsIGd1YXJkKSA6IHJhZGl4ID09IG51bGwpIHtcbiAgICAgICAgcmFkaXggPSAwO1xuICAgICAgfSBlbHNlIGlmIChyYWRpeCkge1xuICAgICAgICByYWRpeCA9ICtyYWRpeDtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRyaW0oc3RyaW5nKTtcbiAgICAgIHJldHVybiBuYXRpdmVQYXJzZUludChzdHJpbmcsIHJhZGl4IHx8IChyZUhhc0hleFByZWZpeC50ZXN0KHN0cmluZykgPyAxNiA6IDEwKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwZWF0cyB0aGUgZ2l2ZW4gc3RyaW5nIGBuYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byByZXBlYXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTBdIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmVwZWF0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnKicsIDMpO1xuICAgICAqIC8vID0+ICcqKionXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMik7XG4gICAgICogLy8gPT4gJ2FiY2FiYydcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCdhYmMnLCAwKTtcbiAgICAgKiAvLyA9PiAnJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGVhdChzdHJpbmcsIG4pIHtcbiAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgbiA9ICtuO1xuICAgICAgaWYgKG4gPCAxIHx8ICFzdHJpbmcgfHwgIW5hdGl2ZUlzRmluaXRlKG4pKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICAvLyBMZXZlcmFnZSB0aGUgZXhwb25lbnRpYXRpb24gYnkgc3F1YXJpbmcgYWxnb3JpdGhtIGZvciBhIGZhc3RlciByZXBlYXQuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXhwb25lbnRpYXRpb25fYnlfc3F1YXJpbmcgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKG4gJSAyKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBuID0gbmF0aXZlRmxvb3IobiAvIDIpO1xuICAgICAgICBzdHJpbmcgKz0gc3RyaW5nO1xuICAgICAgfSB3aGlsZSAobik7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gW3NuYWtlIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NuYWtlX2Nhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc25ha2UgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJy0tZm9vLWJhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqL1xuICAgIHZhciBzbmFrZUNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnXycgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBbc3RhcnQgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3R5bGlzdGljX29yX3NwZWNpYWxpc2VkX3VzYWdlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0YXJ0IGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJy0tZm9vLWJhcicpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICovXG4gICAgdmFyIHN0YXJ0Q2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArICh3b3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj0wXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIGB0YXJnZXRgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PSBudWxsXG4gICAgICAgID8gMFxuICAgICAgICA6IG5hdGl2ZU1pbihwb3NpdGlvbiA8IDAgPyAwIDogKCtwb3NpdGlvbiB8fCAwKSwgc3RyaW5nLmxlbmd0aCk7XG5cbiAgICAgIHJldHVybiBzdHJpbmcubGFzdEluZGV4T2YodGFyZ2V0LCBwb3NpdGlvbikgPT0gcG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgY2FuIGludGVycG9sYXRlIGRhdGEgcHJvcGVydGllc1xuICAgICAqIGluIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJzLCBIVE1MLWVzY2FwZSBpbnRlcnBvbGF0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluXG4gICAgICogXCJlc2NhcGVcIiBkZWxpbWl0ZXJzLCBhbmQgZXhlY3V0ZSBKYXZhU2NyaXB0IGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLiBEYXRhXG4gICAgICogcHJvcGVydGllcyBtYXkgYmUgYWNjZXNzZWQgYXMgZnJlZSB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlLiBJZiBhIHNldHRpbmdcbiAgICAgKiBvYmplY3QgaXMgcHJvdmlkZWQgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBfLnRlbXBsYXRlU2V0dGluZ3NgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgYF8udGVtcGxhdGVgIHV0aWxpemVzXG4gICAgICogW3NvdXJjZVVSTHNdKGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmwpXG4gICAgICogZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZVxuICAgICAqIFtsb2Rhc2gncyBjdXN0b20gYnVpbGRzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzKS5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZVxuICAgICAqIFtDaHJvbWUncyBleHRlbnNpb25zIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSB0ZW1wbGF0ZSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZV0gVGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlXSBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0c10gQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBmcmVlIHZhcmlhYmxlcy5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGVdIFRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VVUkxdIFRoZSBzb3VyY2VVUkwgb2YgdGhlIHRlbXBsYXRlJ3MgY29tcGlsZWQgc291cmNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YXJpYWJsZV0gVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbb3RoZXJPcHRpb25zXSBFbmFibGVzIHRoZSBsZWdhY3kgYG9wdGlvbnNgIHBhcmFtIHNpZ25hdHVyZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlciB0byBjcmVhdGUgYSBjb21waWxlZCB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIGRhdGEgcHJvcGVydHkgdmFsdWVzXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAgICAgKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIgdG8gZXhlY3V0ZSBKYXZhU2NyaXB0IGFuZCBnZW5lcmF0ZSBIVE1MXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgXy5mb3JFYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIHVzZXIpOyAlPiEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2Jhcm5leScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgRVMgZGVsaW1pdGVyIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBkZWZhdWx0IFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyAkeyB1c2VyIH0hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gcGViYmxlcyEnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVyc1xuICAgICAqIF8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZSA9IC97eyhbXFxzXFxTXSs/KX19L2c7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8ge3sgdXNlciB9fSEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ211c3RhY2hlJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCU9IFwiXFxcXDwlLSB2YWx1ZSAlXFxcXD5cIiAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJ2lnbm9yZWQnIH0pO1xuICAgICAqIC8vID0+ICc8JS0gdmFsdWUgJT4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgYGpRdWVyeWAgYXMgYGpxYFxuICAgICAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSh0ZXh0LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcbiAgICAgKiBjb21waWxlZChkYXRhKTtcbiAgICAgKiAvLyA9PiBmaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS51c2VyICU+IScsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICAgICAqIGNvbXBpbGVkLnNvdXJjZTtcbiAgICAgKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICogLy8gICB2YXIgX190LCBfX3AgPSAnJztcbiAgICAgKiAvLyAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLnVzZXIgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAgICAgKiAvLyAgIHJldHVybiBfX3A7XG4gICAgICogLy8gfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAgICAgKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIGEgc3RhY2sgdHJhY2VcbiAgICAgKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihjd2QsICdqc3QuanMnKSwgJ1xcXG4gICAgICogICB2YXIgSlNUID0ge1xcXG4gICAgICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gICAgICogICB9O1xcXG4gICAgICogJyk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGVtcGxhdGUoc3RyaW5nLCBvcHRpb25zLCBvdGhlck9wdGlvbnMpIHtcbiAgICAgIC8vIEJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb24gKGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvKVxuICAgICAgLy8gYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qcyAoaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVCkuXG4gICAgICB2YXIgc2V0dGluZ3MgPSBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncztcblxuICAgICAgaWYgKG90aGVyT3B0aW9ucyAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIG90aGVyT3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IG90aGVyT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgb3B0aW9ucyA9IGFzc2lnbldpdGgoYmFzZUFzc2lnbih7fSwgb3RoZXJPcHRpb25zIHx8IG9wdGlvbnMpLCBzZXR0aW5ncywgYXNzaWduT3duRGVmYXVsdHMpO1xuXG4gICAgICB2YXIgaW1wb3J0cyA9IGFzc2lnbldpdGgoYmFzZUFzc2lnbih7fSwgb3B0aW9ucy5pbXBvcnRzKSwgc2V0dGluZ3MuaW1wb3J0cywgYXNzaWduT3duRGVmYXVsdHMpLFxuICAgICAgICAgIGltcG9ydHNLZXlzID0ga2V5cyhpbXBvcnRzKSxcbiAgICAgICAgICBpbXBvcnRzVmFsdWVzID0gYmFzZVZhbHVlcyhpbXBvcnRzLCBpbXBvcnRzS2V5cyk7XG5cbiAgICAgIHZhciBpc0VzY2FwaW5nLFxuICAgICAgICAgIGlzRXZhbHVhdGluZyxcbiAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgaW50ZXJwb2xhdGUgPSBvcHRpb25zLmludGVycG9sYXRlIHx8IHJlTm9NYXRjaCxcbiAgICAgICAgICBzb3VyY2UgPSBcIl9fcCArPSAnXCI7XG5cbiAgICAgIC8vIENvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlci5cbiAgICAgIHZhciByZURlbGltaXRlcnMgPSBSZWdFeHAoXG4gICAgICAgIChvcHRpb25zLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXG4gICAgICAgIChpbnRlcnBvbGF0ZSA9PT0gcmVJbnRlcnBvbGF0ZSA/IHJlRXNUZW1wbGF0ZSA6IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgKG9wdGlvbnMuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCQnXG4gICAgICAsICdnJyk7XG5cbiAgICAgIC8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgIHZhciBzb3VyY2VVUkwgPSAnLy8jIHNvdXJjZVVSTD0nICtcbiAgICAgICAgKCdzb3VyY2VVUkwnIGluIG9wdGlvbnNcbiAgICAgICAgICA/IG9wdGlvbnMuc291cmNlVVJMXG4gICAgICAgICAgOiAoJ2xvZGFzaC50ZW1wbGF0ZVNvdXJjZXNbJyArICgrK3RlbXBsYXRlQ291bnRlcikgKyAnXScpXG4gICAgICAgICkgKyAnXFxuJztcblxuICAgICAgc3RyaW5nLnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgICAgIC8vIEVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2FuJ3QgYmUgaW5jbHVkZWQgaW4gc3RyaW5nIGxpdGVyYWxzLlxuICAgICAgICBzb3VyY2UgKz0gc3RyaW5nLnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzLlxuICAgICAgICBpZiAoZXNjYXBlVmFsdWUpIHtcbiAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgICAvLyBUaGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIHJlcXVpcmVzIHJldHVybmluZyB0aGUgYG1hdGNoYFxuICAgICAgICAvLyBzdHJpbmcgaW4gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7XG5cbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAgIC8vIElmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgICAgIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpbi5cbiAgICAgIHZhciB2YXJpYWJsZSA9IG9wdGlvbnMudmFyaWFibGU7XG4gICAgICBpZiAoIXZhcmlhYmxlKSB7XG4gICAgICAgIHNvdXJjZSA9ICd3aXRoIChvYmopIHtcXG4nICsgc291cmNlICsgJ1xcbn1cXG4nO1xuICAgICAgfVxuICAgICAgLy8gQ2xlYW51cCBjb2RlIGJ5IHN0cmlwcGluZyBlbXB0eSBzdHJpbmdzLlxuICAgICAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCAnJykgOiBzb3VyY2UpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xuXG4gICAgICAvLyBGcmFtZSBjb2RlIGFzIHRoZSBmdW5jdGlvbiBib2R5LlxuICAgICAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyAodmFyaWFibGUgfHwgJ29iaicpICsgJykge1xcbicgK1xuICAgICAgICAodmFyaWFibGVcbiAgICAgICAgICA/ICcnXG4gICAgICAgICAgOiAnb2JqIHx8IChvYmogPSB7fSk7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgXCJ2YXIgX190LCBfX3AgPSAnJ1wiICtcbiAgICAgICAgKGlzRXNjYXBpbmdcbiAgICAgICAgICAgPyAnLCBfX2UgPSBfLmVzY2FwZSdcbiAgICAgICAgICAgOiAnJ1xuICAgICAgICApICtcbiAgICAgICAgKGlzRXZhbHVhdGluZ1xuICAgICAgICAgID8gJywgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XFxuJyArXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCAnJykgfVxcblwiXG4gICAgICAgICAgOiAnO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIHNvdXJjZSArXG4gICAgICAgICdyZXR1cm4gX19wXFxufSc7XG5cbiAgICAgIHZhciByZXN1bHQgPSBhdHRlbXB0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb24oaW1wb3J0c0tleXMsIHNvdXJjZVVSTCArICdyZXR1cm4gJyArIHNvdXJjZSkuYXBwbHkodW5kZWZpbmVkLCBpbXBvcnRzVmFsdWVzKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbidzIHNvdXJjZSBieSBpdHMgYHRvU3RyaW5nYCBtZXRob2Qgb3JcbiAgICAgIC8vIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBhcyBhIGNvbnZlbmllbmNlIGZvciBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMuXG4gICAgICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICAgICAgaWYgKGlzRXJyb3IocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW0oJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy50cmltKCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy5tYXAoWycgIGZvbyAgJywgJyAgYmFyICAnXSwgXy50cmltKTtcbiAgICAgKiAvLyA9PiBbJ2ZvbycsICdiYXInXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW0oc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHN0cmluZztcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBjaGFycywgZ3VhcmQpIDogY2hhcnMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKHRyaW1tZWRMZWZ0SW5kZXgoc3RyaW5nKSwgdHJpbW1lZFJpZ2h0SW5kZXgoc3RyaW5nKSArIDEpO1xuICAgICAgfVxuICAgICAgY2hhcnMgPSAoY2hhcnMgKyAnJyk7XG4gICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKGNoYXJzTGVmdEluZGV4KHN0cmluZywgY2hhcnMpLCBjaGFyc1JpZ2h0SW5kZXgoc3RyaW5nLCBjaGFycykgKyAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1MZWZ0KCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJ2FiYyAgJ1xuICAgICAqXG4gICAgICogXy50cmltTGVmdCgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiYy1fLSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltTGVmdChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgdmFyIHZhbHVlID0gc3RyaW5nO1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoIXN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGNoYXJzLCBndWFyZCkgOiBjaGFycyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UodHJpbW1lZExlZnRJbmRleChzdHJpbmcpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UoY2hhcnNMZWZ0SW5kZXgoc3RyaW5nLCAoY2hhcnMgKyAnJykpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltUmlnaHQoJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnICBhYmMnXG4gICAgICpcbiAgICAgKiBfLnRyaW1SaWdodCgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJy1fLWFiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltUmlnaHQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHN0cmluZztcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBjaGFycywgZ3VhcmQpIDogY2hhcnMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIHRyaW1tZWRSaWdodEluZGV4KHN0cmluZykgKyAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgY2hhcnNSaWdodEluZGV4KHN0cmluZywgKGNoYXJzICsgJycpKSArIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydW5jYXRlcyBgc3RyaW5nYCBpZiBpdCdzIGxvbmdlciB0aGFuIHRoZSBnaXZlbiBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogVGhlIGxhc3QgY2hhcmFjdGVycyBvZiB0aGUgdHJ1bmNhdGVkIHN0cmluZyBhcmUgcmVwbGFjZWQgd2l0aCB0aGUgb21pc3Npb25cbiAgICAgKiBzdHJpbmcgd2hpY2ggZGVmYXVsdHMgdG8gXCIuLi5cIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cnVuY2F0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxudW1iZXJ9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3Qgb3IgbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sZW5ndGg9MzBdIFRoZSBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm9taXNzaW9uPScuLi4nXSBUaGUgc3RyaW5nIHRvIGluZGljYXRlIHRleHQgaXMgb21pdHRlZC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtvcHRpb25zLnNlcGFyYXRvcl0gVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHRydW5jYXRlIHRvLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRydW5jYXRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJ1bmMoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nKTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuYygnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIDI0KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuYygnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdsZW5ndGgnOiAyNCxcbiAgICAgKiAgICdzZXBhcmF0b3InOiAnICdcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLC4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmMoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnbGVuZ3RoJzogMjQsXG4gICAgICogICAnc2VwYXJhdG9yJzogLyw/ICsvXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZS4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmMoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnb21pc3Npb24nOiAnIFsuLi5dJ1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWcgWy4uLl0nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ1bmMoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gREVGQVVMVF9UUlVOQ19MRU5HVEgsXG4gICAgICAgICAgb21pc3Npb24gPSBERUZBVUxUX1RSVU5DX09NSVNTSU9OO1xuXG4gICAgICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICAgIHZhciBzZXBhcmF0b3IgPSAnc2VwYXJhdG9yJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zZXBhcmF0b3IgOiBzZXBhcmF0b3I7XG4gICAgICAgICAgbGVuZ3RoID0gJ2xlbmd0aCcgaW4gb3B0aW9ucyA/ICgrb3B0aW9ucy5sZW5ndGggfHwgMCkgOiBsZW5ndGg7XG4gICAgICAgICAgb21pc3Npb24gPSAnb21pc3Npb24nIGluIG9wdGlvbnMgPyBiYXNlVG9TdHJpbmcob3B0aW9ucy5vbWlzc2lvbikgOiBvbWlzc2lvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZW5ndGggPSArb3B0aW9ucyB8fCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChsZW5ndGggPj0gc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIGVuZCA9IGxlbmd0aCAtIG9taXNzaW9uLmxlbmd0aDtcbiAgICAgIGlmIChlbmQgPCAxKSB7XG4gICAgICAgIHJldHVybiBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzdHJpbmcuc2xpY2UoMCwgZW5kKTtcbiAgICAgIGlmIChzZXBhcmF0b3IgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG4gICAgICB9XG4gICAgICBpZiAoaXNSZWdFeHAoc2VwYXJhdG9yKSkge1xuICAgICAgICBpZiAoc3RyaW5nLnNsaWNlKGVuZCkuc2VhcmNoKHNlcGFyYXRvcikpIHtcbiAgICAgICAgICB2YXIgbWF0Y2gsXG4gICAgICAgICAgICAgIG5ld0VuZCxcbiAgICAgICAgICAgICAgc3Vic3RyaW5nID0gc3RyaW5nLnNsaWNlKDAsIGVuZCk7XG5cbiAgICAgICAgICBpZiAoIXNlcGFyYXRvci5nbG9iYWwpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCAocmVGbGFncy5leGVjKHNlcGFyYXRvcikgfHwgJycpICsgJ2cnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN1YnN0cmluZykpKSB7XG4gICAgICAgICAgICBuZXdFbmQgPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIG5ld0VuZCA9PSBudWxsID8gZW5kIDogbmV3RW5kKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdHJpbmcuaW5kZXhPZihzZXBhcmF0b3IsIGVuZCkgIT0gZW5kKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHJlc3VsdC5sYXN0SW5kZXhPZihzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQgKyBvbWlzc2lvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy5lc2NhcGVgOyB0aGlzIG1ldGhvZCBjb252ZXJ0cyB0aGUgSFRNTCBlbnRpdGllc1xuICAgICAqIGAmYW1wO2AsIGAmbHQ7YCwgYCZndDtgLCBgJnF1b3Q7YCwgYCYjMzk7YCwgYW5kIGAmIzk2O2AgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICAgKiBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm8gb3RoZXIgSFRNTCBlbnRpdGllcyBhcmUgdW5lc2NhcGVkLiBUbyB1bmVzY2FwZSBhZGRpdGlvbmFsIEhUTUxcbiAgICAgKiBlbnRpdGllcyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdW5lc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc0VzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZUVzY2FwZWRIdG1sLCB1bmVzY2FwZUh0bWxDaGFyKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtwYXR0ZXJuXSBUaGUgcGF0dGVybiB0byBtYXRjaCB3b3Jkcy5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycsIC9bXiwgXSsvZyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICcmJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdvcmRzKHN0cmluZywgcGF0dGVybiwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIHBhdHRlcm4sIGd1YXJkKSkge1xuICAgICAgICBwYXR0ZXJuID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHBhdHRlcm4gfHwgcmVXb3JkcykgfHwgW107XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gaW52b2tlIGBmdW5jYCwgcmV0dXJuaW5nIGVpdGhlciB0aGUgcmVzdWx0IG9yIHRoZSBjYXVnaHQgZXJyb3JcbiAgICAgKiBvYmplY3QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQgaXMgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXR0ZW1wdC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYGZ1bmNgIHJlc3VsdCBvciBlcnJvciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIGF2b2lkIHRocm93aW5nIGVycm9ycyBmb3IgaW52YWxpZCBzZWxlY3RvcnNcbiAgICAgKiB2YXIgZWxlbWVudHMgPSBfLmF0dGVtcHQoZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgKiAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgKiB9LCAnPl8+Jyk7XG4gICAgICpcbiAgICAgKiBpZiAoXy5pc0Vycm9yKGVsZW1lbnRzKSkge1xuICAgICAqICAgZWxlbWVudHMgPSBbXTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgdmFyIGF0dGVtcHQgPSByZXN0UGFyYW0oZnVuY3Rpb24oZnVuYywgYXJncykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gaXNFcnJvcihlKSA/IGUgOiBuZXcgRXJyb3IoZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLiBJZiBgZnVuY2AgaXMgYSBwcm9wZXJ0eSBuYW1lIHRoZVxuICAgICAqIGNyZWF0ZWQgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgZm9yIGEgZ2l2ZW4gZWxlbWVudC4gSWYgYGZ1bmNgXG4gICAgICogaXMgYW4gb2JqZWN0IHRoZSBjcmVhdGVkIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGNvbnRhaW5cbiAgICAgKiB0aGUgZXF1aXZhbGVudCBvYmplY3QgcHJvcGVydGllcywgb3RoZXJ3aXNlIGl0IHJldHVybnMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBpdGVyYXRlZVxuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjYWxsYmFjay5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gd3JhcCB0byBjcmVhdGUgY3VzdG9tIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgKiBfLmNhbGxiYWNrID0gXy53cmFwKF8uY2FsbGJhY2ssIGZ1bmN0aW9uKGNhbGxiYWNrLCBmdW5jLCB0aGlzQXJnKSB7XG4gICAgICogICB2YXIgbWF0Y2ggPSAvXiguKz8pX18oW2dsXXQpKC4rKSQvLmV4ZWMoZnVuYyk7XG4gICAgICogICBpZiAoIW1hdGNoKSB7XG4gICAgICogICAgIHJldHVybiBjYWxsYmFjayhmdW5jLCB0aGlzQXJnKTtcbiAgICAgKiAgIH1cbiAgICAgKiAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgKiAgICAgcmV0dXJuIG1hdGNoWzJdID09ICdndCdcbiAgICAgKiAgICAgICA/IG9iamVjdFttYXRjaFsxXV0gPiBtYXRjaFszXVxuICAgICAqICAgICAgIDogb2JqZWN0W21hdGNoWzFdXSA8IG1hdGNoWzNdO1xuICAgICAqICAgfTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCAnYWdlX19ndDM2Jyk7XG4gICAgICogLy8gPT4gW3sgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoZnVuYywgdGhpc0FyZywgZ3VhcmQpKSB7XG4gICAgICAgIHRoaXNBcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKGZ1bmMpXG4gICAgICAgID8gbWF0Y2hlcyhmdW5jKVxuICAgICAgICA6IGJhc2VDYWxsYmFjayhmdW5jLCB0aGlzQXJnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICogdmFyIGdldHRlciA9IF8uY29uc3RhbnQob2JqZWN0KTtcbiAgICAgKlxuICAgICAqIGdldHRlcigpID09PSBvYmplY3Q7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgcHJvdmlkZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiBfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGEgZ2l2ZW4gb2JqZWN0XG4gICAgICogYW5kIGBzb3VyY2VgLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZSBnaXZlbiBvYmplY3QgaGFzIGVxdWl2YWxlbnQgcHJvcGVydHlcbiAgICAgKiB2YWx1ZXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBib29sZWFucywgYERhdGVgIG9iamVjdHMsXG4gICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgYW5kIHN0cmluZ3MuIE9iamVjdHMgYXJlIGNvbXBhcmVkIGJ5XG4gICAgICogdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZvciBjb21wYXJpbmcgYSBzaW5nbGVcbiAgICAgKiBvd24gb3IgaW5oZXJpdGVkIHByb3BlcnR5IHZhbHVlIHNlZSBgXy5tYXRjaGVzUHJvcGVydHlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5tYXRjaGVzKHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSkpO1xuICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXMoc291cmNlKSB7XG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXMoYmFzZUNsb25lKHNvdXJjZSwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNvbXBhcmVzIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiBgcGF0aGAgb24gYSBnaXZlblxuICAgICAqIG9iamVjdCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGJvb2xlYW5zLCBgRGF0ZWAgb2JqZWN0cyxcbiAgICAgKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBhbmQgc3RyaW5ncy4gT2JqZWN0cyBhcmUgY29tcGFyZWQgYnlcbiAgICAgKiB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKHVzZXJzLCBfLm1hdGNoZXNQcm9wZXJ0eSgndXNlcicsICdmcmVkJykpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgYmFzZUNsb25lKHNyY1ZhbHVlLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvbiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogeyAnYyc6IF8uY29uc3RhbnQoMikgfSB9IH0sXG4gICAgICogICB7ICdhJzogeyAnYic6IHsgJ2MnOiBfLmNvbnN0YW50KDEpIH0gfSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ubWV0aG9kKCdhLmIuYycpKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKlxuICAgICAqIF8uaW52b2tlKF8uc29ydEJ5KG9iamVjdHMsIF8ubWV0aG9kKFsnYScsICdiJywgJ2MnXSkpLCAnYS5iLmMnKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICB2YXIgbWV0aG9kID0gcmVzdFBhcmFtKGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGludm9rZVBhdGgob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWV0aG9kYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIHRoZSBtZXRob2QgYXQgYSBnaXZlbiBwYXRoIG9uIGBvYmplY3RgLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlXG4gICAgICogcHJvdmlkZWQgdG8gdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBfLnRpbWVzKDMsIF8uY29uc3RhbnQpLFxuICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnYVsyXScsICdjWzBdJ10sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICpcbiAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICovXG4gICAgdmFyIG1ldGhvZE9mID0gcmVzdFBhcmFtKGZ1bmN0aW9uKG9iamVjdCwgYXJncykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGludm9rZVBhdGgob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFsbCBvd24gZW51bWVyYWJsZSBmdW5jdGlvbiBwcm9wZXJ0aWVzIG9mIGEgc291cmNlIG9iamVjdCB0byB0aGVcbiAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuIElmIGBvYmplY3RgIGlzIGEgZnVuY3Rpb24gdGhlbiBtZXRob2RzIGFyZSBhZGRlZCB0b1xuICAgICAqIGl0cyBwcm90b3R5cGUgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVc2UgYF8ucnVuSW5Db250ZXh0YCB0byBjcmVhdGUgYSBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB0b1xuICAgICAqIGF2b2lkIGNvbmZsaWN0cyBjYXVzZWQgYnkgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IFtvYmplY3Q9bG9kYXNoXSBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBmdW5jdGlvbnMgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hhaW49dHJ1ZV0gU3BlY2lmeSB3aGV0aGVyIHRoZSBmdW5jdGlvbnMgYWRkZWRcbiAgICAgKiAgYXJlIGNoYWluYWJsZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiB2b3dlbHMoc3RyaW5nKSB7XG4gICAgICogICByZXR1cm4gXy5maWx0ZXIoc3RyaW5nLCBmdW5jdGlvbih2KSB7XG4gICAgICogICAgIHJldHVybiAvW2FlaW91XS9pLnRlc3Qodik7XG4gICAgICogICB9KTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9KTtcbiAgICAgKiBfLnZvd2VscygnZnJlZCcpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICd2b3dlbHMnOiB2b3dlbHMgfSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhpbihvYmplY3QsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICB2YXIgaXNPYmogPSBpc09iamVjdChzb3VyY2UpLFxuICAgICAgICAgICAgcHJvcHMgPSBpc09iaiA/IGtleXMoc291cmNlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1ldGhvZE5hbWVzID0gKHByb3BzICYmIHByb3BzLmxlbmd0aCkgPyBiYXNlRnVuY3Rpb25zKHNvdXJjZSwgcHJvcHMpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmICghKG1ldGhvZE5hbWVzID8gbWV0aG9kTmFtZXMubGVuZ3RoIDogaXNPYmopKSB7XG4gICAgICAgICAgbWV0aG9kTmFtZXMgPSBmYWxzZTtcbiAgICAgICAgICBvcHRpb25zID0gc291cmNlO1xuICAgICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgICBvYmplY3QgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW1ldGhvZE5hbWVzKSB7XG4gICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIGtleXMoc291cmNlKSk7XG4gICAgICB9XG4gICAgICB2YXIgY2hhaW4gPSB0cnVlLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNGdW5jID0gaXNGdW5jdGlvbihvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IG1ldGhvZE5hbWVzLmxlbmd0aDtcblxuICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGNoYWluID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpICYmICdjaGFpbicgaW4gb3B0aW9ucykge1xuICAgICAgICBjaGFpbiA9IG9wdGlvbnMuY2hhaW47XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IG1ldGhvZE5hbWVzW2luZGV4XSxcbiAgICAgICAgICAgIGZ1bmMgPSBzb3VyY2VbbWV0aG9kTmFtZV07XG5cbiAgICAgICAgb2JqZWN0W21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgICAgaWYgKGlzRnVuYykge1xuICAgICAgICAgIG9iamVjdC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSAoZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXztcbiAgICAgICAgICAgICAgaWYgKGNoYWluIHx8IGNoYWluQWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCh0aGlzLl9fd3JhcHBlZF9fKSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9ucyA9IHJlc3VsdC5fX2FjdGlvbnNfXyA9IGFycmF5Q29weSh0aGlzLl9fYWN0aW9uc19fKTtcblxuICAgICAgICAgICAgICAgIGFjdGlvbnMucHVzaCh7ICdmdW5jJzogZnVuYywgJ2FyZ3MnOiBhcmd1bWVudHMsICd0aGlzQXJnJzogb2JqZWN0IH0pO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5fX2NoYWluX18gPSBjaGFpbkFsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG9iamVjdCwgYXJyYXlQdXNoKFt0aGlzLnZhbHVlKCldLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfShmdW5jKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJ0cyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0b1xuICAgICAqIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGxvZGFzaCA9IF8ubm9Db25mbGljdCgpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG4gICAgICByb290Ll8gPSBvbGREYXNoO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBuby1vcGVyYXRpb24gZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB1bmRlZmluZWRgIHJlZ2FyZGxlc3Mgb2YgdGhlXG4gICAgICogYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKlxuICAgICAqIF8ubm9vcChvYmplY3QpID09PSB1bmRlZmluZWQ7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIGF0IGBwYXRoYCBvbiBhXG4gICAgICogZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogeyAnYyc6IDIgfSB9IH0sXG4gICAgICogICB7ICdhJzogeyAnYic6IHsgJ2MnOiAxIH0gfSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYi5jJykpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqXG4gICAgICogXy5wbHVjayhfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJywgJ2MnXSkpLCAnYS5iLmMnKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gICAgICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkocGF0aCkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5wcm9wZXJ0eWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnNcbiAgICAgKiB0aGUgcHJvcGVydHkgdmFsdWUgYXQgYSBnaXZlbiBwYXRoIG9uIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFswLCAxLCAyXSxcbiAgICAgKiAgICAgb2JqZWN0ID0geyAnYSc6IGFycmF5LCAnYic6IGFycmF5LCAnYyc6IGFycmF5IH07XG4gICAgICpcbiAgICAgKiBfLm1hcChbJ2FbMl0nLCAnY1swXSddLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICpcbiAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eU9mKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCB0b1BhdGgocGF0aCksIHBhdGggKyAnJyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gICAgICogYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBJZiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkIGl0IGlzXG4gICAgICogc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC4gSWYgYGVuZGAgaXMgbGVzcyB0aGFuIGBzdGFydGBcbiAgICAgKiBhIHplcm8tbGVuZ3RoIHJhbmdlIGlzIGNyZWF0ZWQgdW5sZXNzIGEgbmVnYXRpdmUgYHN0ZXBgIGlzIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIG51bWJlcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoNCk7XG4gICAgICogLy8gPT4gWzAsIDEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzAsIDUsIDEwLCAxNV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgICAgaWYgKHN0ZXAgJiYgaXNJdGVyYXRlZUNhbGwoc3RhcnQsIGVuZCwgc3RlcCkpIHtcbiAgICAgICAgZW5kID0gc3RlcCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gK3N0YXJ0IHx8IDA7XG4gICAgICBzdGVwID0gc3RlcCA9PSBudWxsID8gMSA6ICgrc3RlcCB8fCAwKTtcblxuICAgICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSArZW5kIHx8IDA7XG4gICAgICB9XG4gICAgICAvLyBVc2UgYEFycmF5KGxlbmd0aClgIHNvIGVuZ2luZXMgbGlrZSBDaGFrcmEgYW5kIFY4IGF2b2lkIHNsb3dlciBtb2Rlcy5cbiAgICAgIC8vIFNlZSBodHRwczovL3lvdXR1LmJlL1hBcUlwR1U4WlprI3Q9MTdtMjVzIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgobmF0aXZlQ2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIGl0ZXJhdGVlIGZ1bmN0aW9uIGBuYCB0aW1lcywgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzXG4gICAgICogb2YgZWFjaCBpbnZvY2F0aW9uLiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aFxuICAgICAqIG9uZSBhcmd1bWVudDsgKGluZGV4KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBkaWNlUm9sbHMgPSBfLnRpbWVzKDMsIF8ucGFydGlhbChfLnJhbmRvbSwgMSwgNiwgZmFsc2UpKTtcbiAgICAgKiAvLyA9PiBbMywgNiwgNF1cbiAgICAgKlxuICAgICAqIF8udGltZXMoMywgZnVuY3Rpb24obikge1xuICAgICAqICAgbWFnZS5jYXN0U3BlbGwobik7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gaW52b2tlcyBgbWFnZS5jYXN0U3BlbGwobilgIHRocmVlIHRpbWVzIHdpdGggYG5gIG9mIGAwYCwgYDFgLCBhbmQgYDJgXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHRoaXMuY2FzdChuKTtcbiAgICAgKiB9LCBtYWdlKTtcbiAgICAgKiAvLyA9PiBhbHNvIGludm9rZXMgYG1hZ2UuY2FzdFNwZWxsKG4pYCB0aHJlZSB0aW1lc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRpbWVzKG4sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICBuID0gbmF0aXZlRmxvb3Iobik7XG5cbiAgICAgIC8vIEV4aXQgZWFybHkgdG8gYXZvaWQgYSBKU0MgSklUIGJ1ZyBpbiBTYWZhcmkgOFxuICAgICAgLy8gd2hlcmUgYEFycmF5KDApYCBpcyB0cmVhdGVkIGFzIGBBcnJheSgxKWAuXG4gICAgICBpZiAobiA8IDEgfHwgIW5hdGl2ZUlzRmluaXRlKG4pKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KG5hdGl2ZU1pbihuLCBNQVhfQVJSQVlfTEVOR1RIKSk7XG5cbiAgICAgIGl0ZXJhdGVlID0gYmluZENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAxKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgICBpZiAoaW5kZXggPCBNQVhfQVJSQVlfTEVOR1RIKSB7XG4gICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVyYXRlZShpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBwcm92aWRlZCB0aGUgSUQgaXMgYXBwZW5kZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4XSBUaGUgdmFsdWUgdG8gcHJlZml4IHRoZSBJRCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuaXF1ZSBJRC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgnY29udGFjdF8nKTtcbiAgICAgKiAvLyA9PiAnY29udGFjdF8xMDQnXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCk7XG4gICAgICogLy8gPT4gJzEwNSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgICAgIHZhciBpZCA9ICsraWRDb3VudGVyO1xuICAgICAgcmV0dXJuIGJhc2VUb1N0cmluZyhwcmVmaXgpICsgaWQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGF1Z2VuZCBUaGUgZmlyc3QgbnVtYmVyIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYWRkZW5kIFRoZSBzZWNvbmQgbnVtYmVyIHRvIGFkZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYWRkKDYsIDQpO1xuICAgICAqIC8vID0+IDEwXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkKGF1Z2VuZCwgYWRkZW5kKSB7XG4gICAgICByZXR1cm4gKCthdWdlbmQgfHwgMCkgKyAoK2FkZGVuZCB8fCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGBuYCByb3VuZGVkIHVwIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIHRvIHJvdW5kIHVwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgdXAgdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCB1cCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2VpbCg0LjAwNik7XG4gICAgICogLy8gPT4gNVxuICAgICAqXG4gICAgICogXy5jZWlsKDYuMDA0LCAyKTtcbiAgICAgKiAvLyA9PiA2LjAxXG4gICAgICpcbiAgICAgKiBfLmNlaWwoNjA0MCwgLTIpO1xuICAgICAqIC8vID0+IDYxMDBcbiAgICAgKi9cbiAgICB2YXIgY2VpbCA9IGNyZWF0ZVJvdW5kKCdjZWlsJyk7XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGBuYCByb3VuZGVkIGRvd24gdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgdG8gcm91bmQgZG93bi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIGRvd24gdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCBkb3duIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbG9vcig0LjAwNik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5mbG9vcigwLjA0NiwgMik7XG4gICAgICogLy8gPT4gMC4wNFxuICAgICAqXG4gICAgICogXy5mbG9vcig0MDYwLCAtMik7XG4gICAgICogLy8gPT4gNDAwMFxuICAgICAqL1xuICAgIHZhciBmbG9vciA9IGNyZWF0ZVJvdW5kKCdmbG9vcicpO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBgY29sbGVjdGlvbmAuIElmIGBjb2xsZWN0aW9uYCBpcyBlbXB0eSBvciBmYWxzZXlcbiAgICAgKiBgLUluZmluaXR5YCBpcyByZXR1cm5lZC4gSWYgYW4gaXRlcmF0ZWUgZnVuY3Rpb24gaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZFxuICAgICAqIGZvciBlYWNoIHZhbHVlIGluIGBjb2xsZWN0aW9uYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoIHRoZSB2YWx1ZVxuICAgICAqIGlzIHJhbmtlZC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1heChbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWF4KFtdKTtcbiAgICAgKiAvLyA9PiAtSW5maW5pdHlcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWF4KHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWF4KHVzZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1cbiAgICAgKi9cbiAgICB2YXIgbWF4ID0gY3JlYXRlRXh0cmVtdW0oZ3QsIE5FR0FUSVZFX0lORklOSVRZKTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1pbmltdW0gdmFsdWUgb2YgYGNvbGxlY3Rpb25gLiBJZiBgY29sbGVjdGlvbmAgaXMgZW1wdHkgb3IgZmFsc2V5XG4gICAgICogYEluZmluaXR5YCBpcyByZXR1cm5lZC4gSWYgYW4gaXRlcmF0ZWUgZnVuY3Rpb24gaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZFxuICAgICAqIGZvciBlYWNoIHZhbHVlIGluIGBjb2xsZWN0aW9uYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoIHRoZSB2YWx1ZVxuICAgICAqIGlzIHJhbmtlZC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1pbihbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8ubWluKFtdKTtcbiAgICAgKiAvLyA9PiBJbmZpbml0eVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5taW4odXNlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2U7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1pbih1c2VycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKi9cbiAgICB2YXIgbWluID0gY3JlYXRlRXh0cmVtdW0obHQsIFBPU0lUSVZFX0lORklOSVRZKTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgYG5gIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgdG8gcm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yb3VuZCg0LjAwNik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5yb3VuZCg0LjAwNiwgMik7XG4gICAgICogLy8gPT4gNC4wMVxuICAgICAqXG4gICAgICogXy5yb3VuZCg0MDYwLCAtMik7XG4gICAgICogLy8gPT4gNDEwMFxuICAgICAqL1xuICAgIHZhciByb3VuZCA9IGNyZWF0ZVJvdW5kKCdyb3VuZCcpO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3VtIG9mIHRoZSB2YWx1ZXMgaW4gYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdW0oWzQsIDZdKTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqXG4gICAgICogXy5zdW0oeyAnYSc6IDQsICdiJzogNiB9KTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICduJzogNCB9LFxuICAgICAqICAgeyAnbic6IDYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnN1bShvYmplY3RzLCBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgKiAgIHJldHVybiBvYmplY3QubjtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnN1bShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IDEwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VtKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICBpZiAodGhpc0FyZyAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpdGVyYXRlZSA9IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcbiAgICAgIHJldHVybiBpdGVyYXRlZS5sZW5ndGggPT0gMVxuICAgICAgICA/IGFycmF5U3VtKGlzQXJyYXkoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uIDogdG9JdGVyYWJsZShjb2xsZWN0aW9uKSwgaXRlcmF0ZWUpXG4gICAgICAgIDogYmFzZVN1bShjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gRW5zdXJlIHdyYXBwZXJzIGFyZSBpbnN0YW5jZXMgb2YgYGJhc2VMb2Rhc2hgLlxuICAgIGxvZGFzaC5wcm90b3R5cGUgPSBiYXNlTG9kYXNoLnByb3RvdHlwZTtcblxuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG4gICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2Rhc2hXcmFwcGVyO1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF6eVdyYXBwZXI7XG5cbiAgICAvLyBBZGQgZnVuY3Rpb25zIHRvIHRoZSBgTWFwYCBjYWNoZS5cbiAgICBNYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwRGVsZXRlO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBHZXQ7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcEhhcztcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwU2V0O1xuXG4gICAgLy8gQWRkIGZ1bmN0aW9ucyB0byB0aGUgYFNldGAgY2FjaGUuXG4gICAgU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBjYWNoZVB1c2g7XG5cbiAgICAvLyBBc3NpZ24gY2FjaGUgdG8gYF8ubWVtb2l6ZWAuXG4gICAgbWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG4gICAgLy8gQWRkIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB3cmFwcGVkIHZhbHVlcyB3aGVuIGNoYWluaW5nLlxuICAgIGxvZGFzaC5hZnRlciA9IGFmdGVyO1xuICAgIGxvZGFzaC5hcnkgPSBhcnk7XG4gICAgbG9kYXNoLmFzc2lnbiA9IGFzc2lnbjtcbiAgICBsb2Rhc2guYXQgPSBhdDtcbiAgICBsb2Rhc2guYmVmb3JlID0gYmVmb3JlO1xuICAgIGxvZGFzaC5iaW5kID0gYmluZDtcbiAgICBsb2Rhc2guYmluZEFsbCA9IGJpbmRBbGw7XG4gICAgbG9kYXNoLmJpbmRLZXkgPSBiaW5kS2V5O1xuICAgIGxvZGFzaC5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGxvZGFzaC5jaGFpbiA9IGNoYWluO1xuICAgIGxvZGFzaC5jaHVuayA9IGNodW5rO1xuICAgIGxvZGFzaC5jb21wYWN0ID0gY29tcGFjdDtcbiAgICBsb2Rhc2guY29uc3RhbnQgPSBjb25zdGFudDtcbiAgICBsb2Rhc2guY291bnRCeSA9IGNvdW50Qnk7XG4gICAgbG9kYXNoLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBsb2Rhc2guY3VycnkgPSBjdXJyeTtcbiAgICBsb2Rhc2guY3VycnlSaWdodCA9IGN1cnJ5UmlnaHQ7XG4gICAgbG9kYXNoLmRlYm91bmNlID0gZGVib3VuY2U7XG4gICAgbG9kYXNoLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgbG9kYXNoLmRlZmF1bHRzRGVlcCA9IGRlZmF1bHRzRGVlcDtcbiAgICBsb2Rhc2guZGVmZXIgPSBkZWZlcjtcbiAgICBsb2Rhc2guZGVsYXkgPSBkZWxheTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2U7XG4gICAgbG9kYXNoLmRyb3AgPSBkcm9wO1xuICAgIGxvZGFzaC5kcm9wUmlnaHQgPSBkcm9wUmlnaHQ7XG4gICAgbG9kYXNoLmRyb3BSaWdodFdoaWxlID0gZHJvcFJpZ2h0V2hpbGU7XG4gICAgbG9kYXNoLmRyb3BXaGlsZSA9IGRyb3BXaGlsZTtcbiAgICBsb2Rhc2guZmlsbCA9IGZpbGw7XG4gICAgbG9kYXNoLmZpbHRlciA9IGZpbHRlcjtcbiAgICBsb2Rhc2guZmxhdHRlbiA9IGZsYXR0ZW47XG4gICAgbG9kYXNoLmZsYXR0ZW5EZWVwID0gZmxhdHRlbkRlZXA7XG4gICAgbG9kYXNoLmZsb3cgPSBmbG93O1xuICAgIGxvZGFzaC5mbG93UmlnaHQgPSBmbG93UmlnaHQ7XG4gICAgbG9kYXNoLmZvckVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5mb3JFYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZvckluID0gZm9ySW47XG4gICAgbG9kYXNoLmZvckluUmlnaHQgPSBmb3JJblJpZ2h0O1xuICAgIGxvZGFzaC5mb3JPd24gPSBmb3JPd247XG4gICAgbG9kYXNoLmZvck93blJpZ2h0ID0gZm9yT3duUmlnaHQ7XG4gICAgbG9kYXNoLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICBsb2Rhc2guZ3JvdXBCeSA9IGdyb3VwQnk7XG4gICAgbG9kYXNoLmluZGV4QnkgPSBpbmRleEJ5O1xuICAgIGxvZGFzaC5pbml0aWFsID0gaW5pdGlhbDtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICAgIGxvZGFzaC5pbnZlcnQgPSBpbnZlcnQ7XG4gICAgbG9kYXNoLmludm9rZSA9IGludm9rZTtcbiAgICBsb2Rhc2gua2V5cyA9IGtleXM7XG4gICAgbG9kYXNoLmtleXNJbiA9IGtleXNJbjtcbiAgICBsb2Rhc2gubWFwID0gbWFwO1xuICAgIGxvZGFzaC5tYXBLZXlzID0gbWFwS2V5cztcbiAgICBsb2Rhc2gubWFwVmFsdWVzID0gbWFwVmFsdWVzO1xuICAgIGxvZGFzaC5tYXRjaGVzID0gbWF0Y2hlcztcbiAgICBsb2Rhc2gubWF0Y2hlc1Byb3BlcnR5ID0gbWF0Y2hlc1Byb3BlcnR5O1xuICAgIGxvZGFzaC5tZW1vaXplID0gbWVtb2l6ZTtcbiAgICBsb2Rhc2gubWVyZ2UgPSBtZXJnZTtcbiAgICBsb2Rhc2gubWV0aG9kID0gbWV0aG9kO1xuICAgIGxvZGFzaC5tZXRob2RPZiA9IG1ldGhvZE9mO1xuICAgIGxvZGFzaC5taXhpbiA9IG1peGluO1xuICAgIGxvZGFzaC5tb2RBcmdzID0gbW9kQXJncztcbiAgICBsb2Rhc2gubmVnYXRlID0gbmVnYXRlO1xuICAgIGxvZGFzaC5vbWl0ID0gb21pdDtcbiAgICBsb2Rhc2gub25jZSA9IG9uY2U7XG4gICAgbG9kYXNoLnBhaXJzID0gcGFpcnM7XG4gICAgbG9kYXNoLnBhcnRpYWwgPSBwYXJ0aWFsO1xuICAgIGxvZGFzaC5wYXJ0aWFsUmlnaHQgPSBwYXJ0aWFsUmlnaHQ7XG4gICAgbG9kYXNoLnBhcnRpdGlvbiA9IHBhcnRpdGlvbjtcbiAgICBsb2Rhc2gucGljayA9IHBpY2s7XG4gICAgbG9kYXNoLnBsdWNrID0gcGx1Y2s7XG4gICAgbG9kYXNoLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgbG9kYXNoLnByb3BlcnR5T2YgPSBwcm9wZXJ0eU9mO1xuICAgIGxvZGFzaC5wdWxsID0gcHVsbDtcbiAgICBsb2Rhc2gucHVsbEF0ID0gcHVsbEF0O1xuICAgIGxvZGFzaC5yYW5nZSA9IHJhbmdlO1xuICAgIGxvZGFzaC5yZWFyZyA9IHJlYXJnO1xuICAgIGxvZGFzaC5yZWplY3QgPSByZWplY3Q7XG4gICAgbG9kYXNoLnJlbW92ZSA9IHJlbW92ZTtcbiAgICBsb2Rhc2gucmVzdCA9IHJlc3Q7XG4gICAgbG9kYXNoLnJlc3RQYXJhbSA9IHJlc3RQYXJhbTtcbiAgICBsb2Rhc2guc2V0ID0gc2V0O1xuICAgIGxvZGFzaC5zaHVmZmxlID0gc2h1ZmZsZTtcbiAgICBsb2Rhc2guc2xpY2UgPSBzbGljZTtcbiAgICBsb2Rhc2guc29ydEJ5ID0gc29ydEJ5O1xuICAgIGxvZGFzaC5zb3J0QnlBbGwgPSBzb3J0QnlBbGw7XG4gICAgbG9kYXNoLnNvcnRCeU9yZGVyID0gc29ydEJ5T3JkZXI7XG4gICAgbG9kYXNoLnNwcmVhZCA9IHNwcmVhZDtcbiAgICBsb2Rhc2gudGFrZSA9IHRha2U7XG4gICAgbG9kYXNoLnRha2VSaWdodCA9IHRha2VSaWdodDtcbiAgICBsb2Rhc2gudGFrZVJpZ2h0V2hpbGUgPSB0YWtlUmlnaHRXaGlsZTtcbiAgICBsb2Rhc2gudGFrZVdoaWxlID0gdGFrZVdoaWxlO1xuICAgIGxvZGFzaC50YXAgPSB0YXA7XG4gICAgbG9kYXNoLnRocm90dGxlID0gdGhyb3R0bGU7XG4gICAgbG9kYXNoLnRocnUgPSB0aHJ1O1xuICAgIGxvZGFzaC50aW1lcyA9IHRpbWVzO1xuICAgIGxvZGFzaC50b0FycmF5ID0gdG9BcnJheTtcbiAgICBsb2Rhc2gudG9QbGFpbk9iamVjdCA9IHRvUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBsb2Rhc2gudW5pb24gPSB1bmlvbjtcbiAgICBsb2Rhc2gudW5pcSA9IHVuaXE7XG4gICAgbG9kYXNoLnVuemlwID0gdW56aXA7XG4gICAgbG9kYXNoLnVuemlwV2l0aCA9IHVuemlwV2l0aDtcbiAgICBsb2Rhc2gudmFsdWVzID0gdmFsdWVzO1xuICAgIGxvZGFzaC52YWx1ZXNJbiA9IHZhbHVlc0luO1xuICAgIGxvZGFzaC53aGVyZSA9IHdoZXJlO1xuICAgIGxvZGFzaC53aXRob3V0ID0gd2l0aG91dDtcbiAgICBsb2Rhc2gud3JhcCA9IHdyYXA7XG4gICAgbG9kYXNoLnhvciA9IHhvcjtcbiAgICBsb2Rhc2guemlwID0gemlwO1xuICAgIGxvZGFzaC56aXBPYmplY3QgPSB6aXBPYmplY3Q7XG4gICAgbG9kYXNoLnppcFdpdGggPSB6aXBXaXRoO1xuXG4gICAgLy8gQWRkIGFsaWFzZXMuXG4gICAgbG9kYXNoLmJhY2tmbG93ID0gZmxvd1JpZ2h0O1xuICAgIGxvZGFzaC5jb2xsZWN0ID0gbWFwO1xuICAgIGxvZGFzaC5jb21wb3NlID0gZmxvd1JpZ2h0O1xuICAgIGxvZGFzaC5lYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5leHRlbmQgPSBhc3NpZ247XG4gICAgbG9kYXNoLml0ZXJhdGVlID0gY2FsbGJhY2s7XG4gICAgbG9kYXNoLm1ldGhvZHMgPSBmdW5jdGlvbnM7XG4gICAgbG9kYXNoLm9iamVjdCA9IHppcE9iamVjdDtcbiAgICBsb2Rhc2guc2VsZWN0ID0gZmlsdGVyO1xuICAgIGxvZGFzaC50YWlsID0gcmVzdDtcbiAgICBsb2Rhc2gudW5pcXVlID0gdW5pcTtcblxuICAgIC8vIEFkZCBmdW5jdGlvbnMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIG1peGluKGxvZGFzaCwgbG9kYXNoKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIEFkZCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gdW53cmFwcGVkIHZhbHVlcyB3aGVuIGNoYWluaW5nLlxuICAgIGxvZGFzaC5hZGQgPSBhZGQ7XG4gICAgbG9kYXNoLmF0dGVtcHQgPSBhdHRlbXB0O1xuICAgIGxvZGFzaC5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG4gICAgbG9kYXNoLmNhcGl0YWxpemUgPSBjYXBpdGFsaXplO1xuICAgIGxvZGFzaC5jZWlsID0gY2VpbDtcbiAgICBsb2Rhc2guY2xvbmUgPSBjbG9uZTtcbiAgICBsb2Rhc2guY2xvbmVEZWVwID0gY2xvbmVEZWVwO1xuICAgIGxvZGFzaC5kZWJ1cnIgPSBkZWJ1cnI7XG4gICAgbG9kYXNoLmVuZHNXaXRoID0gZW5kc1dpdGg7XG4gICAgbG9kYXNoLmVzY2FwZSA9IGVzY2FwZTtcbiAgICBsb2Rhc2guZXNjYXBlUmVnRXhwID0gZXNjYXBlUmVnRXhwO1xuICAgIGxvZGFzaC5ldmVyeSA9IGV2ZXJ5O1xuICAgIGxvZGFzaC5maW5kID0gZmluZDtcbiAgICBsb2Rhc2guZmluZEluZGV4ID0gZmluZEluZGV4O1xuICAgIGxvZGFzaC5maW5kS2V5ID0gZmluZEtleTtcbiAgICBsb2Rhc2guZmluZExhc3QgPSBmaW5kTGFzdDtcbiAgICBsb2Rhc2guZmluZExhc3RJbmRleCA9IGZpbmRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLmZpbmRMYXN0S2V5ID0gZmluZExhc3RLZXk7XG4gICAgbG9kYXNoLmZpbmRXaGVyZSA9IGZpbmRXaGVyZTtcbiAgICBsb2Rhc2guZmlyc3QgPSBmaXJzdDtcbiAgICBsb2Rhc2guZmxvb3IgPSBmbG9vcjtcbiAgICBsb2Rhc2guZ2V0ID0gZ2V0O1xuICAgIGxvZGFzaC5ndCA9IGd0O1xuICAgIGxvZGFzaC5ndGUgPSBndGU7XG4gICAgbG9kYXNoLmhhcyA9IGhhcztcbiAgICBsb2Rhc2guaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICBsb2Rhc2guaW5jbHVkZXMgPSBpbmNsdWRlcztcbiAgICBsb2Rhc2guaW5kZXhPZiA9IGluZGV4T2Y7XG4gICAgbG9kYXNoLmluUmFuZ2UgPSBpblJhbmdlO1xuICAgIGxvZGFzaC5pc0FyZ3VtZW50cyA9IGlzQXJndW1lbnRzO1xuICAgIGxvZGFzaC5pc0FycmF5ID0gaXNBcnJheTtcbiAgICBsb2Rhc2guaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICAgIGxvZGFzaC5pc0RhdGUgPSBpc0RhdGU7XG4gICAgbG9kYXNoLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbiAgICBsb2Rhc2guaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgbG9kYXNoLmlzRXF1YWwgPSBpc0VxdWFsO1xuICAgIGxvZGFzaC5pc0Vycm9yID0gaXNFcnJvcjtcbiAgICBsb2Rhc2guaXNGaW5pdGUgPSBpc0Zpbml0ZTtcbiAgICBsb2Rhc2guaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gICAgbG9kYXNoLmlzTWF0Y2ggPSBpc01hdGNoO1xuICAgIGxvZGFzaC5pc05hTiA9IGlzTmFOO1xuICAgIGxvZGFzaC5pc05hdGl2ZSA9IGlzTmF0aXZlO1xuICAgIGxvZGFzaC5pc051bGwgPSBpc051bGw7XG4gICAgbG9kYXNoLmlzTnVtYmVyID0gaXNOdW1iZXI7XG4gICAgbG9kYXNoLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4gICAgbG9kYXNoLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuICAgIGxvZGFzaC5pc1N0cmluZyA9IGlzU3RyaW5nO1xuICAgIGxvZGFzaC5pc1R5cGVkQXJyYXkgPSBpc1R5cGVkQXJyYXk7XG4gICAgbG9kYXNoLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG4gICAgbG9kYXNoLmtlYmFiQ2FzZSA9IGtlYmFiQ2FzZTtcbiAgICBsb2Rhc2gubGFzdCA9IGxhc3Q7XG4gICAgbG9kYXNoLmxhc3RJbmRleE9mID0gbGFzdEluZGV4T2Y7XG4gICAgbG9kYXNoLmx0ID0gbHQ7XG4gICAgbG9kYXNoLmx0ZSA9IGx0ZTtcbiAgICBsb2Rhc2gubWF4ID0gbWF4O1xuICAgIGxvZGFzaC5taW4gPSBtaW47XG4gICAgbG9kYXNoLm5vQ29uZmxpY3QgPSBub0NvbmZsaWN0O1xuICAgIGxvZGFzaC5ub29wID0gbm9vcDtcbiAgICBsb2Rhc2gubm93ID0gbm93O1xuICAgIGxvZGFzaC5wYWQgPSBwYWQ7XG4gICAgbG9kYXNoLnBhZExlZnQgPSBwYWRMZWZ0O1xuICAgIGxvZGFzaC5wYWRSaWdodCA9IHBhZFJpZ2h0O1xuICAgIGxvZGFzaC5wYXJzZUludCA9IHBhcnNlSW50O1xuICAgIGxvZGFzaC5yYW5kb20gPSByYW5kb207XG4gICAgbG9kYXNoLnJlZHVjZSA9IHJlZHVjZTtcbiAgICBsb2Rhc2gucmVkdWNlUmlnaHQgPSByZWR1Y2VSaWdodDtcbiAgICBsb2Rhc2gucmVwZWF0ID0gcmVwZWF0O1xuICAgIGxvZGFzaC5yZXN1bHQgPSByZXN1bHQ7XG4gICAgbG9kYXNoLnJvdW5kID0gcm91bmQ7XG4gICAgbG9kYXNoLnJ1bkluQ29udGV4dCA9IHJ1bkluQ29udGV4dDtcbiAgICBsb2Rhc2guc2l6ZSA9IHNpemU7XG4gICAgbG9kYXNoLnNuYWtlQ2FzZSA9IHNuYWtlQ2FzZTtcbiAgICBsb2Rhc2guc29tZSA9IHNvbWU7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4ID0gc29ydGVkSW5kZXg7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleCA9IHNvcnRlZExhc3RJbmRleDtcbiAgICBsb2Rhc2guc3RhcnRDYXNlID0gc3RhcnRDYXNlO1xuICAgIGxvZGFzaC5zdGFydHNXaXRoID0gc3RhcnRzV2l0aDtcbiAgICBsb2Rhc2guc3VtID0gc3VtO1xuICAgIGxvZGFzaC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIGxvZGFzaC50cmltID0gdHJpbTtcbiAgICBsb2Rhc2gudHJpbUxlZnQgPSB0cmltTGVmdDtcbiAgICBsb2Rhc2gudHJpbVJpZ2h0ID0gdHJpbVJpZ2h0O1xuICAgIGxvZGFzaC50cnVuYyA9IHRydW5jO1xuICAgIGxvZGFzaC51bmVzY2FwZSA9IHVuZXNjYXBlO1xuICAgIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuICAgIGxvZGFzaC53b3JkcyA9IHdvcmRzO1xuXG4gICAgLy8gQWRkIGFsaWFzZXMuXG4gICAgbG9kYXNoLmFsbCA9IGV2ZXJ5O1xuICAgIGxvZGFzaC5hbnkgPSBzb21lO1xuICAgIGxvZGFzaC5jb250YWlucyA9IGluY2x1ZGVzO1xuICAgIGxvZGFzaC5lcSA9IGlzRXF1YWw7XG4gICAgbG9kYXNoLmRldGVjdCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZvbGRsID0gcmVkdWNlO1xuICAgIGxvZGFzaC5mb2xkciA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5oZWFkID0gZmlyc3Q7XG4gICAgbG9kYXNoLmluY2x1ZGUgPSBpbmNsdWRlcztcbiAgICBsb2Rhc2guaW5qZWN0ID0gcmVkdWNlO1xuXG4gICAgbWl4aW4obG9kYXNoLCAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0ge307XG4gICAgICBiYXNlRm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAoIWxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgICBzb3VyY2VbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfSgpKSwgZmFsc2UpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gQWRkIGZ1bmN0aW9ucyBjYXBhYmxlIG9mIHJldHVybmluZyB3cmFwcGVkIGFuZCB1bndyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmcuXG4gICAgbG9kYXNoLnNhbXBsZSA9IHNhbXBsZTtcblxuICAgIGxvZGFzaC5wcm90b3R5cGUuc2FtcGxlID0gZnVuY3Rpb24obikge1xuICAgICAgaWYgKCF0aGlzLl9fY2hhaW5fXyAmJiBuID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNhbXBsZSh0aGlzLnZhbHVlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudGhydShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gc2FtcGxlKHZhbHVlLCBuKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKi9cbiAgICBsb2Rhc2guVkVSU0lPTiA9IFZFUlNJT047XG5cbiAgICAvLyBBc3NpZ24gZGVmYXVsdCBwbGFjZWhvbGRlcnMuXG4gICAgYXJyYXlFYWNoKFsnYmluZCcsICdiaW5kS2V5JywgJ2N1cnJ5JywgJ2N1cnJ5UmlnaHQnLCAncGFydGlhbCcsICdwYXJ0aWFsUmlnaHQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgbG9kYXNoW21ldGhvZE5hbWVdLnBsYWNlaG9sZGVyID0gbG9kYXNoO1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uZHJvcGAgYW5kIGBfLnRha2VgIHZhcmlhbnRzLlxuICAgIGFycmF5RWFjaChbJ2Ryb3AnLCAndGFrZSddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24obikge1xuICAgICAgICB2YXIgZmlsdGVyZWQgPSB0aGlzLl9fZmlsdGVyZWRfXztcbiAgICAgICAgaWYgKGZpbHRlcmVkICYmICFpbmRleCkge1xuICAgICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IG4gPT0gbnVsbCA/IDEgOiBuYXRpdmVNYXgobmF0aXZlRmxvb3IobikgfHwgMCwgMCk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgaWYgKGZpbHRlcmVkKSB7XG4gICAgICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSBuYXRpdmVNaW4ocmVzdWx0Ll9fdGFrZUNvdW50X18sIG4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5fX3ZpZXdzX18ucHVzaCh7ICdzaXplJzogbiwgJ3R5cGUnOiBtZXRob2ROYW1lICsgKHJlc3VsdC5fX2Rpcl9fIDwgMCA/ICdSaWdodCcgOiAnJykgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lICsgJ1JpZ2h0J10gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKVttZXRob2ROYW1lXShuKS5yZXZlcnNlKCk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0aGF0IGFjY2VwdCBhbiBgaXRlcmF0ZWVgIHZhbHVlLlxuICAgIGFycmF5RWFjaChbJ2ZpbHRlcicsICdtYXAnLCAndGFrZVdoaWxlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgdHlwZSA9IGluZGV4ICsgMSxcbiAgICAgICAgICBpc0ZpbHRlciA9IHR5cGUgIT0gTEFaWV9NQVBfRkxBRztcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18ucHVzaCh7ICdpdGVyYXRlZSc6IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAxKSwgJ3R5cGUnOiB0eXBlIH0pO1xuICAgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gcmVzdWx0Ll9fZmlsdGVyZWRfXyB8fCBpc0ZpbHRlcjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5maXJzdGAgYW5kIGBfLmxhc3RgLlxuICAgIGFycmF5RWFjaChbJ2ZpcnN0JywgJ2xhc3QnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciB0YWtlTmFtZSA9ICd0YWtlJyArIChpbmRleCA/ICdSaWdodCcgOiAnJyk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpc1t0YWtlTmFtZV0oMSkudmFsdWUoKVswXTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5pbml0aWFsYCBhbmQgYF8ucmVzdGAuXG4gICAgYXJyYXlFYWNoKFsnaW5pdGlhbCcsICdyZXN0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgZHJvcE5hbWUgPSAnZHJvcCcgKyAoaW5kZXggPyAnJyA6ICdSaWdodCcpO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19maWx0ZXJlZF9fID8gbmV3IExhenlXcmFwcGVyKHRoaXMpIDogdGhpc1tkcm9wTmFtZV0oMSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8ucGx1Y2tgIGFuZCBgXy53aGVyZWAuXG4gICAgYXJyYXlFYWNoKFsncGx1Y2snLCAnd2hlcmUnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciBvcGVyYXRpb25OYW1lID0gaW5kZXggPyAnZmlsdGVyJyA6ICdtYXAnLFxuICAgICAgICAgIGNyZWF0ZUNhbGxiYWNrID0gaW5kZXggPyBiYXNlTWF0Y2hlcyA6IHByb3BlcnR5O1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpc1tvcGVyYXRpb25OYW1lXShjcmVhdGVDYWxsYmFjayh2YWx1ZSkpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb21wYWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoaWRlbnRpdHkpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24ocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDEpO1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhcHJlZGljYXRlKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogKCtzdGFydCB8fCAwKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHRoaXM7XG4gICAgICBpZiAocmVzdWx0Ll9fZmlsdGVyZWRfXyAmJiAoc3RhcnQgPiAwIHx8IGVuZCA8IDApKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnRha2VSaWdodCgtc3RhcnQpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuZHJvcChzdGFydCk7XG4gICAgICB9XG4gICAgICBpZiAoZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gKCtlbmQgfHwgMCk7XG4gICAgICAgIHJlc3VsdCA9IGVuZCA8IDAgPyByZXN1bHQuZHJvcFJpZ2h0KC1lbmQpIDogcmVzdWx0LnRha2UoZW5kIC0gc3RhcnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRha2VSaWdodFdoaWxlID0gZnVuY3Rpb24ocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkudGFrZVdoaWxlKHByZWRpY2F0ZSwgdGhpc0FyZykucmV2ZXJzZSgpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGFrZShQT1NJVElWRV9JTkZJTklUWSk7XG4gICAgfTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgY2hlY2tJdGVyYXRlZSA9IC9eKD86ZmlsdGVyfG1hcHxyZWplY3QpfFdoaWxlJC8udGVzdChtZXRob2ROYW1lKSxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSAvXig/OmZpcnN0fGxhc3QpJC8udGVzdChtZXRob2ROYW1lKSxcbiAgICAgICAgICBsb2Rhc2hGdW5jID0gbG9kYXNoW3JldFVud3JhcHBlZCA/ICgndGFrZScgKyAobWV0aG9kTmFtZSA9PSAnbGFzdCcgPyAnUmlnaHQnIDogJycpKSA6IG1ldGhvZE5hbWVdO1xuXG4gICAgICBpZiAoIWxvZGFzaEZ1bmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IHJldFVud3JhcHBlZCA/IFsxXSA6IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgICBpc0h5YnJpZCA9ICEhdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgsXG4gICAgICAgICAgICBpc0xhenkgPSB2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyLFxuICAgICAgICAgICAgaXRlcmF0ZWUgPSBhcmdzWzBdLFxuICAgICAgICAgICAgdXNlTGF6eSA9IGlzTGF6eSB8fCBpc0FycmF5KHZhbHVlKTtcblxuICAgICAgICBpZiAodXNlTGF6eSAmJiBjaGVja0l0ZXJhdGVlICYmIHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nICYmIGl0ZXJhdGVlLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgICAgLy8gQXZvaWQgbGF6eSB1c2UgaWYgdGhlIGl0ZXJhdGVlIGhhcyBhIFwibGVuZ3RoXCIgdmFsdWUgb3RoZXIgdGhhbiBgMWAuXG4gICAgICAgICAgaXNMYXp5ID0gdXNlTGF6eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIChyZXRVbndyYXBwZWQgJiYgY2hhaW5BbGwpXG4gICAgICAgICAgICA/IGxvZGFzaEZ1bmModmFsdWUsIDEpWzBdXG4gICAgICAgICAgICA6IGxvZGFzaEZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcnJheVB1c2goW3ZhbHVlXSwgYXJncykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhY3Rpb24gPSB7ICdmdW5jJzogdGhydSwgJ2FyZ3MnOiBbaW50ZXJjZXB0b3JdLCAndGhpc0FyZyc6IHVuZGVmaW5lZCB9LFxuICAgICAgICAgICAgb25seUxhenkgPSBpc0xhenkgJiYgIWlzSHlicmlkO1xuXG4gICAgICAgIGlmIChyZXRVbndyYXBwZWQgJiYgIWNoYWluQWxsKSB7XG4gICAgICAgICAgaWYgKG9ubHlMYXp5KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmNsb25lKCk7XG4gICAgICAgICAgICB2YWx1ZS5fX2FjdGlvbnNfXy5wdXNoKGFjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxvZGFzaEZ1bmMuY2FsbCh1bmRlZmluZWQsIHRoaXMudmFsdWUoKSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXRVbndyYXBwZWQgJiYgdXNlTGF6eSkge1xuICAgICAgICAgIHZhbHVlID0gb25seUxhenkgPyB2YWx1ZSA6IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fLnB1c2goYWN0aW9uKTtcbiAgICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIocmVzdWx0LCBjaGFpbkFsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGhydShpbnRlcmNlcHRvcik7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBBcnJheWAgYW5kIGBTdHJpbmdgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIGFycmF5RWFjaChbJ2pvaW4nLCAncG9wJywgJ3B1c2gnLCAncmVwbGFjZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICdzcGxpdCcsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gKC9eKD86cmVwbGFjZXxzcGxpdCkkLy50ZXN0KG1ldGhvZE5hbWUpID8gc3RyaW5nUHJvdG8gOiBhcnJheVByb3RvKVttZXRob2ROYW1lXSxcbiAgICAgICAgICBjaGFpbk5hbWUgPSAvXig/OnB1c2h8c29ydHx1bnNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSkgPyAndGFwJyA6ICd0aHJ1JyxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSAvXig/OmpvaW58cG9wfHJlcGxhY2V8c2hpZnQpJC8udGVzdChtZXRob2ROYW1lKTtcblxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgaWYgKHJldFVud3JhcHBlZCAmJiAhdGhpcy5fX2NoYWluX18pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLnZhbHVlKCksIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2NoYWluTmFtZV0oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIE1hcCBtaW5pZmllZCBmdW5jdGlvbiBuYW1lcyB0byB0aGVpciByZWFsIG5hbWVzLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgbG9kYXNoRnVuYyA9IGxvZGFzaFttZXRob2ROYW1lXTtcbiAgICAgIGlmIChsb2Rhc2hGdW5jKSB7XG4gICAgICAgIHZhciBrZXkgPSBsb2Rhc2hGdW5jLm5hbWUsXG4gICAgICAgICAgICBuYW1lcyA9IHJlYWxOYW1lc1trZXldIHx8IChyZWFsTmFtZXNba2V5XSA9IFtdKTtcblxuICAgICAgICBuYW1lcy5wdXNoKHsgJ25hbWUnOiBtZXRob2ROYW1lLCAnZnVuYyc6IGxvZGFzaEZ1bmMgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZWFsTmFtZXNbY3JlYXRlSHlicmlkV3JhcHBlcih1bmRlZmluZWQsIEJJTkRfS0VZX0ZMQUcpLm5hbWVdID0gW3sgJ25hbWUnOiAnd3JhcHBlcicsICdmdW5jJzogdW5kZWZpbmVkIH1dO1xuXG4gICAgLy8gQWRkIGZ1bmN0aW9ucyB0byB0aGUgbGF6eSB3cmFwcGVyLlxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jbG9uZSA9IGxhenlDbG9uZTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUucmV2ZXJzZSA9IGxhenlSZXZlcnNlO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS52YWx1ZSA9IGxhenlWYWx1ZTtcblxuICAgIC8vIEFkZCBjaGFpbmluZyBmdW5jdGlvbnMgdG8gdGhlIGBsb2Rhc2hgIHdyYXBwZXIuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5jaGFpbiA9IHdyYXBwZXJDaGFpbjtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNvbW1pdCA9IHdyYXBwZXJDb21taXQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jb25jYXQgPSB3cmFwcGVyQ29uY2F0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUucGxhbnQgPSB3cmFwcGVyUGxhbnQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5yZXZlcnNlID0gd3JhcHBlclJldmVyc2U7XG4gICAgbG9kYXNoLnByb3RvdHlwZS50b1N0cmluZyA9IHdyYXBwZXJUb1N0cmluZztcbiAgICBsb2Rhc2gucHJvdG90eXBlLnJ1biA9IGxvZGFzaC5wcm90b3R5cGUudG9KU09OID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZU9mID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZSA9IHdyYXBwZXJWYWx1ZTtcblxuICAgIC8vIEFkZCBmdW5jdGlvbiBhbGlhc2VzIHRvIHRoZSBgbG9kYXNoYCB3cmFwcGVyLlxuICAgIGxvZGFzaC5wcm90b3R5cGUuY29sbGVjdCA9IGxvZGFzaC5wcm90b3R5cGUubWFwO1xuICAgIGxvZGFzaC5wcm90b3R5cGUuaGVhZCA9IGxvZGFzaC5wcm90b3R5cGUuZmlyc3Q7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5zZWxlY3QgPSBsb2Rhc2gucHJvdG90eXBlLmZpbHRlcjtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnRhaWwgPSBsb2Rhc2gucHJvdG90eXBlLnJlc3Q7XG5cbiAgICByZXR1cm4gbG9kYXNoO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gRXhwb3J0IGxvZGFzaC5cbiAgdmFyIF8gPSBydW5JbkNvbnRleHQoKTtcblxuICAvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzIGxpa2Ugci5qcyBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2UgdGhlIGZvbGxvd2luZzpcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gRXhwb3NlIGxvZGFzaCB0byB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGFuIEFNRCBsb2FkZXIgaXMgcHJlc2VudCB0byBhdm9pZFxuICAgIC8vIGVycm9ycyBpbiBjYXNlcyB3aGVyZSBsb2Rhc2ggaXMgbG9hZGVkIGJ5IGEgc2NyaXB0IHRhZyBhbmQgbm90IGludGVuZGVkXG4gICAgLy8gYXMgYW4gQU1EIG1vZHVsZS4gU2VlIGh0dHA6Ly9yZXF1aXJlanMub3JnL2RvY3MvZXJyb3JzLmh0bWwjbWlzbWF0Y2ggZm9yXG4gICAgLy8gbW9yZSBkZXRhaWxzLlxuICAgIHJvb3QuXyA9IF87XG5cbiAgICAvLyBEZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSBzbywgdGhyb3VnaCBwYXRoIG1hcHBpbmcsIGl0IGNhbiBiZVxuICAgIC8vIHJlZmVyZW5jZWQgYXMgdGhlIFwidW5kZXJzY29yZVwiIG1vZHVsZS5cbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxuICAvLyBDaGVjayBmb3IgYGV4cG9ydHNgIGFmdGVyIGBkZWZpbmVgIGluIGNhc2UgYSBidWlsZCBvcHRpbWl6ZXIgYWRkcyBhbiBgZXhwb3J0c2Agb2JqZWN0LlxuICBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG4gICAgLy8gRXhwb3J0IGZvciBOb2RlLmpzIG9yIFJpbmdvSlMuXG4gICAgaWYgKG1vZHVsZUV4cG9ydHMpIHtcbiAgICAgIChmcmVlTW9kdWxlLmV4cG9ydHMgPSBfKS5fID0gXztcbiAgICB9XG4gICAgLy8gRXhwb3J0IGZvciBSaGlubyB3aXRoIENvbW1vbkpTIHN1cHBvcnQuXG4gICAgZWxzZSB7XG4gICAgICBmcmVlRXhwb3J0cy5fID0gXztcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gRXhwb3J0IGZvciBhIGJyb3dzZXIgb3IgUmhpbm8uXG4gICAgcm9vdC5fID0gXztcbiAgfVxufS5jYWxsKHRoaXMpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYicpXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc2FwID0gcmVxdWlyZSgnYXNhcC9yYXcnKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbi8vIFN0YXRlczpcbi8vXG4vLyAwIC0gcGVuZGluZ1xuLy8gMSAtIGZ1bGZpbGxlZCB3aXRoIF92YWx1ZVxuLy8gMiAtIHJlamVjdGVkIHdpdGggX3ZhbHVlXG4vLyAzIC0gYWRvcHRlZCB0aGUgc3RhdGUgb2YgYW5vdGhlciBwcm9taXNlLCBfdmFsdWVcbi8vXG4vLyBvbmNlIHRoZSBzdGF0ZSBpcyBubyBsb25nZXIgcGVuZGluZyAoMCkgaXQgaXMgaW1tdXRhYmxlXG5cbi8vIEFsbCBgX2AgcHJlZml4ZWQgcHJvcGVydGllcyB3aWxsIGJlIHJlZHVjZWQgdG8gYF97cmFuZG9tIG51bWJlcn1gXG4vLyBhdCBidWlsZCB0aW1lIHRvIG9iZnVzY2F0ZSB0aGVtIGFuZCBkaXNjb3VyYWdlIHRoZWlyIHVzZS5cbi8vIFdlIGRvbid0IHVzZSBzeW1ib2xzIG9yIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0byBmdWxseSBoaWRlIHRoZW1cbi8vIGJlY2F1c2UgdGhlIHBlcmZvcm1hbmNlIGlzbid0IGdvb2QgZW5vdWdoLlxuXG5cbi8vIHRvIGF2b2lkIHVzaW5nIHRyeS9jYXRjaCBpbnNpZGUgY3JpdGljYWwgZnVuY3Rpb25zLCB3ZVxuLy8gZXh0cmFjdCB0aGVtIHRvIGhlcmUuXG52YXIgTEFTVF9FUlJPUiA9IG51bGw7XG52YXIgSVNfRVJST1IgPSB7fTtcbmZ1bmN0aW9uIGdldFRoZW4ob2JqKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG9iai50aGVuO1xuICB9IGNhdGNoIChleCkge1xuICAgIExBU1RfRVJST1IgPSBleDtcbiAgICByZXR1cm4gSVNfRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5Q2FsbE9uZShmbiwgYSkge1xuICB0cnkge1xuICAgIHJldHVybiBmbihhKTtcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBMQVNUX0VSUk9SID0gZXg7XG4gICAgcmV0dXJuIElTX0VSUk9SO1xuICB9XG59XG5mdW5jdGlvbiB0cnlDYWxsVHdvKGZuLCBhLCBiKSB7XG4gIHRyeSB7XG4gICAgZm4oYSwgYik7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgTEFTVF9FUlJPUiA9IGV4O1xuICAgIHJldHVybiBJU19FUlJPUjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cbmZ1bmN0aW9uIFByb21pc2UoZm4pIHtcbiAgaWYgKHR5cGVvZiB0aGlzICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuICB9XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlIGNvbnN0cnVjdG9yXFwncyBhcmd1bWVudCBpcyBub3QgYSBmdW5jdGlvbicpO1xuICB9XG4gIHRoaXMuXzQwID0gMDtcbiAgdGhpcy5fNjUgPSAwO1xuICB0aGlzLl81NSA9IG51bGw7XG4gIHRoaXMuXzcyID0gbnVsbDtcbiAgaWYgKGZuID09PSBub29wKSByZXR1cm47XG4gIGRvUmVzb2x2ZShmbiwgdGhpcyk7XG59XG5Qcm9taXNlLl8zNyA9IG51bGw7XG5Qcm9taXNlLl84NyA9IG51bGw7XG5Qcm9taXNlLl82MSA9IG5vb3A7XG5cblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICBpZiAodGhpcy5jb25zdHJ1Y3RvciAhPT0gUHJvbWlzZSkge1xuICAgIHJldHVybiBzYWZlVGhlbih0aGlzLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gIH1cbiAgdmFyIHJlcyA9IG5ldyBQcm9taXNlKG5vb3ApO1xuICBoYW5kbGUodGhpcywgbmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHJlcykpO1xuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gc2FmZVRoZW4oc2VsZiwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgcmV0dXJuIG5ldyBzZWxmLmNvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVzID0gbmV3IFByb21pc2Uobm9vcCk7XG4gICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICBoYW5kbGUoc2VsZiwgbmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHJlcykpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZShzZWxmLCBkZWZlcnJlZCkge1xuICB3aGlsZSAoc2VsZi5fNjUgPT09IDMpIHtcbiAgICBzZWxmID0gc2VsZi5fNTU7XG4gIH1cbiAgaWYgKFByb21pc2UuXzM3KSB7XG4gICAgUHJvbWlzZS5fMzcoc2VsZik7XG4gIH1cbiAgaWYgKHNlbGYuXzY1ID09PSAwKSB7XG4gICAgaWYgKHNlbGYuXzQwID09PSAwKSB7XG4gICAgICBzZWxmLl80MCA9IDE7XG4gICAgICBzZWxmLl83MiA9IGRlZmVycmVkO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2VsZi5fNDAgPT09IDEpIHtcbiAgICAgIHNlbGYuXzQwID0gMjtcbiAgICAgIHNlbGYuXzcyID0gW3NlbGYuXzcyLCBkZWZlcnJlZF07XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGYuXzcyLnB1c2goZGVmZXJyZWQpO1xuICAgIHJldHVybjtcbiAgfVxuICBoYW5kbGVSZXNvbHZlZChzZWxmLCBkZWZlcnJlZCk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVJlc29sdmVkKHNlbGYsIGRlZmVycmVkKSB7XG4gIGFzYXAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNiID0gc2VsZi5fNjUgPT09IDEgPyBkZWZlcnJlZC5vbkZ1bGZpbGxlZCA6IGRlZmVycmVkLm9uUmVqZWN0ZWQ7XG4gICAgaWYgKGNiID09PSBudWxsKSB7XG4gICAgICBpZiAoc2VsZi5fNjUgPT09IDEpIHtcbiAgICAgICAgcmVzb2x2ZShkZWZlcnJlZC5wcm9taXNlLCBzZWxmLl81NSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWplY3QoZGVmZXJyZWQucHJvbWlzZSwgc2VsZi5fNTUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmV0ID0gdHJ5Q2FsbE9uZShjYiwgc2VsZi5fNTUpO1xuICAgIGlmIChyZXQgPT09IElTX0VSUk9SKSB7XG4gICAgICByZWplY3QoZGVmZXJyZWQucHJvbWlzZSwgTEFTVF9FUlJPUik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmUoZGVmZXJyZWQucHJvbWlzZSwgcmV0KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVzb2x2ZShzZWxmLCBuZXdWYWx1ZSkge1xuICAvLyBQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlOiBodHRwczovL2dpdGh1Yi5jb20vcHJvbWlzZXMtYXBsdXMvcHJvbWlzZXMtc3BlYyN0aGUtcHJvbWlzZS1yZXNvbHV0aW9uLXByb2NlZHVyZVxuICBpZiAobmV3VmFsdWUgPT09IHNlbGYpIHtcbiAgICByZXR1cm4gcmVqZWN0KFxuICAgICAgc2VsZixcbiAgICAgIG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZSBjYW5ub3QgYmUgcmVzb2x2ZWQgd2l0aCBpdHNlbGYuJylcbiAgICApO1xuICB9XG4gIGlmIChcbiAgICBuZXdWYWx1ZSAmJlxuICAgICh0eXBlb2YgbmV3VmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ2Z1bmN0aW9uJylcbiAgKSB7XG4gICAgdmFyIHRoZW4gPSBnZXRUaGVuKG5ld1ZhbHVlKTtcbiAgICBpZiAodGhlbiA9PT0gSVNfRVJST1IpIHtcbiAgICAgIHJldHVybiByZWplY3Qoc2VsZiwgTEFTVF9FUlJPUik7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHRoZW4gPT09IHNlbGYudGhlbiAmJlxuICAgICAgbmV3VmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlXG4gICAgKSB7XG4gICAgICBzZWxmLl82NSA9IDM7XG4gICAgICBzZWxmLl81NSA9IG5ld1ZhbHVlO1xuICAgICAgZmluYWxlKHNlbGYpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRvUmVzb2x2ZSh0aGVuLmJpbmQobmV3VmFsdWUpLCBzZWxmKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgc2VsZi5fNjUgPSAxO1xuICBzZWxmLl81NSA9IG5ld1ZhbHVlO1xuICBmaW5hbGUoc2VsZik7XG59XG5cbmZ1bmN0aW9uIHJlamVjdChzZWxmLCBuZXdWYWx1ZSkge1xuICBzZWxmLl82NSA9IDI7XG4gIHNlbGYuXzU1ID0gbmV3VmFsdWU7XG4gIGlmIChQcm9taXNlLl84Nykge1xuICAgIFByb21pc2UuXzg3KHNlbGYsIG5ld1ZhbHVlKTtcbiAgfVxuICBmaW5hbGUoc2VsZik7XG59XG5mdW5jdGlvbiBmaW5hbGUoc2VsZikge1xuICBpZiAoc2VsZi5fNDAgPT09IDEpIHtcbiAgICBoYW5kbGUoc2VsZiwgc2VsZi5fNzIpO1xuICAgIHNlbGYuXzcyID0gbnVsbDtcbiAgfVxuICBpZiAoc2VsZi5fNDAgPT09IDIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuXzcyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoYW5kbGUoc2VsZiwgc2VsZi5fNzJbaV0pO1xuICAgIH1cbiAgICBzZWxmLl83MiA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcHJvbWlzZSl7XG4gIHRoaXMub25GdWxmaWxsZWQgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IG51bGw7XG4gIHRoaXMub25SZWplY3RlZCA9IHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nID8gb25SZWplY3RlZCA6IG51bGw7XG4gIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG59XG5cbi8qKlxuICogVGFrZSBhIHBvdGVudGlhbGx5IG1pc2JlaGF2aW5nIHJlc29sdmVyIGZ1bmN0aW9uIGFuZCBtYWtlIHN1cmVcbiAqIG9uRnVsZmlsbGVkIGFuZCBvblJlamVjdGVkIGFyZSBvbmx5IGNhbGxlZCBvbmNlLlxuICpcbiAqIE1ha2VzIG5vIGd1YXJhbnRlZXMgYWJvdXQgYXN5bmNocm9ueS5cbiAqL1xuZnVuY3Rpb24gZG9SZXNvbHZlKGZuLCBwcm9taXNlKSB7XG4gIHZhciBkb25lID0gZmFsc2U7XG4gIHZhciByZXMgPSB0cnlDYWxsVHdvKGZuLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgIGRvbmUgPSB0cnVlO1xuICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICBkb25lID0gdHJ1ZTtcbiAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgfSk7XG4gIGlmICghZG9uZSAmJiByZXMgPT09IElTX0VSUk9SKSB7XG4gICAgZG9uZSA9IHRydWU7XG4gICAgcmVqZWN0KHByb21pc2UsIExBU1RfRVJST1IpO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi9jb3JlLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblByb21pc2UucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgdmFyIHNlbGYgPSBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50aGVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB0aGlzO1xuICBzZWxmLnRoZW4obnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0sIDApO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBFUzYgZXh0ZW5zaW9ucyB0byB0aGUgY29yZSBQcm9taXNlcy9BKyBBUElcblxudmFyIFByb21pc2UgPSByZXF1aXJlKCcuL2NvcmUuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuXG4vKiBTdGF0aWMgRnVuY3Rpb25zICovXG5cbnZhciBUUlVFID0gdmFsdWVQcm9taXNlKHRydWUpO1xudmFyIEZBTFNFID0gdmFsdWVQcm9taXNlKGZhbHNlKTtcbnZhciBOVUxMID0gdmFsdWVQcm9taXNlKG51bGwpO1xudmFyIFVOREVGSU5FRCA9IHZhbHVlUHJvbWlzZSh1bmRlZmluZWQpO1xudmFyIFpFUk8gPSB2YWx1ZVByb21pc2UoMCk7XG52YXIgRU1QVFlTVFJJTkcgPSB2YWx1ZVByb21pc2UoJycpO1xuXG5mdW5jdGlvbiB2YWx1ZVByb21pc2UodmFsdWUpIHtcbiAgdmFyIHAgPSBuZXcgUHJvbWlzZShQcm9taXNlLl82MSk7XG4gIHAuXzY1ID0gMTtcbiAgcC5fNTUgPSB2YWx1ZTtcbiAgcmV0dXJuIHA7XG59XG5Qcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIHZhbHVlO1xuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIE5VTEw7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gVU5ERUZJTkVEO1xuICBpZiAodmFsdWUgPT09IHRydWUpIHJldHVybiBUUlVFO1xuICBpZiAodmFsdWUgPT09IGZhbHNlKSByZXR1cm4gRkFMU0U7XG4gIGlmICh2YWx1ZSA9PT0gMCkgcmV0dXJuIFpFUk87XG4gIGlmICh2YWx1ZSA9PT0gJycpIHJldHVybiBFTVBUWVNUUklORztcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHRoZW4gPSB2YWx1ZS50aGVuO1xuICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSh0aGVuLmJpbmQodmFsdWUpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcmVqZWN0KGV4KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWVQcm9taXNlKHZhbHVlKTtcbn07XG5cblByb21pc2UuYWxsID0gZnVuY3Rpb24gKGFycikge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycik7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiByZXNvbHZlKFtdKTtcbiAgICB2YXIgcmVtYWluaW5nID0gYXJncy5sZW5ndGg7XG4gICAgZnVuY3Rpb24gcmVzKGksIHZhbCkge1xuICAgICAgaWYgKHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFByb21pc2UgJiYgdmFsLnRoZW4gPT09IFByb21pc2UucHJvdG90eXBlLnRoZW4pIHtcbiAgICAgICAgICB3aGlsZSAodmFsLl82NSA9PT0gMykge1xuICAgICAgICAgICAgdmFsID0gdmFsLl81NTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbC5fNjUgPT09IDEpIHJldHVybiByZXMoaSwgdmFsLl81NSk7XG4gICAgICAgICAgaWYgKHZhbC5fNjUgPT09IDIpIHJlamVjdCh2YWwuXzU1KTtcbiAgICAgICAgICB2YWwudGhlbihmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXMoaSwgdmFsKTtcbiAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdGhlbiA9IHZhbC50aGVuO1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIHAgPSBuZXcgUHJvbWlzZSh0aGVuLmJpbmQodmFsKSk7XG4gICAgICAgICAgICBwLnRoZW4oZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICByZXMoaSwgdmFsKTtcbiAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcmdzW2ldID0gdmFsO1xuICAgICAgaWYgKC0tcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgIHJlc29sdmUoYXJncyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzKGksIGFyZ3NbaV0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG5Qcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlamVjdCh2YWx1ZSk7XG4gIH0pO1xufTtcblxuUHJvbWlzZS5yYWNlID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qIFByb3RvdHlwZSBNZXRob2RzICovXG5cblByb21pc2UucHJvdG90eXBlWydjYXRjaCddID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi9jb3JlLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblByb21pc2UucHJvdG90eXBlWydmaW5hbGx5J10gPSBmdW5jdGlvbiAoZikge1xuICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZigpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZigpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29yZS5qcycpO1xucmVxdWlyZSgnLi9kb25lLmpzJyk7XG5yZXF1aXJlKCcuL2ZpbmFsbHkuanMnKTtcbnJlcXVpcmUoJy4vZXM2LWV4dGVuc2lvbnMuanMnKTtcbnJlcXVpcmUoJy4vbm9kZS1leHRlbnNpb25zLmpzJyk7XG5yZXF1aXJlKCcuL3N5bmNocm9ub3VzLmpzJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgZmlsZSBjb250YWlucyB0aGVuL3Byb21pc2Ugc3BlY2lmaWMgZXh0ZW5zaW9ucyB0aGF0IGFyZSBvbmx5IHVzZWZ1bFxuLy8gZm9yIG5vZGUuanMgaW50ZXJvcFxuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vY29yZS5qcycpO1xudmFyIGFzYXAgPSByZXF1aXJlKCdhc2FwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblxuLyogU3RhdGljIEZ1bmN0aW9ucyAqL1xuXG5Qcm9taXNlLmRlbm9kZWlmeSA9IGZ1bmN0aW9uIChmbiwgYXJndW1lbnRDb3VudCkge1xuICBpZiAoXG4gICAgdHlwZW9mIGFyZ3VtZW50Q291bnQgPT09ICdudW1iZXInICYmIGFyZ3VtZW50Q291bnQgIT09IEluZmluaXR5XG4gICkge1xuICAgIHJldHVybiBkZW5vZGVpZnlXaXRoQ291bnQoZm4sIGFyZ3VtZW50Q291bnQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkZW5vZGVpZnlXaXRob3V0Q291bnQoZm4pO1xuICB9XG59O1xuXG52YXIgY2FsbGJhY2tGbiA9IChcbiAgJ2Z1bmN0aW9uIChlcnIsIHJlcykgeycgK1xuICAnaWYgKGVycikgeyByaihlcnIpOyB9IGVsc2UgeyBycyhyZXMpOyB9JyArXG4gICd9J1xuKTtcbmZ1bmN0aW9uIGRlbm9kZWlmeVdpdGhDb3VudChmbiwgYXJndW1lbnRDb3VudCkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50Q291bnQ7IGkrKykge1xuICAgIGFyZ3MucHVzaCgnYScgKyBpKTtcbiAgfVxuICB2YXIgYm9keSA9IFtcbiAgICAncmV0dXJuIGZ1bmN0aW9uICgnICsgYXJncy5qb2luKCcsJykgKyAnKSB7JyxcbiAgICAndmFyIHNlbGYgPSB0aGlzOycsXG4gICAgJ3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocnMsIHJqKSB7JyxcbiAgICAndmFyIHJlcyA9IGZuLmNhbGwoJyxcbiAgICBbJ3NlbGYnXS5jb25jYXQoYXJncykuY29uY2F0KFtjYWxsYmFja0ZuXSkuam9pbignLCcpLFxuICAgICcpOycsXG4gICAgJ2lmIChyZXMgJiYnLFxuICAgICcodHlwZW9mIHJlcyA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgcmVzID09PSBcImZ1bmN0aW9uXCIpICYmJyxcbiAgICAndHlwZW9mIHJlcy50aGVuID09PSBcImZ1bmN0aW9uXCInLFxuICAgICcpIHtycyhyZXMpO30nLFxuICAgICd9KTsnLFxuICAgICd9OydcbiAgXS5qb2luKCcnKTtcbiAgcmV0dXJuIEZ1bmN0aW9uKFsnUHJvbWlzZScsICdmbiddLCBib2R5KShQcm9taXNlLCBmbik7XG59XG5mdW5jdGlvbiBkZW5vZGVpZnlXaXRob3V0Q291bnQoZm4pIHtcbiAgdmFyIGZuTGVuZ3RoID0gTWF0aC5tYXgoZm4ubGVuZ3RoIC0gMSwgMyk7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5MZW5ndGg7IGkrKykge1xuICAgIGFyZ3MucHVzaCgnYScgKyBpKTtcbiAgfVxuICB2YXIgYm9keSA9IFtcbiAgICAncmV0dXJuIGZ1bmN0aW9uICgnICsgYXJncy5qb2luKCcsJykgKyAnKSB7JyxcbiAgICAndmFyIHNlbGYgPSB0aGlzOycsXG4gICAgJ3ZhciBhcmdzOycsXG4gICAgJ3ZhciBhcmdMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOycsXG4gICAgJ2lmIChhcmd1bWVudHMubGVuZ3RoID4gJyArIGZuTGVuZ3RoICsgJykgeycsXG4gICAgJ2FyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCArIDEpOycsXG4gICAgJ2ZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7JyxcbiAgICAnYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsnLFxuICAgICd9JyxcbiAgICAnfScsXG4gICAgJ3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocnMsIHJqKSB7JyxcbiAgICAndmFyIGNiID0gJyArIGNhbGxiYWNrRm4gKyAnOycsXG4gICAgJ3ZhciByZXM7JyxcbiAgICAnc3dpdGNoIChhcmdMZW5ndGgpIHsnLFxuICAgIGFyZ3MuY29uY2F0KFsnZXh0cmEnXSkubWFwKGZ1bmN0aW9uIChfLCBpbmRleCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgJ2Nhc2UgJyArIChpbmRleCkgKyAnOicgK1xuICAgICAgICAncmVzID0gZm4uY2FsbCgnICsgWydzZWxmJ10uY29uY2F0KGFyZ3Muc2xpY2UoMCwgaW5kZXgpKS5jb25jYXQoJ2NiJykuam9pbignLCcpICsgJyk7JyArXG4gICAgICAgICdicmVhazsnXG4gICAgICApO1xuICAgIH0pLmpvaW4oJycpLFxuICAgICdkZWZhdWx0OicsXG4gICAgJ2FyZ3NbYXJnTGVuZ3RoXSA9IGNiOycsXG4gICAgJ3JlcyA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOycsXG4gICAgJ30nLFxuICAgIFxuICAgICdpZiAocmVzICYmJyxcbiAgICAnKHR5cGVvZiByZXMgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHJlcyA9PT0gXCJmdW5jdGlvblwiKSAmJicsXG4gICAgJ3R5cGVvZiByZXMudGhlbiA9PT0gXCJmdW5jdGlvblwiJyxcbiAgICAnKSB7cnMocmVzKTt9JyxcbiAgICAnfSk7JyxcbiAgICAnfTsnXG4gIF0uam9pbignJyk7XG5cbiAgcmV0dXJuIEZ1bmN0aW9uKFxuICAgIFsnUHJvbWlzZScsICdmbiddLFxuICAgIGJvZHlcbiAgKShQcm9taXNlLCBmbik7XG59XG5cblByb21pc2Uubm9kZWlmeSA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgY2FsbGJhY2sgPVxuICAgICAgdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJyA/IGFyZ3MucG9wKCkgOiBudWxsO1xuICAgIHZhciBjdHggPSB0aGlzO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKS5ub2RlaWZ5KGNhbGxiYWNrLCBjdHgpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgcmVqZWN0KGV4KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKGN0eCwgZXgpO1xuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubm9kZWlmeSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY3R4KSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXM7XG5cbiAgdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2suY2FsbChjdHgsIG51bGwsIHZhbHVlKTtcbiAgICB9KTtcbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2suY2FsbChjdHgsIGVycik7XG4gICAgfSk7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFByb21pc2UgPSByZXF1aXJlKCcuL2NvcmUuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuUHJvbWlzZS5lbmFibGVTeW5jaHJvbm91cyA9IGZ1bmN0aW9uICgpIHtcbiAgUHJvbWlzZS5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGUoKSA9PSAwO1xuICB9O1xuXG4gIFByb21pc2UucHJvdG90eXBlLmlzRnVsZmlsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGUoKSA9PSAxO1xuICB9O1xuXG4gIFByb21pc2UucHJvdG90eXBlLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSgpID09IDI7XG4gIH07XG5cbiAgUHJvbWlzZS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuXzY1ID09PSAzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fNTUuZ2V0VmFsdWUoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZ2V0IGEgdmFsdWUgb2YgYW4gdW5mdWxmaWxsZWQgcHJvbWlzZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fNTU7XG4gIH07XG5cbiAgUHJvbWlzZS5wcm90b3R5cGUuZ2V0UmVhc29uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl82NSA9PT0gMykge1xuICAgICAgcmV0dXJuIHRoaXMuXzU1LmdldFJlYXNvbigpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc1JlamVjdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGdldCBhIHJlamVjdGlvbiByZWFzb24gb2YgYSBub24tcmVqZWN0ZWQgcHJvbWlzZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fNTU7XG4gIH07XG5cbiAgUHJvbWlzZS5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuXzY1ID09PSAzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fNTUuZ2V0U3RhdGUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuXzY1ID09PSAtMSB8fCB0aGlzLl82NSA9PT0gLTIpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl82NTtcbiAgfTtcbn07XG5cblByb21pc2UuZGlzYWJsZVN5bmNocm9ub3VzID0gZnVuY3Rpb24oKSB7XG4gIFByb21pc2UucHJvdG90eXBlLmlzUGVuZGluZyA9IHVuZGVmaW5lZDtcbiAgUHJvbWlzZS5wcm90b3R5cGUuaXNGdWxmaWxsZWQgPSB1bmRlZmluZWQ7XG4gIFByb21pc2UucHJvdG90eXBlLmlzUmVqZWN0ZWQgPSB1bmRlZmluZWQ7XG4gIFByb21pc2UucHJvdG90eXBlLmdldFZhbHVlID0gdW5kZWZpbmVkO1xuICBQcm9taXNlLnByb3RvdHlwZS5nZXRSZWFzb24gPSB1bmRlZmluZWQ7XG4gIFByb21pc2UucHJvdG90eXBlLmdldFN0YXRlID0gdW5kZWZpbmVkO1xufTtcbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuMy4yIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjMuMicsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVwbGFjZSA9IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZTtcbnZhciBwZXJjZW50VHdlbnRpZXMgPSAvJTIwL2c7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdkZWZhdWx0JzogJ1JGQzM5ODYnLFxuICAgIGZvcm1hdHRlcnM6IHtcbiAgICAgICAgUkZDMTczODogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZS5jYWxsKHZhbHVlLCBwZXJjZW50VHdlbnRpZXMsICcrJyk7XG4gICAgICAgIH0sXG4gICAgICAgIFJGQzM5ODY6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBSRkMxNzM4OiAnUkZDMTczOCcsXG4gICAgUkZDMzk4NjogJ1JGQzM5ODYnXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnknKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKTtcbnZhciBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGZvcm1hdHM6IGZvcm1hdHMsXG4gICAgcGFyc2U6IHBhcnNlLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gICAgYWxsb3dEb3RzOiBmYWxzZSxcbiAgICBhbGxvd1Byb3RvdHlwZXM6IGZhbHNlLFxuICAgIGFycmF5TGltaXQ6IDIwLFxuICAgIGRlY29kZXI6IHV0aWxzLmRlY29kZSxcbiAgICBkZWxpbWl0ZXI6ICcmJyxcbiAgICBkZXB0aDogNSxcbiAgICBwYXJhbWV0ZXJMaW1pdDogMTAwMCxcbiAgICBwbGFpbk9iamVjdHM6IGZhbHNlLFxuICAgIHN0cmljdE51bGxIYW5kbGluZzogZmFsc2Vcbn07XG5cbnZhciBwYXJzZVZhbHVlcyA9IGZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmdWYWx1ZXMoc3RyLCBvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIHZhciBjbGVhblN0ciA9IG9wdGlvbnMuaWdub3JlUXVlcnlQcmVmaXggPyBzdHIucmVwbGFjZSgvXlxcPy8sICcnKSA6IHN0cjtcbiAgICB2YXIgbGltaXQgPSBvcHRpb25zLnBhcmFtZXRlckxpbWl0ID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IG9wdGlvbnMucGFyYW1ldGVyTGltaXQ7XG4gICAgdmFyIHBhcnRzID0gY2xlYW5TdHIuc3BsaXQob3B0aW9ucy5kZWxpbWl0ZXIsIGxpbWl0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcblxuICAgICAgICB2YXIgYnJhY2tldEVxdWFsc1BvcyA9IHBhcnQuaW5kZXhPZignXT0nKTtcbiAgICAgICAgdmFyIHBvcyA9IGJyYWNrZXRFcXVhbHNQb3MgPT09IC0xID8gcGFydC5pbmRleE9mKCc9JykgOiBicmFja2V0RXF1YWxzUG9zICsgMTtcblxuICAgICAgICB2YXIga2V5LCB2YWw7XG4gICAgICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICAgICAgICBrZXkgPSBvcHRpb25zLmRlY29kZXIocGFydCwgZGVmYXVsdHMuZGVjb2Rlcik7XG4gICAgICAgICAgICB2YWwgPSBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA/IG51bGwgOiAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleSA9IG9wdGlvbnMuZGVjb2RlcihwYXJ0LnNsaWNlKDAsIHBvcyksIGRlZmF1bHRzLmRlY29kZXIpO1xuICAgICAgICAgICAgdmFsID0gb3B0aW9ucy5kZWNvZGVyKHBhcnQuc2xpY2UocG9zICsgMSksIGRlZmF1bHRzLmRlY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gW10uY29uY2F0KG9ialtrZXldKS5jb25jYXQodmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBwYXJzZU9iamVjdCA9IGZ1bmN0aW9uIHBhcnNlT2JqZWN0UmVjdXJzaXZlKGNoYWluLCB2YWwsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWNoYWluLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIHZhciByb290ID0gY2hhaW4uc2hpZnQoKTtcblxuICAgIHZhciBvYmo7XG4gICAgaWYgKHJvb3QgPT09ICdbXScpIHtcbiAgICAgICAgb2JqID0gW107XG4gICAgICAgIG9iaiA9IG9iai5jb25jYXQocGFyc2VPYmplY3QoY2hhaW4sIHZhbCwgb3B0aW9ucykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9iaiA9IG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuICAgICAgICB2YXIgY2xlYW5Sb290ID0gcm9vdC5jaGFyQXQoMCkgPT09ICdbJyAmJiByb290LmNoYXJBdChyb290Lmxlbmd0aCAtIDEpID09PSAnXScgPyByb290LnNsaWNlKDEsIC0xKSA6IHJvb3Q7XG4gICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KGNsZWFuUm9vdCwgMTApO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhaXNOYU4oaW5kZXgpXG4gICAgICAgICAgICAmJiByb290ICE9PSBjbGVhblJvb3RcbiAgICAgICAgICAgICYmIFN0cmluZyhpbmRleCkgPT09IGNsZWFuUm9vdFxuICAgICAgICAgICAgJiYgaW5kZXggPj0gMFxuICAgICAgICAgICAgJiYgKG9wdGlvbnMucGFyc2VBcnJheXMgJiYgaW5kZXggPD0gb3B0aW9ucy5hcnJheUxpbWl0KVxuICAgICAgICApIHtcbiAgICAgICAgICAgIG9iaiA9IFtdO1xuICAgICAgICAgICAgb2JqW2luZGV4XSA9IHBhcnNlT2JqZWN0KGNoYWluLCB2YWwsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqW2NsZWFuUm9vdF0gPSBwYXJzZU9iamVjdChjaGFpbiwgdmFsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG52YXIgcGFyc2VLZXlzID0gZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZ0tleXMoZ2l2ZW5LZXksIHZhbCwgb3B0aW9ucykge1xuICAgIGlmICghZ2l2ZW5LZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRyYW5zZm9ybSBkb3Qgbm90YXRpb24gdG8gYnJhY2tldCBub3RhdGlvblxuICAgIHZhciBrZXkgPSBvcHRpb25zLmFsbG93RG90cyA/IGdpdmVuS2V5LnJlcGxhY2UoL1xcLihbXi5bXSspL2csICdbJDFdJykgOiBnaXZlbktleTtcblxuICAgIC8vIFRoZSByZWdleCBjaHVua3NcblxuICAgIHZhciBicmFja2V0cyA9IC8oXFxbW15bXFxdXSpdKS87XG4gICAgdmFyIGNoaWxkID0gLyhcXFtbXltcXF1dKl0pL2c7XG5cbiAgICAvLyBHZXQgdGhlIHBhcmVudFxuXG4gICAgdmFyIHNlZ21lbnQgPSBicmFja2V0cy5leGVjKGtleSk7XG4gICAgdmFyIHBhcmVudCA9IHNlZ21lbnQgPyBrZXkuc2xpY2UoMCwgc2VnbWVudC5pbmRleCkgOiBrZXk7XG5cbiAgICAvLyBTdGFzaCB0aGUgcGFyZW50IGlmIGl0IGV4aXN0c1xuXG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIC8vIElmIHdlIGFyZW4ndCB1c2luZyBwbGFpbiBvYmplY3RzLCBvcHRpb25hbGx5IHByZWZpeCBrZXlzXG4gICAgICAgIC8vIHRoYXQgd291bGQgb3ZlcndyaXRlIG9iamVjdCBwcm90b3R5cGUgcHJvcGVydGllc1xuICAgICAgICBpZiAoIW9wdGlvbnMucGxhaW5PYmplY3RzICYmIGhhcy5jYWxsKE9iamVjdC5wcm90b3R5cGUsIHBhcmVudCkpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBrZXlzLnB1c2gocGFyZW50KTtcbiAgICB9XG5cbiAgICAvLyBMb29wIHRocm91Z2ggY2hpbGRyZW4gYXBwZW5kaW5nIHRvIHRoZSBhcnJheSB1bnRpbCB3ZSBoaXQgZGVwdGhcblxuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoKHNlZ21lbnQgPSBjaGlsZC5leGVjKGtleSkpICE9PSBudWxsICYmIGkgPCBvcHRpb25zLmRlcHRoKSB7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnBsYWluT2JqZWN0cyAmJiBoYXMuY2FsbChPYmplY3QucHJvdG90eXBlLCBzZWdtZW50WzFdLnNsaWNlKDEsIC0xKSkpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAga2V5cy5wdXNoKHNlZ21lbnRbMV0pO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlJ3MgYSByZW1haW5kZXIsIGp1c3QgYWRkIHdoYXRldmVyIGlzIGxlZnRcblxuICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIGtleXMucHVzaCgnWycgKyBrZXkuc2xpY2Uoc2VnbWVudC5pbmRleCkgKyAnXScpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZU9iamVjdChrZXlzLCB2YWwsIG9wdGlvbnMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyLCBvcHRzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzID8gdXRpbHMuYXNzaWduKHt9LCBvcHRzKSA6IHt9O1xuXG4gICAgaWYgKG9wdGlvbnMuZGVjb2RlciAhPT0gbnVsbCAmJiBvcHRpb25zLmRlY29kZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5kZWNvZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RlY29kZXIgaGFzIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5pZ25vcmVRdWVyeVByZWZpeCA9IG9wdGlvbnMuaWdub3JlUXVlcnlQcmVmaXggPT09IHRydWU7XG4gICAgb3B0aW9ucy5kZWxpbWl0ZXIgPSB0eXBlb2Ygb3B0aW9ucy5kZWxpbWl0ZXIgPT09ICdzdHJpbmcnIHx8IHV0aWxzLmlzUmVnRXhwKG9wdGlvbnMuZGVsaW1pdGVyKSA/IG9wdGlvbnMuZGVsaW1pdGVyIDogZGVmYXVsdHMuZGVsaW1pdGVyO1xuICAgIG9wdGlvbnMuZGVwdGggPSB0eXBlb2Ygb3B0aW9ucy5kZXB0aCA9PT0gJ251bWJlcicgPyBvcHRpb25zLmRlcHRoIDogZGVmYXVsdHMuZGVwdGg7XG4gICAgb3B0aW9ucy5hcnJheUxpbWl0ID0gdHlwZW9mIG9wdGlvbnMuYXJyYXlMaW1pdCA9PT0gJ251bWJlcicgPyBvcHRpb25zLmFycmF5TGltaXQgOiBkZWZhdWx0cy5hcnJheUxpbWl0O1xuICAgIG9wdGlvbnMucGFyc2VBcnJheXMgPSBvcHRpb25zLnBhcnNlQXJyYXlzICE9PSBmYWxzZTtcbiAgICBvcHRpb25zLmRlY29kZXIgPSB0eXBlb2Ygb3B0aW9ucy5kZWNvZGVyID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5kZWNvZGVyIDogZGVmYXVsdHMuZGVjb2RlcjtcbiAgICBvcHRpb25zLmFsbG93RG90cyA9IHR5cGVvZiBvcHRpb25zLmFsbG93RG90cyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5hbGxvd0RvdHMgOiBkZWZhdWx0cy5hbGxvd0RvdHM7XG4gICAgb3B0aW9ucy5wbGFpbk9iamVjdHMgPSB0eXBlb2Ygb3B0aW9ucy5wbGFpbk9iamVjdHMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMucGxhaW5PYmplY3RzIDogZGVmYXVsdHMucGxhaW5PYmplY3RzO1xuICAgIG9wdGlvbnMuYWxsb3dQcm90b3R5cGVzID0gdHlwZW9mIG9wdGlvbnMuYWxsb3dQcm90b3R5cGVzID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmFsbG93UHJvdG90eXBlcyA6IGRlZmF1bHRzLmFsbG93UHJvdG90eXBlcztcbiAgICBvcHRpb25zLnBhcmFtZXRlckxpbWl0ID0gdHlwZW9mIG9wdGlvbnMucGFyYW1ldGVyTGltaXQgPT09ICdudW1iZXInID8gb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCA6IGRlZmF1bHRzLnBhcmFtZXRlckxpbWl0O1xuICAgIG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nID0gdHlwZW9mIG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA6IGRlZmF1bHRzLnN0cmljdE51bGxIYW5kbGluZztcblxuICAgIGlmIChzdHIgPT09ICcnIHx8IHN0ciA9PT0gbnVsbCB8fCB0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gICAgfVxuXG4gICAgdmFyIHRlbXBPYmogPSB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHBhcnNlVmFsdWVzKHN0ciwgb3B0aW9ucykgOiBzdHI7XG4gICAgdmFyIG9iaiA9IG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBrZXlzIGFuZCBzZXR1cCB0aGUgbmV3IG9iamVjdFxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0ZW1wT2JqKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciBuZXdPYmogPSBwYXJzZUtleXMoa2V5LCB0ZW1wT2JqW2tleV0sIG9wdGlvbnMpO1xuICAgICAgICBvYmogPSB1dGlscy5tZXJnZShvYmosIG5ld09iaiwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWxzLmNvbXBhY3Qob2JqKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XG5cbnZhciBhcnJheVByZWZpeEdlbmVyYXRvcnMgPSB7XG4gICAgYnJhY2tldHM6IGZ1bmN0aW9uIGJyYWNrZXRzKHByZWZpeCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgJ1tdJztcbiAgICB9LFxuICAgIGluZGljZXM6IGZ1bmN0aW9uIGluZGljZXMocHJlZml4LCBrZXkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcbiAgICAgICAgcmV0dXJuIHByZWZpeCArICdbJyArIGtleSArICddJztcbiAgICB9LFxuICAgIHJlcGVhdDogZnVuY3Rpb24gcmVwZWF0KHByZWZpeCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgIH1cbn07XG5cbnZhciB0b0lTTyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nO1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gICAgZGVsaW1pdGVyOiAnJicsXG4gICAgZW5jb2RlOiB0cnVlLFxuICAgIGVuY29kZXI6IHV0aWxzLmVuY29kZSxcbiAgICBlbmNvZGVWYWx1ZXNPbmx5OiBmYWxzZSxcbiAgICBzZXJpYWxpemVEYXRlOiBmdW5jdGlvbiBzZXJpYWxpemVEYXRlKGRhdGUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcbiAgICAgICAgcmV0dXJuIHRvSVNPLmNhbGwoZGF0ZSk7XG4gICAgfSxcbiAgICBza2lwTnVsbHM6IGZhbHNlLFxuICAgIHN0cmljdE51bGxIYW5kbGluZzogZmFsc2Vcbn07XG5cbnZhciBzdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkoIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG4gICAgb2JqZWN0LFxuICAgIHByZWZpeCxcbiAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgIHN0cmljdE51bGxIYW5kbGluZyxcbiAgICBza2lwTnVsbHMsXG4gICAgZW5jb2RlcixcbiAgICBmaWx0ZXIsXG4gICAgc29ydCxcbiAgICBhbGxvd0RvdHMsXG4gICAgc2VyaWFsaXplRGF0ZSxcbiAgICBmb3JtYXR0ZXIsXG4gICAgZW5jb2RlVmFsdWVzT25seVxuKSB7XG4gICAgdmFyIG9iaiA9IG9iamVjdDtcbiAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvYmogPSBmaWx0ZXIocHJlZml4LCBvYmopO1xuICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBvYmogPSBzZXJpYWxpemVEYXRlKG9iaik7XG4gICAgfSBlbHNlIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHN0cmljdE51bGxIYW5kbGluZykge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZXIgJiYgIWVuY29kZVZhbHVlc09ubHkgPyBlbmNvZGVyKHByZWZpeCwgZGVmYXVsdHMuZW5jb2RlcikgOiBwcmVmaXg7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSAnJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG9iaiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIG9iaiA9PT0gJ2Jvb2xlYW4nIHx8IHV0aWxzLmlzQnVmZmVyKG9iaikpIHtcbiAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgIHZhciBrZXlWYWx1ZSA9IGVuY29kZVZhbHVlc09ubHkgPyBwcmVmaXggOiBlbmNvZGVyKHByZWZpeCwgZGVmYXVsdHMuZW5jb2Rlcik7XG4gICAgICAgICAgICByZXR1cm4gW2Zvcm1hdHRlcihrZXlWYWx1ZSkgKyAnPScgKyBmb3JtYXR0ZXIoZW5jb2RlcihvYmosIGRlZmF1bHRzLmVuY29kZXIpKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtmb3JtYXR0ZXIocHJlZml4KSArICc9JyArIGZvcm1hdHRlcihTdHJpbmcob2JqKSldO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cblxuICAgIHZhciBvYmpLZXlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcikpIHtcbiAgICAgICAgb2JqS2V5cyA9IGZpbHRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIG9iaktleXMgPSBzb3J0ID8ga2V5cy5zb3J0KHNvcnQpIDoga2V5cztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iaktleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IG9iaktleXNbaV07XG5cbiAgICAgICAgaWYgKHNraXBOdWxscyAmJiBvYmpba2V5XSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICBvYmpba2V5XSxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4KHByZWZpeCwga2V5KSxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgICAgICAgICAgICAgIHN0cmljdE51bGxIYW5kbGluZyxcbiAgICAgICAgICAgICAgICBza2lwTnVsbHMsXG4gICAgICAgICAgICAgICAgZW5jb2RlcixcbiAgICAgICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICAgICAgc29ydCxcbiAgICAgICAgICAgICAgICBhbGxvd0RvdHMsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXIsXG4gICAgICAgICAgICAgICAgZW5jb2RlVmFsdWVzT25seVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICBvYmpba2V5XSxcbiAgICAgICAgICAgICAgICBwcmVmaXggKyAoYWxsb3dEb3RzID8gJy4nICsga2V5IDogJ1snICsga2V5ICsgJ10nKSxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgICAgICAgICAgICAgIHN0cmljdE51bGxIYW5kbGluZyxcbiAgICAgICAgICAgICAgICBza2lwTnVsbHMsXG4gICAgICAgICAgICAgICAgZW5jb2RlcixcbiAgICAgICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICAgICAgc29ydCxcbiAgICAgICAgICAgICAgICBhbGxvd0RvdHMsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXIsXG4gICAgICAgICAgICAgICAgZW5jb2RlVmFsdWVzT25seVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBvcHRzKSB7XG4gICAgdmFyIG9iaiA9IG9iamVjdDtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdHMgPyB1dGlscy5hc3NpZ24oe30sIG9wdHMpIDoge307XG5cbiAgICBpZiAob3B0aW9ucy5lbmNvZGVyICE9PSBudWxsICYmIG9wdGlvbnMuZW5jb2RlciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb25zLmVuY29kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW5jb2RlciBoYXMgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgZGVsaW1pdGVyID0gdHlwZW9mIG9wdGlvbnMuZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzLmRlbGltaXRlciA6IG9wdGlvbnMuZGVsaW1pdGVyO1xuICAgIHZhciBzdHJpY3ROdWxsSGFuZGxpbmcgPSB0eXBlb2Ygb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nIDogZGVmYXVsdHMuc3RyaWN0TnVsbEhhbmRsaW5nO1xuICAgIHZhciBza2lwTnVsbHMgPSB0eXBlb2Ygb3B0aW9ucy5za2lwTnVsbHMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc2tpcE51bGxzIDogZGVmYXVsdHMuc2tpcE51bGxzO1xuICAgIHZhciBlbmNvZGUgPSB0eXBlb2Ygb3B0aW9ucy5lbmNvZGUgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuZW5jb2RlIDogZGVmYXVsdHMuZW5jb2RlO1xuICAgIHZhciBlbmNvZGVyID0gdHlwZW9mIG9wdGlvbnMuZW5jb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuZW5jb2RlciA6IGRlZmF1bHRzLmVuY29kZXI7XG4gICAgdmFyIHNvcnQgPSB0eXBlb2Ygb3B0aW9ucy5zb3J0ID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5zb3J0IDogbnVsbDtcbiAgICB2YXIgYWxsb3dEb3RzID0gdHlwZW9mIG9wdGlvbnMuYWxsb3dEb3RzID09PSAndW5kZWZpbmVkJyA/IGZhbHNlIDogb3B0aW9ucy5hbGxvd0RvdHM7XG4gICAgdmFyIHNlcmlhbGl6ZURhdGUgPSB0eXBlb2Ygb3B0aW9ucy5zZXJpYWxpemVEYXRlID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5zZXJpYWxpemVEYXRlIDogZGVmYXVsdHMuc2VyaWFsaXplRGF0ZTtcbiAgICB2YXIgZW5jb2RlVmFsdWVzT25seSA9IHR5cGVvZiBvcHRpb25zLmVuY29kZVZhbHVlc09ubHkgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuZW5jb2RlVmFsdWVzT25seSA6IGRlZmF1bHRzLmVuY29kZVZhbHVlc09ubHk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZvcm1hdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb3B0aW9ucy5mb3JtYXQgPSBmb3JtYXRzLmRlZmF1bHQ7XG4gICAgfSBlbHNlIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZvcm1hdHMuZm9ybWF0dGVycywgb3B0aW9ucy5mb3JtYXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZm9ybWF0IG9wdGlvbiBwcm92aWRlZC4nKTtcbiAgICB9XG4gICAgdmFyIGZvcm1hdHRlciA9IGZvcm1hdHMuZm9ybWF0dGVyc1tvcHRpb25zLmZvcm1hdF07XG4gICAgdmFyIG9iaktleXM7XG4gICAgdmFyIGZpbHRlcjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIG9iaiA9IGZpbHRlcignJywgb2JqKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5maWx0ZXIpKSB7XG4gICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICBvYmpLZXlzID0gZmlsdGVyO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gW107XG5cbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICB2YXIgYXJyYXlGb3JtYXQ7XG4gICAgaWYgKG9wdGlvbnMuYXJyYXlGb3JtYXQgaW4gYXJyYXlQcmVmaXhHZW5lcmF0b3JzKSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gb3B0aW9ucy5hcnJheUZvcm1hdDtcbiAgICB9IGVsc2UgaWYgKCdpbmRpY2VzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gb3B0aW9ucy5pbmRpY2VzID8gJ2luZGljZXMnIDogJ3JlcGVhdCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlGb3JtYXQgPSAnaW5kaWNlcyc7XG4gICAgfVxuXG4gICAgdmFyIGdlbmVyYXRlQXJyYXlQcmVmaXggPSBhcnJheVByZWZpeEdlbmVyYXRvcnNbYXJyYXlGb3JtYXRdO1xuXG4gICAgaWYgKCFvYmpLZXlzKSB7XG4gICAgICAgIG9iaktleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIH1cblxuICAgIGlmIChzb3J0KSB7XG4gICAgICAgIG9iaktleXMuc29ydChzb3J0KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iaktleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IG9iaktleXNbaV07XG5cbiAgICAgICAgaWYgKHNraXBOdWxscyAmJiBvYmpba2V5XSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoc3RyaW5naWZ5KFxuICAgICAgICAgICAgb2JqW2tleV0sXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgICAgICAgICAgc3RyaWN0TnVsbEhhbmRsaW5nLFxuICAgICAgICAgICAgc2tpcE51bGxzLFxuICAgICAgICAgICAgZW5jb2RlID8gZW5jb2RlciA6IG51bGwsXG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICBzb3J0LFxuICAgICAgICAgICAgYWxsb3dEb3RzLFxuICAgICAgICAgICAgc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgICAgIGZvcm1hdHRlcixcbiAgICAgICAgICAgIGVuY29kZVZhbHVlc09ubHlcbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgdmFyIGpvaW5lZCA9IGtleXMuam9pbihkZWxpbWl0ZXIpO1xuICAgIHZhciBwcmVmaXggPSBvcHRpb25zLmFkZFF1ZXJ5UHJlZml4ID09PSB0cnVlID8gJz8nIDogJyc7XG5cbiAgICByZXR1cm4gam9pbmVkLmxlbmd0aCA+IDAgPyBwcmVmaXggKyBqb2luZWQgOiAnJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgaGV4VGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICAgICAgYXJyYXkucHVzaCgnJScgKyAoKGkgPCAxNiA/ICcwJyA6ICcnKSArIGkudG9TdHJpbmcoMTYpKS50b1VwcGVyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG59KCkpO1xuXG5leHBvcnRzLmFycmF5VG9PYmplY3QgPSBmdW5jdGlvbiAoc291cmNlLCBvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBvYmpbaV0gPSBzb3VyY2VbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxuZXhwb3J0cy5tZXJnZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKHNvdXJjZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBsYWluT2JqZWN0cyB8fCBvcHRpb25zLmFsbG93UHJvdG90eXBlcyB8fCAhaGFzLmNhbGwoT2JqZWN0LnByb3RvdHlwZSwgc291cmNlKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtzb3VyY2VdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbdGFyZ2V0LCBzb3VyY2VdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIFt0YXJnZXRdLmNvbmNhdChzb3VyY2UpO1xuICAgIH1cblxuICAgIHZhciBtZXJnZVRhcmdldCA9IHRhcmdldDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmICFBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgbWVyZ2VUYXJnZXQgPSBleHBvcnRzLmFycmF5VG9PYmplY3QodGFyZ2V0LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICBzb3VyY2UuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICAgICAgaWYgKGhhcy5jYWxsKHRhcmdldCwgaSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0W2ldICYmIHR5cGVvZiB0YXJnZXRbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtpXSA9IGV4cG9ydHMubWVyZ2UodGFyZ2V0W2ldLCBpdGVtLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFtpXSA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhzb3VyY2UpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW2tleV07XG5cbiAgICAgICAgaWYgKGhhcy5jYWxsKGFjYywga2V5KSkge1xuICAgICAgICAgICAgYWNjW2tleV0gPSBleHBvcnRzLm1lcmdlKGFjY1trZXldLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgbWVyZ2VUYXJnZXQpO1xufTtcblxuZXhwb3J0cy5hc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ25TaW5nbGVTb3VyY2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc291cmNlKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgIGFjY1trZXldID0gc291cmNlW2tleV07XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgdGFyZ2V0KTtcbn07XG5cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxufTtcblxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgLy8gVGhpcyBjb2RlIHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gYnkgQnJpYW4gV2hpdGUgKG1zY2RleCkgZm9yIHRoZSBpby5qcyBjb3JlIHF1ZXJ5c3RyaW5nIGxpYnJhcnkuXG4gICAgLy8gSXQgaGFzIGJlZW4gYWRhcHRlZCBoZXJlIGZvciBzdHJpY3RlciBhZGhlcmVuY2UgdG8gUkZDIDM5ODZcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHZhciBzdHJpbmcgPSB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHN0ciA6IFN0cmluZyhzdHIpO1xuXG4gICAgdmFyIG91dCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgYyA9PT0gMHgyRCAgICAvLyAtXG4gICAgICAgICAgICB8fCBjID09PSAweDJFIC8vIC5cbiAgICAgICAgICAgIHx8IGMgPT09IDB4NUYgLy8gX1xuICAgICAgICAgICAgfHwgYyA9PT0gMHg3RSAvLyB+XG4gICAgICAgICAgICB8fCAoYyA+PSAweDMwICYmIGMgPD0gMHgzOSkgLy8gMC05XG4gICAgICAgICAgICB8fCAoYyA+PSAweDQxICYmIGMgPD0gMHg1QSkgLy8gYS16XG4gICAgICAgICAgICB8fCAoYyA+PSAweDYxICYmIGMgPD0gMHg3QSkgLy8gQS1aXG4gICAgICAgICkge1xuICAgICAgICAgICAgb3V0ICs9IHN0cmluZy5jaGFyQXQoaSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgb3V0ID0gb3V0ICsgaGV4VGFibGVbY107XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIG91dCA9IG91dCArIChoZXhUYWJsZVsweEMwIHwgKGMgPj4gNildICsgaGV4VGFibGVbMHg4MCB8IChjICYgMHgzRildKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCAweEQ4MDAgfHwgYyA+PSAweEUwMDApIHtcbiAgICAgICAgICAgIG91dCA9IG91dCArIChoZXhUYWJsZVsweEUwIHwgKGMgPj4gMTIpXSArIGhleFRhYmxlWzB4ODAgfCAoKGMgPj4gNikgJiAweDNGKV0gKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpICs9IDE7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKCgoYyAmIDB4M0ZGKSA8PCAxMCkgfCAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgJiAweDNGRikpO1xuICAgICAgICBvdXQgKz0gaGV4VGFibGVbMHhGMCB8IChjID4+IDE4KV1cbiAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiAxMikgJiAweDNGKV1cbiAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiA2KSAmIDB4M0YpXVxuICAgICAgICAgICAgKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbmV4cG9ydHMuY29tcGFjdCA9IGZ1bmN0aW9uIChvYmosIHJlZmVyZW5jZXMpIHtcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgdmFyIHJlZnMgPSByZWZlcmVuY2VzIHx8IFtdO1xuICAgIHZhciBsb29rdXAgPSByZWZzLmluZGV4T2Yob2JqKTtcbiAgICBpZiAobG9va3VwICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gcmVmc1tsb29rdXBdO1xuICAgIH1cblxuICAgIHJlZnMucHVzaChvYmopO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICB2YXIgY29tcGFjdGVkID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChvYmpbaV0gJiYgdHlwZW9mIG9ialtpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBjb21wYWN0ZWQucHVzaChleHBvcnRzLmNvbXBhY3Qob2JqW2ldLCByZWZzKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmpbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29tcGFjdGVkLnB1c2gob2JqW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wYWN0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIG9ialtrZXldID0gZXhwb3J0cy5jb21wYWN0KG9ialtrZXldLCByZWZzKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBvYmo7XG59O1xuXG5leHBvcnRzLmlzUmVnRXhwID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59O1xuXG5leHBvcnRzLmlzQnVmZmVyID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAhIShvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopKTtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFZhbGlkYXRpb25SdWxlcyA9IGZ1bmN0aW9uKCl7fTtcblZhbGlkYXRpb25SdWxlcy5wcm90b3R5cGUuZ3Vlc3RPcmRlckZvcm1SdWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvYmogPSB7XG4gICAgICAgIHJ1bGVzOiB7XG4gICAgICAgICAgICBcImR3ZnJtX2d1ZXN0b3JkZXJoaXN0b3J5X29yZGVyTnVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBudW1iZXI6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImR3ZnJtX2d1ZXN0b3JkZXJoaXN0b3J5X29yZGVyRW1haWxcIjoge1xuICAgICAgICAgICAgICAgIGVtYWlsOiB0cnVlLFxuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJkd2ZybV9ndWVzdG9yZGVyaGlzdG9yeV9wb3N0YWxDb2RlXCI6IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgbWlubGVuZ3RoOiA1LFxuICAgICAgICAgICAgICAgIG1heGxlbmd0aDogMTVcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuICAgICAgICBtZXNzYWdlczoge1xuICAgICAgICAgICAgXCJkd2ZybV9ndWVzdG9yZGVyaGlzdG9yeV9vcmRlckVtYWlsXCI6IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogUmVzb3VyY2VzLlZBTElEQVRFX0VNQUlMLFxuICAgICAgICAgICAgICAgIGVtYWlsOiBSZXNvdXJjZXMuVkFMSURBVEVfRU1BSUxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImR3ZnJtX2d1ZXN0b3JkZXJoaXN0b3J5X3Bvc3RhbENvZGVcIjoge1xuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBSZXNvdXJjZXMuVkFMSURBVEVfUE9TVEFMLFxuICAgICAgICAgICAgICAgIG51bWJlcjogUmVzb3VyY2VzLlZBTElEQVRFX1BPU1RBTCxcbiAgICAgICAgICAgICAgICBtaW5sZW5ndGg6IFJlc291cmNlcy5WQUxJREFURV9QT1NUQUwsXG4gICAgICAgICAgICAgICAgbWF4bGVuZ3RoOiBSZXNvdXJjZXMuVkFMSURBVEVfUE9TVEFMXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJkd2ZybV9ndWVzdG9yZGVyaGlzdG9yeV9vcmRlck51bWJlclwiOiB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFJlc291cmNlcy5WQUxJREFURV9PUkRFUk5VTUJFUixcbiAgICAgICAgICAgICAgICBudW1iZXI6IFJlc291cmNlcy5WQUxJREFURV9PUkRFUk5VTUJFUlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvckNsYXNzIDogJ2Vycm9yJyxcbiAgICAgICAgZXJyb3JFbGVtZW50IDogJ3NwYW4nLFxuICAgICAgICBpZ25vcmU6IFwiOmhpZGRlbjpub3QoLnJlcGxhY2VkKVwiLFxuICAgICAgICBvbmtleXVwIDogZmFsc2UsXG4gICAgICAgIG9uZm9jdXNvdXQgOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgaWYoIXRoaXMuY2hlY2thYmxlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBoaWdobGlnaHQgOiBmdW5jdGlvbihlbGVtZW50LCBlcnJvckNsYXNzLCB2YWxpZENsYXNzKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSAncmFkaW8nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5kQnlOYW1lKGVsZW1lbnQubmFtZSkuYWRkQ2xhc3MoZXJyb3JDbGFzcykucmVtb3ZlQ2xhc3ModmFsaWRDbGFzcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICQoZWxlbWVudCkuYWRkQ2xhc3MoZXJyb3JDbGFzcykucmVtb3ZlQ2xhc3ModmFsaWRDbGFzcyk7XG4gICAgICAgICAgICAgICAgaWYoZWxlbWVudC50eXBlID09PSAnc2VsZWN0LW9uZScpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZigkZWxlbWVudC5hdHRyKCdpZCcpICYmICRlbGVtZW50Lmhhc0NsYXNzKCdyZXBsYWNlZCcpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RCb3ggPSAkKCcjJyArICRlbGVtZW50LmF0dHIoJ2lkJykgKyAnU2VsZWN0Qm94SXRDb250YWluZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNlbGVjdEJveCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0Qm94LmFkZENsYXNzKGVycm9yQ2xhc3MpLnJlbW92ZUNsYXNzKHZhbGlkQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1bmhpZ2hsaWdodCA6IGZ1bmN0aW9uKGVsZW1lbnQsIGVycm9yQ2xhc3MsIHZhbGlkQ2xhc3MpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmRCeU5hbWUoZWxlbWVudC5uYW1lKS5yZW1vdmVDbGFzcyhlcnJvckNsYXNzKS5hZGRDbGFzcyh2YWxpZENsYXNzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJChlbGVtZW50KS5yZW1vdmVDbGFzcyhlcnJvckNsYXNzKS5hZGRDbGFzcyh2YWxpZENsYXNzKTtcbiAgICAgICAgICAgICAgICBpZihlbGVtZW50LnR5cGUgPT09ICdzZWxlY3Qtb25lJyl7XG4gICAgICAgICAgICAgICAgICAgIHZhciAkZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKCRlbGVtZW50LmF0dHIoJ2lkJykgJiYgJGVsZW1lbnQuaGFzQ2xhc3MoJ3JlcGxhY2VkJykpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdEJveCA9ICQoJyMnICsgJGVsZW1lbnQuYXR0cignaWQnKSArICdTZWxlY3RCb3hJdENvbnRhaW5lcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2VsZWN0Qm94KXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RCb3gucmVtb3ZlQ2xhc3MoZXJyb3JDbGFzcykuYWRkQ2xhc3ModmFsaWRDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNob3dFcnJvcnM6IGZ1bmN0aW9uIChlcnJvck1hcCwgZXJyb3JMaXN0KSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRTaG93RXJyb3JzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG9iajtcbn1cbm1vZHVsZS5leHBvcnRzID0gVmFsaWRhdGlvblJ1bGVzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJvZ3Jlc3MgPSByZXF1aXJlKCcuL3Byb2dyZXNzJyksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgY3VycmVudFJlcXVlc3RzID0gW107XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAZGVzY3JpcHRpb24gQWpheCByZXF1ZXN0IHRvIGdldCBqc29uIHJlc3BvbnNlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFzeW5jICBBc3luY2hyb25vdXMgb3Igbm90XG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIFVSSSBmb3IgdGhlIHJlcXVlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIE5hbWUvVmFsdWUgcGFpciBkYXRhIHJlcXVlc3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAqL1xudmFyIGdldEpzb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMudXJsID0gdXRpbC50b0Fic29sdXRlVXJsKG9wdGlvbnMudXJsKTtcbiAgICAvLyByZXR1cm4gaWYgbm8gdXJsIGV4aXN0cyBvciB1cmwgbWF0Y2hlcyBhIGN1cnJlbnQgcmVxdWVzdFxuICAgIGlmICghb3B0aW9ucy51cmwgfHwgY3VycmVudFJlcXVlc3RzW29wdGlvbnMudXJsXSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3VycmVudFJlcXVlc3RzW29wdGlvbnMudXJsXSA9IHRydWU7XG5cbiAgICAvLyBtYWtlIHRoZSBzZXJ2ZXIgY2FsbFxuICAgICQuYWpheCh7XG4gICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgIHVybDogb3B0aW9ucy51cmwsXG4gICAgICAgIGFzeW5jOiAodHlwZW9mIG9wdGlvbnMuYXN5bmMgPT09ICd1bmRlZmluZWQnIHx8IG9wdGlvbnMuYXN5bmMgPT09IG51bGwpID8gdHJ1ZSA6IG9wdGlvbnMuYXN5bmMsXG4gICAgICAgIGRhdGE6IG9wdGlvbnMuZGF0YSB8fCB7fVxuICAgIH0pXG4gICAgLy8gc3VjY2Vzc1xuICAgIC5kb25lKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFjaykge1xuICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICB9KVxuICAgIC8vIGZhaWxlZFxuICAgIC5mYWlsKGZ1bmN0aW9uICh4aHIsIHRleHRTdGF0dXMpIHtcbiAgICAgICAgaWYgKHRleHRTdGF0dXMgPT09ICdwYXJzZXJlcnJvcicpIHtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFjaykge1xuICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgLy8gZXhlY3V0ZWQgb24gc3VjY2VzcyBvciBmYWlsXG4gICAgLmFsd2F5cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHJlbW92ZSBjdXJyZW50IHJlcXVlc3QgZnJvbSBoYXNoXG4gICAgICAgIGlmIChjdXJyZW50UmVxdWVzdHNbb3B0aW9ucy51cmxdKSB7XG4gICAgICAgICAgICBkZWxldGUgY3VycmVudFJlcXVlc3RzW29wdGlvbnMudXJsXTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAZGVzY3JpcHRpb24gYWpheCByZXF1ZXN0IHRvIGxvYWQgaHRtbCByZXNwb25zZSBpbiBhIGdpdmVuIGNvbnRhaW5lclxuICogQHBhcmFtIHtTdHJpbmd9IHVybCBVUkkgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSBOYW1lL1ZhbHVlIHBhaXIgZGF0YSByZXF1ZXN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFNlbGVjdG9yIG9yIGVsZW1lbnQgdGhhdCB3aWxsIHJlY2VpdmUgY29udGVudFxuICovXG52YXIgbG9hZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucy51cmwgPSB1dGlsLnRvQWJzb2x1dGVVcmwob3B0aW9ucy51cmwpO1xuICAgIC8vIHJldHVybiBpZiBubyB1cmwgZXhpc3RzIG9yIHVybCBtYXRjaGVzIGEgY3VycmVudCByZXF1ZXN0XG4gICAgaWYgKCFvcHRpb25zLnVybCB8fCBjdXJyZW50UmVxdWVzdHNbb3B0aW9ucy51cmxdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdXJyZW50UmVxdWVzdHNbb3B0aW9ucy51cmxdID0gdHJ1ZTtcblxuICAgIC8vIG1ha2UgdGhlIHNlcnZlciBjYWxsXG4gICAgJC5hamF4KHtcbiAgICAgICAgZGF0YVR5cGU6ICdodG1sJyxcbiAgICAgICAgdXJsOiB1dGlsLmFwcGVuZFBhcmFtVG9VUkwob3B0aW9ucy51cmwsICdmb3JtYXQnLCAnYWpheCcpLFxuICAgICAgICBkYXRhOiBvcHRpb25zLmRhdGEsXG4gICAgICAgIHhockZpZWxkczoge1xuICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KVxuICAgIC5kb25lKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICAgIGlmIChvcHRpb25zLnRhcmdldCkge1xuICAgICAgICAgICAgJChvcHRpb25zLnRhcmdldCkuZW1wdHkoKS5odG1sKHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFjaykge1xuICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICB9KVxuICAgIC5mYWlsKGZ1bmN0aW9uICh4aHIsIHRleHRTdGF0dXMpIHtcbiAgICAgICAgLy8gZmFpbGVkXG4gICAgICAgIGlmICh0ZXh0U3RhdHVzID09PSAncGFyc2VyZXJyb3InKSB7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhudWxsLCB0ZXh0U3RhdHVzKTtcbiAgICB9KVxuICAgIC5hbHdheXMoZnVuY3Rpb24gKCkge1xuICAgICAgICBwcm9ncmVzcy5oaWRlKCk7XG4gICAgICAgIC8vIHJlbW92ZSBjdXJyZW50IHJlcXVlc3QgZnJvbSBoYXNoXG4gICAgICAgIGlmIChjdXJyZW50UmVxdWVzdHNbb3B0aW9ucy51cmxdKSB7XG4gICAgICAgICAgICBkZWxldGUgY3VycmVudFJlcXVlc3RzW29wdGlvbnMudXJsXTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuZXhwb3J0cy5nZXRKc29uID0gZ2V0SnNvbjtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG4iLCIvKipcbiAqICAgIChjKSAyMDA5LTIwMTQgRGVtYW5kd2FyZSBJbmMuXG4gKiAgICBTdWJqZWN0IHRvIHN0YW5kYXJkIHVzYWdlIHRlcm1zIGFuZCBjb25kaXRpb25zXG4gKiAgICBGb3IgYWxsIGRldGFpbHMgYW5kIGRvY3VtZW50YXRpb246XG4gKiAgICBodHRwczovL2JpdGJ1Y2tldC5jb20vZGVtYW5kd2FyZS9zaXRlZ2VuZXNpc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gaWYgalF1ZXJ5IGhhcyBub3QgYmVlbiBsb2FkZWQsIGxvYWQgZnJvbSBnb29nbGUgY2RuXG5pZiAoIXdpbmRvdy5qUXVlcnkpIHtcbiAgICB2YXIgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIHMuc2V0QXR0cmlidXRlKCdzcmMnLCAnaHR0cHM6Ly9hamF4Lmdvb2dsZWFwaXMuY29tL2FqYXgvbGlicy9qcXVlcnkvMS43LjEvanF1ZXJ5Lm1pbi5qcycpO1xuICAgIHMuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvamF2YXNjcmlwdCcpO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQocyk7XG59XG5cbnJlcXVpcmUoJy4vanF1ZXJ5LWV4dCcpKCk7XG5yZXF1aXJlKCcuL2Nvb2tpZXByaXZhY3knKSgpO1xucmVxdWlyZSgnLi9jYXB0Y2hhJykoKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgVmFsaWRhdGlvblJ1bGVzID0gcmVxdWlyZSgnLi9WYWxpZGF0aW9uUnVsZXMnKTtcblxuZnVuY3Rpb24gaW5pdGlhbGl6ZUV2ZW50cygpIHtcbiAgICB2YXIgY29udHJvbEtleXMgPSBbJzgnLCAnMTMnLCAnNDYnLCAnNDUnLCAnMzYnLCAnMzUnLCAnMzgnLCAnMzcnLCAnNDAnLCAnMzknXTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIGZ1bmN0aW9uKCkge1xuXHQgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3cmFwcGVyJykuY2xhc3NMaXN0LnJlbW92ZSgnbWVudS1hY3RpdmUnKVxuXHQgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF0uY2xhc3NMaXN0LnJlbW92ZSgnbWVudS1hY3RpdmUnKVxuXHR9KVxuICAgIFxuICAgICQoXCJib2R5XCIpLm9uKFwiY2xpY2tcIiwgXCIuZGlhbG9naWZ5LCBbZGF0YS1kbGctb3B0aW9uc10sIFtkYXRhLWRsZy1hY3Rpb25dXCIsIGFwcC51dGlsLnNldERpYWxvZ2lmeSk7XG4gICAgJCgnYm9keScpXG4gICAgICAgIC5vbigna2V5ZG93bicsICd0ZXh0YXJlYVtkYXRhLWNoYXJhY3Rlci1saW1pdF0nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHRleHQgPSAkLnRyaW0oJCh0aGlzKS52YWwoKSksXG4gICAgICAgICAgICAgICAgY2hhcnNMaW1pdCA9ICQodGhpcykuZGF0YSgnY2hhcmFjdGVyLWxpbWl0JyksXG4gICAgICAgICAgICAgICAgY2hhcnNVc2VkID0gdGV4dC5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmICgoY2hhcnNVc2VkID49IGNoYXJzTGltaXQpICYmIChjb250cm9sS2V5cy5pbmRleE9mKGUud2hpY2gudG9TdHJpbmcoKSkgPCAwKSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkub24oJ2NsaWNrJywnI0JWUlJSYXRpbmdTdW1tYXJ5TGlua1JlYWRJRCcsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgJCh0aGlzKS5maW5kKCdhJykudG9nZ2xlQ2xhc3MoJ2FjdGl2ZScpLnJlbW92ZUF0dHIoJ29uY2xpY2snKTtcbiAgICAgICAgICAgICQoJyNCVlJSRGlzcGxheUNvbnRlbnRJRCcpLnRvZ2dsZUNsYXNzKCdvcGVuJyk7XG5cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdjaGFuZ2Uga2V5dXAgbW91c2V1cCcsICd0ZXh0YXJlYVtkYXRhLWNoYXJhY3Rlci1saW1pdF0nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9ICQudHJpbSgkKHRoaXMpLnZhbCgpKSxcbiAgICAgICAgICAgICAgICBjaGFyc0xpbWl0ID0gJCh0aGlzKS5kYXRhKCdjaGFyYWN0ZXItbGltaXQnKSxcbiAgICAgICAgICAgICAgICBjaGFyc1VzZWQgPSB0ZXh0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICBjaGFyc1JlbWFpbiA9IGNoYXJzTGltaXQgLSBjaGFyc1VzZWQ7XG5cbiAgICAgICAgICAgIGlmIChjaGFyc1JlbWFpbiA8IDApIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLnZhbCh0ZXh0LnNsaWNlKDAsIGNoYXJzUmVtYWluKSk7XG4gICAgICAgICAgICAgICAgY2hhcnNSZW1haW4gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkKHRoaXMpLm5leHQoJ2Rpdi5jaGFyLWNvdW50JykuZmluZCgnLmNoYXItcmVtYWluLWNvdW50JykuaHRtbChjaGFyc1JlbWFpbik7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignY2hhbmdlJywgJyNyZWdpc3RyeS1zZWFyY2gtY29udGFpbmVyIHNlbGVjdCcsIGZ1bmN0aW9uICgpe1xuICAgICAgICBcdGlmICgkKHRoaXMpLnZhbCgpKSB7XG4gICAgICAgIFx0XHQkKHRoaXMpLnBhcmVudCgpLmFkZENsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgICBcdH0gZWxzZSB7XG4gICAgICAgIFx0XHQkKHRoaXMpLnBhcmVudCgpLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgICBcdH1cbiAgICAgICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBpbml0aWFsaXplIHNlYXJjaCBzdWdnZXN0aW9ucywgcGVuZGluZyB0aGUgdmFsdWUgb2YgdGhlIHNpdGUgcHJlZmVyZW5jZShlbmhhbmNlZFNlYXJjaFN1Z2dlc3Rpb25zKVxuICAgICAqIHRoaXMgd2lsbCBlaXRoZXIgaW5pdCB0aGUgbGVnYWN5KGZhbHNlKSBvciB0aGUgYmV0YSB2ZXJzaW9ucyh0cnVlKSBvZiB0aGUgdGhlIHNlYXJjaCBzdWdnZXN0IGZlYXR1cmUuXG4gICAgICogKi9cbiAgICB2YXIgJHNlYXJjaENvbnRhaW5lciA9ICQoJyNuYXZpZ2F0aW9uIC5oZWFkZXItc2VhcmNoJyk7XG4gICAgc2VhcmNoc3VnZ2VzdC5pbml0KCRzZWFyY2hDb250YWluZXIsIFJlc291cmNlcy5TSU1QTEVfU0VBUkNIKTtcbiAgICB2YXIgJHNlYXJjaENvbnRhaW5lck1vYmlsZSA9ICQoJyNuYXZpZ2F0aW9uIC5oZWFkZXItc2VhcmNoLW1vYmlsZScpO1xuICAgIHZhciAkbW9iaWxlU2VhcmNoSW5wdXQgPSAkc2VhcmNoQ29udGFpbmVyTW9iaWxlLmZpbmQoJyNxJyk7XG4gICAgdmFyICRtb2JpbGVTZWFyY2hJbnB1dFBsYWNlaG9sZGVyID0gJG1vYmlsZVNlYXJjaElucHV0LmF0dHIoJ3BsYWNlaG9sZGVyJyk7XG4gICAgc2VhcmNoc3VnZ2VzdC5pbml0KCRzZWFyY2hDb250YWluZXJNb2JpbGUsIFJlc291cmNlcy5TSU1QTEVfU0VBUkNIKTtcbiAgICBcbiAgICAkbW9iaWxlU2VhcmNoSW5wdXQuYmx1cihmdW5jdGlvbigpe1xuICAgIFx0aWYoJCh0aGlzKS5hdHRyKCdwbGFjZWhvbGRlcicpID09ICcnKXtcbiAgICBcdFx0JCh0aGlzKS5hdHRyKCdwbGFjZWhvbGRlcicsJG1vYmlsZVNlYXJjaElucHV0UGxhY2Vob2xkZXIpO1xuICAgIFx0fVxuXHR9KTtcbiAgICBcbiAgICAkbW9iaWxlU2VhcmNoSW5wdXQuZm9jdXMoZnVuY3Rpb24oKXtcblx0XHQkKHRoaXMpLmF0dHIoJ3BsYWNlaG9sZGVyJywnJyk7XG5cdH0pO1xuICAgIC8vIGFkZCBzaG93L2hpZGUgbmF2aWdhdGlvbiBlbGVtZW50c1xuICAgICQoJy5zZWNvbmRhcnktbmF2aWdhdGlvbiAudG9nZ2xlJykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAkKHRoaXMpLnRvZ2dsZUNsYXNzKCdvcGVuJykubmV4dCgnZGl2Jykuc2xpZGVUb2dnbGUoeydkdXJhdGlvbic6IDIwMCwnZWFzaW5nJzonbGluZWFyJ30pO1xuICAgIH0pO1xuXG4gICAgJCgnLm1vYmlsZS1hY2NvdW50LW5hdiAuc2Vjb25kYXJ5LW5hdmlnYXRpb24gLm5hdi1oZWFkZXInKS5jbGljayhmdW5jdGlvbiAoZSkge1xuICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgJCh0aGlzKS50b2dnbGVDbGFzcygnZXhwYW5kZWQnKS5uZXh0KCd1bCcpLnRvZ2dsZSgpO1xuICAgICB9KTtcblxuICAgICQoJy5hY2NvdW50LW5hdi1hc3NldCAuaGVscC1uYXYtaGVhZGVyLCAuY3VzdG9tZXItc2VydmljZS1tb2JpbGUtbmF2LWFzc2V0IC5oZWxwLW5hdi1oZWFkZXInKS5jbGljayhmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmKHdpbmRvdy5pbm5lcldpZHRoIDwgOTU5KXtcbiAgICAgICAgICAgICQodGhpcykudG9nZ2xlQ2xhc3MoJ2V4cGFuZGVkJykubmV4dCgnLmFjY291bnQtaGVscC1uYXYtY29udGVudCcpLnRvZ2dsZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKiBkcmF3ZXIgdG9nZ2xlIGZ1bmN0aW9uYWxpdHkgKi9cbiAgICAkKCcuZHJhd2VyIGxhYmVsJykub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgZHJhd2VyID0gJCh0aGlzKS5jbG9zZXN0KCcuZHJhd2VyJyk7XG4gICAgICAgIGRyYXdlci50b2dnbGVDbGFzcygnb3BlbicpO1xuICAgICAgICBkcmF3ZXIuZmluZCgnLmRyYXdlci1jb250ZW50Jykuc2xpZGVUb2dnbGUoKTtcbiAgICB9KTtcbiAgICAkKCcuc2VsZWN0LXNoaXBwaW5nLW1ldGhvZCBpbnB1dFt0eXBlPVwicmFkaW9cIl0nKS5vbignY2hhbmdlJywgZnVuY3Rpb24gKGUpIHtcbiAgICBcdCQoJy5zZWxlY3Qtc2hpcHBpbmctbWV0aG9kIC5mb3JtLXJvdycpLnJlbW92ZUNsYXNzKCdyYWRpby1idXR0b24tc2VsZWN0ZWQnKTtcbiAgICBcdCQodGhpcykucGFyZW50KCkuYWRkQ2xhc3MoJ3JhZGlvLWJ1dHRvbi1zZWxlY3RlZCcpO1xuICAgIH0pO1xuXG4gICAgLy8gYWRkIGdlbmVyaWMgdG9nZ2xlIGZ1bmN0aW9uYWxpdHlcbiAgICAkKCcudG9nZ2xlJykubmV4dCgnLnRvZ2dsZS1jb250ZW50JykuaGlkZSgpO1xuICAgICQoJy50b2dnbGUnKS5jbGljayhmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmKCEoJCh0aGlzKS5wYXJlbnQoJy5zZWNvbmRhcnktbmF2aWdhdGlvbicpLmxlbmd0aCkpe1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgJCh0aGlzKS50b2dnbGVDbGFzcygnZXhwYW5kZWQnKS5uZXh0KCcudG9nZ2xlLWNvbnRlbnQnKS50b2dnbGUoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ3VzdG9tZXIgc2VydmljZSBtb2JpbGUgbmF2aWdhdGlvblxuICAgIHZhciBjdXN0b21lclNlcnZpY2VBY3RpdmVMaW5rID0gJCgnLnB0X2N1c3RvbWVyLXNlcnZpY2UgLnNlY29uZGFyeS1uYXZpZ2F0aW9uIGEuYWN0aXZlLWxpbmsnKTtcbiAgICB2YXIgY3VzdG9tZXJTZXJ2aWNkZU1vYmlsZU5hdiA9ICQoJy5wdF9jdXN0b21lci1zZXJ2aWNlIC5jdXN0b21lci1zZXJ2aWNlLW1vYmlsZS1uYXYnKTtcbiAgICBpZiAoY3VzdG9tZXJTZXJ2aWNlQWN0aXZlTGluay5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHRvZ2dsZUxpbmsgPSBjdXN0b21lclNlcnZpY2VBY3RpdmVMaW5rLmNsb25lKCk7XG4gICAgICAgIGN1c3RvbWVyU2VydmljZGVNb2JpbGVOYXYuZmluZCgnLmN1c3RvbWVyLXNlcnZpY2UtbW9iaWxlLW5hdi10b2dnbGUnKVxuICAgICAgICAgICAgLmVtcHR5KClcbiAgICAgICAgICAgIC5hcHBlbmQodG9nZ2xlTGluayk7XG4gICAgICAgIGN1c3RvbWVyU2VydmljZUFjdGl2ZUxpbmsucGFyZW50KCcuY29udGVudCcpXG4gICAgICAgICAgICAuY2hpbGRyZW4oKVxuICAgICAgICAgICAgLmNsb25lKClcbiAgICAgICAgICAgIC5hcHBlbmRUbyhjdXN0b21lclNlcnZpY2RlTW9iaWxlTmF2LmZpbmQoJy5jdXN0b21lci1zZXJ2aWNlLW1vYmlsZS1uYXYtaXRlbXMnKSk7XG4gICAgfSBlbHNlIGlmIChjdXN0b21lclNlcnZpY2RlTW9iaWxlTmF2Lmxlbmd0aCkge1xuICAgICAgICBjdXN0b21lclNlcnZpY2RlTW9iaWxlTmF2LmZpbmQoJy5jdXN0b21lci1zZXJ2aWNlLW1vYmlsZS1uYXYtZHJvcGRvd24nKS5oaWRlKCk7XG4gICAgfVxuXG4gICAgJCgnLnB0X2N1c3RvbWVyLXNlcnZpY2UgLmN1c3RvbWVyLXNlcnZpY2UtbW9iaWxlLW5hdi10b2dnbGUnKS5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgJCh0aGlzKS50b2dnbGVDbGFzcygnZXhwYW5kZWQnKVxuICAgICAgICAgICAgLm5leHQoJy5jdXN0b21lci1zZXJ2aWNlLW1vYmlsZS1uYXYtaXRlbXMnKVxuICAgICAgICAgICAgLnRvZ2dsZSgpO1xuICAgIH0pO1xuXG4gICAgLy8gc3Vic2NyaWJlIGVtYWlsIGJveFxuICAgIHZhciAkc3Vic2NyaWJlRW1haWwgPSAkKCcuc3Vic2NyaWJlLWVtYWlsJyk7XG4gICAgaWYgKCRzdWJzY3JpYmVFbWFpbC5sZW5ndGggPiAwKSAgICB7XG4gICAgICAgICRzdWJzY3JpYmVFbWFpbC5mb2N1cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gJCh0aGlzLnZhbCgpKTtcbiAgICAgICAgICAgIGlmICh2YWwubGVuZ3RoID4gMCAmJiB2YWwgIT09IFJlc291cmNlcy5TVUJTQ1JJQkVfRU1BSUxfREVGQVVMVCkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZG8gbm90IGFuaW1hdGUgd2hlbiBjb250YWlucyBub24tZGVmYXVsdCB2YWx1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkKHRoaXMpLmFuaW1hdGUoe2NvbG9yOiAnIzk5OTk5OSd9LCA1MDAsICdsaW5lYXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS52YWwoJycpLmNzcygnY29sb3InLCAnIzMzMzMzMycpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmJsdXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZhbCA9ICQudHJpbSgkKHRoaXMudmFsKCkpKTtcbiAgICAgICAgICAgIGlmICh2YWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZG8gbm90IGFuaW1hdGUgd2hlbiBjb250YWlucyB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJCh0aGlzKS52YWwoUmVzb3VyY2VzLlNVQlNDUklCRV9FTUFJTF9ERUZBVUxUKVxuICAgICAgICAgICAgICAgIC5jc3MoJ2NvbG9yJywgJyM5OTk5OTknKVxuICAgICAgICAgICAgICAgIC5hbmltYXRlKHtjb2xvcjogJyMzMzMzMzMnfSwgNTAwLCAnbGluZWFyJyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgICQoJy5wcml2YWN5LXBvbGljeScpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIHdpZHRoO1xuICAgICAgICB2YXIgJGJvZHkgPSAkKCdib2R5Jyk7XG4gICAgICAgIGlmICgkYm9keS53aWR0aCgpIDwgOTYwKSB7XG4gICAgICAgICAgICB3aWR0aCA9ICRib2R5LndpZHRoKCkgLSA0MDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpZHRoID0gODAwO1xuICAgICAgICB9XG4gICAgICAgIGRpYWxvZy5vcGVuKHtcbiAgICAgICAgICAgIHVybDogJChlLnRhcmdldCkuYXR0cignaHJlZicpLFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgXHRkaWFsb2dDbGFzczogJ3ByaXZhY3ktcG9saWN5LWRpYWxvZycsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA2MDAsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgICQoJy5oZWFkZXItaGVscC1zcGFuJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkaWFsb2cub3Blbih7XG4gICAgICAgICAgICB1cmw6ICQoZS50YXJnZXQpLmF0dHIoJ2hyZWYnKSxcbiAgICAgICAgICAgIHdpZHRoOiAzNzUsXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDM3NSxcbiAgICAgICAgICAgICAgICBkaWFsb2dDbGFzczogJ2hlbHAtd2lkZ2V0LWthdGVzcGFkZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAkKCdib2R5Jykub24oJ2NsaWNrJywgJy5ndWVzdC1vcmRlcicsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gJCh0aGlzKS5hdHRyKCdkYXRhLXVybCcpO1xuICAgICAgICAgICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwgKyAnP2Zvcm1hdD1hamF4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBhcHAudmFsaWRhdG9yLmluaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGlhbG9nLm9wZW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlT25Fc2NhcGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogNjY4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogeyBteTogXCJjZW50ZXJcIiwgYXQ6IFwiY2VudGVyXCIsIG9mOiB3aW5kb3cgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlhbG9nQ2xhc3M6ICdwb3B1cC1ndWVzdGhpc3RvcnknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbGlkYXRpb25SdWxlcyA9IG5ldyBWYWxpZGF0aW9uUnVsZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnI2R3ZnJtX2d1ZXN0aGlzdG9yeScpLnZhbGlkYXRlKHZhbGlkYXRpb25SdWxlcy5ndWVzdE9yZGVyRm9ybVJ1bGVzKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdGxhYmVscy5pbml0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBtYWluIG1lbnUgdG9nZ2xlXG4gICAgJCgnLm1lbnUtdG9nZ2xlJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAkKCcjd3JhcHBlcicpLnRvZ2dsZUNsYXNzKCdtZW51LWFjdGl2ZScpO1xuICAgICAgICAkKCdib2R5JykudG9nZ2xlQ2xhc3MoJ21lbnUtYWN0aXZlJyk7XG4gICAgfSk7XG4gICAgJCgnLm5hdmlnYXRpb24tb3ZlcmxheScpLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJCgnI3dyYXBwZXInKS50b2dnbGVDbGFzcygnbWVudS1hY3RpdmUnKTtcbiAgICAgICAgJCgnYm9keScpLnRvZ2dsZUNsYXNzKCdtZW51LWFjdGl2ZScpO1xuICAgIH0pO1xuICAgICQoJy5tZW51LWNhdGVnb3J5IGxpIC5tZW51LWl0ZW0tdG9nZ2xlJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgJHBhcmVudExpID0gJChlLnRhcmdldCkuY2xvc2VzdCgnbGknKTtcbiAgICAgICAgJHBhcmVudExpLnNpYmxpbmdzKCdsaScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKS5maW5kKCcubWVudS1pdGVtLXRvZ2dsZScpLnJlbW92ZUNsYXNzKCdmYS1taW51cyBhY3RpdmUnKS5hZGRDbGFzcygnZmEtY2hldnJvbi1yaWdodCcpO1xuICAgICAgICAkcGFyZW50TGkudG9nZ2xlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAkKGUudGFyZ2V0KS50b2dnbGVDbGFzcygnZmEtY2hldnJvbi1yaWdodCBmYS1taW51cyBhY3RpdmUnKTtcbiAgICB9KTtcblxuICAgIC8vIG1haW4gbWVudSBtb2JpbGUgZm9jdXMgb24gY2xpY2tcbiAgICAkKCcubWVudS1jYXRlZ29yeS5sZXZlbC0xIC5tZW51LWl0ZW0tdG9nZ2xlJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBPbmx5IHJ1biB3aGVuIGEgY2xvc2VkIG1lbnUgaXMgb3BlbmVkXG4gICAgICAgIGlmICgkKHRoaXMpLmhhc0NsYXNzKCdhY3RpdmUnKSkge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBlbGVtZW50IG9mZnNldCBmcm9tIGJvZHkgYW5kIGN1cnJlbnQgbmF2aWdhdGlvbiBzY3JvbGwgcG9zaXRpb25cbiAgICAgICAgICAgIHZhciBwb3MgPSAkKHRoaXMpLm9mZnNldCgpLnRvcCArICQoJyNuYXZpZ2F0aW9uJykuc2Nyb2xsVG9wKCk7XG5cbiAgICAgICAgICAgICQoJyNuYXZpZ2F0aW9uJykuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgICAgc2Nyb2xsVG9wOiBwb3NcbiAgICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEFjY291bnQgbG9naW4gLyBzaWdudXAgZmx5b3V0XG5cbiAgICB2YXIgY3VzdG9tZXJJbmZvVXJsID0gVXJscy5pbmNsdWRlSGVhZGVyQ3VzdG9tZXJJbmZvO1xuICAgIHZhciByaWdodEhlYWRlckxpbmtzID0gJCgnLnJpZ2h0LWhlYWRlci1saW5rcycpO1xuICAgIHZhciBtb2JpbGVTaWduSW4gPSAkKCcjbW9iaWxlLXNpZ25pbicpO1xuXG4gICAgLy8gTG9naW4gdG91Y2ggZXZlbnRcbiAgICAkKCdib2R5Jykub24oJ3RvdWNoZW5kJywgJy5yaWdodC1oZWFkZXItbGlua3MgLmFjY291bnQtbGluayA+IGEnICxmdW5jdGlvbihlKXtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAoISQodGhpcykuaGFzQ2xhc3MoJ29wZW4nKSl7XG4gICAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKCdvcGVuJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9ICQodGhpcykuYXR0cignaHJlZicpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBBY2NvdW50IFByb3RlY3RlZCBMaW5rc1xuICAgICQoJy5wcm90ZWN0ZWQnKS5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICQoJyN0b3AtYmFubmVyLWludGVyaW9yIC5hY2NvdW50LWxpbmstbG9naW4gYS51c2VyLWxvZ2luLWhvcHVwJykuY2xpY2soKTtcbiAgICB9KTtcblxuICAgIC8vIER5bmFtaWNhbGx5IHB1bGwgQWNjb3VudCBMaW5rIGludG8gaGVhZGVyIHZpYSBhamF4IHRvIHJlcGxhY2UgcmVtb3RlIGluY2x1ZGVzIG9uIGhlYWRlci5pc21sXG4gICAgYXBwLmFqYXgubG9hZCh7XG4gICAgICAgIHVybDpjdXN0b21lckluZm9VcmwsXG4gICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAodXJsKXtcbiAgICAgICAgICAgIHJpZ2h0SGVhZGVyTGlua3MuZmluZCgnLnNlYXJjaC10b2dnbGUnKS5hZnRlcih1cmwpO1xuICAgICAgICAgICAgbW9iaWxlU2lnbkluLmFwcGVuZCh1cmwpO1xuICAgICAgICAgICAgYXBwLmhvcHVwUmVnaXN0ZXJMb2dpbi5pbml0KCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFwcC5ob3B1cFJlZ2lzdGVyTG9naW4gPSB7XG4gICAgICAgIHNob3dIb3B1cCA6IGZ1bmN0aW9uKGhvcHVwKXtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSAkKGhvcHVwKTtcbiAgICAgICAgICAgIHZhciBkbGc7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSAod2luZG93LmlubmVyV2lkdGggPCA3MDgpID8gKHdpbmRvdy5pbm5lcldpZHRoIC0gNDApLnRvU3RyaW5nKCkgOiAnNjY4JztcbiAgICAgICAgICAgIGlmICgod2luZG93LmlubmVyV2lkdGggPiA3MDcpICYmICh3aW5kb3cuaW5uZXJXaWR0aCA8IDk2MCkpXG4gICAgICAgICAgICAgICAgd2lkdGggPSAnNDc2J1xuICAgICAgICAgICAgaWYgKChob3B1cCA9PSBcIiNwb3B1cC1yZWdpc3RlclwiIHx8IGhvcHVwID09IFwiI3BvcHVwLWd1ZXN0aGlzdG9yeVwiKSAmJiB0YXJnZXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIEhpZGUgb3RoZXIgaW5zdGFuY2VzIG9mIHRoZSBkaWFsb2dcbiAgICAgICAgICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAvLyBEaXNwbGF5IHRoZSB0YXJnZXRcbiAgICAgICAgICAgICAgICB0YXJnZXQuc2hvdygpO1xuICAgICAgICAgICAgICAgIC8vIFdyYXAgdGFyZ2V0IGluIHVpLWRpYWxvZyBkaXZcbiAgICAgICAgICAgICAgICBkbGcgPSBhcHAuZGlhbG9nLmNyZWF0ZSh7IFwidGFyZ2V0XCIgOiB0YXJnZXQsIFwib3B0aW9uc1wiIDogeyd3aWR0aCcgOiB3aWR0aCwgJ2hlaWdodCcgOiAnYXV0bycsICdkaWFsb2dDbGFzcycgOiAnY3JlYXRlLWFjY291bnQnfSB9KTtcbiAgICAgICAgICAgICAgICAvLyBpZiBkaWFsb2cgaXMgb3BlbiwgcmV0dXJuXG4gICAgICAgICAgICAgICAgaWYoZGxnLmRpYWxvZyhcImlzT3BlblwiKSkge3JldHVybjt9XG4gICAgICAgICAgICAgICAgLy8gZWxzZSwgc2hvdyB0aGUgZGlhbG9nXG4gICAgICAgICAgICAgICAgZGxnLmRpYWxvZyhcIm9wZW5cIik7XG4gICAgICAgICAgICAgICAgdmFyIHRvcE9mZnNldCA9ICh3aW5kb3cuaW5uZXJXaWR0aCA8IDcwOCkgPyA1MCA6ICgod2luZG93LmlubmVyV2lkdGggLSA3MDgpIC8gMikgKyA1MDtcbiAgICAgICAgICAgICAgICBpZiAodG9wT2Zmc2V0ID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcE9mZnNldCA9IDEwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9wT2Zmc2V0ID0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpICsgdG9wT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGZsb2F0bGFiZWxzLmluaXQoKTtcbiAgICAgICAgICAgICAgICAkKCcudWktZGlhbG9nJykuY3NzKCd0b3AnLCB0b3BPZmZzZXQudG9TdHJpbmcoKSArICdweCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnNsaWRlRG93bigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOb25lIEhUTUw1IGlucHV0c1xuICAgICAgICAgICAgdmFyIGZvcm0gPSB0YXJnZXQuZmluZCgnZm9ybSNkd2ZybV9sb2dpbicpO1xuICAgICAgICAgICAgaWYoZm9ybS5sZW5ndGgpe1xuICAgICAgICAgICAgICAgIHZhbGlkYXRvci5pbml0KCk7XG4gICAgICAgICAgICAgICAgLy9mb3JtLmZpbmQoJ2lucHV0W3BsYWNlaG9sZGVyXScpLnBsYWNlaG9sZGVyKCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdCA6IGZ1bmN0aW9uKHRhcmdldCl7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PSAndW5kZWZpbmVkJyB8fCAhdGFyZ2V0KXtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSAkKCdib2R5Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gJCh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUcmlnZ2VyIExPR0lOL1JFR0lTVEVSIGJ1dHRvbiB0byBzaG93IGhvcHVwIG9uIGNsaWNrIGJ5IHNhdmUgZm9yIGxhdGVyIGxvZ2luIGxpbmtcbiAgICAgICAgICAgICQoJ2h0bWwgYm9keScpLm9uKCdjbGljaycsICcuc2F2ZWZvcmxhdGVyLWxvZ2luJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgLy8gc2Nyb2xsIHRvIHRoZSB0b3Agb24gbW9iaWxlIGRldmljZXMgdG8gYmUgY29uc2lzdGVudFxuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA8PSA5NjApIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkKCcuaGVhZGVyLWxpbmtzIC5qcy11c2VyLWxvZ2luLWhvcHVwLXRyaWdnZXInKS50cmlnZ2VyKCdjbGljaycpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEhFQURFUiBMT0dJTi9SRUdJU1RFUiBCVVRUT05TIENMSUNLXG4gICAgICAgICAgICB0YXJnZXQuZmluZCgnYS51c2VyLWxvZ2luLWhvcHVwLCBhLnVzZXItcmVnaXN0ZXItaG9wdXAnKS5vbignY2xpY2snLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBcdHZhciBsaW5rID0gJCh0aGlzKTtcbiAgICAgICAgICAgICAgICB2YXIgcG9wdXAgPSBsaW5rLmF0dHIoJ2hyZWYnKTtcbiAgICAgICAgICAgICAgICB2YXIgc2hvdyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGNsaWNrZWQgZnJvbSBoYW1idXJnZXIgbmF2XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5rLmNsb3Nlc3QoJyNtb2JpbGUtc2lnbmluJykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKCcjd3JhcHBlcicpLnRvZ2dsZUNsYXNzKCdtZW51LWFjdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgnYm9keScpLnRvZ2dsZUNsYXNzKCdtZW51LWFjdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvdyB0aGUgaG9wdXBcbiAgICAgICAgICAgICAgICAgICAgYXBwLmhvcHVwUmVnaXN0ZXJMb2dpbi5zaG93SG9wdXAocG9wdXApO1xuICAgICAgICAgICAgICAgICAgICBsb2dpbi5pbml0KCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmICgkKHBvcHVwKS5sZW5ndGggPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gJCgnPGRpdi8+Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5rLmhhc0NsYXNzKCd1c2VyLWxvZ2luLWhvcHVwJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQuYWRkQ2xhc3MoJ2xvZ2luLXRyYXknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3B1cCA9PT0gJyNwb3B1cC1yZWdpc3RlcicgfHwgcG9wdXAgPT09IFwiI3BvcHVwLWd1ZXN0aGlzdG9yeVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXIgPSAkKCcudG9wLWJhbm5lcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyLmJlZm9yZShkKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgbG9naW4gdHJheSBuZWVkcyB0byBiZSBzdGlja3kgb24gaW5pdGlhbCBsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGVyLmhhc0NsYXNzKCdzdGlja3knKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQuYWRkQ2xhc3MoJ3N0aWNreScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgnYm9keScpLmFwcGVuZChkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcHAuYWpheC5sb2FkKHt1cmw6bGluay5kYXRhKCd1cmwnKSwgdGFyZ2V0OmQsIGNhbGxiYWNrOmZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwLmhvcHVwUmVnaXN0ZXJMb2dpbi5pbml0KGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5maW5kKCcubG9naW4tdHJheS1jbG9zZScpLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQocG9wdXApLnNsaWRlVXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3B1c2ggYWNjb3VudCBjcmVhdGlvbiB0byBkYXRhTGF5ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJyNkd2ZybV9yZWdpc3RlcicpLm9uKCdzdWJtaXQnLGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhTGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUxheWVyLnB1c2goYXBwLmRhdGFsYXllci5nZXRFdmVudChcImV2ZW50XCIsIFwiYWNjb3VudC1jcmVhdGlvblwiLCBcInR5cGVcIiwgXCJLYXRlIFNwYWRlXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlc3QgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9kYXRhTGF5ZXIucHVzaCh7XCJldmVudFwiIDogXCJhY2NvdW50LWNyZWF0aW9uXCIsIFwidHlwZVwiIDogXCJLYXRlIFNwYWRlXCIgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9wdXNoIGVtYWlsIHNpZ251cCB0byBkYXRhTGF5ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQoXCIjZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9hZGR0b2VtYWlsbGlzdFwiKS5pcyhcIjpjaGVja2VkXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhTGF5ZXIucHVzaChhcHAuZGF0YWxheWVyLmdldEV2ZW50KFwiZXZlbnRcIiwgXCJlbWFpbC1zdWJzY3JpYmVcIiwgXCJzdWJzY3JpYmVUeXBlXCIsIFwiYWNjb3VudENyZWF0ZVwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2RhdGFMYXllci5wdXNoKHtcImV2ZW50XCIgOiBcImVtYWlsLXN1YnNjcmliZVwiLCBcInN1YnNjcmliZVR5cGVcIjogXCJhY2NvdW50Q3JlYXRlXCJ9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBMb29rVXBVc2VyTmFtZShmaWVsZElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTG9va1VwVXNlck5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEuIERldGVybWluZXMgaWYgYSB1c2VyIGFscmVhZHkgZXhpc3RzIGJhc2VkIG9uIHRoZSB0aGUgZW1haWwgYWRkcmVzcyBwcm92aWRlZCBpbiB0aGUgY3VycmVudCBmaWVsZCB3aGljaCBpcyB0aGUgb25seS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIuICMxIG9jY3VycyB2aWEgYW4gQUpBWCBjYWxsIHRvIHRoZSBwaXBlbGluZSBBY2NvdW50LUxvZ2luTG9va3VwIHV0aWxpemluZyB0aGUgYXBwcmVzb3VyY2VzLmlzbWwgVVJMIEFjY291bnRMb2dpbkNoZWNrIChhcHAudXJscy5BY2NvdW50TG9naW5DaGVjaykuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBUaGlzIHBpcGVsaW5lIHdpbGwgbG9vayBvbiB0aGUgSHR0cFBhcmFtZXRlck1hcCBmb3IgdGhlIHBhc3NlZCBlbWFpbCBhZGRyZXNzIGNvbWluZyBmcm9tIHRoZSBjdXJyZW50IGZvcm0uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBJdCB0aGVuIGNoZWNrcyBpZiB0aGUgY3VzdG9tZXIgZXhpc3RzIHZpYSB0aGUgR2V0Q3VzdG9tZXIgcGlwZWxldC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIElGIHRoZSBwaXBsZXQgZG9lcyBub3QgcmV0dXJuIGFuIGVycm9yICh0aGlzIG1lYW5zIHRoZSB1c2VyIGV4aXN0cyksIGFuZCBlcnJvcmpzb24uaXNtbCBpcyByZXR1cm5lZCB3aXRoaW4gdGhlIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gT1RIRVJXSVNFLCB1dGlsL3N1Y2Nlc3Nqc29uIGlzIHJldHVybmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCdib2R5Jykub24oJ2JsdXInLCBmaWVsZElkICxmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZW1haWwgYWRkcmVzcyBmaWVsZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVtYWlsQWNjb3VudExvb2t1cCA9ICQoZmllbGRJZCk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIGVtYWlsIGFkZHJlc3MgZXhpc3RzIGFuZCBoYXMgYSBtaW51bXVtIG9mIHRocmVlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbWFpbEFjY291bnRMb29rdXAubGVuZ3RoID4gMCAgJiYgZW1haWxBY2NvdW50TG9va3VwLnZhbCgpLmxlbmd0aCA+IDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmICQoZmllbGRJZCkuaGFzQ2xhc3MoJ3ZhbGlkJykpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBlbWFpbCBhZGRyZXNzIGVudGVyZWQgYnkgdGhlIHVzZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW1haWxUb0xvb2t1cCA9IGVtYWlsQWNjb3VudExvb2t1cC52YWwoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBJZCBvZiB0aGUgRE9NIGVsZW1lbnQgZW1haWxBY2NvdW50TG9va3VwLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVtYWlsQWNjb3VudExvb2t1cElEID0gZW1haWxBY2NvdW50TG9va3VwLmF0dHIoJ2lkJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgdXNlciBlbWFpbCBhZGRyZXNzIHRvIHRoZSBwYXJhbXMgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGJlIHNlbnQgYXMgYSBxdWVyeSBzdHJpbmcgcGFyYW0gaW4gdGhlIEFKQVhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgdG8gZm9sbG93LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtlbWFpbCA6IGVtYWlsVG9Mb29rdXB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHAuYWpheC5nZXRKc29uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFVybHMuQWNjb3VudExvZ2luQ2hlY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihkYXRhICYmIGRhdGEuc3VjY2Vzcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBleGlzdHMgYSB1c2VyIHdpdGggdGhlIHN1cHBsaWVkIGVtYWlsIGFkZHJlc3MgLyB1c2VybmFtZS5cblxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgbmVjZXNzYXJ5IERPTSBlbGVtZW50cyAvIGF0dHJpYnV0ZSBmb3IgalF1ZXJ5IFZhbGlkYXRlIHB1cnBvc2VzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1haWxBY2NvdW50TG9va3VwLnJlbW92ZUNsYXNzKCd2YWxpZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1haWxBY2NvdW50TG9va3VwLmFkZENsYXNzKCdlcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1haWxBY2NvdW50TG9va3VwLnNpYmxpbmdzKCdzcGFuJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ3ZhbGlkJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaHRtbChSZXNvdXJjZXMuSU5WQUxJRF9VU0VSTkFNRVRBS0VOKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoJChcIiNkd2ZybV9ndWVzdGhpc3RvcnlcIikudmFsaWRhdGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXCIjZHdmcm1fZ3Vlc3RoaXN0b3J5XCIpLnZhbGlkYXRlKCkuc2V0dGluZ3MuaWdub3JlPVwiKlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBkaXNhYmxlZCBhdHRyaWJ1dGUgb24gdGhlIFN1Ym1pdCBidXR0b24gc28gdGhlIHVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbm5vdCBzdWJtaXQgc2luY2UgdGhpcyB1c2VyIG5hbWUgLyBlbWFpbGwgYWRkcmVzcyBhbHJlYWR5IGV4aXN0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXCIjZHdmcm1fcmVnaXN0ZXJcIikuZmluZChcIi5hcHBseS1idXR0b25cIikucHJvcCgnZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIERPRVMgTk9UIGV4aXN0IGEgdXNlciB3aXRoIHRoZSBzdXBwbGllZCBlbWFpbCBhZGRyZXNzIC8gdXNlcm5hbWUuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBlcnJvciBtZXNzYWdpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtYWlsQWNjb3VudExvb2t1cC5yZW1vdmVDbGFzcygnZXJyb3InKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtYWlsQWNjb3VudExvb2t1cC5hZGRDbGFzcygndmFsaWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtYWlsQWNjb3VudExvb2t1cC5zaWJsaW5ncygnc3BhbicpLmFkZENsYXNzKCd2YWxpZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGRpc2FibGVkIGF0dHJpYnV0ZSBvZmYgb2YgdGhlIHN1Ym1pdCBidXR0b24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFwiI2R3ZnJtX3JlZ2lzdGVyXCIpLmZpbmQoXCIuYXBwbHktYnV0dG9uXCIpLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGVGaWVsZHMgPSBbXCIjZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aE1vbnRoXCIsIFwiI2R3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfYmlydGhEYXlcIiwgXCIjZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aFllYXJcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAkKCcjZHdmcm1fcmVnaXN0ZXInKS52YWxpZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGU6IFwiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aE1vbnRoIGR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfYmlydGhEYXkgZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aFllYXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2JpcnRoTW9udGhcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlkYXRlOiBkYXRlRmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aERheVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWRhdGU6IGRhdGVGaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2JpcnRoWWVhclwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWRhdGU6IGRhdGVGaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2VtYWlsY29uZmlybVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcXVhbFRvOiBcIiNkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2VtYWlsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkd2ZybV9wcm9maWxlX2xvZ2luX3Bhc3N3b3JkXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlbGVuZ3RoOiBbNywgMjBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZHdmcm1fcHJvZmlsZV9sb2dpbl9wYXNzd29yZGNvbmZpcm1cIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXF1YWxUbzogXCIjZHdmcm1fcHJvZmlsZV9sb2dpbl9wYXNzd29yZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9maXJzdG5hbWVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFJlc291cmNlcy5NSVNTSU5HX0ZJUlNUX05BTUVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2xhc3RuYW1lXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBSZXNvdXJjZXMuTUlTU0lOR19MQVNUX05BTUVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2VtYWlsXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBSZXNvdXJjZXMuTUlTU0lOR19FTUFJTFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfZW1haWxjb25maXJtXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBSZXNvdXJjZXMuTUlTU0lOR19FTUFJTENPTkZJUk0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcXVhbFRvOiBSZXNvdXJjZXMuVkFMSURBVEVfSU5WQUxJRF9FTUFJTE1BVENIXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZHdmcm1fcHJvZmlsZV9sb2dpbl9wYXNzd29yZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogUmVzb3VyY2VzLk1JU1NJTkdfUEFTU1dPUkQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZWxlbmd0aDogUmVzb3VyY2VzLlZBTElEQVRFX1JBTkdFTEVOR1RIXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZHdmcm1fcHJvZmlsZV9sb2dpbl9wYXNzd29yZGNvbmZpcm1cIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFJlc291cmNlcy5NSVNTSU5HX1BBU1NXT1JEQ09ORklSTSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVxdWFsVG86IFJlc291cmNlcy5WQUxJREFURV9JTlZBTElEX1BBU1NNQVRDSFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfemlwXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBSZXNvdXJjZXMuTUlTU0lOR19QT1NUQUxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2JpcnRoTW9udGhcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlkYXRlOiBSZXNvdXJjZXMuQklSVEhEQVRFX0lOVkFMSURcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2JpcnRoRGF5XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpZGF0ZTogUmVzb3VyY2VzLkJJUlRIREFURV9JTlZBTElEXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aFllYXJcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlkYXRlOiBSZXNvdXJjZXMuQklSVEhEQVRFX0lOVkFMSURcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDbGFzcyA6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JFbGVtZW50IDogJ3NwYW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZTogXCI6aGlkZGVuOm5vdCgucmVwbGFjZWQpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25rZXl1cCA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZm9jdXNvdXQgOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighdGhpcy5jaGVja2FibGUoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0IDogZnVuY3Rpb24oZWxlbWVudCwgZXJyb3JDbGFzcywgdmFsaWRDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSAncmFkaW8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRCeU5hbWUoZWxlbWVudC5uYW1lKS5hZGRDbGFzcyhlcnJvckNsYXNzKS5yZW1vdmVDbGFzcyh2YWxpZENsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoZWxlbWVudCkuYWRkQ2xhc3MoZXJyb3JDbGFzcykucmVtb3ZlQ2xhc3ModmFsaWRDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihlbGVtZW50LnR5cGUgPT09ICdzZWxlY3Qtb25lJyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyICRlbGVtZW50ID0gJChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZigkZWxlbWVudC5hdHRyKCdpZCcpICYmICRlbGVtZW50Lmhhc0NsYXNzKCdyZXBsYWNlZCcpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdEJveCA9ICQoJyMnICsgJGVsZW1lbnQuYXR0cignaWQnKSArICdTZWxlY3RCb3hJdENvbnRhaW5lcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzZWxlY3RCb3gpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0Qm94LmFkZENsYXNzKGVycm9yQ2xhc3MpLnJlbW92ZUNsYXNzKHZhbGlkQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkKGVsZW1lbnQpLmF0dHIoJ2lkJykgPT09IFwiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aE1vbnRoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAkKGVsZW1lbnQpLmF0dHIoJ2lkJykgPT09IFwiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aERheVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgJChlbGVtZW50KS5hdHRyKCdpZCcpID09PSBcImR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfYmlydGhZZWFyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoZGF0ZUZpZWxkc1swXSkucmVtb3ZlQ2xhc3MoZXJyb3JDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKGRhdGVGaWVsZHNbMV0pLnJlbW92ZUNsYXNzKGVycm9yQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChkYXRlRmllbGRzWzJdKS5yZW1vdmVDbGFzcyhlcnJvckNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXCIjZXJyb3JzXCIpLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaGlnaGxpZ2h0IDogZnVuY3Rpb24oZWxlbWVudCwgZXJyb3JDbGFzcywgdmFsaWRDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSAncmFkaW8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRCeU5hbWUoZWxlbWVudC5uYW1lKS5yZW1vdmVDbGFzcyhlcnJvckNsYXNzKS5hZGRDbGFzcyh2YWxpZENsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoZWxlbWVudCkucmVtb3ZlQ2xhc3MoZXJyb3JDbGFzcykuYWRkQ2xhc3ModmFsaWRDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihlbGVtZW50LnR5cGUgPT09ICdzZWxlY3Qtb25lJyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyICRlbGVtZW50ID0gJChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZigkZWxlbWVudC5hdHRyKCdpZCcpICYmICRlbGVtZW50Lmhhc0NsYXNzKCdyZXBsYWNlZCcpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdEJveCA9ICQoJyMnICsgJGVsZW1lbnQuYXR0cignaWQnKSArICdTZWxlY3RCb3hJdENvbnRhaW5lcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzZWxlY3RCb3gpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0Qm94LnJlbW92ZUNsYXNzKGVycm9yQ2xhc3MpLmFkZENsYXNzKHZhbGlkQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkKGVsZW1lbnQpLmF0dHIoJ2lkJykgPT09IFwiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aE1vbnRoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAkKGVsZW1lbnQpLmF0dHIoJ2lkJykgPT09IFwiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aERheVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgJChlbGVtZW50KS5hdHRyKCdpZCcpID09PSBcImR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfYmlydGhZZWFyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoZGF0ZUZpZWxkc1swXSkucmVtb3ZlQ2xhc3MoZXJyb3JDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKGRhdGVGaWVsZHNbMV0pLnJlbW92ZUNsYXNzKGVycm9yQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChkYXRlRmllbGRzWzJdKS5yZW1vdmVDbGFzcyhlcnJvckNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXCIjZXJyb3JzXCIpLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dFcnJvcnM6IGZ1bmN0aW9uIChlcnJvck1hcCwgZXJyb3JMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdFNob3dFcnJvcnMoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmlydGhkYXRlRXJyb3IgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JNYXAuaGFzT3duUHJvcGVydHkoXCJkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2JpcnRoTW9udGhcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpcnRoZGF0ZUVycm9yID0gZXJyb3JNYXBbXCJkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2JpcnRoTW9udGhcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3JNYXAuaGFzT3duUHJvcGVydHkoXCJkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2JpcnRoRGF5XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXJ0aGRhdGVFcnJvciA9IGVycm9yTWFwW1wiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aERheVwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvck1hcC5oYXNPd25Qcm9wZXJ0eShcImR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfYmlydGhZZWFyXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXJ0aGRhdGVFcnJvciA9IGVycm9yTWFwW1wiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aFllYXJcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmlydGhkYXRlRXJyb3IgIT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcIiNlcnJvcnNcIikuaHRtbCgnPHNwYW4gY2xhc3M9XCJlcnJvclwiIGdlbmVyYXRlZD1cInRydWVcIiBmb3I9XCJkYXRlXCI+JyArIGJpcnRoZGF0ZUVycm9yICsgJzwvc3Bhbj4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoZGF0ZUZpZWxkc1swXSkuYWRkQ2xhc3MoXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoZGF0ZUZpZWxkc1sxXSkuYWRkQ2xhc3MoXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoZGF0ZUZpZWxkc1syXSkuYWRkQ2xhc3MoXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VibWl0SGFuZGxlcjogZnVuY3Rpb24oZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKCQoZGF0ZUZpZWxkc1swXSkudmFsKCkgPT0gXCJcIiAmJiAkKGRhdGVGaWVsZHNbMV0pLnZhbCgpID09IFwiXCIgJiYgJChkYXRlRmllbGRzWzJdKS52YWwoKSA9PSBcIlwiKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgkKGRhdGVGaWVsZHNbMF0pLnZhbCgpICE9IFwiXCIgJiYgJChkYXRlRmllbGRzWzFdKS52YWwoKSAhPSBcIlwiICYmICQoZGF0ZUZpZWxkc1syXSkudmFsKCkgIT0gXCJcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2VyIGhhcyBwdXQgaW4gb25seSBhIHBhcnRpYWwgYmlydGhkYXRlIGFuZCB3ZSBzaG91bGQgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXCIjZXJyb3JzXCIpLmh0bWwoJzxzcGFuIGNsYXNzPVwiZXJyb3JcIiBnZW5lcmF0ZWQ9XCJ0cnVlXCIgZm9yPVwiZGF0ZVwiPicgKyBSZXNvdXJjZXMuQklSVEhEQVRFX0lOVkFMSUQgKyAnPC9zcGFuPicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChkYXRlRmllbGRzWzBdKS5hZGRDbGFzcyhcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChkYXRlRmllbGRzWzFdKS5hZGRDbGFzcyhcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChkYXRlRmllbGRzWzJdKS5hZGRDbGFzcyhcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluaXRpdGlhbGl6ZSB0aGUgbG9vayB1cCB1c2VybmFtZSBmb3IgdGhlIGZvcm0gd2l0aCBJRCBkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2VtYWlsXG4gICAgICAgICAgICAgICAgICAgICAgICBMb29rVXBVc2VyTmFtZShcIiNkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2VtYWlsXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAkKCcjZHdmcm1fZ3Vlc3RoaXN0b3J5JykudmFsaWRhdGUoe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkd2ZybV9ndWVzdG9yZGVyaGlzdG9yeV9vcmRlck51bWJlclwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImR3ZnJtX2d1ZXN0b3JkZXJoaXN0b3J5X29yZGVyRW1haWxcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1haWw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImR3ZnJtX2d1ZXN0b3JkZXJoaXN0b3J5X3Bvc3RhbENvZGVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5sZW5ndGg6IDVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImR3ZnJtX2d1ZXN0b3JkZXJoaXN0b3J5X29yZGVyRW1haWxcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFJlc291cmNlcy5WQUxJREFURV9FTUFJTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtYWlsOiBSZXNvdXJjZXMuVkFMSURBVEVfRU1BSUxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkd2ZybV9ndWVzdG9yZGVyaGlzdG9yeV9wb3N0YWxDb2RlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBSZXNvdXJjZXMuVkFMSURBVEVfUE9TVEFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlubGVuZ3RoOiBSZXNvdXJjZXMuVkFMSURBVEVfUE9TVEFMXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZHdmcm1fZ3Vlc3RvcmRlcmhpc3Rvcnlfb3JkZXJOdW1iZXJcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFJlc291cmNlcy5WQUxJREFURV9PUkRFUk5VTUJFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcjogUmVzb3VyY2VzLlZBTElEQVRFX09SREVSTlVNQkVSXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ2xhc3MgOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yRWxlbWVudCA6ICdzcGFuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmU6IFwiOmhpZGRlbjpub3QoLnJlcGxhY2VkKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ua2V5dXAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmZvY3Vzb3V0IDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXRoaXMuY2hlY2thYmxlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodCA6IGZ1bmN0aW9uKGVsZW1lbnQsIGVycm9yQ2xhc3MsIHZhbGlkQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kQnlOYW1lKGVsZW1lbnQubmFtZSkuYWRkQ2xhc3MoZXJyb3JDbGFzcykucmVtb3ZlQ2xhc3ModmFsaWRDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLmFkZENsYXNzKGVycm9yQ2xhc3MpLnJlbW92ZUNsYXNzKHZhbGlkQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZWxlbWVudC50eXBlID09PSAnc2VsZWN0LW9uZScpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoJGVsZW1lbnQuYXR0cignaWQnKSAmJiAkZWxlbWVudC5oYXNDbGFzcygncmVwbGFjZWQnKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RCb3ggPSAkKCcjJyArICRlbGVtZW50LmF0dHIoJ2lkJykgKyAnU2VsZWN0Qm94SXRDb250YWluZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2VsZWN0Qm94KXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdEJveC5hZGRDbGFzcyhlcnJvckNsYXNzKS5yZW1vdmVDbGFzcyh2YWxpZENsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5oaWdobGlnaHQgOiBmdW5jdGlvbihlbGVtZW50LCBlcnJvckNsYXNzLCB2YWxpZENsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZEJ5TmFtZShlbGVtZW50Lm5hbWUpLnJlbW92ZUNsYXNzKGVycm9yQ2xhc3MpLmFkZENsYXNzKHZhbGlkQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChlbGVtZW50KS5yZW1vdmVDbGFzcyhlcnJvckNsYXNzKS5hZGRDbGFzcyh2YWxpZENsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGVsZW1lbnQudHlwZSA9PT0gJ3NlbGVjdC1vbmUnKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCRlbGVtZW50LmF0dHIoJ2lkJykgJiYgJGVsZW1lbnQuaGFzQ2xhc3MoJ3JlcGxhY2VkJykpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0Qm94ID0gJCgnIycgKyAkZWxlbWVudC5hdHRyKCdpZCcpICsgJ1NlbGVjdEJveEl0Q29udGFpbmVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNlbGVjdEJveCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RCb3gucmVtb3ZlQ2xhc3MoZXJyb3JDbGFzcykuYWRkQ2xhc3ModmFsaWRDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dFcnJvcnM6IGZ1bmN0aW9uIChlcnJvck1hcCwgZXJyb3JMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdFNob3dFcnJvcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3coKTtcbiAgICAgICAgICAgICAgICAgICAgfX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tTdGF0aWNIZWFkZXIoKTtcbiAgICAgICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3coKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG9uIHRoZSByZWdpc3RyYXRpb24gZmFpbHVyZSBwYWdlLCB3ZSBhcmUgbm90IGluIGEgaG9wdXAgYW5kIG5lZWQgdG8gc2V0IHVwIHZhbGlkYXRpb24gZGlmZmVyZW50bHlcbiAgICAgICAgICAgIGlmICgkKFwiI3JlZ2lzdHJhdGlvbkZhaWx1cmVGb3JtXCIpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRlRmllbGRzID0gW1wiI2R3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfYmlydGhNb250aFwiLCBcIiNkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2JpcnRoRGF5XCIsIFwiI2R3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfYmlydGhZZWFyXCJdO1xuICAgICAgICAgICAgICAgICQoJyNkd2ZybV9yZWdpc3RlcicpLnZhbGlkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiBcImR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfYmlydGhNb250aCBkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2JpcnRoRGF5IGR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfYmlydGhZZWFyXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aE1vbnRoXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWRhdGU6IGRhdGVGaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcImR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfYmlydGhEYXlcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpZGF0ZTogZGF0ZUZpZWxkc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aFllYXJcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpZGF0ZTogZGF0ZUZpZWxkc1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2ZpcnN0bmFtZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFJlc291cmNlcy5NSVNTSU5HX0ZJUlNUX05BTUVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcImR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfbGFzdG5hbWVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBSZXNvdXJjZXMuTUlTU0lOR19MQVNUX05BTUVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcImR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfZW1haWxcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBSZXNvdXJjZXMuTUlTU0lOR19FTUFJTFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9lbWFpbGNvbmZpcm1cIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBSZXNvdXJjZXMuTUlTU0lOR19FTUFJTENPTkZJUk1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcImR3ZnJtX3Byb2ZpbGVfbG9naW5fcGFzc3dvcmRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBSZXNvdXJjZXMuTUlTU0lOR19QQVNTV09SRFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZHdmcm1fcHJvZmlsZV9sb2dpbl9wYXNzd29yZGNvbmZpcm1cIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBSZXNvdXJjZXMuTUlTU0lOR19QQVNTV09SRENPTkZJUk1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcImR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfemlwXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogUmVzb3VyY2VzLk1JU1NJTkdfUE9TVEFMXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2JpcnRoTW9udGhcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpZGF0ZTogUmVzb3VyY2VzLkJJUlRIREFURV9JTlZBTElEXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2JpcnRoRGF5XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWRhdGU6IFJlc291cmNlcy5CSVJUSERBVEVfSU5WQUxJRFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aFllYXJcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpZGF0ZTogUmVzb3VyY2VzLkJJUlRIREFURV9JTlZBTElEXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yQ2xhc3MgOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICBlcnJvckVsZW1lbnQgOiAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgIGlnbm9yZTogXCI6aGlkZGVuOm5vdCgucmVwbGFjZWQpXCIsXG4gICAgICAgICAgICAgICAgICAgIG9ua2V5dXAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgb25mb2N1c291dCA6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZighdGhpcy5jaGVja2FibGUoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodCA6IGZ1bmN0aW9uKGVsZW1lbnQsIGVycm9yQ2xhc3MsIHZhbGlkQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRCeU5hbWUoZWxlbWVudC5uYW1lKS5hZGRDbGFzcyhlcnJvckNsYXNzKS5yZW1vdmVDbGFzcyh2YWxpZENsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChlbGVtZW50KS5hZGRDbGFzcyhlcnJvckNsYXNzKS5yZW1vdmVDbGFzcyh2YWxpZENsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihlbGVtZW50LnR5cGUgPT09ICdzZWxlY3Qtb25lJyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCRlbGVtZW50LmF0dHIoJ2lkJykgJiYgJGVsZW1lbnQuaGFzQ2xhc3MoJ3JlcGxhY2VkJykpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdEJveCA9ICQoJyMnICsgJGVsZW1lbnQuYXR0cignaWQnKSArICdTZWxlY3RCb3hJdENvbnRhaW5lcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2VsZWN0Qm94KXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RCb3guYWRkQ2xhc3MoZXJyb3JDbGFzcykucmVtb3ZlQ2xhc3ModmFsaWRDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJChlbGVtZW50KS5hdHRyKCdpZCcpID09PSBcImR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfYmlydGhNb250aFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8ICQoZWxlbWVudCkuYXR0cignaWQnKSA9PT0gXCJkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2JpcnRoRGF5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgJChlbGVtZW50KS5hdHRyKCdpZCcpID09PSBcImR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfYmlydGhZZWFyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKGRhdGVGaWVsZHNbMF0pLnJlbW92ZUNsYXNzKGVycm9yQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoZGF0ZUZpZWxkc1sxXSkucmVtb3ZlQ2xhc3MoZXJyb3JDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChkYXRlRmllbGRzWzJdKS5yZW1vdmVDbGFzcyhlcnJvckNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFwiI2Vycm9yc1wiKS5lbXB0eSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB1bmhpZ2hsaWdodCA6IGZ1bmN0aW9uKGVsZW1lbnQsIGVycm9yQ2xhc3MsIHZhbGlkQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRCeU5hbWUoZWxlbWVudC5uYW1lKS5yZW1vdmVDbGFzcyhlcnJvckNsYXNzKS5hZGRDbGFzcyh2YWxpZENsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChlbGVtZW50KS5yZW1vdmVDbGFzcyhlcnJvckNsYXNzKS5hZGRDbGFzcyh2YWxpZENsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihlbGVtZW50LnR5cGUgPT09ICdzZWxlY3Qtb25lJyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCRlbGVtZW50LmF0dHIoJ2lkJykgJiYgJGVsZW1lbnQuaGFzQ2xhc3MoJ3JlcGxhY2VkJykpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdEJveCA9ICQoJyMnICsgJGVsZW1lbnQuYXR0cignaWQnKSArICdTZWxlY3RCb3hJdENvbnRhaW5lcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2VsZWN0Qm94KXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RCb3gucmVtb3ZlQ2xhc3MoZXJyb3JDbGFzcykuYWRkQ2xhc3ModmFsaWRDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJChlbGVtZW50KS5hdHRyKCdpZCcpID09PSBcImR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfYmlydGhNb250aFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8ICQoZWxlbWVudCkuYXR0cignaWQnKSA9PT0gXCJkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2JpcnRoRGF5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgJChlbGVtZW50KS5hdHRyKCdpZCcpID09PSBcImR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfYmlydGhZZWFyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKGRhdGVGaWVsZHNbMF0pLnJlbW92ZUNsYXNzKGVycm9yQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoZGF0ZUZpZWxkc1sxXSkucmVtb3ZlQ2xhc3MoZXJyb3JDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChkYXRlRmllbGRzWzJdKS5yZW1vdmVDbGFzcyhlcnJvckNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFwiI2Vycm9yc1wiKS5lbXB0eSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzaG93RXJyb3JzOiBmdW5jdGlvbiAoZXJyb3JNYXAsIGVycm9yTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0U2hvd0Vycm9ycygpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmlydGhkYXRlRXJyb3IgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yTWFwLmhhc093blByb3BlcnR5KFwiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aE1vbnRoXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmlydGhkYXRlRXJyb3IgPSBlcnJvck1hcFtcImR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfYmlydGhNb250aFwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3JNYXAuaGFzT3duUHJvcGVydHkoXCJkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2JpcnRoRGF5XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmlydGhkYXRlRXJyb3IgPSBlcnJvck1hcFtcImR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfYmlydGhEYXlcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yTWFwLmhhc093blByb3BlcnR5KFwiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aFllYXJcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXJ0aGRhdGVFcnJvciA9IGVycm9yTWFwW1wiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aFllYXJcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaXJ0aGRhdGVFcnJvciAhPSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcIiNlcnJvcnNcIikuaHRtbCgnPHNwYW4gY2xhc3M9XCJlcnJvclwiIGdlbmVyYXRlZD1cInRydWVcIiBmb3I9XCJkYXRlXCI+JyArIGJpcnRoZGF0ZUVycm9yICsgJzwvc3Bhbj4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKGRhdGVGaWVsZHNbMF0pLmFkZENsYXNzKFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChkYXRlRmllbGRzWzFdKS5hZGRDbGFzcyhcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoZGF0ZUZpZWxkc1syXSkuYWRkQ2xhc3MoXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3VibWl0SGFuZGxlcjogZnVuY3Rpb24oZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgkKGRhdGVGaWVsZHNbMF0pLnZhbCgpID09IFwiXCIgJiYgJChkYXRlRmllbGRzWzFdKS52YWwoKSA9PSBcIlwiICYmICQoZGF0ZUZpZWxkc1syXSkudmFsKCkgPT0gXCJcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCQoZGF0ZUZpZWxkc1swXSkudmFsKCkgIT0gXCJcIiAmJiAkKGRhdGVGaWVsZHNbMV0pLnZhbCgpICE9IFwiXCIgJiYgJChkYXRlRmllbGRzWzJdKS52YWwoKSAhPSBcIlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZXIgaGFzIHB1dCBpbiBvbmx5IGEgcGFydGlhbCBiaXJ0aGRhdGUgYW5kIHdlIHNob3VsZCBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXCIjZXJyb3JzXCIpLmh0bWwoJzxzcGFuIGNsYXNzPVwiZXJyb3JcIiBnZW5lcmF0ZWQ9XCJ0cnVlXCIgZm9yPVwiZGF0ZVwiPicgKyBSZXNvdXJjZXMuQklSVEhEQVRFX0lOVkFMSUQgKyAnPC9zcGFuPicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoZGF0ZUZpZWxkc1swXSkuYWRkQ2xhc3MoXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKGRhdGVGaWVsZHNbMV0pLmFkZENsYXNzKFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChkYXRlRmllbGRzWzJdKS5hZGRDbGFzcyhcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhPT0sgVkFMSURBVElPTiBGT1IgVEhFIEhPUFVQIEZPUk1cbiAgICAgICAgICAgIGFwcC51dGlsLnZhbGlkYXRlSG9vaygnI3BvcHVwLXJlZ2lzdGVyIC5hcHBseS1idXR0b24nKTtcbiAgICAgICAgICAgIGFwcC51dGlsLnZhbGlkYXRlSG9vaygnI3BvcHVwLWd1ZXN0aGlzdG9yeSAuYXBwbHktYnV0dG9uJyk7XG4gICAgICAgICAgICBhcHAudXRpbC52YWxpZGF0ZUhvb2soJyNwb3B1cC1sb2dpbiAuYXBwbHktYnV0dG9uJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAkKHdpbmRvdykuc2Nyb2xsKGZ1bmN0aW9uKCl7XG4gICAgICAgIGNoZWNrU3RhdGljSGVhZGVyKCk7XG4gICAgfSk7XG5cbiAgICAkKHdpbmRvdykucmVzaXplKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB2aWV3cG9ydFdpZHRoID0gJCh3aW5kb3cpLndpZHRoKCk7XG4gICAgICAgIHZhciBoZWFkZXIgPSAkKCcudG9wLWJhbm5lcicpO1xuXG4gICAgICAgIGlmICgkKCcudWktZGlhbG9nJykubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoISQoJy51aS1kaWFsb2cnKS5pcygnLnN0b3JlLXBpY2t1cC1kaWFsb2csIC51aS1kaWFsb2dfcXVpY2stdmlldycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9ICh2aWV3cG9ydFdpZHRoIDwgNzA4KSA/ICh2aWV3cG9ydFdpZHRoIC0gNDApLnRvU3RyaW5nKCkgOiAnNjY4JztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvcE9mZnNldCA9ICh2aWV3cG9ydFdpZHRoIDwgNzA4KSA/IDUwIDogKCh2aWV3cG9ydFdpZHRoIC0gNzA4KSAvIDIpICsgNTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCQoJy51aS1kaWFsb2cnKS5pcygnLnVpLWRpYWxvZ19xdWljay12aWV3JykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gKHZpZXdwb3J0V2lkdGggPiA5NjApID8gJzgyMCcgOiAnNzIwJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpZXdwb3J0V2lkdGggPD0gNzY4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9ICh2aWV3cG9ydFdpZHRoIDwgNjY5KSA/ICh2aWV3cG9ydFdpZHRoKS50b1N0cmluZygpIDogJzY2OCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoISQoJy51aS1kaWFsb2cnKS5pcygnLnVpLWZyb250LmNyZWF0ZS1hY2NvdW50JykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gKHZpZXdwb3J0V2lkdGggPCA2NjkpID8gKHZpZXdwb3J0V2lkdGgpLnRvU3RyaW5nKCkgOiAnNjY4JztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvcE9mZnNldCA9ICh2aWV3cG9ydFdpZHRoIDwgNzA4KSA/IDYxIDogKCh2aWV3cG9ydFdpZHRoIC0gNzA4KSAvIDIpICsgNjE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gKHZpZXdwb3J0V2lkdGggLSB3aWR0aCkgLyAyO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRvcE9mZnNldCA+IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICB0b3BPZmZzZXQgPSAxMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvcE9mZnNldCA9ICQod2luZG93KS5zY3JvbGxUb3AoKSArIHRvcE9mZnNldDtcbiAgICAgICAgICAgICAgICAkKCcudWktZGlhbG9nJykuY3NzKCd3aWR0aCcsIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAkKCcudWktZGlhbG9nJykuY3NzKCdsZWZ0JywgbGVmdCk7XG4gICAgICAgICAgICAgICAgJCgnLnVpLWRpYWxvZycpLmNzcygndG9wJywgdG9wT2Zmc2V0LnRvU3RyaW5nKCkgKyAncHgnKTtcbiAgICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNoZWNrU3RhdGljSGVhZGVyKCk7XG4gICAgICAgICAgICBpZiAodmlld3BvcnRXaWR0aCA8IDk2MCkge1xuICAgICAgICAgICAgICAgIG1vdmVTZWFyY2goJCgnbmF2JykuZmluZCgnLnNlYXJjaC10b2dnbGUnKSwgJCgnLnJpZ2h0LWhlYWRlci1saW5rcycpLmZpbmQoJy5zZWFyY2gtdG9nZ2xlJyksIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhlYWRlci5oYXNDbGFzcygnc3RpY2t5JykpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZVNlYXJjaCgkKCcucmlnaHQtaGVhZGVyLWxpbmtzJykuZmluZCgnLnNlYXJjaC10b2dnbGUnKSwgJCgnbmF2JykuZmluZCgnLnNlYXJjaC10b2dnbGUnKSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgNTAwKTtcblxuICAgIFx0YWxpZ25OYXZDb250ZW50KCk7XG4gICAgfSk7XG5cbiAgICAkKCcuc2VhcmNoLXRvZ2dsZScpLmZpbmQoJ2EnKS5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgJCgnLnNlYXJjaC10b2dnbGUnKS50b2dnbGVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICQoJy5oZWFkZXItc2VhcmNoJykudG9nZ2xlQ2xhc3MoJ3NlYXJjaC1oaWRkZW4nKTtcbiAgICAgICAgJCgnLnNlYXJjaC10b2dnbGUgLmhlYWRlci1zZWFyY2gnKS5maW5kKCcjcScpLmZvY3VzKCkucmVtb3ZlQ2xhc3MoJ2Vycm9yJyk7XG4gICAgfSk7XG4gICAgJCgnLnNlYXJjaC10b2dnbGUnKS5maW5kKCcuY2xvc2Utc2VhcmNoJykub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgJCgnLnNlYXJjaC10b2dnbGUnKS50b2dnbGVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICQoJy5oZWFkZXItc2VhcmNoJykudG9nZ2xlQ2xhc3MoJ3NlYXJjaC1oaWRkZW4nKTtcbiAgICB9KTtcbiAgICAkKCcuc3VibWl0LXNlYXJjaCcpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VhcmNoVmFsdWUgPSAkKCcuc3VibWl0LXNlYXJjaCcpLnBhcmVudC5maW5kKCcjcScpO1xuICAgICAgICBpZiAoc2VhcmNoVmFsdWUudmFsKCkgPT0gJycpIHtcbiAgICAgICAgICAgIHNlYXJjaFZhbHVlLmFkZENsYXNzKCdlbXB0eScpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgJCgnbmF2W3JvbGU9XCJuYXZpZ2F0aW9uXCJdIC5tZW51LWNhdGVnb3J5LmxldmVsLTEgPiBsaSBhLmhhcy1zdWItbWVudScpLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgJCgnLnNlYXJjaC10b2dnbGUnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICQoJy5oZWFkZXItc2VhcmNoJykuYWRkQ2xhc3MoJ3NlYXJjaC1oaWRkZW4nKTtcbiAgICAgICAgJCgnLnNlYXJjaC10b2dnbGUgLmhlYWRlci1zZWFyY2gnKS5maW5kKCcjcScpLmJsdXIoKTtcblxuICAgICAgICAvLyBoYW5kbGUgc3RpY2t5IG5hdiBwb3NpdGlvbmluZ1xuICAgICAgICB2YXIgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgdmFyIHN1Yk5hdiA9ICQodGhpcykubmV4dCgnZGl2LmxldmVsLTInKTtcbiAgICBcdHZhciBvZmZzZXQgPSAkKCcjbmF2aWdhdGlvbicpLm9mZnNldCgpO1xuXG4gICAgICAgIGlmICh3aWR0aCA+IDk2MCAmJiAkKCcudG9wLWJhbm5lci5zdGlja3knKS5pcygnOnZpc2libGUnKSkge1xuICAgICAgICBcdHN1Yk5hdi5jc3Moe1xuICAgICAgICBcdFx0J3dpZHRoJzogd2lkdGgsXG4gICAgICAgIFx0XHQnbGVmdCc6IC1vZmZzZXQubGVmdCxcbiAgICAgICAgXHRcdCd0ZXh0LWFsaWduJzogJ2NlbnRlcidcbiAgICAgICAgXHR9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgXHRzdWJOYXYucmVtb3ZlQXR0cignc3R5bGUnKTtcbiAgICBcdFx0YWxpZ25OYXZDb250ZW50KHN1Yk5hdik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvKiBtaW1pYyBwbGFjZWhvbGRlciBiZWhhdmlvdXIgKi9cbiAgICAkKCcuc2VhcmNoLXRvZ2dsZSAuaGVhZGVyLXNlYXJjaCcpLmZpbmQoJy5zZWFyY2gtcGxhY2Vob2xkZXInKS5vbignbW91c2Vkb3duIHRvdWNoc3RhcnQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciAkcSA9ICQoJy5zZWFyY2gtdG9nZ2xlIC5oZWFkZXItc2VhcmNoJykuZmluZCgnI3EnKTtcbiAgICBcdGUucHJldmVudERlZmF1bHQoKTtcbiAgICBcdGlmICghJHEuaXMoJzpmb2N1cycpKSB7XG4gICAgXHRcdCRxLmZvY3VzKCk7XG4gICAgXHR9XG4gICAgfSk7XG4gICAgJCgnLnNlYXJjaC10b2dnbGUgLmhlYWRlci1zZWFyY2gnKS5maW5kKCcjcScpLm9uKCdpbnB1dCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcbiAgICAgICAgaWYgKCR0aGlzLnZhbCgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICQoJy5zZWFyY2gtdG9nZ2xlIC5oZWFkZXItc2VhcmNoIC5zZWFyY2gtcGxhY2Vob2xkZXInKS5hZGRDbGFzcygnaGlkZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJCgnLnNlYXJjaC10b2dnbGUgLmhlYWRlci1zZWFyY2ggLnNlYXJjaC1wbGFjZWhvbGRlcicpLnJlbW92ZUNsYXNzKCdoaWRlJyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEJhY2sgdG8gdG9wIGFuZCBjaGF0IGJ1dHRvbnMgb24gcHJvZHVjdCBzZWFyY2ggcmVzdWx0cyBwYWdlXG4gICAgdmFyIG9mZnNldCA9IDUwO1xuICAgIHZhciBkdXJhdGlvbiA9IDMwMDtcblxuICAgICQod2luZG93KS5zY3JvbGwoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgkKHRoaXMpLnNjcm9sbFRvcCgpID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICAkKCcjYmFjay10by10b3AsICNjaGF0JykuZmFkZUluKGR1cmF0aW9uKTtcbiAgICAgICAgICAgICQoJyNiYWNrLXRvLXRvcCwgI2NoYXQnKS5jc3MoJ2Rpc3BsYXknLCAnYmxvY2snKTtcbiAgICAgICAgICAgICQoJyNiYWNrLXRvLXRvcCwgI2NoYXQnKS5jc3MoJ2Rpc3BsYXknLCAnYmxvY2snKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQoJyNiYWNrLXRvLXRvcCwgI2NoYXQnKS5mYWRlT3V0KGR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJCgnI2JhY2stdG8tdG9wJykuY2xpY2soZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgJCgnaHRtbCwgYm9keScpLmFuaW1hdGUoe3Njcm9sbFRvcDogMH0sIGR1cmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgalF1ZXJ5LnZhbGlkYXRvci5zZXREZWZhdWx0cyh7XG4gICAgICAgIHN1Y2Nlc3M6IFwidmFsaWRcIlxuICAgIH0pO1xuXG4gICAgLy8gVE9ETyA6IE1vdmUgYWxsIGFjY291bnQgaXRlbXMgaW50byBhY2NvdW50LmpzXG4gICAgZnVuY3Rpb24gaW5pdFJlc2V0UGFzc3dvcmRGb3JtKCkge1xuICAgICAgICAkKCcjUGFzc3dvcmRSZXNldEZvcm0nKS52YWxpZGF0ZSh7XG4gICAgICAgICAgICBydWxlczoge1xuICAgICAgICAgICAgICAgIGR3ZnJtX3JlcXVlc3RwYXNzd29yZF9lbWFpbDoge1xuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZW1haWw6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3JDbGFzczogJ2Vycm9yJyxcbiAgICAgICAgICAgIGVycm9yRWxlbWVudDogJ3NwYW4nLFxuICAgICAgICAgICAgb25mb2N1c291dDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkoZWxlbWVudCkudmFsaWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgJCgnI1Bhc3N3b3JkUmVzZXRGb3JtJykub24oJ3N1Ym1pdCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpO1xuICAgICAgICAgICAgaWYgKCEkdGhpcy52YWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdXJsID0gYXBwLnV0aWwuYXBwZW5kUGFyYW1Ub1VSTCgkdGhpcy5hdHRyKCdhY3Rpb24nKSwgXCJmb3JtYXRcIiwgXCJhamF4XCIpO1xuICAgICAgICAgICAgdmFyIHBvc3REYXRhID0gJHRoaXMuc2VyaWFsaXplQXJyYXkoKTtcbiAgICAgICAgICAgIHBvc3REYXRhLnB1c2goe25hbWU6ICR0aGlzLmZpbmQoJy5hcHBseS1idXR0b24nKS5hdHRyKCduYW1lJyksIHZhbHVlOiAkdGhpcy5maW5kKCcuYXBwbHktYnV0dG9uJykuYXR0cigndmFsdWUnKX0pO1xuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgZGF0YTogcG9zdERhdGEsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdodG1sJyxcbiAgICAgICAgICAgICAgICBzdWNjZXNzIDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyICRkYXRhID0gJChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRkYXRhLmxlbmd0aCAmJiAkZGF0YS5maWx0ZXIoJy5mb3Jnb3QtcGFzc3dvcmQtd3JhcHBlci5qcy1jb25maXJtYXRpb24tcGFnZScpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmZpcm1haW9uSFRNTCA9ICRkYXRhLmZpbHRlcignLmZvcmdvdC1wYXNzd29yZC13cmFwcGVyLmpzLWNvbmZpcm1hdGlvbi1wYWdlJykucHJvcCgnb3V0ZXJIVE1MJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKCcuZm9yZ290LXBhc3N3b3JkLXdyYXBwZXInKS5odG1sKGNvbmZpcm1haW9uSFRNTCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICQoJy5jbG9zZS1idXR0b24nKS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlhbG9nLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgkZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlSFRNTCA9ICRkYXRhLmZpbmQoJy5qcy1tZXNzYWdlJykucHJvcCgnb3V0ZXJIVE1MJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKCcuZm9yZ290LXBhc3N3b3JkLXdyYXBwZXInKS5maW5kKCcuanMtbWVzc2FnZScpLmh0bWwobWVzc2FnZUhUTUwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmYWlsdXJlIDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoJ0Vycm9yJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgalF1ZXJ5KCdib2R5Jykub24oJ2NsaWNrJywgJyNwYXNzd29yZC1yZXNldCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIHdpZHRoID0gKHdpbmRvdy5pbm5lcldpZHRoIDwgNzA4KSA/ICh3aW5kb3cuaW5uZXJXaWR0aCAtIDQwKS50b1N0cmluZygpIDogJzUwMCc7XG5cbiAgICAgICAgZGlhbG9nLm9wZW4oe1xuICAgICAgICAgICAgdXJsOiAkKGUudGFyZ2V0KS5hdHRyKCdocmVmJyksXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogJ2F1dG8nLFxuICAgICAgICAgICAgICAgIG9wZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxvYXRsYWJlbHMuaW5pdCgpO1xuICAgICAgICAgICAgICAgICAgICBpbml0UmVzZXRQYXNzd29yZEZvcm0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy9UcnVlIEZpdFxuICAgIGlmICh0eXBlb2YgdGZjICE9PSAndW5kZWZpbmVkJyl7XG4gICAgICAgIHRmYy5ldmVudCgndGZjLXNldC11c2VyaWQnLCdyZW5kZXInLGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmKGUucmVzcG9uc2UudGZwVXNlci5pc1VzZXJBdmFpbGFibGUgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgICAgIC8vIFNldCBzZXNzaW9uIGZvciB0cnVlZml0IHZhcmlhYmxlXG4gICAgICAgICAgICAgICAgYXBwLmFqYXgubG9hZCh7dXJsIDogd2luZG93LlVybHMuVHJ1ZUZpdEN1c3RvbWVyU2V0fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFRyaWdnZXIgVUlTIGNhbGwgd2hlbiBzdWJtaXQgb3JkZXIgaXMgY2xpY2tlZC5cbiAgICAkKCcuanMtb3JkZXItcmV2aWV3LWJ0bi1zdWJtaXQnKS5vbignY2xpY2snLCBmdW5jdGlvbigpe1xuICAgIFx0dHJpZ2dlclVJU0NhcnRDaGVjaygncGxhY2VPcmRlcicpO1xuICAgIH0pO1xufVxuXG5cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKiBAZGVzY3JpcHRpb24gQWRkcyBjbGFzcyAoJ2pzJykgdG8gaHRtbCBmb3IgY3NzIHRhcmdldGluZyBhbmQgbG9hZHMganMgc3BlY2lmaWMgc3R5bGVzLlxuICovXG5mdW5jdGlvbiBpbml0aWFsaXplRG9tKCkge1xuXG4gICAgLy8gYWRkIGNsYXNzIHRvIGh0bWwgZm9yIGNzcyB0YXJnZXRpbmdcbiAgICAkKCdodG1sJykuYWRkQ2xhc3MoJ2pzJyk7XG4gICAgaWYgKFNpdGVQcmVmZXJlbmNlcy5MSVNUSU5HX0lORklOSVRFX1NDUk9MTCkge1xuICAgICAgICAkKCdodG1sJykuYWRkQ2xhc3MoJ2luZmluaXRlLXNjcm9sbCcpO1xuICAgIH1cbiAgICAvLyBsb2FkIGpzIHNwZWNpZmljIHN0eWxlc1xuICAgIHV0aWwubGltaXRDaGFyYWN0ZXJzKCk7XG5cbiAgICBjaGVja1N0YXRpY0hlYWRlcigpO1xuICAgIG1vdmVTZWFyY2goJCgnbmF2JykuZmluZCgnLnNlYXJjaC10b2dnbGUnKSwkKCcucmlnaHQtaGVhZGVyLWxpbmtzJykuZmluZCgnLnNlYXJjaC10b2dnbGUnKSx0cnVlKTtcblxuICAgIGFsaWduTmF2Q29udGVudCgpO1xufVxuXG5mdW5jdGlvbiBhbGlnbk5hdkNvbnRlbnQoZWxzKSB7XG5cdHZhciBmaXJzdE1lbnVJdGVtTGVmdCA9ICQoJy5tZW51LWNhdGVnb3J5LmxldmVsLTEnKS5jaGlsZHJlbigpLmZpcnN0KCkucG9zaXRpb24oKS5sZWZ0O1xuXHRcblx0dmFyICRlbHMgPSBlbHMgfHwgJCgnLm1lbnUtY2F0ZWdvcnkubGV2ZWwtMSA+bGkgPi5sZXZlbC0yJyk7XG4gICAgXG4gICAgJGVscy5lYWNoKGZ1bmN0aW9uIChpLCBlKSB7XG4gICAgXHR2YXIgd3JhcHBlclBhZGRpbmcgPSAkKGUpLmNzcygncGFkZGluZy1sZWZ0JykucmVwbGFjZSgncHgnLCAnJyksXG4gICAgXHRcdGxlZnRBbGlnbk9mZnNldCA9IGZpcnN0TWVudUl0ZW1MZWZ0IC0gd3JhcHBlclBhZGRpbmcsXG4gICAgXHRcdCRuYXZDb250ZW50ID0gJChlKS5maW5kKCcubmF2LWFsaWduZWQnKTtcbiAgICBcdFx0XG4gICAgXHQkbmF2Q29udGVudC5jc3Moe1xuICAgIFx0XHRcImxlZnRcIjogbGVmdEFsaWduT2Zmc2V0XG4gICAgXHR9KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY2hlY2tTdGF0aWNIZWFkZXIoKSB7XG4gICAgdmFyIHNtYWxsVmlld3BvcnQgPSAod2luZG93LmlubmVyV2lkdGggPD0gNDgwKTtcbiAgICB2YXIgbWVkaXVtVmlld3BvcnQgPSAod2luZG93LmlubmVyV2lkdGggPiA0ODAgJiYgd2luZG93LmlubmVyV2lkdGggPD0gOTYwKTtcbiAgICB2YXIgbGFyZ2VVcFZpZXdwb3J0ID0gKHdpbmRvdy5pbm5lcldpZHRoID4gOTYwKTtcbiAgICB2YXIgc2l0ZVRhYnMgPSAkKCcjc2l0ZS10YWItYmFyJyk7XG4gICAgdmFyIHNpdGVUYWJzSGVpZ2h0ID0gc2l0ZVRhYnMuaGVpZ2h0KCk7XG4gICAgdmFyIGxvZ2luVHJheSA9ICQoJy5sb2dpbi10cmF5Jyk7XG4gICAgdmFyIGxvZ2luVHJheUhlaWdodCA9IGxvZ2luVHJheS5oZWlnaHQoKTtcbiAgICB2YXIgaGVhZGVyID0gJCgnLnRvcC1iYW5uZXInKTtcbiAgICB2YXIgaGVhZGVySGVpZ2h0ID0gaGVhZGVyLmhlaWdodCgpO1xuICAgIHZhciBzdGlja3lTZWFyY2ggPSAkKCcucmlnaHQtaGVhZGVyLWxpbmtzJykuZmluZCgnLnNlYXJjaC10b2dnbGUnKTtcbiAgICB2YXIgbmF2U2VhcmNoID0gJCgnbmF2JykuZmluZCgnLnNlYXJjaC10b2dnbGUnKTtcbiAgICB2YXIgaGVhZGVyID0gJCgnLnRvcC1iYW5uZXInKTtcbiAgICB2YXIgbWVudVRvZ2dsZSA9IGhlYWRlci5maW5kKCcubWVudS10b2dnbGUnKTtcbiAgICB2YXIgaGFzRmlsdGVycyA9ICgkKCcjZmlsdGVycy1zZWxlY3RlZCcpLmNoaWxkcmVuKCkubGVuZ3RoID4gMCk7XG5cbiAgICBpZiAoc21hbGxWaWV3cG9ydCkge1xuICAgICAgICB2YXIgc3RpY2t5U2Nyb2xsT2Zmc2V0ID0gbG9naW5UcmF5Lmxlbmd0aCA/IGxvZ2luVHJheUhlaWdodCArIDQwIDogMDtcbiAgICAgICAgdmFyIHN0aWNreU1hcmdpbk9mZnNldCA9IGxvZ2luVHJheS5sZW5ndGggPyBsb2dpblRyYXlIZWlnaHQgKyA5MSA6IDA7XG4gICAgICAgIGlmIChpc0NoZWNrb3V0KCkpIHtcbiAgICAgICAgICAgIHZhciBzdGlja3lTY3JvbGxPZmZzZXQgPSBsb2dpblRyYXlIZWlnaHQ7XG4gICAgICAgICAgICB2YXIgc3RpY2t5TWFyZ2luT2Zmc2V0ID0gbG9naW5UcmF5SGVpZ2h0ICsgNjA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobWVkaXVtVmlld3BvcnQpIHtcbiAgICAgICAgdmFyIHN0aWNreVNjcm9sbE9mZnNldCA9IGxvZ2luVHJheUhlaWdodCArIHNpdGVUYWJzSGVpZ2h0O1xuICAgICAgICB2YXIgc3RpY2t5TWFyZ2luT2Zmc2V0ID0gbG9naW5UcmF5SGVpZ2h0ICsgc2l0ZVRhYnNIZWlnaHQgKyA1OTtcbiAgICAgICAgaWYgKGlzQ2hlY2tvdXQoKSkge1xuICAgICAgICAgICAgdmFyIHN0aWNreVNjcm9sbE9mZnNldCA9IGxvZ2luVHJheUhlaWdodDtcbiAgICAgICAgICAgIHZhciBzdGlja3lNYXJnaW5PZmZzZXQgPSBsb2dpblRyYXlIZWlnaHQgKyA2NTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChsYXJnZVVwVmlld3BvcnQpIHtcbiAgICAgICAgdmFyIHN0aWNreVNjcm9sbE9mZnNldCA9IGxvZ2luVHJheUhlaWdodCArIHNpdGVUYWJzSGVpZ2h0ICsgNjU7XG4gICAgICAgIHZhciBzdGlja3lNYXJnaW5PZmZzZXQgPSBsb2dpblRyYXlIZWlnaHQgKyBzaXRlVGFic0hlaWdodCArIDEzOTtcbiAgICAgICAgaWYgKGlzQ2hlY2tvdXQoKSkge1xuICAgICAgICAgICAgdmFyIHN0aWNreVNjcm9sbE9mZnNldCA9IGxvZ2luVHJheUhlaWdodDtcbiAgICAgICAgICAgIHZhciBzdGlja3lNYXJnaW5PZmZzZXQgPSBsb2dpblRyYXlIZWlnaHQgKyA5MDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICgkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSAtIDQwMCA+IHN0aWNreVNjcm9sbE9mZnNldCAmJiAhaGVhZGVyLmhhc0NsYXNzKCdzdGlja3knKSkge1xuICAgICAgICBzaXRlVGFicy5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgICBoZWFkZXIuYWRkQ2xhc3MoJ3N0aWNreScpO1xuICAgICAgICBsb2dpblRyYXkuYWRkQ2xhc3MoJ3N0aWNreScpO1xuICAgICAgICAkKCcubmF2LWFsaWduZWQnKS5jc3MoXCJsZWZ0XCIsIFwiXCIpO1xuICAgICAgICBpZighJCgnLmludGVyaW9yLWFjY291bnQnKS5sZW5ndGgpe1xuICAgICAgICAgICAgJCgnI21haW4nKS5jc3MoJ21hcmdpbi10b3AnLCAoc3RpY2t5TWFyZ2luT2Zmc2V0ICsgJ3B4JykpO1xuICAgICAgICB9XG4gICAgICAgIG1vdmVTZWFyY2gobmF2U2VhcmNoLHN0aWNreVNlYXJjaCxmYWxzZSk7XG4gICAgfSBlbHNlIGlmICgkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSA8PSAxICsgbG9naW5UcmF5SGVpZ2h0ICYmIGhlYWRlci5oYXNDbGFzcygnc3RpY2t5JykpIHtcbiAgICAgICAgc2l0ZVRhYnMuY3NzKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XG4gICAgICAgIGhlYWRlci5yZW1vdmVDbGFzcygnc3RpY2t5Jyk7XG4gICAgICAgIGxvZ2luVHJheS5yZW1vdmVDbGFzcygnc3RpY2t5Jyk7XG4gICAgICAgIGFsaWduTmF2Q29udGVudCgpO1xuICAgICAgICBpZighJCgnLmludGVyaW9yLWFjY291bnQnKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICQoJyNtYWluJykuY3NzKCdtYXJnaW4tdG9wJywgKHNtYWxsVmlld3BvcnQgJiYgIWlzQ2hlY2tvdXQoKSA/ICcxMjBweCcgOiAnMCcpKTtcbiAgICAgICAgfVxuICAgICAgICBtb3ZlU2VhcmNoKHN0aWNreVNlYXJjaCxuYXZTZWFyY2gsZmFsc2UpO1xuICAgIH1cbiAgICAkKCcubG9naW4tdHJheS5zdGlja3knKS5jc3MoJ21hcmdpbi10b3AnLCAnMCcpO1xufVxuXG5mdW5jdGlvbiBtb3ZlU2VhcmNoKGN1cnJlbnRTZWFyY2gsbmV3U2VhcmNoLHBhZ2VMb2FkKXtcbiAgICB2YXIgbWVudVRvZ2dsZSA9ICQoJy50b3AtYmFubmVyJykuZmluZCgnLm1lbnUtdG9nZ2xlJyk7XG4gICAgaWYgKHBhZ2VMb2FkID09IHRydWUgJiYgbWVudVRvZ2dsZS5jc3MoJ2Rpc3BsYXknKSA9PSAnYmxvY2snKXtcbiAgICAgICAgY3VycmVudFNlYXJjaC5maW5kKCcuaGVhZGVyLXNlYXJjaCcpLmRldGFjaCgpLmFwcGVuZFRvKG5ld1NlYXJjaCk7XG4gICAgICAgIHNlYXJjaHN1Z2dlc3QuaW5pdChuZXdTZWFyY2guZmluZCgnLmhlYWRlci1zZWFyY2gnKSwgUmVzb3VyY2VzLlNJTVBMRV9TRUFSQ0gpO1xuICAgIH1lbHNlIGlmKHBhZ2VMb2FkID09IGZhbHNlICYmIG1lbnVUb2dnbGUuY3NzKCdkaXNwbGF5JykgPT0gJ25vbmUnKXtcbiAgICAgICAgY3VycmVudFNlYXJjaC5maW5kKCcuaGVhZGVyLXNlYXJjaCcpLmRldGFjaCgpLmFwcGVuZFRvKG5ld1NlYXJjaCk7XG4gICAgICAgIHNlYXJjaHN1Z2dlc3QuaW5pdChuZXdTZWFyY2guZmluZCgnLmhlYWRlci1zZWFyY2gnKSwgUmVzb3VyY2VzLlNJTVBMRV9TRUFSQ0gpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRBY2NvdW50UGFnZSgpIHtcbiAgICBpZih0eXBlb2YgY3VycmVudEFjY291bnRQYWdlICE9PSAndW5kZWZpbmVkJyl7XG4gICAgICAgIHZhciAkZGVza3RvcEN1cnJlbnRQYWdlID0gJCgnI3NlY29uZGFyeScpLmZpbmQoXCIjXCIrY3VycmVudEFjY291bnRQYWdlKTtcbiAgICAgICAgJGRlc2t0b3BDdXJyZW50UGFnZS5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgIHZhciAkbW9iaWxlQ3VycmVudFBhZ2UgPSAkKCcubW9iaWxlLWFjY291bnQtbmF2IHVsJykuZmluZChcIiNcIitjdXJyZW50QWNjb3VudFBhZ2UpLmRldGFjaCgpO1xuICAgICAgICBpZigkbW9iaWxlQ3VycmVudFBhZ2UubGVuZ3RoKXtcbiAgICAgICAgICAgIHZhciAkbmF2SGVhZGVyID0gJCgnLm1vYmlsZS1hY2NvdW50LW5hdicpLmZpbmQoJy5uYXYtaGVhZGVyJyk7XG4gICAgICAgICAgICAkKCcubW9iaWxlLWFjY291bnQtbmF2IHVsJykucHJlcGVuZChcIjxsaT5cIiskbmF2SGVhZGVyLmh0bWwoKStcIjwvbGk+XCIpO1xuICAgICAgICAgICAgJG5hdkhlYWRlci5maW5kKCdhJykudGV4dCgkbW9iaWxlQ3VycmVudFBhZ2UudGV4dCgpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gQUpBWCBjYWxsIHRvIFVJUzsgYXZvaWQgbXVsdGlwbGUgY2FsbHMgYnkgc2V0dGluZyBhcHAuaXNVSVNSZXF1ZXN0ZWQuXG5mdW5jdGlvbiB0cmlnZ2VyVUlTQ2FydENoZWNrKGNhbGxTb3VyY2UpIHtcbiAgICBpZiAoIWFwcC5pc1VJU1JlcXVlc3RlZCkge1xuICAgIFx0dmFyIHVybCA9IGFwcC51dGlsLmFwcGVuZFBhcmFtVG9VUkwoVXJscy5jYXJ0Q2hlY2ssIFwiY2FsbFNvdXJjZVwiLCBjYWxsU291cmNlKTtcbiAgICAgICAgJC5hamF4KHt1cmw6IHVybH0pO1xuICAgICAgICBhcHAuaXNVSVNSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNDaGVja291dCgpIHtcbiAgICByZXR1cm4gJCgnLnB0X2NoZWNrb3V0JykubGVuZ3RoID4gMDtcbn1cbnZhciBwYWdlcyA9IHtcbiAgICBhY2NvdW50OiByZXF1aXJlKCcuL3BhZ2VzL2FjY291bnQnKSxcbiAgICBjYXJ0OiByZXF1aXJlKCcuL3BhZ2VzL2NhcnQnKSxcbiAgICBjaGVja291dDogcmVxdWlyZSgnLi9wYWdlcy9jaGVja291dCcpLFxuICAgIGNvbXBhcmU6IHJlcXVpcmUoJy4vcGFnZXMvY29tcGFyZScpLFxuICAgIHByb2R1Y3Q6IHJlcXVpcmUoJy4vcGFnZXMvcHJvZHVjdCcpLFxuICAgIHJlZ2lzdHJ5OiByZXF1aXJlKCcuL3BhZ2VzL3JlZ2lzdHJ5JyksXG4gICAgc2VhcmNoOiByZXF1aXJlKCcuL3BhZ2VzL3NlYXJjaCcpLFxuICAgIHN0b3JlZnJvbnQ6IHJlcXVpcmUoJy4vcGFnZXMvc3RvcmVmcm9udCcpLFxuICAgIHdpc2hsaXN0OiByZXF1aXJlKCcuL3BhZ2VzL3dpc2hsaXN0JyksXG4gICAgc3RvcmVsb2NhdG9yOiByZXF1aXJlKCcuL3BhZ2VzL3N0b3JlbG9jYXRvcicpLFxuICAgIG9yZGVyY29uZmlybWF0aW9uOiByZXF1aXJlKCcuL3BhZ2VzL2NoZWNrb3V0L29yZGVyY29uZmlybWF0aW9uJylcbn07XG5cbndpbmRvdy5hcHAgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZG9jdW1lbnQuY29va2llLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgJCgnPGRpdi8+JykuYWRkQ2xhc3MoJ2Jyb3dzZXItY29tcGF0aWJpbGl0eS1hbGVydCcpLmFwcGVuZCgkKCc8cC8+JykuYWRkQ2xhc3MoJ2Jyb3dzZXItZXJyb3InKS5odG1sKFJlc291cmNlcy5DT09LSUVTX0RJU0FCTEVEKSkuYXBwZW5kVG8oJyNicm93c2VyLWNoZWNrJyk7XG4gICAgICAgIH1cbiAgICAgICAgaW5pdGlhbGl6ZURvbSgpO1xuICAgICAgICBpbml0aWFsaXplRXZlbnRzKCk7XG5cbiAgICAgICAgZ2V0Q3VycmVudEFjY291bnRQYWdlKCk7XG5cbiAgICAgICAgLy8gaW5pdCBzcGVjaWZpYyBnbG9iYWwgY29tcG9uZW50c1xuICAgICAgICBjb3VudHJpZXMuaW5pdCgpO1xuICAgICAgICB0b29sdGlwLmluaXQoKTtcbiAgICAgICAgbWluaWNhcnQuaW5pdCgpO1xuICAgICAgICBmbG9hdGxhYmVscy5pbml0KCk7XG4gICAgICAgIHZhbGlkYXRvci5pbml0KCk7XG4gICAgICAgIHJhdGluZy5pbml0KCk7XG4gICAgICAgIHNlYXJjaHBsYWNlaG9sZGVyLmluaXQoKTtcbiAgICAgICAgZW1haWxzdWJzY3JpcHRpb24uaW5pdCgpO1xuICAgICAgICAvLyBleGVjdXRlIHBhZ2Ugc3BlY2lmaWMgaW5pdGlhbGl6YXRpb25zXG4gICAgICAgICQuZXh0ZW5kKHBhZ2UsIHdpbmRvdy5wYWdlQ29udGV4dCk7XG4gICAgICAgIHZhciBucyA9IHBhZ2UubnM7XG4gICAgICAgIGlmIChucyAmJiBwYWdlc1tuc10gJiYgcGFnZXNbbnNdLmluaXQpIHtcbiAgICAgICAgICAgIHBhZ2VzW25zXS5pbml0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBUTFMgc3RhdHVzIGlmIGluZGljYXRlZCBieSBzaXRlIHByZWZlcmVuY2VcbiAgICAgICAgaWYgKFNpdGVQcmVmZXJlbmNlcy5DSEVDS19UTFMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRscy5nZXRVc2VyQWdlbnQoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmFwcC5yZXNvdXJjZXMgPSB3aW5kb3cuUmVzb3VyY2VzO1xuXG5hcHAuZGlhbG9nID0ge1xuICAgIGNyZWF0ZSA6IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgLy8gb3B0aW9ucy50YXJnZXQgY2FuIGJlIGFuIGlkIHNlbGVjdG9yIG9yIGFuIGpxdWVyeSBvYmplY3RcbiAgICAgICAgdmFyIHRhcmdldCA9ICQocGFyYW1zLnRhcmdldCB8fCBcIiNkaWFsb2ctY29udGFpbmVyXCIpO1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIC8vIGlmIG5vIGVsZW1lbnQgZm91bmQsIGNyZWF0ZSBvbmVcbiAgICAgICAgaWYodGFyZ2V0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYodGFyZ2V0LnNlbGVjdG9yICYmIHRhcmdldC5zZWxlY3Rvci5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICAgICAgaWQgPSB0YXJnZXQuc2VsZWN0b3Iuc3Vic3RyKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0ID0gJChcIjxkaXY+XCIpLmF0dHIoXCJpZFwiLCBpZCkuYWRkQ2xhc3MoXCJkaWFsb2ctY29udGVudFwiKS5hcHBlbmRUbyhcImJvZHlcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGRpYWxvZ1xuICAgICAgICB2YXIgY29udGFpbmVyPXRhcmdldDtcbiAgICAgICAgY29udGFpbmVyLmRpYWxvZygkLmV4dGVuZCh0cnVlLCB7fSwgYXBwLmRpYWxvZy5zZXR0aW5ncywgcGFyYW1zLm9wdGlvbnMgfHwge30pKTtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLy8gb3BlbnMgYSBkaWFsb2cgdXNpbmcgdGhlIGdpdmVuIHVybFxuICAgIG9wZW4gOiBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIGlmICghcGFyYW1zLnVybCB8fCBwYXJhbXMudXJsLmxlbmd0aD09PTApIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgJGNhY2hlLmNvbnRhaW5lciA9IGFwcC5kaWFsb2cuY3JlYXRlKHBhcmFtcyk7XG4gICAgICAgIHBhcmFtcy51cmwgPSBhcHAudXRpbC5hcHBlbmRQYXJhbXNUb1VybChwYXJhbXMudXJsLCB7Zm9ybWF0OlwiYWpheFwifSk7XG5cbiAgICAgICAgLy8gZmluYWxseSBsb2FkIHRoZSBkaWFsb2dcbiAgICAgICAgYXBwLmFqYXgubG9hZCh7XG4gICAgICAgICAgICB0YXJnZXQgOiAkY2FjaGUuY29udGFpbmVyLFxuICAgICAgICAgICAgdXJsIDogcGFyYW1zLnVybCxcbiAgICAgICAgICAgIGNhbGxiYWNrIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmKCRjYWNoZS5jb250YWluZXIuZGlhbG9nKFwiaXNPcGVuXCIpKSB7XHRyZXR1cm47XHR9XG4gICAgICAgICAgICAgICAgJGNhY2hlLmNvbnRhaW5lci5kaWFsb2coXCJvcGVuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIH0sXG4gICAgLy8gY2xvc2VzIHRoZSBkaWFsb2cgYW5kIHRyaWdnZXJzIHRoZSBcImNsb3NlXCIgZXZlbnQgZm9yIHRoZSBkaWFsb2dcbiAgICBjbG9zZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYoISRjYWNoZS5jb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAkY2FjaGUuY29udGFpbmVyLmRpYWxvZyhcImNsb3NlXCIpO1xuICAgIH0sXG4gICAgLy8gdHJpZ2dlcnMgdGhlIFwiYXBwbHlcIiBldmVudCBmb3IgdGhlIGRpYWxvZ1xuICAgIHRyaWdnZXJBcHBseSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJCh0aGlzKS50cmlnZ2VyKFwiZGlhbG9nQXBwbGllZFwiKTtcbiAgICB9LFxuICAgIC8vIGF0dGFjaGVzIHRoZSBnaXZlbiBjYWxsYmFjayBmdW5jdGlvbiB1cG9uIGRpYWxvZyBcImFwcGx5XCIgZXZlbnRcbiAgICBvbkFwcGx5IDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAkKHRoaXMpLmJpbmQoXCJkaWFsb2dBcHBsaWVkXCIsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8gdHJpZ2dlcnMgdGhlIFwiZGVsZXRlXCIgZXZlbnQgZm9yIHRoZSBkaWFsb2dcbiAgICB0cmlnZ2VyRGVsZXRlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAkKHRoaXMpLnRyaWdnZXIoXCJkaWFsb2dEZWxldGVkXCIpO1xuICAgIH0sXG4gICAgLy8gYXR0YWNoZXMgdGhlIGdpdmVuIGNhbGxiYWNrIGZ1bmN0aW9uIHVwb24gZGlhbG9nIFwiZGVsZXRlXCIgZXZlbnRcbiAgICBvbkRlbGV0ZSA6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZihjYWxsYmFjaykge1xuICAgICAgICAgICAgJCh0aGlzKS5iaW5kKFwiZGlhbG9nRGVsZXRlZFwiLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vIHN1Ym1pdHMgdGhlIGRpYWxvZyBmb3JtIHdpdGggdGhlIGdpdmVuIGFjdGlvblxuICAgIHN1Ym1pdCA6IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgdmFyIGZvcm0gPSAkY2FjaGUuY29udGFpbmVyLmZpbmQoXCJmb3JtOmZpcnN0XCIpO1xuXG4gICAgICAgIGlmICghZm9ybS52YWxpZCgpKSByZXR1cm47XG5cbiAgICAgICAgLy8gc2V0IHRoZSBhY3Rpb25cbiAgICAgICAgJChcIjxpbnB1dC8+XCIpLmF0dHIoe1xuICAgICAgICAgICAgbmFtZSA6IGFjdGlvbixcbiAgICAgICAgICAgIHR5cGUgOiBcImhpZGRlblwiXG4gICAgICAgIH0pLmFwcGVuZFRvKGZvcm0pO1xuXG4gICAgICAgIC8vIHNlcmlhbGl6ZSB0aGUgZm9ybSBhbmQgZ2V0IHRoZSBwb3N0IHVybFxuICAgICAgICB2YXIgcG9zdCA9IGZvcm0uc2VyaWFsaXplKCk7XG4gICAgICAgIHZhciB1cmwgPSBmb3JtLmF0dHIoXCJhY3Rpb25cIik7XG5cbiAgICAgICAgLy8gcG9zdCB0aGUgZGF0YSBhbmQgcmVwbGFjZSBjdXJyZW50IGNvbnRlbnQgd2l0aCByZXNwb25zZSBjb250ZW50XG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICB0eXBlIDogXCJQT1NUXCIsXG4gICAgICAgICAgICB1cmwgOiB1cmwsXG4gICAgICAgICAgICBkYXRhIDogcG9zdCxcbiAgICAgICAgICAgIGRhdGFUeXBlIDogXCJodG1sXCIsXG4gICAgICAgICAgICBzdWNjZXNzIDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAkY2FjaGUuY29udGFpbmVyLmh0bWwoZGF0YSk7XG4gICAgICAgICAgICAgICAgJChcIi51aS1kaWFsb2ctY29udGVudFwiKS5kaWFsb2coXCJvcHRpb25cIixcImNsb3NlT25Fc2NhcGVcIiwgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmFpbHVyZSA6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmFsZXJ0KGFwcC5yZXNvdXJjZXMuU0VSVkVSX0VSUk9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBzZXR0aW5ncyA6IHtcbiAgICAgICAgYXV0b09wZW4gOiBmYWxzZSxcbiAgICAgICAgcmVzaXphYmxlIDogZmFsc2UsXG4gICAgICAgIGJnaWZyYW1lIDogdHJ1ZSxcbiAgICAgICAgbW9kYWwgOiB0cnVlLFxuICAgICAgICBjbG9zZU9uRXNjYXBlIDogZmFsc2UsXG4gICAgICAgIGhlaWdodCA6ICdhdXRvJyxcbiAgICAgICAgd2lkdGggOiAnNDg0JyxcbiAgICAgICAgYnV0dG9ucyA6IHt9LFxuICAgICAgICB0aXRsZSA6ICcnLFxuICAgICAgICBkcmFnZ2FibGUgOiBmYWxzZSxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIG15OiAnY2VudGVyJyxcbiAgICAgICAgICAgIGF0OiAnY2VudGVyJyxcbiAgICAgICAgICAgIG9mOiB3aW5kb3csXG4gICAgICAgICAgICBjb2xsaXNpb246ICdmbGlwZml0J1xuICAgICAgICB9LFxuICAgICAgICBvdmVybGF5IDoge1xuICAgICAgICAgICAgb3BhY2l0eSA6IDAuNSxcbiAgICAgICAgICAgIGJhY2tncm91bmQgOiBcIndoaXRlXCJcbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2UgOiBmdW5jdGlvbiAoZXZlbnQsIHVpKSB7XG4gICAgICAgICAgICAkKHRoaXMpLmRpYWxvZyhcImRlc3Ryb3lcIik7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEEgZml4IGZvciB3ZWJraXQgYnJvd3NlcnMuIGpRdWVyeSBEaWFsb2cgYm94IGRpc2FibGVzIGNsaWNrIGZ1bmN0aW9uYWxpdHksIHdoaWNoIGJyZWFrcyB0aGUgYnJvd3NlcidzIHNjcm9sbCBiYXJzXG4gICAgICAgIC8vIEpTLTEwOTkuIDYuOS4xMyBFdGhhbkdcbiAgICAgICAgb3BlbjogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIGpRdWVyeShkb2N1bWVudCkudW5iaW5kKCdtb3VzZWRvd24uZGlhbG9nLW92ZXJsYXknKVxuICAgICAgICAgICAgICAgIC51bmJpbmQoJ21vdXNldXAuZGlhbG9nLW92ZXJsYXknKTtcbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgIH1cbiAgICB9XG59Oy8vZW5kIGFwcC5kaWFsb2dcbmFwcC51dGlsID0ge1xuICAgIC8vIHRyaW1zIGEgcHJlZml4IGZyb20gYSBnaXZlbiBzdHJpbmcsIHRoaXMgY2FuIGJlIHVzZWQgdG8gdHJpbVxuICAgIC8vIGEgY2VydGFpbiBwcmVmaXggZnJvbSBET00gZWxlbWVudCBJRHMgZm9yIGZ1cnRoZXIgcHJvY2Vzc2luZyBvbiB0aGUgSURcbiAgICB0cmltUHJlZml4IDogZnVuY3Rpb24gKHN0ciwgcHJlZml4KSB7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKHByZWZpeC5sZW5ndGgpO1xuICAgIH0sXG4gICAgc2V0RGlhbG9naWZ5IDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgYWN0aW9uU291cmNlID0gJCh0aGlzKSxcbiAgICAgICAgICAgIGRsZ0FjdGlvbiA9IGFjdGlvblNvdXJjZS5kYXRhKFwiZGxnLWFjdGlvblwiKSB8fCB7fSwgLy8gdXJsLCB0YXJnZXQsIGlzRm9ybVxuICAgICAgICAgICAgZGxnQ2FsbGJhY2sgPSAoYWN0aW9uU291cmNlLmRhdGEoXCJkbGctY2FsbGJhY2tcIikgIT0gbnVsbCAmJiBhY3Rpb25Tb3VyY2UuZGF0YShcImRsZy1jYWxsYmFja1wiKSkgPyBhY3Rpb25Tb3VyY2UuZGF0YShcImRsZy1jYWxsYmFja1wiKSA6IG51bGwsXG4gICAgICAgICAgICBkbGdPcHRpb25zID0gJC5leHRlbmQoe30sIGFwcC5kaWFsb2cuc2V0dGluZ3MsIGFjdGlvblNvdXJjZS5kYXRhKFwiZGxnLW9wdGlvbnNcIikgfHwge30pLFxuICAgICAgICAgICAgY3VzdG9tQ2xhc3MgPSAoYWN0aW9uU291cmNlLmRhdGEoXCJkbGctY3VzdG9tY2xhc3NcIikgIT0gbnVsbCAmJiBhY3Rpb25Tb3VyY2UuZGF0YShcImRsZy1jdXN0b21jbGFzc1wiKSA/IGFjdGlvblNvdXJjZS5kYXRhKFwiZGxnLWN1c3RvbWNsYXNzXCIpIDogbnVsbCksXG4gICAgICAgICAgICB2YWxpZEZvcm0gPSAoICFkbGdBY3Rpb24uaXNGb3JtIHx8ICggZGxnQWN0aW9uLmlzRm9ybSAmJiBhY3Rpb25Tb3VyY2UuY2xvc2VzdChcImZvcm1cIikudmFsaWQoKSApKTtcbiAgICAgICAgZGxnT3B0aW9ucy50aXRsZSA9IGRsZ09wdGlvbnMudGl0bGUgfHwgYWN0aW9uU291cmNlLmF0dHIoXCJ0aXRsZVwiKSB8fCBcIlwiO1xuICAgICAgICAvLyBJZiB3ZSBhcmUgc3VibWl0dGluZyBhIGZvcm0sIG1ha2Ugc3VyZSBpdCBpcyB2YWxpZCBmaXJzdFxuICAgICAgICBpZighdmFsaWRGb3JtKSByZXR1cm47XG4gICAgICAgIC8vIEVsc2UgY29udGludWVcbiAgICAgICAgdmFyIHVybCA9IGRsZ0FjdGlvbi51cmwgLy8gdXJsIGZyb20gZGF0YVxuICAgICAgICAgICAgICAgICAgfHwgKGRsZ0FjdGlvbi5pc0Zvcm0gPyBhY3Rpb25Tb3VyY2UuY2xvc2VzdChcImZvcm1cIikuYXR0cihcImFjdGlvblwiKSA6IG51bGwpIC8vIG9yIHVybCBmcm9tIGZvcm0gYWN0aW9uIGlmIGlzRm9ybT10cnVlXG4gICAgICAgICAgICAgICAgICB8fCBhY3Rpb25Tb3VyY2UuYXR0cihcImhyZWZcIik7IC8vIG9yIHVybCBmcm9tIGhyZWZcbiAgICAgICAgaWYgKCF1cmwpIHJldHVybjtcblxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgY29udGVudCBsaW5rLCB1cGRhdGUgdXJsIGZyb20gUGFnZS1TaG93IHRvIFBhZ2UtSW5jbHVkZVxuICAgICAgICBpZiAoYWN0aW9uU291cmNlLmhhc0NsYXNzKFwiYXR0cmlidXRlY29udGVudGxpbmtcIikpIHtcbiAgICAgICAgICAgIHZhciB1cmkgPSBhcHAudXRpbC5nZXRVcmkodXJsKTtcbiAgICAgICAgICAgIHVybCA9IFVybHMucGFnZUluY2x1ZGUrdXJpLnF1ZXJ5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkbGcgPSBhcHAuZGlhbG9nLmNyZWF0ZSh7dGFyZ2V0OmRsZ0FjdGlvbi50YXJnZXQsIG9wdGlvbnMgOiBkbGdPcHRpb25zLCBjdXN0b21DbGFzcyA6IGN1c3RvbUNsYXNzfSk7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBhbnkgY2xvc2UgYnV0dG9ucyBhcmUgaW5pdGlhdGVkXG4gICAgICAgIGRsZy5vbihcImNsaWNrXCIsIFwiLmRpYWxvZy1jbG9zZS1idXR0b24sIC51aS1kaWFsb2ctdGl0bGViYXItY2xvc2VcIiwgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBhcHAuZGlhbG9nLmNsb3NlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIElmIHdlIGFyZSBzZW5kaW5nIGEgZm9ybSwgc2VyaWFsaXplIGl0IGFuZCBzZW5kIGl0IChpbmNsdWRpbmcgdGhlIGJ1dHRvbiBuYW1lL3ZhbHVlKVxuICAgICAgICB2YXIgZm9ybURhdGEgPSBkbGdBY3Rpb24uaXNGb3JtID8gKGFjdGlvblNvdXJjZS5jbG9zZXN0KFwiZm9ybVwiKS5zZXJpYWxpemUoKSArIFwiJlwiICsgYWN0aW9uU291cmNlLmF0dHIoXCJuYW1lXCIpICsgXCI9XCIgKyBhY3Rpb25Tb3VyY2UuYXR0cihcInZhbHVlXCIpKSA6IHt9O1xuICAgICAgICBhcHAuYWpheC5sb2FkKHtcbiAgICAgICAgICAgIHVybDogYWN0aW9uU291cmNlLmF0dHIoXCJocmVmXCIpIHx8IGFjdGlvblNvdXJjZS5jbG9zZXN0KFwiZm9ybVwiKS5hdHRyKFwiYWN0aW9uXCIpLFxuICAgICAgICAgICAgZGF0YSA6IGZvcm1EYXRhLFxuICAgICAgICAgICAgdGFyZ2V0OiBkbGcsXG4gICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBkbGcuZGlhbG9nKFwib3BlblwiKTsgLy8gb3BlbiBhZnRlciBsb2FkIHRvIGVuc3VyZSBkaWFsb2cgaXMgY2VudGVyZWRcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tQ2xhc3Mpe1xuICAgICAgICAgICAgICAgICAgICBkbGcuY2xvc2VzdCgnLnVpLWRpYWxvZycpLmFkZENsYXNzKGN1c3RvbUNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRsZ09wdGlvbnMuY3VzdG9tQ2xhc3M9PT0nc2l6ZS1kaWFsb2cnKSAkKCcjc2l6ZS1jaGFydC10YWJzJykudGFicygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmbG9hdGxhYmVscy5pbml0KCk7XG4gICAgICAgICAgICAgICAgYXBwLnZhbGlkYXRvci5pbml0KCk7IC8vIHJlLWluaXQgdmFsaWRhdG9yXG5cbiAgICAgICAgICAgICAgICBpZiAoZGxnT3B0aW9ucy5jZW50ZXIgJiYgZGxnT3B0aW9ucy5kaWFsb2dDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAkKCcuJyArIGRsZ09wdGlvbnMuZGlhbG9nQ2xhc3MpLmNlbnRlcigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENhbGwgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlmIGl0IHdhcyBzZXQgaW4gdGhlIGluaXRpYWwgPGE+IHRhZydzIGRhdGEtZGxnLWNhbGxiYWNrIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgIGlmKCFkbGdDYWxsYmFjayB8fCAhd2luZG93Lmhhc093blByb3BlcnR5KGRsZ0NhbGxiYWNrKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGxnQ2FsbGJhY2sgPT0gXCJzdHJpbmdcIil7XG4gICAgICAgICAgICAgICAgICAgIGRsZ0NhbGxiYWNrID0gZXZhbChkbGdDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGxnQ2FsbGJhY2sgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkbGdDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3dbZGxnQ2FsbGJhY2tdKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHNldEN1c3RvbVJlZGlyZWN0VVJMIDogZnVuY3Rpb24odXJsKXtcbiAgICAgICAgJC5hamF4KGFwcC51dGlsLmFwcGVuZFBhcmFtVG9VUkwoXG4gICAgICAgICAgICAgICAgYXBwLnVybHMuaG9tZVNldEN1c3RvbVJlZGlyZWN0VXJsLFwidXJsXCIsdXJsKSk7XG4gICAgfSxcbiAgICAvLyBDcmVhdGUgYSBob29rIGZvciBhIGZvcm0gdGhhdCB1dGlsaXplcyBzdGFuZGFyZCBzdWJtaXQgZmVhdHVyZXMgKG5vbi1hamF4KSwgYnV0IG5lZWRzIGFkZGl0aW9uYWwgZnJvbnQtZW5kIHZhbGlkYXRpb24gYmVmb3JlIHN1Ym1pdHRpbmdcbiAgICB2YWxpZGF0ZUhvb2sgOiBmdW5jdGlvbih0YXJnZXQpe1xuICAgICAgICAkKHRhcmdldCkub24oJ2NsaWNrJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgYWN0aW9uIGlmIGZvcm0gaXMgbm90IHZhbGlkXG4gICAgICAgICAgICBpZighJCh0aGlzKS5jbG9zZXN0KCdmb3JtJykudmFsaWQoKSkge2UucHJldmVudERlZmF1bHQoKTtyZXR1cm4gZmFsc2U7fVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIC8vIENsZWFyIGZvcm0gZWxlbWVudHMgYW5kIG1ha2Ugc3VyZSB0aGV5IGRvbid0IGhhdmUgZm9jdXMgb24gbG9hZFxuICAgIC8vIEB0YXJnZXQgOiBBIGpRdWVyeSBvYmplY3QgcmVwcmVzZW50aW5nIGEgZm9ybVxuICAgIC8vIEBwbGFjZWhvbGRlciAgOiBBIGJvb2xlYW4uIHRydWUgLSBvbmx5IHJlZG8gdGhlIHBsYWNlIGhvbGRlcnMgOiBmYWxzZSAtIGRvIGV2ZXJ5dGhpbmdcbiAgICBmb3JtQmx1ciA6IGZ1bmN0aW9uKHRhcmdldCwgc2V0SG9sZGVyKXtcbiAgICAgICAgdGFyZ2V0LmVhY2goZnVuY3Rpb24oaW5kZXgpe1xuICAgICAgICAgICAgLy8gUmVtb3ZlcyBhbnkgY2hhcmFjdGVycyBpbiB0aGUgaW5wdXQgZmllbGRzXG4gICAgICAgICAgICBpZighc2V0SG9sZGVyKSB0aGlzLnJlc2V0KCk7XG5cbiAgICAgICAgICAgIC8vIEdvIHRocm91Z2ggdGhlIGlucHV0cyBhbmQgcmVtb3ZlIGFueSBlcnJvciBjbGFzc1xuICAgICAgICAgICAgJCh0aGlzKS5maW5kKCdpbnB1dCcpLmVhY2goZnVuY3Rpb24oaSl7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gJCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIG9ubHkgbmVlZCB0byBkbyB0aGUgcGxhY2Vob2xkZXJzIC0gcmV0dXJuIG91dCBvZiB0aGlzIGxvb3AgYW5kIGRvbid0IHJlc2V0IGVycm9yc1xuICAgICAgICAgICAgICAgIGlmKHNldEhvbGRlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb25lIEhUTUw1IHBsYWNlIGhvbGRlcnNcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQucGxhY2Vob2xkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGl0IGlzbid0IGF1dG8gZm9jdXNlZCAoaGlkZXMgbm9uZS1odG1sNSBwbGFjZSBob2xkZXJzKVxuICAgICAgICAgICAgICAgIGlucHV0LmJsdXIoKTtcbiAgICAgICAgICAgICAgICAvLyBOb25lIEhUTUw1IHBsYWNlIGhvbGRlcnNcbiAgICAgICAgICAgICAgICAvL2lucHV0LnBsYWNlaG9sZGVyKCk7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlL2hpZGUgZXJyb3JzIGR1ZSB0byBibHVyXG4gICAgICAgICAgICAgICAgaW5wdXQucmVtb3ZlQ2xhc3MoJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgaW5wdXQucGFyZW50KCkuZmluZCgnc3Bhbi5lcnJvcicpLmhpZGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIC8vIFN1Ym1pdCBhIGZvcm0gdmlhIGFqYXggKG9ubHkgaWYgaXQgaXMgdmFsaWQpIGFuZCBhbGxvdyBmb3IgYSBjYWxsIGJhY2tcbiAgICBmb3Jtc3VibWl0IDogZnVuY3Rpb24oZm9ybSwgYnRuLCB0eXBlLCBjYWxsYmFjayl7XG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiBmb3JtIGlzIHZhbGlkXG4gICAgICAgIGlmICghZm9ybS52YWxpZCgpKSByZXR1cm47XG4gICAgICAgIC8vIElmIHZhbGlkLCBzZW5kIHRoZSBmb3JtIHZpYSBhamF4XG4gICAgICAgIC8vIERhdGEgdG8gc2VuZCB0byB0aGUganF1ZXJ5IGNhbGxcbiAgICAgICAgdmFyIHVybCA9IGFwcC51dGlsLmFwcGVuZFBhcmFtVG9VUkwoZm9ybS5hdHRyKCdhY3Rpb24nKSwgXCJmb3JtYXRcIiwgXCJhamF4XCIpO1xuICAgICAgICAvLyBDb2xsZWN0IHRoZSByZXF1aXJlZCBmb3JtIGZpZWxkc1xuICAgICAgICB2YXIgZGF0YSA9IGZvcm0uc2VyaWFsaXplKCk7XG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgd2hhdCB0eXBlIG9mIGNhbGwgdGhpcyBpcyAoZnJvbSB0aGUgYnV0dG9uKVxuICAgICAgICBkYXRhICs9IFwiJlwiICsgYnRuLmF0dHIoXCJuYW1lXCIpICsgXCI9XCIgKyBidG4uYXR0cihcInZhbHVlXCIpO1xuICAgICAgICAvLyBtYWtlIHRoZSBzZXJ2ZXIgY2FsbFxuICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgdXJsIDogdXJsLFxuICAgICAgICAgICAgZGF0YSA6IGRhdGEsXG4gICAgICAgICAgICB0eXBlOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGRhdGFUeXBlOiB0eXBlIHx8IFwiaHRtbFwiXG4gICAgICAgIH0pXG4gICAgICAgIC5kb25lKGZ1bmN0aW9uKGUsIHRleHRTdGF0dXMpe1xuICAgICAgICAgICAgaWYoIWNhbGxiYWNrKSByZXR1cm47XG4gICAgICAgICAgICBjYWxsYmFjayhlLCB0ZXh0U3RhdHVzKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmZhaWwoZnVuY3Rpb24gKGUsIHRleHRTdGF0dXMpIHtcbiAgICAgICAgICAgIGlmKHRleHRTdGF0dXMgPT09IFwicGFyc2VyZXJyb3JcIikge1xuICAgICAgICAgICAgICAgIGFsZXJ0KHRleHRTdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIHBhZExlZnQgOiBmdW5jdGlvbiAoc3RyLCBwYWRDaGFyLCBsZW4pIHtcbiAgICAgICAgdmFyIGRpZ3MgPSBsZW4gfHwgMTA7XG4gICAgICAgIHZhciBzID0gc3RyLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBkaWYgPSBkaWdzIC0gcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlKGRpZiA+IDApIHtcbiAgICAgICAgICAgIHMgPSBwYWRDaGFyICsgcztcbiAgICAgICAgICAgIGRpZi0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH0sXG4gICAgLy8gYXBwZW5kcyB0aGUgcGFyYW1ldGVyIHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kXG4gICAgLy8gdmFsdWUgdG8gdGhlIGdpdmVuIHVybCBhbmQgcmV0dXJucyB0aGUgY2hhbmdlZCB1cmxcbiAgICBhcHBlbmRQYXJhbVRvVVJMIDogZnVuY3Rpb24gKHVybCwgbmFtZSwgdmFsdWUsIGVuY29kZSkge1xuICAgICAgICBpZiAodHlwZW9mIGVuY29kZSA9PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgICAgIGVuY29kZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGMgPSBcIj9cIjtcbiAgICAgICAgaWYodXJsICYmIHVybC5pbmRleE9mKGMpICE9PSAtMSkge1xuICAgICAgICAgICAgYyA9IFwiJlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmwgKyBjICsgbmFtZSArIFwiPVwiICsgKGVuY29kZSA/IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiB2YWx1ZSk7XG4gICAgfSxcbiAgICBhcHBlbmRQYXJhbXNUb1VybCA6IGZ1bmN0aW9uICh1cmwsIHBhcmFtcykge1xuICAgICAgICB2YXIgdXJpID0gYXBwLnV0aWwuZ2V0VXJpKHVybCksXG4gICAgICAgICAgICBpbmNsdWRlSGFzaCA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gZmFsc2UgOiBhcmd1bWVudHNbMl07XG5cbiAgICAgICAgdmFyIHFzUGFyYW1zID0gJC5leHRlbmQodXJpLnF1ZXJ5UGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdXJpLnBhdGgrXCI/XCIrJC5wYXJhbShxc1BhcmFtcyk7XG4gICAgICAgIGlmIChpbmNsdWRlSGFzaCkge1xuICAgICAgICAgICAgcmVzdWx0Kz11cmkuaGFzaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LmluZGV4T2YoXCJodHRwXCIpPDAgJiYgcmVzdWx0LmNoYXJBdCgwKSE9PVwiL1wiKSB7XG4gICAgICAgICAgICByZXN1bHQ9XCIvXCIrcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIHJlbW92ZVBhcmFtRnJvbVVSTCA6IGZ1bmN0aW9uICh1cmwsIHBhcmFtZXRlcikge1xuICAgICAgICB2YXIgdXJscGFydHMgPSB1cmwuc3BsaXQoJz8nKTtcbiAgICAgICAgaWYodXJscGFydHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIHZhciB1cmxCYXNlID0gdXJscGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgIHZhciBxdWVyeVN0cmluZyA9IHVybHBhcnRzLmpvaW4oXCI/XCIpO1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IGVuY29kZVVSSUNvbXBvbmVudChwYXJhbWV0ZXIpICsgJz0nO1xuICAgICAgICAgICAgdmFyIHBhcnMgPSBxdWVyeVN0cmluZy5zcGxpdCgvWyY7XS9nKTtcbiAgICAgICAgICAgIHZhciBpPXBhcnMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUoMCA8IGktLSkge1xuICAgICAgICAgICAgICAgIGlmKHBhcnNbaV0ubGFzdEluZGV4T2YocHJlZml4LCAwKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXJsID0gdXJsQmFzZSArICc/JyArIHBhcnMuam9pbignJicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfSxcbiAgICBzdGF0aWNVcmwgOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICBpZighcGF0aCB8fCAkLnRyaW0ocGF0aCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwLnVybHMuc3RhdGljUGF0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwLnVybHMuc3RhdGljUGF0aCArIChwYXRoLmNoYXJBdCgwKSA9PT0gXCIvXCIgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGggKTtcbiAgICB9LFxuICAgIGFqYXhVcmwgOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICByZXR1cm4gYXBwLnV0aWwuYXBwZW5kUGFyYW1Ub1VSTChwYXRoLCBcImZvcm1hdFwiLCBcImFqYXhcIik7XG4gICAgfSxcblxuICAgIHRvQWJzb2x1dGVVcmwgOiBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIGlmICh1cmwuaW5kZXhPZihcImh0dHBcIikhPT0wICYmIHVybC5jaGFyQXQoMCkhPT1cIi9cIikge1xuICAgICAgICAgICAgdXJsID0gXCIvXCIrdXJsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfSxcbiAgICBsb2FkRHluYW1pY0NzcyA6IGZ1bmN0aW9uICh1cmxzKSB7XG4gICAgICAgIHZhciBpLCBsZW49dXJscy5sZW5ndGg7XG4gICAgICAgIGZvcihpPTA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgYXBwLnV0aWwubG9hZGVkQ3NzRmlsZXMucHVzaChhcHAudXRpbC5sb2FkQ3NzRmlsZSh1cmxzW2ldKSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vIGR5bmFtaWNhbGx5IGxvYWRzIGEgQ1NTIGZpbGVcbiAgICBsb2FkQ3NzRmlsZSA6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgcmV0dXJuICQoXCI8bGluay8+XCIpLmFwcGVuZFRvKCQoXCJoZWFkXCIpKS5hdHRyKHtcbiAgICAgICAgICAgIHR5cGUgOiBcInRleHQvY3NzXCIsXG4gICAgICAgICAgICByZWwgOiBcInN0eWxlc2hlZXRcIlxuICAgICAgICB9KS5hdHRyKFwiaHJlZlwiLCB1cmwpOyAvLyBmb3IgaS5lLiA8OSwgaHJlZiBtdXN0IGJlIGFkZGVkIGFmdGVyIGxpbmsgaGFzIGJlZW4gYXBwZW5kZWQgdG8gaGVhZFxuICAgIH0sXG4gICAgLy8gYXJyYXkgdG8ga2VlcCB0cmFjayBvZiB0aGUgZHluYW1pY2FsbHkgbG9hZGVkIENTUyBmaWxlc1xuICAgIGxvYWRlZENzc0ZpbGVzIDogW10sXG4gICAgLy8gcmVtb3ZlcyBhbGwgZHluYW1pY2FsbHkgbG9hZGVkIENTUyBmaWxlc1xuICAgIGNsZWFyRHluYW1pY0NzcyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGkgPSBhcHAudXRpbC5sb2FkZWRDc3NGaWxlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlKDAgPiBpLS0pIHtcbiAgICAgICAgICAgICQoYXBwLnV0aWwubG9hZGVkQ3NzRmlsZXNbaV0pLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGFwcC51dGlsLmxvYWRlZENzc0ZpbGVzID0gW107XG4gICAgfSxcbiAgICBzY3JpcHRzIDogW10sXG4gICAgbG9hZFNjcmlwdCA6IGZ1bmN0aW9uICh1cmwsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBzY3JpcHQgPSAgYXBwLnV0aWwuc2NyaXB0c1t1cmxdIHx8ICggYXBwLnV0aWwuc2NyaXB0c1t1cmxdID0ge1xuICAgICAgICAgICAgbG9hZGVkICAgIDogZmFsc2UsXG4gICAgICAgICAgICBjYWxsYmFja3MgOiBbXVxuICAgICAgICB9KTtcblxuICAgICAgICBpZihzY3JpcHQubG9hZGVkICYmIGNhbGxiYWNrICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NyaXB0LmNhbGxiYWNrcy5wdXNoKHtcbiAgICAgICAgICAgIGZuICAgICAgOiBjYWxsYmFjayxcbiAgICAgICAgICAgIGNvbnRleHQgOiBjb250ZXh0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmKHNjcmlwdC5jYWxsYmFja3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgdHlwZSAgICAgOiAnR0VUJyxcbiAgICAgICAgICAgICAgICB1cmwgICAgICA6IHVybCxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZSA6ICdzY3JpcHQnLFxuICAgICAgICAgICAgICAgIGNhY2hlICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzICA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHQubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHNjcmlwdC5jYWxsYmFja3MsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZm4gIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mbi5hcHBseSh0aGlzLmNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0LmNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXRRdWVyeVN0cmluZ1BhcmFtcyA6IGZ1bmN0aW9uIChxcykge1xuICAgICAgICBpZighcXMgfHwgcXMubGVuZ3RoID09PSAwKSB7IHJldHVybiB7fTsgfVxuICAgICAgICB2YXIgcGFyYW1zID0ge307XG4gICAgICAgIC8vIFVzZSB0aGUgU3RyaW5nOjpyZXBsYWNlIG1ldGhvZCB0byBpdGVyYXRlIG92ZXIgZWFjaFxuICAgICAgICAvLyBuYW1lLXZhbHVlIHBhaXIgaW4gdGhlIHN0cmluZy5cbiAgICAgICAgcXMucmVwbGFjZSggbmV3IFJlZ0V4cCggXCIoW14/PSZdKykoPShbXiZdKikpP1wiLCBcImdcIiApLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoICQwLCAkMSwgJDIsICQzICkgeyAgIHBhcmFtc1sgJDEgXSA9ICQzOyB9XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfSxcbiAgICBnZXRVcmkgOiBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgYTtcbiAgICAgICAgaWYgKG8udGFnTmFtZSAmJiAkKG8pLmF0dHIoXCJocmVmXCIpKSB7XG4gICAgICAgICAgICBhID0gbztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICAgICAgYS5ocmVmID0gbztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXRoUGFydHMgPSAnJztcbiAgICAgICAgaWYgKGEucGF0aG5hbWUpIHtcbiAgICAgICAgICAgIHBhdGhQYXJ0cyA9IGEucGF0aG5hbWUuc3BsaXQoJy8nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvdG9jb2wgOiBhLnByb3RvY29sLCAvL2h0dHA6XG4gICAgICAgICAgICBob3N0IDogYS5ob3N0LCAvL3d3dy5teWV4YW1wbGUuY29tXG4gICAgICAgICAgICBob3N0bmFtZSA6IGEuaG9zdG5hbWUsIC8vd3d3Lm15ZXhhbXBsZS5jb20nXG4gICAgICAgICAgICBwb3J0IDogYS5wb3J0LCAvLzo4MFxuICAgICAgICAgICAgcGF0aCA6IGEucGF0aG5hbWUsIC8vIC9zdWIxL3N1YjJcbiAgICAgICAgICAgIHF1ZXJ5IDogYS5zZWFyY2gsIC8vID9wYXJhbTE9dmFsMSZwYXJhbTI9dmFsMlxuICAgICAgICAgICAgcXVlcnlQYXJhbXMgOiBhLnNlYXJjaC5sZW5ndGggPiAxID8gYXBwLnV0aWwuZ2V0UXVlcnlTdHJpbmdQYXJhbXMoYS5zZWFyY2guc3Vic3RyKDEpKSA6IHt9LFxuICAgICAgICAgICAgaGFzaCA6IGEuaGFzaCwgLy8gI09VODEyLDUxNTBcbiAgICAgICAgICAgIHVybCA6IGEucHJvdG9jb2wrIFwiLy9cIiArIGEuaG9zdCArIGEucGF0aG5hbWUsXG4gICAgICAgICAgICB1cmxXaXRoUXVlcnkgOiBhLnByb3RvY29sKyBcIi8vXCIgKyBhLmhvc3QgKyBhLnBvcnQgKyBhLnBhdGhuYW1lICsgYS5zZWFyY2gsXG4gICAgICAgICAgICBwYWdlIDogcGF0aFBhcnRzLmxlbmd0aCA+IDAgPyBwYXRoUGFydHNbcGF0aFBhcnRzLmxlbmd0aC0xXSA6ICcnIC8vIHN1YjJcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHBvc3RGb3JtIDogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgdmFyIGZvcm0gPSAkKFwiPGZvcm0+XCIpLmF0dHIoe2FjdGlvbjphcmdzLnVybCxtZXRob2Q6XCJwb3N0XCJ9KS5hcHBlbmRUbyhcImJvZHlcIik7XG4gICAgICAgIHZhciBwO1xuICAgICAgICBmb3IgKHAgaW4gYXJncy5maWVsZHMpIHtcbiAgICAgICAgICAgICQoXCI8aW5wdXQ+XCIpLmF0dHIoe25hbWU6cCx2YWx1ZTphcmdzLmZpZWxkc1twXX0pLmFwcGVuZFRvKGZvcm0pO1xuICAgICAgICB9XG4gICAgICAgIGZvcm0uc3VibWl0KCk7XG4gICAgfSxcbiAgICBnZXRNZXNzYWdlIDogZnVuY3Rpb24gKGtleSwgYnVuZGxlTmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjayB8fCAha2V5IHx8IGtleS5sZW5ndGg9PT0wKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmFtcyA9IHtrZXk6a2V5fTtcbiAgICAgICAgaWYgKGJ1bmRsZU5hbWUgJiYgYnVuZGxlTmFtZS5sZW5ndGg9PT0wKSB7XG4gICAgICAgICAgICBwYXJhbXMuYm4gPSBidW5kbGVOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cmwgPSBhcHAudXRpbC5hcHBlbmRQYXJhbXNUb1VybChhcHAudXJscy5hcHBSZXNvdXJjZXMsIHBhcmFtcyk7XG4gICAgICAgICQuZ2V0SlNPTih1cmwsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgbGltaXRDaGFyYWN0ZXJzIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAkKCdmb3JtJykuZmluZCgndGV4dGFyZWFbZGF0YS1jaGFyYWN0ZXItbGltaXRdJykuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgdmFyIGNoYXJhY3RlckxpbWl0ID0gJCh0aGlzKS5kYXRhKFwiY2hhcmFjdGVyLWxpbWl0XCIpO1xuICAgICAgICAgICAgdmFyIGNoYXJDb3VudEh0bWwgPSBTdHJpbmcuZm9ybWF0KGFwcC5yZXNvdXJjZXMuQ0hBUl9MSU1JVF9NU0csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJjaGFyLXJlbWFpbi1jb3VudFwiPicrY2hhcmFjdGVyTGltaXQrJzwvc3Bhbj4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiY2hhci1hbGxvd2VkLWNvdW50XCI+JytjaGFyYWN0ZXJMaW1pdCsnPC9zcGFuPicpO1xuICAgICAgICAgICAgdmFyIGNoYXJDb3VudENvbnRhaW5lciA9ICQodGhpcykubmV4dCgnZGl2LmNoYXItY291bnQnKTtcbiAgICAgICAgICAgIGlmIChjaGFyQ291bnRDb250YWluZXIubGVuZ3RoPT09MCkge1xuICAgICAgICAgICAgICAgIGNoYXJDb3VudENvbnRhaW5lciA9ICQoJzxkaXYgY2xhc3M9XCJjaGFyLWNvdW50XCIvPicpLmluc2VydEFmdGVyKCQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhckNvdW50Q29udGFpbmVyLmh0bWwoY2hhckNvdW50SHRtbCk7XG4gICAgICAgICAgICAvLyB0cmlnZ2VyIHRoZSBrZXlkb3duIGV2ZW50IHNvIHRoYXQgYW55IGV4aXN0aW5nIGNoYXJhY3RlciBkYXRhIGlzIGNhbGN1bGF0ZWRcbiAgICAgICAgICAgICQodGhpcykuY2hhbmdlKCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBzZXREZWxldGVDb25maXJtYXRpb24gOiBmdW5jdGlvbihjb250YWluZXIsIG1lc3NhZ2UpIHtcbiAgICAgICAgJChjb250YWluZXIpLm9uKFwiY2xpY2tcIiwgXCIuZGVsZXRlXCIsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpcm0obWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBzY3JvbGxCcm93c2VyIDogZnVuY3Rpb24gKHhMb2NhdGlvbikge1xuICAgICAgICAkKCdodG1sLCBib2R5JykuYW5pbWF0ZSh7IHNjcm9sbFRvcDogeExvY2F0aW9uIH0sIDUwMCk7XG4gICAgfSxcblxuICAgIG5vSW1hZ2UgOiBmdW5jdGlvbihpbWcpIHtcbiAgICAgICAgaWYoYXBwICYmIGFwcC5yZXNvdXJjZXMgJiYgYXBwLnJlc291cmNlcy5OT19JTUFHRV9VUkwpe1xuICAgICAgICAgICAgdmFyICRpbWcgPSAkKGltZyk7XG4gICAgICAgICAgICAkaW1nLmF0dHIoJ2RhdGEtZmFpbGVkLXNyYycsICRpbWcuYXR0cignc3JjJykpO1xuICAgICAgICAgICAgJGltZy5hdHRyKCdzcmMnLCBhcHAucmVzb3VyY2VzLk5PX0lNQUdFX1VSTCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbm9JbWFnZUhhbmRsZXIgOiBmdW5jdGlvbihpbWcsIGVycm9ySGFuZGxlcikge1xuICAgICAgICB2YXIgJGltZyA9ICQoaW1nKTtcbiAgICAgICAgJGltZy5vbignZXJyb3InLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYoZXJyb3JIYW5kbGVyKXtcbiAgICAgICAgICAgICAgICBlcnJvckhhbmRsZXIodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIGFwcC51dGlsLm5vSW1hZ2UodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyByZWxvYWQgaW1hZ2UgaW4gY2FzZSB3ZSBtaXNzZWQgdGhlIGVycm9yIGV2ZW50XG4gICAgICAgIHZhciBzcmMgPSAkaW1nLmF0dHIoJ3NyYycpO1xuICAgICAgICAvLyRpbWcuYXR0cignc3JjJywgJycpOyAvLyB0aGlzIGxpbmUgY3Jhc2hlcyBpT1MgNi4wXG4gICAgICAgIGlmKGFwcCAmJiBhcHAucmVzb3VyY2VzICYmIGFwcC5yZXNvdXJjZXMuQkxBTktfSU1BR0VfVVJMKXtcbiAgICAgICAgICAgICRpbWcuYXR0cignc3JjJywgYXBwLnJlc291cmNlcy5CTEFOS19JTUFHRV9VUkwpO1xuICAgICAgICB9XG4gICAgICAgICRpbWcuYXR0cignc3JjJywgc3JjKTtcbiAgICB9LFxuICAgIHNldENvb2tpZSA6IGZ1bmN0aW9uKGNfbmFtZSx2YWx1ZSxleGRheXMpe1xuICAgICAgICAvLyBodHRwOi8vd3d3Lnczc2Nob29scy5jb20vanMvanNfY29va2llcy5hc3BcbiAgICAgICAgdmFyIGV4ZGF0ZT1uZXcgRGF0ZSgpO1xuICAgICAgICBleGRhdGUuc2V0RGF0ZShleGRhdGUuZ2V0RGF0ZSgpICsgZXhkYXlzKTtcbiAgICAgICAgdmFyIGNfdmFsdWU9ZXNjYXBlKHZhbHVlKSArICgoZXhkYXlzPT1udWxsKSA/IFwiXCIgOiBcIjsgZXhwaXJlcz1cIitleGRhdGUudG9VVENTdHJpbmcoKSkgKyBcIjsgcGF0aD0vXCI7XG4gICAgICAgIGRvY3VtZW50LmNvb2tpZT1jX25hbWUgKyBcIj1cIiArIGNfdmFsdWU7XG4gICAgfSxcbiAgICBnZXRDb29raWUgOiBmdW5jdGlvbihjX25hbWUpe1xuICAgICAgICAvLyBodHRwOi8vd3d3Lnczc2Nob29scy5jb20vanMvanNfY29va2llcy5hc3BcbiAgICAgICAgdmFyIGNfdmFsdWUgPSBkb2N1bWVudC5jb29raWU7XG4gICAgICAgIHZhciBjX3N0YXJ0ID0gY192YWx1ZS5pbmRleE9mKFwiIFwiICsgY19uYW1lICsgXCI9XCIpO1xuICAgICAgICBpZiAoY19zdGFydCA9PSAtMSl7XG4gICAgICAgICAgICBjX3N0YXJ0ID0gY192YWx1ZS5pbmRleE9mKGNfbmFtZSArIFwiPVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY19zdGFydCA9PSAtMSl7XG4gICAgICAgICAgICBjX3ZhbHVlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNfc3RhcnQgPSBjX3ZhbHVlLmluZGV4T2YoXCI9XCIsIGNfc3RhcnQpICsgMTtcbiAgICAgICAgICAgIHZhciBjX2VuZCA9IGNfdmFsdWUuaW5kZXhPZihcIjtcIiwgY19zdGFydCk7XG4gICAgICAgICAgICBpZiAoY19lbmQgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjX2VuZCA9IGNfdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY192YWx1ZSA9IHVuZXNjYXBlKGNfdmFsdWUuc3Vic3RyaW5nKGNfc3RhcnQsY19lbmQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY192YWx1ZTtcblxuICAgIH0sXG4gICAgc2hvd0hvcHVwOiBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgdmFyIGRsZyA9IGFwcC5kaWFsb2cuY3JlYXRlKHtvcHRpb25zIDogYXBwLmRpYWxvZy5zZXR0aW5nc30pO1xuICAgICAgICAvLyBNYWtlIHN1cmUgYW55IGNsb3NlIGJ1dHRvbnMgYXJlIGluaXRpYXRlZFxuICAgICAgICBkbGcub24oXCJjbGlja1wiLCBcIi5kaWFsb2ctY2xvc2UtYnV0dG9uXCIsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgYXBwLmRpYWxvZy5jbG9zZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICBkYXRhIDoge30sXG4gICAgICAgICAgICB0YXJnZXQ6IGRsZyxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgZGxnLmRpYWxvZyhcIm9wZW5cIik7IC8vIG9wZW4gYWZ0ZXIgbG9hZCB0byBlbnN1cmUgZGlhbG9nIGlzIGNlbnRlcmVkXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxufTsvL2VuZCBhcHAudXRpbFxuXG5hcHAucHJvZHVjdCA9IHtcbiAgICBpbml0IDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgQ2xvdWRab29tXG4gICAgICAgIGlmKCFhcHAucXVpY2tWaWV3LmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgIENsb3VkWm9vbS5xdWlja1N0YXJ0KCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGFwcC5wcm9kdWN0LmluaXRNb2JpbGVQRFBDYXJvdXNlbCgpO1xuXG4gICAgICAgIGlmIChhcHAucGFnZS5wYXJhbXMgJiYgYXBwLnBhZ2UucGFyYW1zLmVnY2ltZyl7XG4gICAgICAgICAgICB2YXIgZWdjSW1nUGF0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhcHAucGFnZS5wYXJhbXMuZWdjaW1nKTtcbiAgICAgICAgICAgICQoJy5zd2F0Y2hlcyBhW2hyZWYkPVwiJyArIGVnY0ltZ1BhdGggKyAnXCJdJykuY2xpY2soKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZ2V0IDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gbG9hZHMgYSBwcm9kdWN0IGludG8gYSBnaXZlbiBjb250YWluZXIgZGl2XG4gICAgICAgIC8vIHBhcmFtc1xuICAgICAgICAvLyAgICAgIGNvbnRhaW5lcklkIC0gaWQgb2YgdGhlIGNvbnRhaW5lciBkaXYsIGlmIGVtcHR5IHRoZW4gZ2xvYmFsIGFwcC5jb250YWluZXJJZCBpcyB1c2VkXG4gICAgICAgIC8vICAgICAgc291cmNlIC0gc291cmNlIHN0cmluZyBlLmcuIHNlYXJjaCwgY2FydCBldGMuXG4gICAgICAgIC8vICAgICAgbGFiZWwgLSBsYWJlbCBmb3IgdGhlIGFkZCB0byBjYXJ0IGJ1dHRvbiwgZGVmYXVsdCBpcyBBZGQgdG8gQ2FydFxuICAgICAgICAvLyAgICAgIHVybCAtIHVybCB0byBnZXQgdGhlIHByb2R1Y3RcbiAgICAgICAgLy8gICAgICBpZCAtIGlkIG9mIHRoZSBwcm9kdWN0IHRvIGdldCwgaXMgb3B0aW9uYWwgb25seSB1c2VkIHdoZW4gdXJsIGlzIGVtcHR5XG4gICAgICAgIHZhciB0YXJnZXQgPSBvcHRpb25zLnRhcmdldCB8fCBhcHAucXVpY2tWaWV3LmluaXQoKTtcbiAgICAgICAgdmFyIHNvdXJjZSA9IG9wdGlvbnMuc291cmNlIHx8IFwiXCI7XG4gICAgICAgIHZhciBwcm9kdWN0VXJsID0gb3B0aW9ucy51cmwgfHwgYXBwLnV0aWwuYXBwZW5kUGFyYW1Ub1VSTChhcHAudXJscy5nZXRQcm9kdWN0VXJsLCBcInBpZFwiLCBvcHRpb25zLmlkKTtcbiAgICAgICAgaWYoc291cmNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHByb2R1Y3RVcmwgPSBhcHAudXRpbC5hcHBlbmRQYXJhbVRvVVJMKHByb2R1Y3RVcmwsIFwic291cmNlXCIsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2hvdyBzbWFsbCBsb2FkaW5nIGltYWdlXG4gICAgICAgIC8vYXBwLnByb2dyZXNzLnNob3coYXBwLnVpLnByaW1hcnkpO1xuICAgICAgICBhcHAuYWpheC5sb2FkKHtcbiAgICAgICAgICAgIHRhcmdldCA6IHRhcmdldCxcbiAgICAgICAgICAgIHVybCA6IHByb2R1Y3RVcmwsXG4gICAgICAgICAgICBkYXRhIDogb3B0aW9ucy5kYXRhIHx8IFwiXCIsXG4gICAgICAgICAgICAvLyByZXBsYWNlIHdpdGggY2FsbGJhY2sgcGFzc2VkIGluIGJ5IG9wdGlvbnNcbiAgICAgICAgICAgIGNhbGxiYWNrIDogb3B0aW9ucy5jYWxsYmFjayB8fCBhcHAucHJvZHVjdC5pbml0XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0QXZhaWxhYmlsaXR5IDogZnVuY3Rpb24gKHBpZCwgcXVhbnRpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgIGFwcC5hamF4LmdldEpzb24oe1xuICAgICAgICAgICAgdXJsOiBhcHAudXRpbC5hcHBlbmRQYXJhbXNUb1VybChhcHAudXJscy5nZXRBdmFpbGFiaWxpdHksIHtwaWQ6cGlkLCBRdWFudGl0eTpxdWFudGl0eX0pLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgaW5pdEFkZFRoaXMgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhZGRUaGlzU2VydmljZXMgPSBbXCJjb21wYWN0XCIsXCJmYWNlYm9va1wiLFwibXlzcGFjZVwiLFwiZ29vZ2xlXCIsXCJ0d2l0dGVyXCJdLFxuICAgICAgICAgICAgYWRkVGhpc1Rvb2xib3ggPSAkKFwiLmFkZHRoaXNfdG9vbGJveFwiKSxcbiAgICAgICAgICAgIGFkZFRoaXNMaW5rcz1cIlwiO1xuXG4gICAgICAgIHZhciBpLGxlbj1hZGRUaGlzU2VydmljZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGk9MDtpPGxlbjtpKyspIHtcbiAgICAgICAgICAgIGlmIChhZGRUaGlzVG9vbGJveC5maW5kKFwiLmFkZHRoaXNfYnV0dG9uX1wiK2FkZFRoaXNTZXJ2aWNlc1tpXSkubGVuZ3RoPT0wKSB7XG4gICAgICAgICAgICAgICAgYWRkVGhpc0xpbmtzICs9ICc8YSBjbGFzcz1cImFkZHRoaXNfYnV0dG9uXycrYWRkVGhpc1NlcnZpY2VzW2ldKydcIj48L2E+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkVGhpc0xpbmtzLmxlbmd0aD09PTApIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgYWRkVGhpc1Rvb2xib3guaHRtbChhZGRUaGlzTGlua3MpO1xuICAgICAgICBpZih0eXBlb2YgYWRkdGhpcyAhPSAndW5kZWZpbmVkJyl7XG4gICAgICAgICAgICBhZGR0aGlzLnRvb2xib3goXCIuYWRkdGhpc190b29sYm94XCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBpbml0QWRkVG9DYXJ0IDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIC8vXHR0YXJnZXQub24oXCJjbGlja1wiLCBcIi5hZGQtdG8tY2FydFwiLCBzZXRBZGRUb0NhcnRIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNhbGxpbmcgb2ZmIGZpcnN0IGVuc3VyZXMgdGhlIGV2ZW50IGlzIG5vdCBkb3VibGUgaG9va2VkIHdoZW4gaW5pdCBpcyBjYWxsZWQgYWZ0ZXIgYWpheCBldmVudHNcbiAgICAgICAgICAgIC8vIHRoYXQgZG9uJ3QgcmVwbGFjZSB0aGUgYWRkLXRvLWNhcnQgYnV0dG9uXG4gICAgICAgIC8vXHQkKFwiLmFkZC10by1jYXJ0XCIpLm9mZihcImNsaWNrXCIsIHNldEFkZFRvQ2FydEhhbmRsZXIpO1xuICAgICAgICAvL1x0JChcIi5hZGQtdG8tY2FydFwiKS5vbihcImNsaWNrXCIsIHNldEFkZFRvQ2FydEhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBpbml0QWRkVG9XYWl0TGlzdCA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgdGFyZ2V0Lm9uKFwiY2xpY2tcIixcIi5hZGQtdG8td2FpdGxpc3RcIiwgc2V0QWRkVG9XYWl0TGlzdEhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgJGNhY2hlLnBkcE1haW4ub24oXCJjbGlja1wiLFwiLmFkZC10by13YWl0bGlzdFwiLCBzZXRBZGRUb1dhaXRMaXN0SGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHVwZGF0ZVF1YW50aXR5IDogIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gbG9hZCB0aGUgdXBkYXRlZCBxdWFudGl0eSBmb3IgdGhlIHBkcFxuICAgICAgICB2YXIgc3dhdGNoID0gJCgnI3Byb2R1Y3QtY29udGVudCAucHJvZHVjdC12YXJpYXRpb25zIHVsLnN3YXRjaGVzLkNvbG9yIGxpLnNlbGVjdGVkID4gYS5zd2F0Y2hhbmNob3InKS5maXJzdCgpO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSBhcmVuJ3QgcmV0cmlldmluZyBhIGdpZnQgY2FyZCBpbWFnZSwgd2hpY2ggYnJlYWtzIGluIENocm9tZSBhbmQgb3RoZXIgc2ltaWxhciBicm93c2Vyc1xuICAgICAgICBpZiAoc3dhdGNoLmNsb3Nlc3QoJy5naWZ0LWNhcmQtaW1hZ2UnKS5sZW5ndGggIT0gMCkgcmV0dXJuO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHN3YXRjaCBvYmplY3QsIHVwZGF0ZSBxdWFudGl0eVxuICAgICAgICBpZihzd2F0Y2gubGVuZ3RoKXtcbiAgICAgICAgICAgIHZhciB1cmwgPSBzd2F0Y2guYXR0cignaHJlZicpO1xuICAgICAgICAgICAgaWYodXJsKXtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0geydmb3JtYXQnOidhamF4J307XG4gICAgICAgICAgICAgICAgdXJsID0gYXBwLnV0aWwuYXBwZW5kUGFyYW1zVG9VcmwodXJsLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzIDogZnVuY3Rpb24ocmVzcG9uc2Upe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVzcG9uc2Upe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkcmVzcG9uc2UgPSAkKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgJG5ld1F1YW50aXR5ID0gJHJlc3BvbnNlLmZpbmQoJ3NlbGVjdC5zZWxlY3QtcXVhbnRpdHknKS5maXJzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCRuZXdRdWFudGl0eSAmJiAkbmV3UXVhbnRpdHkubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIG5vdywgYXMgYSBzYWZldHkgY2hlY2ssIG9ubHkgY29udGludWUgaWYgXCJkYXRhLWluY2FydFwiIGlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCRuZXdRdWFudGl0eS5hdHRyKCdkYXRhLWluY2FydCcpICYmICRuZXdRdWFudGl0eS5hdHRyKCdkYXRhLWluY2FydCcpID4gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgJG9sZFF1YW50aXR5ID0gJCgnI3Byb2R1Y3QtY29udGVudCBzZWxlY3Quc2VsZWN0LXF1YW50aXR5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkb2xkUXVhbnRpdHkubmV4dCgnLnNlbGVjdGJveGl0LWNvbnRhaW5lcicpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG9sZFF1YW50aXR5LnJlcGxhY2VXaXRoKCRuZXdRdWFudGl0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RCb3hJdCgkbmV3UXVhbnRpdHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYob3B0aW9ucyAmJiBvcHRpb25zLmNoZWNrUHVyY2hhc2VMaW1pdCA9PSB0cnVlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHAucHJvZHVjdC5wdXJjaGFzZUxpbWl0LmNoZWNrKCRuZXdRdWFudGl0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy9UT0RPLU1PTk8gUmVwbGFjZSB0aGlzIHdpdGggYXBwLm1vbm9ncmFtLmdldEltYWdlXG4gICAgZ2V0TW9ub2dyYW1JbWFnZSA6IGZ1bmN0aW9uKGFzc2V0TmFtZSwgbW9ub2dyYW1UZXh0LCBwcmVzZXQpIHtcbiAgICAgICAgYXNzZXROYW1lID0gYXNzZXROYW1lLnNwbGl0KCcvJyk7XG4gICAgICAgIGFzc2V0TmFtZSA9IGFzc2V0TmFtZS5sZW5ndGggPT0gMSA/IGFzc2V0TmFtZVswXSA6IGFzc2V0TmFtZVsxXTtcbiAgICAgICAgYXNzZXROYW1lID0gYXNzZXROYW1lLnJlcGxhY2UoL19SJC8sJycpO1xuXG4gICAgICAgIHZhciB1cmwgPSBhcHAubW9ub2dyYW1JbWFnZVVybDtcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJ3swfScsIGFzc2V0TmFtZSk7XG4gICAgICAgIHVybCA9IHVybC5yZXBsYWNlKCd7MX0nLCBtb25vZ3JhbVRleHQudG9VcHBlckNhc2UoKSk7XG4gICAgICAgIHVybCA9IHVybC5yZXBsYWNlKCd7Mn0nLCBwcmVzZXQpO1xuXG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfSxcblxuICAgIGluaXRNb2JpbGVQRFBDYXJvdXNlbCA6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAvLyBibSAtIHNpdGVwcmVmcyBzdG9yZWZyb250IC0gY2xvdWR6b29tXG4gICAgICAgIGlmKFJlc291cmNlcy5DTE9VRF9aT09NX0VOQUJMRUQpe1xuXG4gICAgICAgICAgICAvLyBzZXR1cCBjYXJvdXNlbCBpdGVtc1xuICAgICAgICAgICAgdmFyIHBkcEltZyA9ICQoJy5wcm9kdWN0LWltYWdlcnktY29udGFpbmVyJyk7XG4gICAgICAgICAgICB2YXIgY2Fyb3VzZWwgPSBwZHBJbWcuZmluZCgnLmpjYXJvdXNlbCcpO1xuICAgICAgICAgICAgdmFyIGNvbnRyb2xzID0gcGRwSW1nLmZpbmQoJy5jb250cm9scycpO1xuICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSBwZHBJbWcuZmluZCgnLmNvbnRyb2wnKTtcbiAgICAgICAgICAgIHZhciB0aHVtYmxpbmsgPSBwZHBJbWcuZmluZCgnLnRodW1ibmFpbC1saW5rJyk7XG5cbiAgICAgICAgICAgIC8vIGluaXQgY2Fyb3VzZWxcbiAgICAgICAgICAgIGNhcm91c2VsLmpjYXJvdXNlbCh7XG4gICAgICAgICAgICAgICAgc2Nyb2xsOiAxLFxuICAgICAgICAgICAgICAgIGl0ZW1GYWxsYmFja0RpbWVuc2lvbjogMTAwLFxuICAgICAgICAgICAgICAgIGl0ZW1Mb2FkQ2FsbGJhY2s6IHtcbiAgICAgICAgICAgICAgICAgICAgb25BZnRlckFuaW1hdGlvbjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2wucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbHMuZmluZCgnI2NvbnRyb2wtJyArIGUuZmlyc3QpLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1vYmlsZSBzd2lwZVxuICAgICAgICAgICAgfSkudG91Y2h3aXBlKHtcbiAgICAgICAgICAgICAgICB3aXBlTGVmdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjYXJvdXNlbC5qY2Fyb3VzZWwoJ25leHQnKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdpcGVSaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjYXJvdXNlbC5qY2Fyb3VzZWwoJ3ByZXYnKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0RXZlbnRzOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHBhZ2luYXRpb24gY29udHJvbHNcbiAgICAgICAgICAgIGNvbnRyb2wuY2xpY2soZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKCdhY3RpdmUnKTtcblxuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgY3VycmVudCBpdGVtcyBpbmRleFxuICAgICAgICAgICAgICAgIHZhciBkZWxpbWl0ZXIgPSBwYXJzZUludCgkKHRoaXMpLmF0dHIoJ2lkJykuc3BsaXQoJy0nKVsxXSk7XG5cbiAgICAgICAgICAgICAgICAvLyBwYXNzIGluZGV4IHRvIGNhcm91c2VsIHNjcm9sbFxuICAgICAgICAgICAgICAgIGNhcm91c2VsLmpjYXJvdXNlbCgnc2Nyb2xsJywgZGVsaW1pdGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHB1cmNoYXNlTGltaXQgOiB7XG5cbiAgICAgICAgY2hlY2sgOiBmdW5jdGlvbiAocXVhbnRpdHkpIHtcblxuICAgICAgICAgICAgaWYoIXF1YW50aXR5KXtcbiAgICAgICAgICAgICAgICBxdWFudGl0eSA9ICQoJyNwcm9kdWN0LWNvbnRlbnQgLnByb2R1Y3QtYWRkLXRvLWNhcnQgc2VsZWN0LnNlbGVjdC1xdWFudGl0eScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyICRxdWFudGl0eSA9ICQocXVhbnRpdHkpO1xuICAgICAgICAgICAgaWYoJHF1YW50aXR5Lmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSAkcXVhbnRpdHkuZmluZCgnb3B0aW9uJykubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBpbkNhcnQgPSAkcXVhbnRpdHkuYXR0cignZGF0YS1pbmNhcnQnKTtcbiAgICAgICAgICAgICAgICBpZihvcHRpb25zID09IDAgJiYgaW5DYXJ0ID4gMCB8fCAkcXVhbnRpdHkuZGF0YSgnbWF4bGltaXQnKSl7XG4gICAgICAgICAgICAgICAgICAgIGFwcC5wcm9kdWN0LnB1cmNoYXNlTGltaXQuc2hvdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2hvdyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHB1cmNoYXNlIGxpbWl0IGV4Y2VlZGVkXG4gICAgICAgICAgICB2YXIgJHF1YW50aXR5ID0gJCgnI3Byb2R1Y3QtY29udGVudCAucHJvZHVjdC1hZGQtdG8tY2FydCAuaW52ZW50b3J5IC5xdWFudGl0eSAudmFsdWUnKTtcbiAgICAgICAgICAgIGlmKCRxdWFudGl0eS5sZW5ndGgpe1xuICAgICAgICAgICAgICAgIC8vY2xlYXIgb3V0IHRoZSBxdWFudGl0eSBzZWxlY3QgYm94IG9mIGFsbCBvcHRpb25zIHRvIGVmZmVjdGl2ZWx5IGRpc2FibGUgaXRcbiAgICAgICAgICAgICAgICAkcXVhbnRpdHkuZmluZCgnc2VsZWN0JykuaHRtbCgnJylcbiAgICAgICAgICAgICAgICBzZWxlY3RCb3hJdCgkKCdzZWxlY3Quc2VsZWN0LXF1YW50aXR5JykpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgJGF2YWlsYWJpbGl0eSA9ICQoJyNwcm9kdWN0LWNvbnRlbnQgLnByb2R1Y3QtYWRkLXRvLWNhcnQgLmF2YWlsYWJpbGl0eScpO1xuICAgICAgICAgICAgaWYoJGF2YWlsYWJpbGl0eS5sZW5ndGgpe1xuICAgICAgICAgICAgICAgIC8vY2xlYXIgb3V0IHRoZSBjdXJyZW50IGF2YWlsYWJpbGl0eSBtZXNzYWdpbmcgYW5kIHJlcGxhY2UgaXQgd2l0aCB0aGUgcHVyY2hhc2UgbGltaXQgbWVzc2FnZVxuICAgICAgICAgICAgICAgICRhdmFpbGFiaWxpdHkuZmluZCgnLnZhbHVlJykuZW1wdHkoKS5odG1sKCc8ZGl2IGNsYXNzPVwiYXZhaWxhYmlsaXR5LW1zZ1wiPjxwIGNsYXNzPVwibm90LWF2YWlsYWJsZS1tc2dcIj4nICsgUmVzb3VyY2VzLlBST0RVQ1RfUFVSQ0hBU0VfTElNSVQgKyAnPC9wPjwvZGl2PicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFkZHRvY2FydCA9ICQoJyNhZGQtdG8tY2FydCcpO1xuICAgICAgICAgICAgaWYoYWRkdG9jYXJ0Lmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgYWRkdG9jYXJ0LmFkZENsYXNzKCdncmF5LWRpc2FibGVkJyk7XG4gICAgICAgICAgICAgICAgYWRkdG9jYXJ0LmF0dHIoJ2Rpc2FibGVkJywnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcbiAgICBhZGRUb0luQ2FydFRvdGFsIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBxdWFudGl0eUVsZW1lbnQgPSAkKCcjcHJvZHVjdC1jb250ZW50IC5wcm9kdWN0LWFkZC10by1jYXJ0IHNlbGVjdC5zZWxlY3QtcXVhbnRpdHknKTtcbiAgICAgICAgdmFyIHF1YW50aXR5ID0gcXVhbnRpdHlFbGVtZW50LmF0dHIoJ2RhdGEtaW5jYXJ0Jyk7XG4gICAgICAgIGlmKHF1YW50aXR5IDwgNSl7XG4gICAgICAgICAgICBxdWFudGl0eSsrO1xuICAgICAgICAgICAgcXVhbnRpdHlFbGVtZW50LmF0dHIoJ2RhdGEtaW5jYXJ0JyxxdWFudGl0eSk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgYXBwLnByb2R1Y3QucHVyY2hhc2VMaW1pdC5zaG93KCk7XG4gICAgICAgIH1cbiAgICB9XG59Oy8vZW5kIGFwcC5wcm9kdWN0XG5cbmFwcC52YWxpZGF0b3IgPSB7XG4gICAgaW5pdCA6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAkKFwiZm9ybTpub3QoLnN1cHByZXNzKVwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQodGhpcykudmFsaWRhdGUoYXBwLnZhbGlkYXRvci5zZXR0aW5ncyk7XG4gICAgICAgIH0pO1xuXG4gICAgfSxcbiAgICBpbml0Rm9ybSA6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgJChmKS52YWxpZGF0ZShhcHAudmFsaWRhdG9yLnNldHRpbmdzKTtcbiAgICB9LFxuICAgIGluaXRGb3JtV1NldHRpbmdzIDogZnVuY3Rpb24oZixzKXtcbiAgICAgICAgJChmKS52YWxpZGF0ZShzKTtcbiAgICB9LFxuICAgIHZhbGlkRW1haWwgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcmVnZXguZW1haWwudGVzdCgkLnRyaW0odmFsdWUpKTtcbiAgICB9LFxuICAgIGFzbENvbmZpcm0gOiBmdW5jdGlvbihmb3JtKXtcbiAgICAgICAgLy8gY3JlYXRlIGFzbCBkaWFsb2cgcG9wdXBcbiAgICAgICAgdmFyIHdpZHRoID0gd2luZG93LmlubmVyV2lkdGggPCA0ODAgPyAzMDAgOiAzNjE7XG5cbiAgICAgICAgdmFyIGRsZyA9IGFwcC5kaWFsb2cuY3JlYXRlKHt0YXJnZXQ6JCgnI2FzbC1jb25maXJtYXRpb24nKSwgb3B0aW9uczp7XG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICBhdXRvT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgIGNsb3NlT25Fc2NhcGU6IHRydWUsXG4gICAgICAgICAgICBkaWFsb2dDbGFzczogJ2FzbC1jb25maXJtYXRpb24tZGlhbG9nJyxcbiAgICAgICAgICAgIG9wZW46IGZ1bmN0aW9uKCBldmVudCwgdWkgKSB7XG5cbiAgICAgICAgICAgIHZhciAkZm9ybSA9IGZvcm07XG4gICAgICAgICAgICB2YXIgZm9ybWRhdGEgPSAkZm9ybS5zZXJpYWxpemUoKTtcbiAgICAgICAgICAgICQoJyNjb25maXJtYXRpb24tbGluaycpLmNsaWNrKGZ1bmN0aW9uKGUpIHtcblxuICAgICAgICAgICAgICAgIHZhciBjaGVja2JveCA9IGRsZy5maW5kKCcjanNwLWFzbC1jb25maXJtJyk7XG4gICAgICAgICAgICAgICAgaWYoY2hlY2tib3guaXMoJzpjaGVja2VkJykpe1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaGlkZGVuIGlucHV0IGZpZWxkIHN0YXRpbmcgY29uZmlybWF0aW9uXG4gICAgICAgICAgICAgICAgICAgICQoJzxpbnB1dD4nKS5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2FudGlTcGFtSW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICd0cnVlJ1xuICAgICAgICAgICAgICAgICAgICB9KS5hcHBlbmRUbygkZm9ybSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2xvc2UgZGlhbG9nXG4gICAgICAgICAgICAgICAgICAgIGRsZy5kaWFsb2coXCJjbG9zZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmUgc3VibWl0IGZvcm1cbiAgICAgICAgICAgICAgICAgICAgJGZvcm0uc3VibWl0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgYW50aXNwYW0gYWZ0ZXIgdXNlXG4gICAgICAgICAgICAgICAgICAgICRmb3JtLmZpbmQoJ2lucHV0W25hbWU9YW50aVNwYW1JbnB1dF0nKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgfVxuICAgICAgICB9fSk7XG4gICAgfVxufTsgLy9lbmQgYXBwLnZhbGlkYXRvclxuXG5hcHAucXVpY2tWaWV3ID0ge1xuICAgIGluaXRpYWxpemVCdXR0b24gOiBmdW5jdGlvbiAoY29udGFpbmVyLCB0YXJnZXQpIHtcbiAgICAgICAgLy8gcXVpY2sgdmlldyBidXR0b25cbiAgICAgICAgaWYobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvaVBhZC9pKSA9PSBudWxsKXtcbiAgICAgICAgICAgICQoY29udGFpbmVyKS5vbihcIm1vdXNlZW50ZXJcIiwgdGFyZ2V0LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmKCEkY2FjaGUucXZCdXR0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgJGNhY2hlLnF2QnV0dG9uID0gJChcIjxhIGlkPSdxdWlja3ZpZXdidXR0b24nLz5cIik7XG4gICAgICAgICAgICAgICAgICAgICRjYWNoZS5xdkJ1dHRvbi5odG1sKGFwcC5yZXNvdXJjZXNbJ1FVSUNLU0hPUCddKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmluZFF2QnV0dG9uKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbGluayA9ICQodGhpcykuY2hpbGRyZW4oXCJhOmZpcnN0XCIpO1xuICAgICAgICAgICAgICAgICRjYWNoZS5xdkJ1dHRvbi5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgXCJocmVmXCIgOiBsaW5rLmF0dHIoXCJkYXRhLWZ1bGwtdXJsXCIpLFxuICAgICAgICAgICAgICAgICAgICBcInRpdGxlXCIgOiBsaW5rLmF0dHIoXCJ0aXRsZVwiKVxuICAgICAgICAgICAgICAgIH0pLmFwcGVuZFRvKCQodGhpcykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaW5pdFF1aWNrVmlld0Nhcm91c2VsIDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkaWFsb2dDb250YWluZXIgPSAkKCcjcXVpY2stdmlldy1kaWFsb2cnKTtcbiAgICB2YXIgcHJvZHVjdEltYWdlID0gZGlhbG9nQ29udGFpbmVyLmZpbmQoJCgnLnByb2R1Y3QtcHJpbWFyeS1pbWFnZSBpbWcnKSk7XG5cbiAgICAkKFwiLnRodW1iIGFcIikuY2xpY2soZnVuY3Rpb24oZSl7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIGltYWdlU3JjID0gJCh0aGlzKS5hdHRyKCdocmVmJyk7XG4gICAgICAgIHByb2R1Y3RJbWFnZS5hdHRyKCdzcmMnLCBpbWFnZVNyYylcbiAgICAgICAgJChlLnRhcmdldCkuY2xvc2VzdChcIi50aHVtYiAuamNhcm91c2VsLWl0ZW0gbGlcIikuYWRkQ2xhc3MoXCJzZWxlY3RlZFwiKS5zaWJsaW5ncygpLnJlbW92ZUNsYXNzKFwic2VsZWN0ZWRcIik7XG4gICAgfSk7XG5cbiAgICB2YXIgJGxpc3QgPSBkaWFsb2dDb250YWluZXIuZmluZCgnI3RodW1ibmFpbC1jYXJvdXNlbCcpO1xuICAgIHZhciBuZXh0ID0gZGlhbG9nQ29udGFpbmVyLmZpbmQoJyNuZXh0Jyk7XG4gICAgdmFyIHByZXYgPSBkaWFsb2dDb250YWluZXIuZmluZCgnI3ByZXYnKTtcbiAgICB2YXIgamNhcm91c2VsUHJldiA9IGRpYWxvZ0NvbnRhaW5lci5maW5kKCcuamNhcm91c2VsLXByZXYnKTtcbiAgICB2YXIgamNhcm91c2VsTmV4dCA9IGRpYWxvZ0NvbnRhaW5lci5maW5kKCcuamNhcm91c2VsLW5leHQnKTtcblxuICAgIHZhciAkZmlyc3QgPSAkKCdsaTpmaXJzdCcsICRsaXN0KSxcbiAgICAgICAgJGxhc3QgPSAkKCdsaTpsYXN0JywgJGxpc3QpO1xuICAgICAgICBuZXh0LmNsaWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgJG5leHQsICRzZWxlY3RlZCA9IGRpYWxvZ0NvbnRhaW5lci5maW5kKChcIi50aHVtYi5zZWxlY3RlZFwiKSk7XG4gICAgICAgICAgICAkbmV4dCA9ICRzZWxlY3RlZC5uZXh0KCdsaScpLmxlbmd0aCA/ICRzZWxlY3RlZC5uZXh0KCdsaScpIDogJGZpcnN0O1xuICAgICAgICAgICAgJHNlbGVjdGVkLnJlbW92ZUNsYXNzKFwic2VsZWN0ZWRcIik7XG4gICAgICAgICAgICAkbmV4dC5hZGRDbGFzcygnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgIHByb2R1Y3RJbWFnZS5hdHRyKCdzcmMnLCAkbmV4dC5maW5kKCdhJykuYXR0cihcImhyZWZcIikpO1xuICAgICAgICAgICAgaWYgKCRsYXN0Lmhhc0NsYXNzKCdzZWxlY3RlZCcpKSB7XG4gICAgICAgICAgICAgICAgJChcIi5qY2Fyb3VzZWwtbmV4dFwiKS50cmlnZ2VyKCBcImNsaWNrXCIgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICBwcmV2LmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAkcHJldiwgJHNlbGVjdGVkID0gZGlhbG9nQ29udGFpbmVyLmZpbmQoKFwiLnRodW1iLnNlbGVjdGVkXCIpKTtcbiAgICAgICAgICAgICRwcmV2ID0gJHNlbGVjdGVkLnByZXYoJ2xpJykubGVuZ3RoID8gJHNlbGVjdGVkLnByZXYoJ2xpJykgOiAkbGFzdDtcbiAgICAgICAgICAgICRzZWxlY3RlZC5yZW1vdmVDbGFzcyhcInNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgJHByZXYuYWRkQ2xhc3MoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICBwcm9kdWN0SW1hZ2UuYXR0cignc3JjJywgJHByZXYuZmluZCgnYScpLmF0dHIoXCJocmVmXCIpKTtcblxuICAgICAgICAgICAgaWYgKCRmaXJzdC5oYXNDbGFzcygnc2VsZWN0ZWQnKSkge1xuICAgICAgICAgICAgICAgICQoXCIuamNhcm91c2VsLXByZXZcIikudHJpZ2dlciggXCJjbGlja1wiICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgJGxpc3QuamNhcm91c2VsKHtcbiAgICAgICAgICAgIGF1dG86IDAsXG4gICAgICAgICAgICB2ZXJ0aWNhbDp0cnVlLFxuICAgICAgICAgICAgc2Nyb2xsOjFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gMSBhbHQgaW1hZ2Ugbm8gbmVlZCB0byBkaXNwbGF5IGFycm93c1xuICAgICAgICBpZiAoZGlhbG9nQ29udGFpbmVyLmZpbmQoJyN0aHVtYm5haWwtY2Fyb3VzZWwgbGknKS5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgamNhcm91c2VsUHJldi5oaWRlKCk7XG4gICAgICAgICAgICBqY2Fyb3VzZWxOZXh0LmhpZGUoKTtcbiAgICAgICAgICAgIG5leHQuaGlkZSgpO1xuICAgICAgICAgICAgcHJldi5oaWRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9kdWN0SW1hZ2UudG91Y2h3aXBlKHtcbiAgICAgICAgICAgIHdpcGVMZWZ0OiBmdW5jdGlvbigpIHsgJCgnI25leHQnKS5jbGljaygpOyB9LFxuICAgICAgICAgICAgd2lwZVJpZ2h0OiBmdW5jdGlvbigpIHsgJCgnI3ByZXYnKS5jbGljaygpOyB9LFxuICAgICAgICAgICAgcHJldmVudERlZmF1bHRFdmVudHM6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICAkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBkcE1haW4gPSAkKCcjcGRwTWFpbicpO1xuICAgICAgICAgICAgdmFyIGlzY05leHQgPSBwZHBNYWluLmZpbmQoJCgnLmpjYXJvdXNlbC1uZXh0JykpLmlzKCc6aGlkZGVuJyk7XG4gICAgICAgICAgICB2YXIgaXNjUHJldiA9IHBkcE1haW4uZmluZCgkKCcuamNhcm91c2VsLXByZXYnKSkuaXMoJzpoaWRkZW4nKTtcbiAgICAgICAgICAgIHZhciBjYXJvdXNlbENsaXAgPSBwZHBNYWluLmZpbmQoJy5qY2Fyb3VzZWwtY2xpcCcpO1xuXG4gICAgICAgICAgICBpZihpc2NOZXh0ICYmIGlzY1ByZXYpe1xuICAgICAgICAgICAgICAgIGNhcm91c2VsQ2xpcC5jc3MoeydtYXJnaW4tdG9wJzogJzAnfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgfSxcblxuICAgIGluaXQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmKGFwcC5xdWlja1ZpZXcuZXhpc3RzKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAkY2FjaGUucXVpY2tWaWV3O1xuICAgICAgICB9XG4gICAgICAgICRjYWNoZS5xdWlja1ZpZXcgPSAkKFwiPGRpdi8+XCIpLmF0dHIoXCJpZFwiLCBcInF1aWNrLXZpZXctZGlhbG9nXCIpLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpO1xuICAgICAgICByZXR1cm4gJGNhY2hlLnF1aWNrVmlldztcbiAgICB9LFxuICAgIC8vIHNob3cgcXVpY2sgdmlldyBkaWFsb2cgYW5kIHNlbmQgcmVxdWVzdCB0byB0aGUgc2VydmVyIHRvIGdldCB0aGUgcHJvZHVjdFxuICAgIC8vIG9wdGlvbnMuc291cmNlIC0gc291cmNlIG9mIHRoZSBkaWFsb2cgaS5lLiBzZWFyY2gvY2FydFxuICAgIC8vIG9wdGlvbnMudXJsIC0gcHJvZHVjdCB1cmxcbiAgICBzaG93IDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucy50YXJnZXQgPSBhcHAucXVpY2tWaWV3LmluaXQoKTtcbiAgICAgICAgb3B0aW9ucy5jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFwcC5wcm9kdWN0LmluaXQoKTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IDc3NDtcblxuICAgICAgICAgICAgYXBwLmRpYWxvZy5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIHRhcmdldCA6ICRjYWNoZS5xdWlja1ZpZXcsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA6IHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0IDogJ2F1dG8nLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBkaWFsb2dDbGFzcyA6ICdxdWlja3ZpZXcnLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZSA6ICdQcm9kdWN0IFF1aWNrdmlldycsXG4gICAgICAgICAgICAgICAgICAgIHJlc2l6YWJsZSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICBvcGVuIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwLnByb2dyZXNzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGFwcC5yZXNvdXJjZXMuU0VTU0lPTl9DVVNUT01fU0lURUlEID09PSAna2F0ZW1vYmlsZScpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJy51aS13aWRnZXQtb3ZlcmxheScpLmJpbmQoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJy5xdWlja3ZpZXcsICNxdWljay12aWV3LWRpYWxvZyAnKS5kaWFsb2coJ2Nsb3NlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHAudG9vbHRpcHMuaW5pdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBGQiAhPSAndW5kZWZpbmVkJyAmJiAnWEZCTUwnIGluIEZCICYmICdwYXJzZScgaW4gRkIuWEZCTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCdmYlxcXFw6bGlrZScpLmF0dHIoJ2hyZWYnLG9wdGlvbnMudXJsLnJlcGxhY2UoJ3NvdXJjZT1jYXJ0JywgJ3NvdXJjZT0nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRkIuWEZCTUwucGFyc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVHJ1ZSBGaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGZjICE9PSAndW5kZWZpbmVkJyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGZjLmNhbGN1bGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBxdWljayB2aWV3IGlzIGZvciBhbiBlR0Mgc2VhcmNoIGZvciB0aGUgc2VsZWN0ZWQgc3dhdGNoIGFuZCBzZWxlY3QgaXRcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVnY2ltZyl7XG4gICAgICAgICAgICAgICAgdmFyIGVnY0ltZ1BhdGggPSBvcHRpb25zLmVnY2ltZztcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgaGF2ZSBhbiBFR0MgaW1hZ2UgcGF0aCBzdXBwbGllZFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YoZWdjSW1nUGF0aCkgIT0gJ3VuZGVmaW5lZCcgJiYgZWdjSW1nUGF0aCAhPSAnJyl7XG4gICAgICAgICAgICAgICAgICAgICQoJy5zd2F0Y2hlcyBhJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oaSxlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWFyY2ggZm9yIGEgc3dhY2ggd2l0aCBhIG1hdGNoaW5nIGltYWdlIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBocmVmID0gJHRoaXMuYXR0cignaHJlZicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YoaHJlZikgPT0gJ3VuZGVmaW5lZCcgfHwgaHJlZiA9PSAnJyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVyaSA9IGFwcC51dGlsLmdldFVyaShocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHVyaS5wYWdlID09IGVnY0ltZ1BhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9KS5jbGljaygpOyAvLyAnY2xpY2snIHN3YXRjaCB0byBzZWxlY3QgaXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkY2FjaGUucXVpY2tWaWV3LmRpYWxvZygnb3BlbicpO1xuICAgICAgICAgICAgYXBwLnF1aWNrVmlldy5pbml0UXVpY2tWaWV3Q2Fyb3VzZWwoKTtcbiAgICAgICAgfTtcbiAgICAgICAgYXBwLnByb2R1Y3QuZ2V0KG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gJGNhY2hlLnF1aWNrVmlldztcbiAgICB9LFxuICAgIC8vIGNsb3NlIHRoZSBxdWljayB2aWV3IGRpYWxvZ1xuICAgIGNsb3NlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZigkY2FjaGUucXVpY2tWaWV3KSB7XG4gICAgICAgICAgICAkY2FjaGUucXVpY2tWaWV3LmRpYWxvZygnY2xvc2UnKS5lbXB0eSgpO1xuICAgICAgICAgICAgcmV0dXJuICRjYWNoZS5xdWlja1ZpZXc7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGV4aXN0cyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICRjYWNoZS5xdWlja1ZpZXcgJiYgKCRjYWNoZS5xdWlja1ZpZXcubGVuZ3RoID4gMCk7XG4gICAgfSxcbiAgICBpc0FjdGl2ZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICRjYWNoZS5xdWlja1ZpZXcgJiYgKCRjYWNoZS5xdWlja1ZpZXcubGVuZ3RoID4gMCkgJiYgKCRjYWNoZS5xdWlja1ZpZXcuY2hpbGRyZW4ubGVuZ3RoID4gMCk7XG4gICAgfVxufTsvL2VuZCBhcHAucXVpY2tWaWV3XG5cbmFwcC5taW5pY2FydCA9IHtcbiAgICB1cmwgOiBcIlwiLCAvLyBkdXJpbmcgcGFnZSBsb2FkaW5nLCB0aGUgRGVtYW5kd2FyZSBVUkwgaXMgc3RvcmVkIGhlcmVcbiAgICAvLyBhcHAubWluaWNhcnQuaW5pdDogaW5pdGlhbGl6YXRpb25zXG4gICAgY291bnRkb3duSUQgOiBudWxsLFxuICAgIGluaXQgOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIG1pbmljYXJ0ID0gJChcIiNtaW5pLWNhcnRcIik7XG4gICAgICAgIHZhciBtY0NvbmRlbnNlZCA9ICQoXCIjbWluaS1jYXJ0LWNvbmRlbnNlZFwiKTtcblxuICAgICAgICB2YXIgbWNUb3RhbCA9IG1pbmljYXJ0LmZpbmQoXCIubWluaS1jYXJ0LXRvdGFsXCIpO1xuXG4gICAgICAgIHZhciBtb3ZlZCA9IGZhbHNlO1xuXG5cbiAgICAgICAgaWYgKHR5cGVvZihzcl9yZWZyZXNoTWVzc2FnZXMpICE9ICd1bmRlZmluZWQnKXtcbiAgICAgICAgICAgIHNyX3VwZGF0ZU1lc3NhZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIHdlIG5lZWQgdG8gbW92ZSB0aGUgbWluaSBjYXJ0XG4gICAgICAgIGlmKG1jQ29uZGVuc2VkLmxlbmd0aCl7XG5cbiAgICAgICAgICAgICRjYWNoZS5tY0NvbmRlbnNlZCA9IG1jQ29uZGVuc2VkO1xuXG4gICAgICAgICAgICB2YXIgbWNDb250ZW50UmVndWxhciA9IG1pbmljYXJ0LmZpbmQoXCIubWluaS1jYXJ0LWNvbnRlbnRcIik7XG4gICAgICAgICAgICB2YXIgbWNDb250ZW50Q29uZGVuc2VkID0gbWNDb25kZW5zZWQuZmluZChcIi5taW5pLWNhcnQtY29udGVudFwiKTtcbiAgICAgICAgICAgIHZhciBoZWFkZXJDb25kZW5zZWQgPSAkKCcjaGVhZGVyLWNvbmRlbnNlZCcpO1xuICAgICAgICAgICAgaWYoaGVhZGVyQ29uZGVuc2VkLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgaWYoaGVhZGVyQ29uZGVuc2VkLmhhc0NsYXNzKCd2aXNpYmxlJykpe1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIGNvbmRlbnNlZCBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgJGNhY2hlLm1pbmljYXJ0ID0gbWNDb25kZW5zZWQ7XG4gICAgICAgICAgICAgICAgICAgIG1jVG90YWwgPSAkY2FjaGUubWluaWNhcnQuZmluZChcIi5taW5pLWNhcnQtdG90YWxcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmKG1jQ29udGVudFJlZ3VsYXIgJiYgbWNDb250ZW50UmVndWxhci5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBtaW5pLWNhcnQtY29udGVudCBmcm9tIHJlZ3VsYXIgaGVhZGVyIHRvIGNvbmRlbnNlZCBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1jQ29udGVudFJlZ3VsYXIuYXBwZW5kVG8obWNUb3RhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gY29weSBjb3VudCBpbnRvIHJlZ3VsYXIgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICQoJyNtaW5pLWNhcnQgLm1pbmktY2FydC1sYWJlbCcpLmh0bWwoJCgnI21pbmktY2FydC1jb25kZW5zZWQgLm1pbmktY2FydC1sYWJlbCcpLmh0bWwoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgcmVndWxhciBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgJGNhY2hlLm1pbmljYXJ0ID0gbWluaWNhcnQ7XG4gICAgICAgICAgICAgICAgICAgIG1jVG90YWwgPSAkY2FjaGUubWluaWNhcnQuZmluZChcIi5taW5pLWNhcnQtdG90YWxcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmKG1jQ29udGVudENvbmRlbnNlZCAmJiBtY0NvbnRlbnRDb25kZW5zZWQubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgbWluaS1jYXJ0LWNvbnRlbnQgZnJvbSBjb25kZW5zZWQgaGVhZGVyIHRvIHJlZ3VsYXIgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBtY0NvbnRlbnRDb25kZW5zZWQuYXBwZW5kVG8obWNUb3RhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gY29weSBjb3VudCBpbnRvIGNvbmRlbnNlZCBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgJCgnI21pbmktY2FydC1jb25kZW5zZWQgLm1pbmktY2FydC1sYWJlbCcpLmh0bWwoJCgnI21pbmktY2FydCAubWluaS1jYXJ0LWxhYmVsJykuaHRtbCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICRjYWNoZS5taW5pY2FydCA9IG1pbmljYXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYobW92ZWQpe1xuICAgICAgICAgICAgJGNhY2hlLm1jQ29udGFpbmVyLnJlbW92ZUNsYXNzKCdleHBhbmRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgJGNhY2hlLm1jUmVmcmVzaCA9ICRjYWNoZS5taW5pY2FydC5maW5kKFwiLm1pbmktY2FydC1yZWZyZXNoXCIpO1xuICAgICAgICAkY2FjaGUubWNUb3RhbCA9ICRjYWNoZS5taW5pY2FydC5maW5kKFwiLm1pbmktY2FydC10b3RhbFwiKTtcbiAgICAgICAgJGNhY2hlLm1jQ29udGVudCA9ICRjYWNoZS5taW5pY2FydC5maW5kKFwiLm1pbmktY2FydC1jb250ZW50XCIpO1xuICAgICAgICAkY2FjaGUubWNDb250YWluZXIgPSAkY2FjaGUubWluaWNhcnQucGFyZW50cyhcIi5jYXJ0LWxpbmtcIik7XG4gICAgICAgICRjYWNoZS5tY0Nsb3NlID0gJGNhY2hlLm1pbmljYXJ0LmZpbmQoXCIubWluaS1jYXJ0LWNsb3NlXCIpO1xuICAgICAgICAkY2FjaGUubWNQcm9kdWN0TGlzdCA9ICRjYWNoZS5taW5pY2FydC5maW5kKFwiLm1pbmktY2FydC1wcm9kdWN0c1wiKTtcbiAgICAgICAgJGNhY2hlLm1jUHJvZHVjdHMgPSAkY2FjaGUubWNQcm9kdWN0TGlzdC5jaGlsZHJlbihcIi5taW5pLWNhcnQtcHJvZHVjdFwiKTtcbiAgICAgICAgLy92YXIgY29sbGFwc2VkID0gJGNhY2hlLm1jUHJvZHVjdExpc3QuY2hpbGRyZW4oKS5ub3QoXCI6Zmlyc3RcIikuYWRkQ2xhc3MoXCJjb2xsYXBzZWRcIik7XG5cbiAgICAgICAgJGNhY2hlLm1pbmljYXJ0LmZpbmQoJy5taW5pLWNhcnQtaW1hZ2UgaW1nJykuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgYXBwLnV0aWwubm9JbWFnZUhhbmRsZXIodGhpcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICgkY2FjaGUubWNDb250ZW50Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAkY2FjaGUubWNDb250YWluZXIucmVtb3ZlQ2xhc3MoJ2V4cGFuZGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZighaW5pdGlhbGl6ZWQgfHwgbW92ZWQpe1xuXG4gICAgICAgICAgICBpZigkY2FjaGUubWNDb250ZW50LmlzKFwiOnZpc2libGVcIikpIHtcbiAgICAgICAgICAgICAgICAkY2FjaGUubWNDb250YWluZXIuYWRkQ2xhc3MoJ2V4cGFuZGVkJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggYXBwLnJlc291cmNlcy5TRVNTSU9OX0NVU1RPTV9TSVRFSUQgIT0gJ2thdGVtb2JpbGUnIClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBub24tbW9iaWxlIGV2ZW50IGhhbmRsZXJzXG5cbiAgICAgICAgICAgICAgICAvLyB1c2luZyBjbGljay5taW5pY2FydCBuYW1lc3BhY2UgdG8gcHJldmVudCBkdXBsaWNhdGlvbiBvZiBldmVudHNcbiAgICAgICAgICAgICAgICAkY2FjaGUubWluaWNhcnQudW5iaW5kKFwibW91c2VvdmVyLm1pbmljYXJ0XCIpLnVuYmluZChcIm1vdXNlbGVhdmUubWluaWNhcnRcIik7XG5cbiAgICAgICAgICAgICAgICAvLyBiaW5kIGNsaWNrIGV2ZW50IHRvIHRoZSBjYXJ0IHRvdGFsIGxpbmsgYXQgdGhlIHRvcCByaWdodCBjb3JuZXIgb2YgdGhlIGNvbmRlbnNlZCBoZWFkZXJcbiAgICAgICAgICAgICAgICAkY2FjaGUubWluaWNhcnQub24oXCJtb3VzZW92ZXIubWluaWNhcnRcIiwgXCIubWluaS1jYXJ0LWxpbmtcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZighJGNhY2hlLm1jQ29udGVudC5pcyhcIjp2aXNpYmxlXCIpICYmICQodGhpcykucGFyZW50cygnLmNoZWNrb3V0LXJlZGVzaWduJykubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9wZW4gdGhlIG1pbmkgY2FydFxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwLm1pbmljYXJ0LnNsaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICRjYWNoZS5taW5pY2FydC5vbihcIm1vdXNlb3Zlci5taW5pY2FydFwiLCBcIi5taW5pLWNhcnQtY29udGVudFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lci5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgJGNhY2hlLm1pbmljYXJ0Lm9uKFwibW91c2VsZWF2ZS5taW5pY2FydFwiLCBcIi5taW5pLWNhcnQtdG90YWxcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoJGNhY2hlLm1jQ29udGVudC5pcyhcIjp2aXNpYmxlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lci5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIuc3RhcnQoYXBwLm1pbmljYXJ0LmNsb3NlLGFwcC5yZXNvdXJjZXMuTUlOSUNBUlRfVElNRU9VVCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBtb2JpbGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgICAgICAgICAkY2FjaGUubWluaWNhcnQub24oXCJjbGlja1wiLCBcIi5taW5pLWNhcnQtbGlua1wiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghJGNhY2hlLm1jQ29udGVudC5pcyhcIjp2aXNpYmxlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHAubWluaWNhcnQuc2xpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkY2FjaGUubWluaWNhcnQub24oXCJjbGlja1wiLCBcIi5jbG9zZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmKCRjYWNoZS5tY0NvbnRlbnQuaXMoXCI6dmlzaWJsZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBhcHAubWluaWNhcnQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy9zaG93IHJlbW92ZSBidXR0b24gb24gaG92ZXJcbiAgICAgICAgICAgICRjYWNoZS5taW5pY2FydC5vbihcIm1vdXNlb3ZlclwiLCBcIi5taW5pLWNhcnQtcHJvZHVjdFwiLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICQodGhpcykuZmluZChcIi5taW5pLWNhcnQtcmVtb3ZlXCIpLnNob3coKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oXCJtb3VzZWxlYXZlXCIsIFwiLm1pbmktY2FydC1wcm9kdWN0XCIsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5maW5kKFwiLm1pbmktY2FydC1yZW1vdmVcIikuaGlkZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICRjYWNoZS5taW5pY2FydC5vbihcImNsaWNrXCIsIFwiLm1pbmktY2FydC1yZW1vdmVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHV1aWQgPSAkKHRoaXMpLnBhcmVudHMoJy5taW5pLWNhcnQtcHJvZHVjdCcpLmRhdGEoJ3V1aWQnKTtcbiAgICAgICAgICAgICAgICBpZiAodXVpZCkge1xuICAgICAgICAgICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsIDogYXBwLnV0aWwuYWpheFVybChhcHAudXJscy5yZW1vdmVQcm9kdWN0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgOiB7IFwidXVpZFwiIDogdXVpZCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGUgOiBcImh0bWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MgOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHAubWluaWNhcnQudXBkYXRlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgICAgICB9XG5cbiAgICB9LFxuICAgIC8vIHJlbG9hZHMgdGhlIG1pbmkgY2FydCwgdXNlZCBieSBrYXRlc3BhZGUuanMgZm9yIG1vdmluZyBiZXR3ZWVuIHRoZSB0d28gZGlmZmVyZW50IGhlYWRlcnNcbiAgICByZWxvYWQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFwcC5taW5pY2FydC5pbml0KCk7XG4gICAgICAgIGlmKCRjYWNoZS5tY0NvbnRhaW5lci5oYXNDbGFzcygnZXhwYW5kZWQnKSl7XG4gICAgICAgICAgICBhcHAubWluaWNhcnQuY2xvc2UoKTtcbiAgICAgICAgICAgIGFwcC5taW5pY2FydC5zbGlkZSgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvLyBzaG93cyB0aGUgZ2l2ZW4gY29udGVudCBpbiB0aGUgbWluaSBjYXJ0XG4gICAgc2hvdyA6IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICAgIGFwcC5taW5pY2FydC51cGRhdGUoaHRtbCk7XG4gICAgICAgIGlmKCEkY2FjaGUubWNDb25kZW5zZWQpe1xuICAgICAgICAgICAgLy8gb25seSBzY3JvbGwgdXAgdG8gdGhlIHRvcCBpZiB3ZSBkb24ndCBoYXZlIGEgY29uZGVuc2VkIHZlcnNpb25cbiAgICAgICAgICAgIGFwcC51dGlsLnNjcm9sbEJyb3dzZXIoMCk7XG4gICAgICAgIH1cbiAgICAgICAgYXBwLm1pbmljYXJ0LnNsaWRlKCk7XG4gICAgICAgIGFwcC5ib251c1Byb2R1Y3RzVmlldy5sb2FkQm9udXNPcHRpb24oKTtcbiAgICAgICAgLy8gYWZ0ZXIgYSB0aW1lIG91dCBhdXRvbWF0aWNhbGx5IGNsb3NlIGl0XG4gICAgICAgIHRpbWVyLnN0YXJ0KGFwcC5taW5pY2FydC5jbG9zZSxhcHAucmVzb3VyY2VzLk1JTklDQVJUX1RJTUVPVVQpO1xuICAgIH0sXG4gICAgLy8gc2xpZGUgZG93biBhbmQgc2hvdyB0aGUgY29udGVudHMgb2YgdGhlIG1pbmkgY2FydFxuICAgIHNsaWRlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBhcHAubWluaWNhcnQuaW5pdCgpO1xuICAgICAgICBpZihhcHAubWluaWNhcnQuc3VwcHJlc3NTbGlkZURvd24gJiYgYXBwLm1pbmljYXJ0LnN1cHByZXNzU2xpZGVEb3duKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAkY2FjaGUubWNDb250YWluZXIuYWRkQ2xhc3MoJ2V4cGFuZGVkJyk7XG4gICAgICAgIHRpbWVyLmNsZWFyKCk7XG4gICAgICAgIC8vIHNob3cgdGhlIGl0ZW1cbiAgICAgICAgaWYoISRjYWNoZS5tY0NvbnRlbnQuYXR0cignc3R5bGUnKSl7XG4gICAgICAgICAgICAvLyBhZGRpbmcgdGhpcyB3aWxsIGVuc3VyZSBpdCBzbGlkZXMgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgICAgICRjYWNoZS5tY0NvbnRlbnQuY3NzKCdkaXNwbGF5Jywnbm9uZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT24gdGhlIG1vYmlsZSBzaXRlLCB0aGUgb3BlbmVkIHNlYXJjaCBiYXIgb3ZlcmxheXMgdGhlIG1pbi1jYXJ0XG4gICAgICAgIGlmIChhcHAucmVzb3VyY2VzLlNFU1NJT05fQ1VTVE9NX1NJVEVJRCA9PT0gJ2thdGVtb2JpbGUnKSB7XG4gICAgICAgICAgICAkKCcuaGVhZGVyLXNlYXJjaC1iYXInKS5yZW1vdmVDbGFzcygnb3BlbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgJCgnLm1pbmktY2FydC1tYXNrJykuY3NzKHt2aXNpYmlsaXR5OiAndmlzaWJsZScsIG9wYWNpdHk6ICcwLjgnfSk7XG4gICAgICAgICRjYWNoZS5tY0NvbnRlbnQuc2xpZGVEb3duKCdzbG93JywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICRjYWNoZS5tY0NvbnRhaW5lci5hZGRDbGFzcygnZXhwYW5kZWQnKTtcbiAgICAgICAgICAgIHRpbWVyLmNsZWFyKCk7XG4gICAgICAgICAgICBpZiAoYXBwLnJlc291cmNlcy5TRVNTSU9OX0NVU1RPTV9TSVRFSUQgIT09ICdrYXRlbW9iaWxlJykge1xuICAgICAgICAgICAgICAgIHRpbWVyLnN0YXJ0KGFwcC5taW5pY2FydC5jbG9zZSxhcHAucmVzb3VyY2VzLk1JTklDQVJUX1RJTUVPVVQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIC8vIGNsb3NlcyB0aGUgbWluaSBjYXJ0IHdpdGggZ2l2ZW4gZGVsYXlcbiAgICBjbG9zZSA6IGZ1bmN0aW9uIChkZWxheSkge1xuICAgICAgICB0aW1lci5jbGVhcigpO1xuICAgICAgICAkKCcubWluaS1jYXJ0LW1hc2snKS5jc3Moe29wYWNpdHk6ICcwJ30pO1xuICAgICAgICAkY2FjaGUubWNDb250ZW50LnNsaWRlVXAoJ3Nsb3cnLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgJGNhY2hlLm1jQ29udGFpbmVyLnJlbW92ZUNsYXNzKCdleHBhbmRlZCcpO1xuICAgICAgICAgICAgJCgnLm1pbmktY2FydC1tYXNrJykuY3NzKHt2aXNpYmlsaXR5OiAnaGlkZGVuJ30pO1xuICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmVDbGFzcygnc2hvdycpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIC8vIGhvb2sgd2hpY2ggY2FuIGJlIHJlcGxhY2VkIGJ5IGluZGl2aWR1YWwgcGFnZXMvcGFnZSB0eXBlcyAoZS5nLiBjYXJ0KVxuICAgIHN1cHByZXNzU2xpZGVEb3duIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICAvLyB1cGRhdGUgbWluaWNhcnQgaHRtbFxuICAgIHVwZGF0ZSA6IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICAgICRjYWNoZS5tY1JlZnJlc2gucmVwbGFjZVdpdGgoaHRtbCk7XG4gICAgICAgIGFwcC5taW5pY2FydC5pbml0KCk7XG4gICAgfSxcbiAgICAvLyBhcHAubWluaWNhcnQuZmx5b3V0OiBzaG93IGZseW91dCBpbnN0ZWFkIG9mIG1pbmljYXJ0XG4gICAgZmx5b3V0IDogZnVuY3Rpb24gKGh0bWwscGRwTWFpbix0YXJnZXRCdXR0b24sY3VzdG9tTWVzc2FnZSkge1xuXG4gICAgICAgIHZhciBhZGR0b2NhcnQgPSAodGFyZ2V0QnV0dG9uICE9IG51bGwpPyB0YXJnZXRCdXR0b24gOiAkKCcjYWRkLXRvLWNhcnQnKTtcblxuICAgICAgICBpZihhZGR0b2NhcnQubGVuZ3RoKXtcblxuICAgICAgICAgICAgdmFyIGFkZHRvY2FydCA9ICh0YXJnZXRCdXR0b24gIT0gbnVsbCk/IHRhcmdldEJ1dHRvbiA6ICQoJyNhZGQtdG8tY2FydCcpO1xuXG4gICAgICAgICAgICB2YXIgZmx5b3V0ID0gJCgnI21pbmljYXJ0LWZseW91dCcpO1xuICAgICAgICAgICAgaWYoZmx5b3V0Lmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgZmx5b3V0LnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgJGh0bWwgPSAkKGh0bWwpO1xuICAgICAgICAgICAgdmFyICRwdXJjaGFzZUxpbWl0TXNnID0gJGh0bWwuZmluZCgnLnB1cmNoYXNlLWxpbWl0LWV4Y2VlZGVkJyk7XG4gICAgICAgICAgICBpZigkcHVyY2hhc2VMaW1pdE1zZy5sZW5ndGggKXsgLy8gZm9yIG5vdyBvbmx5IGVuYWJsZSBvbiBrYXRlIHNwYWRlIGFuZCBrYXRlIHNhbGUpe1xuICAgICAgICAgICAgICAgIGFwcC5wcm9kdWN0LnB1cmNoYXNlTGltaXQuc2hvdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICBmbHlvdXQgPSAkKCc8ZGl2PjwvZGl2PicpLmF0dHIoJ2lkJywgJ21pbmljYXJ0LWZseW91dCcpO1xuICAgICAgICAgICAgICAgIGZseW91dC5odG1sKGh0bWwpO1xuICAgICAgICAgICAgICAgIGlmIChjdXN0b21NZXNzYWdlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZmx5b3V0Lmh0bWwoJzxkaXYgY2xhc3M9XCJhdmFpbGFiaWxpdHktbXNnIHB1cmNoYXNlLWxpbWl0LWV4Y2VlZGVkXCI+PHA+JyArIGN1c3RvbU1lc3NhZ2UgKyAnPC9wPjwvZGl2PicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKCRwdXJjaGFzZUxpbWl0TXNnLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgIGZseW91dC5hZGRDbGFzcygncHVyY2hhc2UtbGltaXQnKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkdG9jYXJ0LmF0dHIoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYWRkdG9jYXJ0LmFmdGVyKGZseW91dCk7XG4gICAgICAgICAgICAgICAgaWYgKCBhcHAucmVzb3VyY2VzLlNFU1NJT05fQ1VTVE9NX1NJVEVJRCA9PT0gJ2thdGVtb2JpbGUnICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGZseW91dC5kaWFsb2coe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlhbG9nQ2xhc3M6IFwibWluaWNhcnQtZmx5b3V0LWRpYWxvZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGZseW91dC5maW5kKCcubWluaS1jYXJ0LXRpdGxlJykucmVtb3ZlKCkuaHRtbCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJy51aS13aWRnZXQtb3ZlcmxheScpLmJpbmQoJ2NsaWNrJyxmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbHlvdXQuZGlhbG9nKCdjbG9zZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLmZpbmQoJy5taW5pLWNhcnQtbGluay1jb250aW51ZScpLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZseW91dC5kaWFsb2coJ2Nsb3NlJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZXIuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGltZXIuc3RhcnQoYXBwLm1pbmljYXJ0LmNsb3NlRmFkZSxhcHAucmVzb3VyY2VzLkFEREJBR19USU1FT1VUKTtcblxuICAgICAgICAgICAgICAgICAgICBmbHlvdXQub24oXCJtb3VzZWxlYXZlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lci5zdGFydChhcHAubWluaWNhcnQuY2xvc2VGYWRlLGFwcC5yZXNvdXJjZXMuQUREQkFHX1RJTUVPVVQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBmbHlvdXQub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGZseW91dC5maW5kKCcubWluaS1jYXJ0LWltYWdlIGltZycpLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcC51dGlsLm5vSW1hZ2VIYW5kbGVyKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgJCgnLmNvbnRpbnVlLXNob3BwaW5nLWJ1dHRvbicpLm9mZignY2xpY2snKTtcbiAgICAgICAgICAgICAgICAgICAgJCgnLmNvbnRpbnVlLXNob3BwaW5nLWJ1dHRvbicpLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJyNtaW5pY2FydC1mbHlvdXQnKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcbiAgICBjbG9zZUZhZGUgOiBmdW5jdGlvbiAoKXtcbiAgICAgICAgJCgnI21pbmljYXJ0LWZseW91dCcpLmZhZGVPdXQoJ3Nsb3cnKTtcbiAgICB9LFxuICAgIGNhbmNlbCA6IGZ1bmN0aW9uICgpe1xuICAgICAgICB0aW1lci5jbGVhcigpO1xuICAgIH1cbn07Ly9lbmQgYXBwLm1pbmljYXJ0XG52YXIgY3VycmVudFJlcXVlc3RzID0gW107XG5hcHAuYWpheCA9IHtcbiAgICAvLyBhamF4IHJlcXVlc3QgdG8gZ2V0IGpzb24gcmVzcG9uc2VcbiAgICAvLyBAcGFyYW0gLSBhc3luYyAtIGJvb2xlYW4gLSBhc3luY2hyb25vdXMgb3Igbm90XG4gICAgLy8gQHBhcmFtIC0gdXJsIC0gU3RyaW5nIC0gdXJpIGZvciB0aGUgcmVxdWVzdFxuICAgIC8vIEBwYXJhbSAtIGRhdGEgLSBuYW1lL3ZhbHVlIHBhaXIgZGF0YSByZXF1ZXN0XG4gICAgLy8gQHBhcmFtIC0gY2FsbGJhY2sgLSBmdW5jdGlvbiAtIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgIGdldEpzb246IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBjdXJyZW50UmVxdWVzdHMgPSBbXTtcbiAgICAgICAgb3B0aW9ucy51cmwgPSBhcHAudXRpbC50b0Fic29sdXRlVXJsKG9wdGlvbnMudXJsKTtcbiAgICAgICAgLy8gcmV0dXJuIGlmIG5vIHVybCBleGlzdHMgb3IgdXJsIG1hdGNoZXMgYSBjdXJyZW50IHJlcXVlc3RcbiAgICAgICAgaWYoIW9wdGlvbnMudXJsIHx8IGN1cnJlbnRSZXF1ZXN0c1tvcHRpb25zLnVybF0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRSZXF1ZXN0c1tvcHRpb25zLnVybF0gPSB0cnVlO1xuICAgICAgICAvLyBtYWtlIHRoZSBzZXJ2ZXIgY2FsbFxuICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgZGF0YVR5cGUgOiBcImpzb25cIixcbiAgICAgICAgICAgIHVybCA6IG9wdGlvbnMudXJsLFxuICAgICAgICAgICAgYXN5bmMgOiAodHlwZW9mIG9wdGlvbnMuYXN5bmM9PT1cInVuZGVmaW5lZFwiIHx8IG9wdGlvbnMuYXN5bmM9PT1udWxsKSA/IHRydWUgOiBvcHRpb25zLmFzeW5jLFxuICAgICAgICAgICAgZGF0YSA6IG9wdGlvbnMuZGF0YSB8fCB7fVxuICAgICAgICB9KVxuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICAgIC5kb25lKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYob3B0aW9ucy5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2socmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAvLyBmYWlsZWRcbiAgICAgICAgLmZhaWwoZnVuY3Rpb24gKHhociwgdGV4dFN0YXR1cykge1xuICAgICAgICAgICAgaWYodGV4dFN0YXR1cyA9PT0gXCJwYXJzZXJlcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmFsZXJ0KGFwcC5yZXNvdXJjZXMuQkFEX1JFU1BPTlNFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKG9wdGlvbnMuY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAvLyBleGVjdXRlZCBvbiBzdWNjZXNzIG9yIGZhaWxcbiAgICAgICAgLmFsd2F5cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgY3VycmVudCByZXF1ZXN0IGZyb20gaGFzaFxuICAgICAgICAgICAgaWYoY3VycmVudFJlcXVlc3RzW29wdGlvbnMudXJsXSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjdXJyZW50UmVxdWVzdHNbb3B0aW9ucy51cmxdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIC8vIGFqYXggcmVxdWVzdCB0byBsb2FkIGh0bWwgcmVzcG9uc2UgaW4gYSBnaXZlbiBjb250YWluZXJcbiAgICAvLyBAcGFyYW0gLSB1cmwgLSBTdHJpbmcgLSB1cmkgZm9yIHRoZSByZXF1ZXN0XG4gICAgLy8gQHBhcmFtIC0gZGF0YSAtIG5hbWUvdmFsdWUgcGFpciBkYXRhIHJlcXVlc3RcbiAgICAvLyBAcGFyYW0gLSBjYWxsYmFjayAtIGZ1bmN0aW9uIC0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG4gICAgLy8gQHBhcmFtIC0gdGFyZ2V0IC0gT2JqZWN0IC0gU2VsZWN0b3Igb3IgZWxlbWVudCB0aGF0IHdpbGwgcmVjZWl2ZSBjb250ZW50XG4gICAgbG9hZCA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMudXJsID0gYXBwLnV0aWwudG9BYnNvbHV0ZVVybChvcHRpb25zLnVybCk7XG4gICAgICAgIC8vIHJldHVybiBpZiBubyB1cmwgZXhpc3RzIG9yIHVybCBtYXRjaGVzIGEgY3VycmVudCByZXF1ZXN0XG4gICAgICAgIGlmKCFvcHRpb25zLnVybCB8fCBjdXJyZW50UmVxdWVzdHNbb3B0aW9ucy51cmxdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFJlcXVlc3RzW29wdGlvbnMudXJsXSA9IHRydWU7XG4gICAgICAgIC8vIG1ha2UgdGhlIHNlcnZlciBjYWxsXG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICBkYXRhVHlwZSA6IFwiaHRtbFwiLFxuICAgICAgICAgICAgdXJsIDogYXBwLnV0aWwuYXBwZW5kUGFyYW1Ub1VSTChvcHRpb25zLnVybCwgXCJmb3JtYXRcIiwgXCJhamF4XCIpLFxuICAgICAgICAgICAgZGF0YSA6IG9wdGlvbnMuZGF0YSxcbiAgICAgICAgICAgIHR5cGU6IG9wdGlvbnMudHlwZSA/IG9wdGlvbnMudHlwZSA6ICdHRVQnXG4gICAgICAgIH0pXG4gICAgICAgIC5kb25lKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgICAgICAgaWYob3B0aW9ucy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAkKG9wdGlvbnMudGFyZ2V0KS5lbXB0eSgpLmh0bWwocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYob3B0aW9ucy5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2socmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuZmFpbChmdW5jdGlvbiAoeGhyLCB0ZXh0U3RhdHVzKSB7XG4gICAgICAgICAgICAvLyBmYWlsZWRcbiAgICAgICAgICAgIGlmKHRleHRTdGF0dXMgPT09IFwicGFyc2VyZXJyb3JcIikge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hbGVydChhcHAucmVzb3VyY2VzLkJBRF9SRVNQT05TRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ2NhbGxiYWNrJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhudWxsLCB0ZXh0U3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLmFsd2F5cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhcHAucHJvZ3Jlc3MuaGlkZSgpO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGN1cnJlbnQgcmVxdWVzdCBmcm9tIGhhc2hcbiAgICAgICAgICAgIGlmKGN1cnJlbnRSZXF1ZXN0c1tvcHRpb25zLnVybF0pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY3VycmVudFJlcXVlc3RzW29wdGlvbnMudXJsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTsvL2VuZCBhcHAuYWpheFxuXG5hcHAubW9ub2dyYW0gPSB7XG4gICAgaW5pdCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRmlyc3QsIGNoZWNrcyBpZiBpdCBpc24ndCBpbXBsZW1lbnRlZCB5ZXQuXG4gICAgICAgIGlmICghU3RyaW5nLnByb3RvdHlwZS5mb3JtYXQpIHtcbiAgICAgICAgICBTdHJpbmcucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKC97KFxcZCspfS9nLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJnc1tudW1iZXJdICE9ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyBhcmdzW251bWJlcl1cbiAgICAgICAgICAgICAgICA6IG1hdGNoXG4gICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgbG9hZGVyO1xudmFyIGxhc3RDb250YWluZXI7XG52YXIgZGVwdGggPSAwO1xuYXBwLnByb2dyZXNzID0ge1xuICAgIHNob3c6IGZ1bmN0aW9uIChjb250YWluZXIsIG5hdmlnYXRlVG9MaW5rKSB7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICAgIGlmIChkZXB0aCA+IDEpIHJldHVybjtcbiAgICAgICAgdmFyIHRhcmdldCA9ICghY29udGFpbmVyIHx8ICQoY29udGFpbmVyKS5sZW5ndGg9PT0wKSA/ICQoXCJib2R5XCIpIDogJChjb250YWluZXIpO1xuICAgICAgICB2YXIgbG9hZGVyO1xuICAgICAgICAvLyBQQ1JTUEFERVMtMjM6IGtlZXAgdXNlciBmcm9tIHNjcm9sbGluZyBpZiB0aGUgd2hvbGUgcGFnZSBpcyBtZWFudCB0byBiZSBoaWRkZW5cbiAgICAgICAgaWYodGFyZ2V0LmlzKCdib2R5JykpIHRhcmdldC5jc3MoJ292ZXJmbG93JywgJ2hpZGRlbicpO1xuICAgICAgICAvLyBQQ1JTUEFERVMtMjMgLSBzaXRlIHNwZWNpZmljIGxvYWRpbmcsIGV2ZW4gb24gY2FydFxuICAgICAgICBsb2FkZXIgPSAkKFwiPGRpdi8+XCIpLmFkZENsYXNzKFwibG9hZGVyXCIpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgkKFwiPGRpdi8+XCIpLmFkZENsYXNzKGFwcC5yZXNvdXJjZXMuU0VTU0lPTl9DVVNUT01fU0lURUlEICsgXCItbG9hZGVyLWluZGljYXRvclwiKSwgJChcIjxkaXYvPlwiKS5hZGRDbGFzcyhcImxvYWRlci1iZ1wiKSk7XG4gICAgICAgIGxhc3RDb250YWluZXIgPSB0YXJnZXQ7XG4gICAgICAgIGxvYWRlci5hcHBlbmRUbyh0YXJnZXQpLnNob3coKTtcblxuICAgICAgICBpZiAobmF2aWdhdGVUb0xpbmsgPT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHt3aW5kb3cubG9jYXRpb24gPSBuYXZpZ2F0ZVRvTGluazt9LDEwMDApO1xuICAgIH0sXG4gICAgaGlkZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgICBkZXB0aCA9IE1hdGgubWF4KGRlcHRoLTEsMCk7XG4gICAgICAgIGlmIChkZXB0aCA+IDApIHJldHVybjtcbiAgICAgICAgdmFyIHRhcmdldCA9IGNvbnRhaW5lciB8fCBsYXN0Q29udGFpbmVyO1xuICAgICAgICBpZih0YXJnZXQpe1xuICAgICAgICAgICAgLy8gUENSU1BBREVTLTIzOiBhbGxvdyB1c2VyIHRvIGZyb20gc2Nyb2xsaW5nIGlmIHRoZSB3aG9sZSBwYWdlXG4gICAgICAgICAgICBpZih0YXJnZXQuaXMoJ2JvZHknKSkgdGFyZ2V0LmNzcygnb3ZlcmZsb3cnLCAnYXV0bycpO1xuICAgICAgICAgICAgdmFyIGxvYWRlciA9IHRhcmdldC5maW5kKCcubG9hZGVyJyk7XG4gICAgICAgICAgICBpZihmYWxzZSl7XG4gICAgICAgICAgICAgICAgLy8gZmFkZU91dCBzZWVtcyB0byBwcmV2ZW50IGNsaWNraW5nIGluIEthdGVTcGFkZSBpbiBJRVxuICAgICAgICAgICAgICAgIGxvYWRlci5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIGxvYWRlci5mYWRlT3V0KCdmYXN0JywgZnVuY3Rpb24oKSB7bG9hZGVyLnJlbW92ZSgpO30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvLyBQQ1JTUEFERVMtMjM6IEFsbG93IHByb2dyZXNzIHdoZW4gc3VibWl0dGluZyBmb3JtcyBuYXRpdmVseVxuICAgIHN1Ym1pdEZvcm06IGZ1bmN0aW9uIChidXR0b25zKXtcbiAgICAgICAgYnV0dG9ucy5lYWNoKCBmdW5jdGlvbihpbmRleCl7XG4gICAgICAgICAgICB2YXIgYnV0dG9uID0gJCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBmb3JtID0gYnV0dG9uLmNsb3Nlc3QoJ2Zvcm0nKTtcblxuICAgICAgICAgICAgLy8gQ2FwdHVyZSBzdWJtaXQgb2YgdGhlIGZvcm1cbiAgICAgICAgICAgIGJ1dHRvbi5vbignY2xpY2snLGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZm9ybSBpc24ndCBsb29waW5nIGl0cyBzdWJtaXRcbiAgICAgICAgICAgICAgICBpZiggISRjYWNoZVtmb3JtLmF0dHIoJ2lkJyldICl7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBpdCBpcyB2YWxpZFxuICAgICAgICAgICAgICAgICAgICAvL2lmKCBmb3JtLnZhbGlkKCkgIHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgdGhlIGZvcm0gZnJvbSBzdWJtaXR0aW5nIHJpZ2h0IGF3YXkgc28gdGhhdCB0aGUgcHJvZ3Jlc3Mgb3ZlcmxheSBjYW4gZGlzcGxheVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsb2NrIHRoZSBmb3JtIHN1Ym1pc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICAgICRjYWNoZVtmb3JtLmF0dHIoJ2lkJyldID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzcGxheSBwcm9ncmVzcyBvdmVybGF5IHdpdGggdGhlICQoJ2JvZHknKSBhcyB0aGUgZGVmYXVsdCB0YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcC5wcm9ncmVzcy5zaG93KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1Ym1pdCB0aGUgZm9ybSBub3cgdGhhdCB0aGUgb3ZlcmxheSBoYXMgaGFkIHRpbWUgdG8gcG9wdWxhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHNlbmQgZGVtYW5kd2FyZSB0aGUgJ3NhdmUnIGFjdGlvbiBzbyB0aGUgZm9ybSBpcyBwcm9jZXNzZWQgY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcIjxpbnB1dC8+XCIpLmF0dHIoe3R5cGU6XCJoaWRkZW5cIiwgbmFtZTogYnV0dG9uLmF0dHIoXCJuYW1lXCIpfSkuYXBwZW5kVG8oZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VibWl0IHRoZSBmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5zdWJtaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59Oy8vZW5kIGFwcC5wcm9ncmVzc1xuXG5hcHAudG9vbHRpcHMgPSB7XG4gICAgaW5pdCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVE9PTFRJUFxuICAgICAgIC8qKioqKiBzdGFydCBjaGVja291dCByZWRlc2lnbiBldmVudHMgKioqKiovXG4gICAgICAgIGlmICgkKFwiLnBhZ2UtaGVhZGluZy52MlwiKS5sZW5ndGggfHwgJChcIi5jaGVja291dC1yZWRlc2lnblwiKS5sZW5ndGggKSB7XG4gICAgICAgICAgICAkKCdib2R5JykuYWRkQ2xhc3MoJ0NSdjInKTtcbiAgICAgICAgICAgICQoXCIucGhvbmUtdGlwLXJvdyAudGlwXCIpLm9uKCdtb3VzZWVudGVyJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAkKFwiI3Rvb2x0aXBcIikuYWRkQ2xhc3MoJ3Bob25lJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICQoXCIuZm9ybS1yb3cucGhvbmUtdGlwLXJvdy5jdm4gLnRpcFwiKS5vbignbW91c2VlbnRlcicsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgJChcIiN0b29sdGlwXCIpLmFkZENsYXNzKCdjdm4nKTtcbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgIHZhciAkY3ZjRmllbGQgPSAkKCcuaW5wdXQtdGV4dC5jdmMucmVxdWlyZWQnKTtcbiAgICAgICAgICAgIHZhciAkcGhvbmVGaWVsZCA9ICQoJy5pbnB1dC10ZXh0LnBob25lLnJlcXVpcmVkJyk7XG4gICAgICAgICAgICB2YXIgJHRvb2xUaXAgPSAkKCcucGhvbmUtdGlwLXJvdycpO1xuICAgICAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAgICAqIEZ1bmN0aW9uIHRvIGhpZGUgdG9vbHRpcCBmcm9tIHJvd1xuICAgICAgICAgICAgKiBvbmNlIHRoZSB1c2VyIGhhcyBzdGFydGVkIHR5cGluZyBzbyB0aGUgZXJyb3JcbiAgICAgICAgICAgICogYW5kIHZhbGlkIGljb25zIGRvIG5vdCBvdmVybGFwXG4gICAgICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgICAgICAkcGhvbmVGaWVsZC5vbigna2V5ZG93bicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICR0b29sVGlwLmhpZGUoKTtcbiAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRjdmNGaWVsZC5vbigna2V5ZG93bicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICR0b29sVGlwLmhpZGUoKTtcbiAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAgICAqIEZ1bmN0aW9uIHRvIGhpZGUgdG9vbHRpcCBmcm9tIHJvd1xuICAgICAgICAgICAgKiBpZiB0aGUgdXNlciBjbGlja3MgaW50byB0aGUgZmllbGVkIHRoZW4gb3V0XG4gICAgICAgICAgICAqIHdpdGhvdXQgdHlwaW5nIHNvIHRoZSBlcnJvciBpY29uIGRvZXMgbm90IG92ZXJsYXBcbiAgICAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAgICAgJHBob25lRmllbGQub24oJ2ZvY3Vzb3V0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJHRvb2xUaXAuaGlkZSgpO1xuICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJGN2Y0ZpZWxkLm9uKCdmb2N1c291dCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICR0b29sVGlwLmhpZGUoKTtcbiAgICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG4gICAgICAgIC8qKioqKiBlbmQgb2YgY2hlY2tvdXQgcmVkZXNpZ24gZXZlbnRzICoqKioqL1xuXG4gICAgICAgICQoJy50aXAnKS5vbignbW91c2VlbnRlcicsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpO1xuICAgICAgICAgICAgaWYoISRjYWNoZS50aXApIHtcbiAgICAgICAgICAgICAgICAkY2FjaGUudGlwID0gJCgnI3Rvb2x0aXAnKTtcbiAgICAgICAgICAgICAgICBpZiAoIGFwcC5yZXNvdXJjZXMuU0VTU0lPTl9DVVNUT01fU0lURUlEID09PSAna2F0ZW1vYmlsZScgKSB7XG4gICAgICAgICAgICAgICAgICAgICRjYWNoZS5iZyA9ICQoXCI8ZGl2IGlkPSd0b29sdGlwLW1hc2snPjwvZGl2PlwiKTtcbiAgICAgICAgICAgICAgICAgICAgJGNhY2hlLmJnLmluc2VydEJlZm9yZSgkY2FjaGUudGlwKTtcbiAgICAgICAgICAgICAgICAgICAgJGNhY2hlLmJnLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcENsb3NpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNudCA9ICQoJHRoaXMuZGF0YSgnY29udGVudCcpKTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9ICR0aGlzLmRhdGEoJ3dpZHRoJyk7XG4gICAgICAgICAgICB2YXIgY3RvcCA9ICR0aGlzLm9mZnNldCgpLnRvcDtcbiAgICAgICAgICAgIHZhciBjbGVmdCA9ICR0aGlzLm9mZnNldCgpLmxlZnQ7XG4gICAgICAgICAgICB2YXIgYWxpZ24gPSAkdGhpcy5kYXRhKCdhbGlnbicpO1xuICAgICAgICAgICAgaWYoIWFsaWduKXtcbiAgICAgICAgICAgICAgICBhbGlnbiA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2hlbiB0aGUgdG9vbHRpcCBpcyBvcGVuLCB0aGlzIGFkZHMgb3BhY2l0eVxuICAgICAgICAgICAgaWYgKCBhcHAucmVzb3VyY2VzLlNFU1NJT05fQ1VTVE9NX1NJVEVJRCA9PT0gJ2thdGVtb2JpbGUnICkge1xuICAgICAgICAgICAgICAgICRjYWNoZS5iZy5jc3Moe3Zpc2liaWxpdHk6ICd2aXNpYmxlJywgb3BhY2l0eTogJzAuOCd9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBvcHVsYXRlIHRpcCB3aXRoIGNvbnRlbnRcbiAgICAgICAgICAgICRjYWNoZS50aXAuZmluZCgnLmJvZHknKS5odG1sKGNudC5odG1sKCkpXG4gICAgICAgICAgICAvLyBBZGp1c3Qgd2lkdGhcbiAgICAgICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgICAgICRjYWNoZS50aXAuY3NzKCd3aWR0aCcsd2lkdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGp1c3QgcG9zaXRpb25cbiAgICAgICAgICAgIGlmIChhbGlnbi5pbmRleE9mKCdyaWdodCcpID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyByaWdodCBhbGlnblxuICAgICAgICAgICAgICAgIGlmIChhbGlnbi5pbmRleE9mKCdpbm5lcnJpZ2h0JykgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciBzaWRlIHJpZ2h0LCBhZGQgd2lkdGggb2YgZWxlbWVudCBhbmQgNSBwaXhlbHMgZm9yIHNwYWNpbmdcbiAgICAgICAgICAgICAgICAgICAgY2xlZnQgPSBjbGVmdCArICR0aGlzLm91dGVyV2lkdGgoKSArIDU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbGVmdCBhbGlnblxuICAgICAgICAgICAgICAgIC8vIHN1YnRyYWN0IHdpZHRoIG9mIHRpcCBib3hcbiAgICAgICAgICAgICAgICBjbGVmdCA9IGNsZWZ0IC0gJGNhY2hlLnRpcC5vdXRlcldpZHRoKCk7XG4gICAgICAgICAgICAgICAgaWYgKGFsaWduLmluZGV4T2YoJ2lubmVybGVmdCcpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGlubmVyIGxlZnQsIHN1YnRyYWN0IHdpZHRoIG9mIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgY2xlZnQgPSBjbGVmdCArICR0aGlzLm91dGVyV2lkdGgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gbGVmdCBvdXRlciBhbGlnblxuICAgICAgICAgICAgICAgICAgICAvLyBmb3Igb3V0ZXIgbGVmdCwgc3VidHJhY3QgZXh0cmEgNSBwaXhlbHMgZm9yIHNwYWNpbmdcbiAgICAgICAgICAgICAgICAgICAgY2xlZnQgPSBjbGVmdCAtIDU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsaWduLmluZGV4T2YoJ2JvdHRvbScpID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyBib3R0b20gYWxpZ25cbiAgICAgICAgICAgICAgICBpZiAoYWxpZ24uaW5kZXhPZignaW5uZXJib3R0b20nKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIG91dGVyIGJvdHRvbSAoYWthIGJvdHRvbSksIGFkZCBlbGVtZW50IGhlaWdodCBhbmQgZXh0cmEgNSBwaXhlbHMgZm9yIHNwYWNpbmdcbiAgICAgICAgICAgICAgICAgICAgY3RvcCA9IGN0b3AgKyAkdGhpcy5vdXRlckhlaWdodCgpICs1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJsaXR5LCBkZWZhdWx0IHRvIDIwIHBpeGVscyB1cCBmcm9tIHRvcCBvZiBlbGVtZW50XG4gICAgICAgICAgICAgICAgY3RvcCA9IGN0b3AgLSAyMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUG9zaXRpb24gdGlwXG4gICAgICAgICAgICAkY2FjaGUudGlwLmNzcyh7J2xlZnQnOiBjbGVmdCwgJ3RvcCc6IGN0b3B9KVxuICAgICAgICAgICAgJGNhY2hlLnRpcC5zdG9wKGNsZWFyUXVldWUsIGp1bXBUb0VuZCkuc2hvdygpO1xuICAgICAgICAgICAgbW91c2VPblRyaWdnZXIgPSB0cnVlO1xuICAgICAgICB9KS5vbignbW91c2VsZWF2ZScsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0b29sdGlwQ2xvc2luZygpO1xuICAgICAgICAgICAgbW91c2VPblRyaWdnZXIgPSBmYWxzZTtcbiAgICAgICAgfSkuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgLy8gRGlzYWJsZSBjbGljayBldmVudCBvbiB0b29sdGlwIGxpbmtzIGZvciB0aGUgbW9iaWxlIHNpdGVcbiAgICAgICAgICAgIGlmICggYXBwLnJlc291cmNlcy5TRVNTSU9OX0NVU1RPTV9TSVRFSUQgPT09ICdrYXRlbW9iaWxlJyApIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJ2EnKS5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgJChkb2N1bWVudCkub24oJ21vdXNlZW50ZXInLCcjdG9vbHRpcCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCBhcHAucmVzb3VyY2VzLlNFU1NJT05fQ1VTVE9NX1NJVEVJRCA9PT0gJ2thdGVtb2JpbGUnICkge1xuICAgICAgICAgICAgICAgICQoJyN3cmFwcGVyJykuYWRkQ2xhc3MoJ3Rvb2x0aXBoZWxwJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vdXNlT25UaXAgPSB0cnVlO1xuICAgICAgICB9KS5vbignbW91c2VsZWF2ZScsJyN0b29sdGlwJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0b29sdGlwQ2xvc2luZygpO1xuICAgICAgICAgICAgbW91c2VPblRpcCA9IGZhbHNlO1xuICAgICAgICB9KS5vbignY2xpY2snLCAnLmNsb3NlSGVscCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAoIGFwcC5yZXNvdXJjZXMuU0VTU0lPTl9DVVNUT01fU0lURUlEID09PSAna2F0ZW1vYmlsZScgKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcENsb3NpbmcoKTtcbiAgICAgICAgICAgICAgICBtb3VzZU9uVGlwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgJCgnI3dyYXBwZXInKS5yZW1vdmVDbGFzcygndG9vbHRpcGhlbHAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuYXBwLnRyaWdnZXJVSVNDYXJ0Q2hlY2sgPSB0cmlnZ2VyVUlTQ2FydENoZWNrO1xuXG4vLyBnZW5lcmFsIGV4dGVuc2lvbiBmdW5jdGlvbnNcbihmdW5jdGlvbiAoKSB7XG4gICAgU3RyaW5nLmZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHMgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciBpLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cCgnXFxcXHsnICsgaSArICdcXFxcfScsICdnbScpO1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShyZWcsIGFyZ3VtZW50c1tpICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG59KSgpO1xuXG5mdW5jdGlvbiBiaW5kUXZCdXR0b24oKSB7XG4gICAgJGNhY2hlLnF2QnV0dG9uLm9uZShcImNsaWNrXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYXBwLnF1aWNrVmlldy5zaG93KHtcbiAgICAgICAgICAgIHVybCA6ICQodGhpcykuYXR0cihcImhyZWZcIiksXG4gICAgICAgICAgICBzb3VyY2UgOiBcInF1aWNrdmlld1wiXG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RCb3hJdChzZWxlY3QpIHtcblxuICAgIHZhciBpdGVtcyA9IHNlbGVjdC5maWx0ZXIoJ3NlbGVjdCcpO1xuICAgIGlmIChpdGVtcy5sZW5ndGggPT0gMCkgcmV0dXJuO1xuXG4gICAgLy8gc2VsZWN0IGJveCByZXBsYWNlbWVudCBpcyBkaXNhYmxlZCBmb3IgY2VydGFpbiBwYXJ0cyBvZiB0aGUgc2l0ZVxuICAgIGlmIChcInBhZ2VcIiBpbiBhcHAgJiYgXCJuc1wiIGluIGFwcC5wYWdlICYmXG4gICAgICAgICAgICAoYXBwLnBhZ2UudHlwZSA9PSAnY2hlY2tvdXQnXG4gICAgICAgICAgICB8fCBhcHAucGFnZS50eXBlID09ICdvcmRlcmNvbmZpcm1hdGlvbidcbiAgICAgICAgICAgIHx8IGFwcC5wYWdlLnR5cGUgPT0gJ0dpZnRSZWdpc3RyeSdcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBudWxsO1xuXG4gICAgICAgIGl0ZW1zLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpdGVtID0gJCh0aGlzKTtcbiAgICAgICAgICAgIGlmIChpdGVtLnBhcmVudCgnZGl2LnNlbGVjdC1jb250YWluZXInKS5sZW5ndGggPT0gMCl7XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gaXRlbS5uZXh0KCdsYWJlbCcpO1xuICAgICAgICAgICAgICAgIHZhciB2YWxpZCA9IGxhYmVsLm5leHQoJy52YWxpZC1pY29uJyk7XG4gICAgICAgICAgICAgICAgJCgnPGRpdiBjbGFzcz1cInNlbGVjdC1jb250YWluZXJcIiAvPicpLmluc2VydEJlZm9yZShpdGVtKS5hcHBlbmQoaXRlbSkuYXBwZW5kKGxhYmVsKS5hcHBlbmQodmFsaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9ZWxzZSB7XG4gICAgICAgIGl0ZW1zLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBpdGVtID0gJCh0aGlzKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaXRlbS5hZGRDbGFzcygncmVwbGFjZWQnKTtcbiAgICAgICAgICAgICAgICB2YXIgc2IgPSBpdGVtLnNlbGVjdEJveEl0KCkuZGF0YShcInNlbGVjdEJveEl0XCIpO1xuICAgICAgICAgICAgICAgIHNiLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICBpdGVtcy5iaW5kKHtcbiAgICAgICAgICAgICAgICAgICAgXCJvcGVuXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZHMgdGhlIFR3aXR0ZXIgQm9vdHN0cmFwICdkcm9wdXAnIGNsYXNzIHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRyb3AgZG93blxuICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5uZXh0KCcuc2VsZWN0Ym94aXQtY29udGFpbmVyJykuYWRkQ2xhc3MoJ29wZW4nKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnY2xvc2UnOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5uZXh0KCcuc2VsZWN0Ym94aXQtY29udGFpbmVyJykucmVtb3ZlQ2xhc3MoJ29wZW4nKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnZm9jdXNpbicgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykubmV4dCgnLnNlbGVjdGJveGl0LWNvbnRhaW5lcicpLmFkZENsYXNzKCdmb2N1cycpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnZm9jdXNvdXQnIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLm5leHQoJy5zZWxlY3Rib3hpdC1jb250YWluZXInKS5yZW1vdmVDbGFzcygnZm9jdXMnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gYWRkIGF2YWlsYWJsaXR5IG1lc3NhZ2Ugd2l0aGluIGRyb3Bkb3duXG4gICAgICAgICAgICAgICAgc2IuZHJvcGRvd25Db250YWluZXIuZmluZCgnbGlbZGF0YS10ZXh0XSBhJykuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9ICQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaSA9IGEucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhVGV4dCA9IGxpLmRhdGEoJ3RleHQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoZGF0YVRleHQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGh0bWwgPSBhLmh0bWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGh0bWwuaW5kZXhPZihkYXRhVGV4dCkgPT0gLTEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpLmFkZENsYXNzKCdhdmFpbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuaHRtbCgnPHNwYW4gY2xhc3M9XCJzaXplXCI+JyArIGh0bWwgKyAnPC9zcGFuPiZuYnNwOzxzcGFuIGNsYXNzPVwibXNnXCI+JyArIGRhdGFUZXh0ICsgJzwvc3Bhbj4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfWNhdGNoKGUpe31cbiAgICAgICAgfSk7XG5cblxuICAgIH1cbn1cblxudmFyIGNvdW50cmllcyA9IHJlcXVpcmUoJy4vY291bnRyaWVzJyksXG5kaWFsb2cgPSByZXF1aXJlKCcuL2RpYWxvZycpLFxuZGF0YWxheWVyID0gcmVxdWlyZSgnLi9kYXRhbGF5ZXInKSxcbmZsb2F0bGFiZWxzID0gcmVxdWlyZSgnLi9mbG9hdC1sYWJlbHMnKSxcbm1pbmljYXJ0ID0gcmVxdWlyZSgnLi9taW5pY2FydCcpLFxucGFnZSA9IHJlcXVpcmUoJy4vcGFnZScpLFxucmF0aW5nID0gcmVxdWlyZSgnLi9yYXRpbmcnKSxcbnNlYXJjaHBsYWNlaG9sZGVyID0gcmVxdWlyZSgnLi9zZWFyY2hwbGFjZWhvbGRlcicpLFxuc2VhcmNoc3VnZ2VzdCA9IHJlcXVpcmUoJy4vc2VhcmNoc3VnZ2VzdCcpLFxudG9vbHRpcCA9IHJlcXVpcmUoJy4vdG9vbHRpcCcpLFxudXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxudmFsaWRhdG9yID0gcmVxdWlyZSgnLi92YWxpZGF0b3InKSxcbnRscyA9IHJlcXVpcmUoJy4vdGxzJyksXG5lbWFpbHN1YnNjcmlwdGlvbiA9IHJlcXVpcmUoJy4vZW1haWxzdWJzY3JpcHRpb24nKSxcbmxvZ2luID0gcmVxdWlyZSgnLi9sb2dpbicpO1xuXG5cbi8vIGluaXRpYWxpemUgYXBwXG4kKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgYXBwLmluaXQoKTtcbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRpYWxvZyA9IHJlcXVpcmUoJy4vZGlhbG9nJyksXG4gICAgcGFnZSA9IHJlcXVpcmUoJy4vcGFnZScpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIHNlbGVjdGVkTGlzdCA9IFtdO1xudmFyIG1heEl0ZW1zID0gMTtcbnZhciBibGlVVUlEID0gJyc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICogZGVzY3JpcHRpb24gR2V0cyBhIGxpc3Qgb2YgYm9udXMgcHJvZHVjdHMgcmVsYXRlZCB0byBhIHByb21vdGVkIHByb2R1Y3RcbiAqL1xuZnVuY3Rpb24gZ2V0Qm9udXNQcm9kdWN0cygpIHtcbiAgICB2YXIgYm9udXNwcm9kdWN0cyA9IFtdO1xuXG4gICAgdmFyIGksIGxlbjtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBzZWxlY3RlZExpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHAgPSB7XG4gICAgICAgICAgICBwaWQ6IHNlbGVjdGVkTGlzdFtpXS5waWQsXG4gICAgICAgICAgICBxdHk6IHNlbGVjdGVkTGlzdFtpXS5xdHksXG4gICAgICAgICAgICBvcHRpb25zOiB7fVxuICAgICAgICB9O1xuICAgICAgICB2YXIgYSwgYWxlbiwgYnAgPSBzZWxlY3RlZExpc3RbaV07XG4gICAgICAgIGlmIChicC5vcHRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGEgPSAwLCBhbGVuID0gYnAub3B0aW9ucy5sZW5ndGg7IGEgPCBhbGVuOyBhKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0ID0gYnAub3B0aW9uc1thXTtcbiAgICAgICAgICAgICAgICBwLm9wdGlvbnMgPSB7b3B0aW9uTmFtZTpvcHQubmFtZSwgb3B0aW9uVmFsdWU6b3B0LnZhbHVlfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBib251c3Byb2R1Y3RzLnB1c2goe3Byb2R1Y3Q6cH0pO1xuICAgIH1cbiAgICByZXR1cm4ge2JvbnVzcHJvZHVjdHM6IGJvbnVzcHJvZHVjdHN9O1xufVxuXG52YXIgc2VsZWN0ZWRJdGVtVGVtcGxhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBhdHRyaWJ1dGVzID0gJyc7XG4gICAgZm9yICh2YXIgYXR0cklEIGluIGRhdGEuYXR0cmlidXRlcykge1xuICAgICAgICB2YXIgYXR0ciA9IGRhdGEuYXR0cmlidXRlc1thdHRySURdO1xuICAgICAgICBhdHRyaWJ1dGVzICs9ICc8bGkgZGF0YS1hdHRyaWJ1dGUtaWQ9XCInICsgYXR0cklEICsgJ1wiPlxcbic7XG4gICAgICAgIGF0dHJpYnV0ZXMgKz0gJzxzcGFuIGNsYXNzPVwiZGlzcGxheS1uYW1lXCI+JyArIGF0dHIuZGlzcGxheU5hbWUgKyAnPC9zcGFuPjogJztcbiAgICAgICAgYXR0cmlidXRlcyArPSAnPHNwYW4gY2xhc3M9XCJkaXNwbGF5LXZhbHVlXCI+JyArIGF0dHIuZGlzcGxheVZhbHVlICsgJzwvc3Bhbj5cXG4nO1xuICAgICAgICBhdHRyaWJ1dGVzICs9ICc8L2xpPic7XG4gICAgfVxuICAgIGF0dHJpYnV0ZXMgKz0gJzxsaSBjbGFzcz1cIml0ZW0tcXR5XCI+XFxuJztcbiAgICBhdHRyaWJ1dGVzICs9ICc8c3BhbiBjbGFzcz1cImRpc3BsYXktbmFtZVwiPlF0eTwvc3Bhbj46ICc7XG4gICAgYXR0cmlidXRlcyArPSAnPHNwYW4gY2xhc3M9XCJkaXNwbGF5LXZhbHVlXCI+JyArIGRhdGEucXR5ICsgJzwvc3Bhbj4nO1xuICAgIHJldHVybiBbXG4gICAgICAgICc8bGkgY2xhc3M9XCJzZWxlY3RlZC1ib251cy1pdGVtXCIgZGF0YS11dWlkPVwiJyArIGRhdGEudXVpZCArICdcIiBkYXRhLXBpZD1cIicgKyBkYXRhLnBpZCArICdcIj4nLFxuICAgICAgICAnPGkgY2xhc3M9XCJyZW1vdmUtbGluayBmYSBmYS1yZW1vdmVcIiB0aXRsZT1cIlJlbW92ZSB0aGlzIHByb2R1Y3RcIiBocmVmPVwiI1wiPjwvaT4nLFxuICAgICAgICAnPGRpdiBjbGFzcz1cIml0ZW0tbmFtZVwiPicgKyBkYXRhLm5hbWUgKyAnPC9kaXY+JyxcbiAgICAgICAgJzx1bCBjbGFzcz1cIml0ZW0tYXR0cmlidXRlc1wiPicsXG4gICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICc8dWw+JyxcbiAgICAgICAgJzxsaT4nXG4gICAgXS5qb2luKCdcXG4nKTtcbn07XG5cbi8vIGhpZGUgc3dhdGNoZXMgdGhhdCBhcmUgbm90IHNlbGVjdGVkIG9yIG5vdCBwYXJ0IG9mIGEgUHJvZHVjdCBWYXJpYXRpb24gR3JvdXBcbnZhciBoaWRlU3dhdGNoZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgJCgnLmJvbnVzLXByb2R1Y3QtaXRlbTpub3QoW2RhdGEtcHJvZHVjdHR5cGU9XCJtYXN0ZXJcIl0pIC5zd2F0Y2hlcyBsaScpLm5vdCgnLnNlbGVjdGVkJykubm90KCcudmFyaWF0aW9uLWdyb3VwLXZhbHVlJykuaGlkZSgpO1xuICAgIC8vIHByZXZlbnQgdW5zZWxlY3RpbmcgdGhlIHNlbGVjdGVkIHZhcmlhbnRcbiAgICAkKCcuYm9udXMtcHJvZHVjdC1pdGVtIC5zd2F0Y2hlcyAuc2VsZWN0ZWQnKS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uIFVwZGF0ZXMgdGhlIHN1bW1hcnkgcGFnZSB3aXRoIHRoZSBzZWxlY3RlZCBib251cyBwcm9kdWN0XG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVN1bW1hcnkoKSB7XG4gICAgdmFyICRib251c1Byb2R1Y3RMaXN0ID0gJCgnI2JvbnVzLXByb2R1Y3QtbGlzdCcpO1xuICAgIGlmICghc2VsZWN0ZWRMaXN0Lmxlbmd0aCkge1xuICAgICAgICAkYm9udXNQcm9kdWN0TGlzdC5maW5kKCdsaS5zZWxlY3RlZC1ib251cy1pdGVtJykucmVtb3ZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHVsTGlzdCA9ICRib251c1Byb2R1Y3RMaXN0LmZpbmQoJ3VsLnNlbGVjdGVkLWJvbnVzLWl0ZW1zJykuZmlyc3QoKTtcbiAgICAgICAgdmFyIGksIGxlbjtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc2VsZWN0ZWRMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHNlbGVjdGVkTGlzdFtpXTtcbiAgICAgICAgICAgIHZhciBsaSA9IHNlbGVjdGVkSXRlbVRlbXBsYXRlKGl0ZW0pO1xuICAgICAgICAgICAgJChsaSkuYXBwZW5kVG8odWxMaXN0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGdldCByZW1haW5pbmcgaXRlbSBjb3VudFxuICAgIHZhciByZW1haW4gPSBtYXhJdGVtcyAtIHNlbGVjdGVkTGlzdC5sZW5ndGg7XG4gICAgJGJvbnVzUHJvZHVjdExpc3QuZmluZCgnLmJvbnVzLWl0ZW1zLWF2YWlsYWJsZScpLnRleHQocmVtYWluKTtcbiAgICBpZiAocmVtYWluIDw9IDApIHtcbiAgICAgICAgJGJvbnVzUHJvZHVjdExpc3QuZmluZCgnLnNlbGVjdC1ib251cy1pdGVtJykuYXR0cignZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAkYm9udXNQcm9kdWN0TGlzdC5maW5kKCcuc2VsZWN0LWJvbnVzLWl0ZW0nKS5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZUdyaWQgKCkge1xuICAgIHZhciAkYm9udXNQcm9kdWN0ID0gJCgnI2JvbnVzLXByb2R1Y3QtZGlhbG9nJyksXG4gICAgICAgICRib251c1Byb2R1Y3RMaXN0ID0gJCgnI2JvbnVzLXByb2R1Y3QtbGlzdCcpLFxuICAgICAgICBibGlEYXRhID0gJGJvbnVzUHJvZHVjdExpc3QuZGF0YSgnbGluZS1pdGVtLWRldGFpbCcpO1xuICAgIG1heEl0ZW1zID0gYmxpRGF0YS5tYXhJdGVtcztcbiAgICBibGlVVUlEID0gYmxpRGF0YS51dWlkO1xuXG4gICAgaWYgKGJsaURhdGEuaXRlbUNvdW50ID49IG1heEl0ZW1zKSB7XG4gICAgICAgICRib251c1Byb2R1Y3RMaXN0LmZpbmQoJy5zZWxlY3QtYm9udXMtaXRlbScpLmF0dHIoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gICAgfVxuXG4gICAgdmFyIGNhcnRJdGVtcyA9ICRib251c1Byb2R1Y3RMaXN0LmZpbmQoJy5zZWxlY3RlZC1ib251cy1pdGVtJyk7XG4gICAgY2FydEl0ZW1zLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2kgPSAkKHRoaXMpO1xuICAgICAgICB2YXIgcHJvZHVjdCA9IHtcbiAgICAgICAgICAgIHV1aWQ6IGNpLmRhdGEoJ3V1aWQnKSxcbiAgICAgICAgICAgIHBpZDogY2kuZGF0YSgncGlkJyksXG4gICAgICAgICAgICBxdHk6IGNpLmZpbmQoJy5pdGVtLXF0eScpLnRleHQoKSxcbiAgICAgICAgICAgIG5hbWU6IGNpLmZpbmQoJy5pdGVtLW5hbWUnKS5odG1sKCksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7fVxuICAgICAgICB9O1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGNpLmZpbmQoJ3VsLml0ZW0tYXR0cmlidXRlcyBsaScpO1xuICAgICAgICBhdHRyaWJ1dGVzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxpID0gJCh0aGlzKTtcbiAgICAgICAgICAgIHByb2R1Y3QuYXR0cmlidXRlc1tsaS5kYXRhKCdhdHRyaWJ1dGVJZCcpXSA9IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTpsaS5jaGlsZHJlbignLmRpc3BsYXktbmFtZScpLmh0bWwoKSxcbiAgICAgICAgICAgICAgICBkaXNwbGF5VmFsdWU6bGkuY2hpbGRyZW4oJy5kaXNwbGF5LXZhbHVlJykuaHRtbCgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgc2VsZWN0ZWRMaXN0LnB1c2gocHJvZHVjdCk7XG4gICAgfSk7XG5cbiAgICAkYm9udXNQcm9kdWN0TGlzdC5vbignY2xpY2snLCAnLmJvbnVzLXByb2R1Y3QtaXRlbSBhW2hyZWZdLnN3YXRjaGFuY2hvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIHVybCA9IHRoaXMuaHJlZixcbiAgICAgICAgICAgICR0aGlzID0gJCh0aGlzKTtcbiAgICAgICAgdXJsID0gdXRpbC5hcHBlbmRQYXJhbXNUb1VybCh1cmwsIHtcbiAgICAgICAgICAgICdzb3VyY2UnOiAnYm9udXMnLFxuICAgICAgICAgICAgJ2Zvcm1hdCc6ICdhamF4J1xuICAgICAgICB9KTtcbiAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuY2xvc2VzdCgnLmJvbnVzLXByb2R1Y3QtaXRlbScpLmVtcHR5KCkuaHRtbChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgaGlkZVN3YXRjaGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pXG4gICAgLm9uKCdjaGFuZ2UnLCAnLmlucHV0LXRleHQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICRib251c1Byb2R1Y3RMaXN0LmZpbmQoJy5zZWxlY3QtYm9udXMtaXRlbScpLnJlbW92ZUF0dHIoJ2Rpc2FibGVkJyk7XG4gICAgICAgICQodGhpcykuY2xvc2VzdCgnLmJvbnVzLXByb2R1Y3QtZm9ybScpLmZpbmQoJy5xdWFudGl0eS1lcnJvcicpLnRleHQoJycpO1xuICAgIH0pXG4gICAgLm9uKCdjbGljaycsICcuc2VsZWN0LWJvbnVzLWl0ZW0nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmIChzZWxlY3RlZExpc3QubGVuZ3RoID49IG1heEl0ZW1zKSB7XG4gICAgICAgICAgICAkYm9udXNQcm9kdWN0TGlzdC5maW5kKCcuc2VsZWN0LWJvbnVzLWl0ZW0nKS5hdHRyKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgJGJvbnVzUHJvZHVjdExpc3QuZmluZCgnLmJvbnVzLWl0ZW1zLWF2YWlsYWJsZScpLnRleHQoJzAnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmb3JtID0gJCh0aGlzKS5jbG9zZXN0KCcuYm9udXMtcHJvZHVjdC1mb3JtJyksXG4gICAgICAgICAgICBkZXRhaWwgPSAkKHRoaXMpLmNsb3Nlc3QoJy5wcm9kdWN0LWRldGFpbCcpLFxuICAgICAgICAgICAgdXVpZCA9IGZvcm0uZmluZCgnaW5wdXRbbmFtZT1cInByb2R1Y3RVVUlEXCJdJykudmFsKCksXG4gICAgICAgICAgICBxdHlWYWwgPSBmb3JtLmZpbmQoJ2lucHV0W25hbWU9XCJRdWFudGl0eVwiXScpLnZhbCgpLFxuICAgICAgICAgICAgcXR5ID0gKGlzTmFOKHF0eVZhbCkpID8gMSA6ICgrcXR5VmFsKTtcblxuICAgICAgICBpZiAocXR5ID4gbWF4SXRlbXMpIHtcbiAgICAgICAgICAgICRib251c1Byb2R1Y3RMaXN0LmZpbmQoJy5zZWxlY3QtYm9udXMtaXRlbScpLmF0dHIoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICBmb3JtLmZpbmQoJy5xdWFudGl0eS1lcnJvcicpLnRleHQoUmVzb3VyY2VzLkJPTlVTX1BST0RVQ1RfVE9PTUFOWSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvZHVjdCA9IHtcbiAgICAgICAgICAgIHV1aWQ6IHV1aWQsXG4gICAgICAgICAgICBwaWQ6IGZvcm0uZmluZCgnaW5wdXRbbmFtZT1cInBpZFwiXScpLnZhbCgpLFxuICAgICAgICAgICAgcXR5OiBxdHksXG4gICAgICAgICAgICBuYW1lOiBkZXRhaWwuZmluZCgnLnByb2R1Y3QtbmFtZScpLnRleHQoKSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGRldGFpbC5maW5kKCcucHJvZHVjdC12YXJpYXRpb25zJykuZGF0YSgnYXR0cmlidXRlcycpLFxuICAgICAgICAgICAgb3B0aW9uczogW11cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgb3B0aW9uU2VsZWN0cyA9IGZvcm0uZmluZCgnLnByb2R1Y3Qtb3B0aW9uJyk7XG5cbiAgICAgICAgb3B0aW9uU2VsZWN0cy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb2R1Y3Qub3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICQodGhpcykudmFsKCksXG4gICAgICAgICAgICAgICAgZGlzcGxheTogJCh0aGlzKS5jaGlsZHJlbignOnNlbGVjdGVkJykuZmlyc3QoKS5odG1sKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgc2VsZWN0ZWRMaXN0LnB1c2gocHJvZHVjdCk7XG4gICAgICAgIHVwZGF0ZVN1bW1hcnkoKTtcbiAgICB9KVxuICAgIC5vbignY2xpY2snLCAnLnJlbW92ZS1saW5rJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gJCh0aGlzKS5jbG9zZXN0KCcuc2VsZWN0ZWQtYm9udXMtaXRlbScpO1xuICAgICAgICBpZiAoIWNvbnRhaW5lci5kYXRhKCd1dWlkJykpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgdmFyIHV1aWQgPSBjb250YWluZXIuZGF0YSgndXVpZCcpO1xuICAgICAgICB2YXIgaSwgbGVuID0gc2VsZWN0ZWRMaXN0Lmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRMaXN0W2ldLnV1aWQgPT09IHV1aWQpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZExpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZVN1bW1hcnkoKTtcbiAgICB9KVxuICAgIC5vbignY2xpY2snLCAnLmFkZC10by1jYXJ0LWJvbnVzJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgdXJsID0gdXRpbC5hcHBlbmRQYXJhbXNUb1VybChVcmxzLmFkZEJvbnVzUHJvZHVjdCwge2JvbnVzRGlzY291bnRMaW5lSXRlbVVVSUQ6IGJsaVVVSUR9KTtcbiAgICAgICAgdmFyIGJvbnVzUHJvZHVjdHMgPSBnZXRCb251c1Byb2R1Y3RzKCk7XG4gICAgICAgIGlmIChib251c1Byb2R1Y3RzLmJvbnVzcHJvZHVjdHNbMF0ucHJvZHVjdC5xdHkgPiBtYXhJdGVtcykge1xuICAgICAgICAgICAgYm9udXNQcm9kdWN0cy5ib251c3Byb2R1Y3RzWzBdLnByb2R1Y3QucXR5ID0gbWF4SXRlbXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFrZSB0aGUgc2VydmVyIGNhbGxcbiAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgICAgICBjYWNoZTogZmFsc2UsXG4gICAgICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeShib251c1Byb2R1Y3RzKVxuICAgICAgICB9KVxuICAgICAgICAuZG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBzdWNjZXNzXG4gICAgICAgICAgICBwYWdlLnJlZnJlc2goKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmZhaWwoZnVuY3Rpb24gKHhociwgdGV4dFN0YXR1cykge1xuICAgICAgICAgICAgLy8gZmFpbGVkXG4gICAgICAgICAgICBpZiAodGV4dFN0YXR1cyA9PT0gJ3BhcnNlcmVycm9yJykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hbGVydChSZXNvdXJjZXMuQkFEX1JFU1BPTlNFKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmFsZXJ0KFJlc291cmNlcy5TRVJWRVJfQ09OTkVDVElPTl9FUlJPUik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5hbHdheXMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJGJvbnVzUHJvZHVjdC5kaWFsb2coJ2Nsb3NlJyk7XG4gICAgICAgIH0pO1xuICAgIH0pXG4gICAgLm9uKCdjbGljaycsICcjbW9yZS1ib251cy1wcm9kdWN0cycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIHV1aWQgPSAkKCcjYm9udXMtcHJvZHVjdC1saXN0JykuZGF0YSgpLmxpbmVJdGVtRGV0YWlsLnV1aWQ7XG5cbiAgICAgICAgLy9nZXQgdGhlIG5leHQgcGFnZSBvZiBjaG9pY2Ugb2YgYm9udXMgcHJvZHVjdHNcbiAgICAgICAgdmFyIGxpbmVJdGVtRGV0YWlsID0gSlNPTi5wYXJzZSgkKCcjYm9udXMtcHJvZHVjdC1saXN0JykuYXR0cignZGF0YS1saW5lLWl0ZW0tZGV0YWlsJykpO1xuICAgICAgICBsaW5lSXRlbURldGFpbC5wYWdlU3RhcnQgPSBsaW5lSXRlbURldGFpbC5wYWdlU3RhcnQgKyBsaW5lSXRlbURldGFpbC5wYWdlU2l6ZTtcbiAgICAgICAgJCgnI2JvbnVzLXByb2R1Y3QtbGlzdCcpLmF0dHIoJ2RhdGEtbGluZS1pdGVtLWRldGFpbCcsIEpTT04uc3RyaW5naWZ5KGxpbmVJdGVtRGV0YWlsKSk7XG5cbiAgICAgICAgdmFyIHVybCA9IHV0aWwuYXBwZW5kUGFyYW1zVG9VcmwoVXJscy5nZXRCb251c1Byb2R1Y3RzLCB7XG4gICAgICAgICAgICBib251c0Rpc2NvdW50TGluZUl0ZW1VVUlEOiB1dWlkLFxuICAgICAgICAgICAgZm9ybWF0OiAnYWpheCcsXG4gICAgICAgICAgICBsYXp5TG9hZDogJ3RydWUnLFxuICAgICAgICAgICAgcGFnZVN0YXJ0OiBsaW5lSXRlbURldGFpbC5wYWdlU3RhcnQsXG4gICAgICAgICAgICBwYWdlU2l6ZTogJCgnI2JvbnVzLXByb2R1Y3QtbGlzdCcpLmRhdGEoKS5saW5lSXRlbURldGFpbC5wYWdlU2l6ZSxcbiAgICAgICAgICAgIGJvbnVzUHJvZHVjdHNUb3RhbDogJCgnI2JvbnVzLXByb2R1Y3QtbGlzdCcpLmRhdGEoKS5saW5lSXRlbURldGFpbC5icFRvdGFsXG4gICAgICAgIH0pO1xuXG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICB0eXBlOiAnR0VUJyxcbiAgICAgICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICB9KVxuICAgICAgICAuZG9uZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgLy9hZGQgdGhlIG5ldyBwYWdlIHRvIERPTSBhbmQgcmVtb3ZlICdNb3JlJyBsaW5rIGlmIGl0IGlzIHRoZSBsYXN0IHBhZ2Ugb2YgcmVzdWx0c1xuICAgICAgICAgICAgJCgnI21vcmUtYm9udXMtcHJvZHVjdHMnKS5iZWZvcmUoZGF0YSk7XG4gICAgICAgICAgICBpZiAoKGxpbmVJdGVtRGV0YWlsLnBhZ2VTdGFydCArIGxpbmVJdGVtRGV0YWlsLnBhZ2VTaXplKSA+PSAkKCcjYm9udXMtcHJvZHVjdC1saXN0JykuZGF0YSgpLmxpbmVJdGVtRGV0YWlsLmJwVG90YWwpIHtcbiAgICAgICAgICAgICAgICAkKCcjbW9yZS1ib251cy1wcm9kdWN0cycpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuZmFpbChmdW5jdGlvbiAoeGhyLCB0ZXh0U3RhdHVzKSB7XG4gICAgICAgICAgICBpZiAodGV4dFN0YXR1cyA9PT0gJ3BhcnNlcmVycm9yJykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hbGVydChSZXNvdXJjZXMuQkFEX1JFU1BPTlNFKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmFsZXJ0KFJlc291cmNlcy5TRVJWRVJfQ09OTkVDVElPTl9FUlJPUik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG52YXIgYm9udXNQcm9kdWN0c1ZpZXcgPSB7XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIE9wZW4gdGhlIGxpc3Qgb2YgYm9udXMgcHJvZHVjdHMgc2VsZWN0aW9uIGRpYWxvZ1xuICAgICAqL1xuICAgIHNob3c6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgdmFyICRib251c1Byb2R1Y3QgPSAkKCcjYm9udXMtcHJvZHVjdC1kaWFsb2cnKTtcbiAgICAgICAgLy8gY3JlYXRlIHRoZSBkaWFsb2dcbiAgICAgICAgZGlhbG9nLm9wZW4oe1xuICAgICAgICAgICAgdGFyZ2V0OiAkYm9udXNQcm9kdWN0LFxuICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDc5NSxcbiAgICAgICAgICAgICAgICB0aXRsZTogUmVzb3VyY2VzLkJPTlVTX1BST0RVQ1RTXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplR3JpZCgpO1xuICAgICAgICAgICAgICAgIGhpZGVTd2F0Y2hlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBPcGVuIGJvbnVzIHByb2R1Y3QgcHJvbW8gcHJvbXB0IGRpYWxvZ1xuICAgICAqL1xuICAgIGxvYWRCb251c09wdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBib251c0Rpc2NvdW50Q29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmJvbnVzLWRpc2NvdW50LWNvbnRhaW5lcicpO1xuICAgICAgICBpZiAoIWJvbnVzRGlzY291bnRDb250YWluZXIpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBodG1sIGZyb20gbWluaWNhcnQsIHRoZW4gdHJhc2ggaXRcbiAgICAgICAgdmFyIGJvbnVzRGlzY291bnRDb250YWluZXJIdG1sID0gYm9udXNEaXNjb3VudENvbnRhaW5lci5vdXRlckhUTUw7XG4gICAgICAgIGJvbnVzRGlzY291bnRDb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChib251c0Rpc2NvdW50Q29udGFpbmVyKTtcblxuICAgICAgICBkaWFsb2cub3Blbih7XG4gICAgICAgICAgICBodG1sOiBib251c0Rpc2NvdW50Q29udGFpbmVySHRtbCxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogNDAwLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBSZXNvdXJjZXMuQk9OVVNfUFJPRFVDVCxcbiAgICAgICAgICAgICAgICBidXR0b25zOiBbe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBSZXNvdXJjZXMuU0VMRUNUX0JPTlVTX1BST0RVQ1RTLFxuICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHV1aWQgPSAkKCcuYm9udXMtcHJvZHVjdC1wcm9tbycpLmRhdGEoJ2xpbmVpdGVtaWQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSB1dGlsLmFwcGVuZFBhcmFtc1RvVXJsKFVybHMuZ2V0Qm9udXNQcm9kdWN0cywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib251c0Rpc2NvdW50TGluZUl0ZW1VVUlEOiB1dWlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICdib251cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ2FqYXgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXp5TG9hZDogJ2ZhbHNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVN0YXJ0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlU2l6ZTogMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbnVzUHJvZHVjdHNUb3RhbDogLTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykuZGlhbG9nKCdjbG9zZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zaG93KHVybCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IFJlc291cmNlcy5OT19USEFOS1MsXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmRpYWxvZygnY2xvc2UnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBzaG93IGhpZGUgcHJvbW8gZGV0YWlsc1xuICAgICAgICAgICAgICAgICQoJy5zaG93LXByb21vLWRldGFpbHMnKS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICQoJy5wcm9tby1kZXRhaWxzJykudG9nZ2xlQ2xhc3MoJ3Zpc2libGUnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBib251c1Byb2R1Y3RzVmlldztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRpYWxvZyA9IHJlcXVpcmUoJy4vZGlhbG9nJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIFNlc3Npb25BdHRyaWJ1dGVzID0gd2luZG93LlNlc3Npb25BdHRyaWJ1dGVzO1xuXG4vKipcbiAqIEBmdW5jdGlvbiBjYXB0Y2hhICAgIFVzZWQgdG8gZGlzcGxheS9jb250cm9sIHRoZSBzY3JpbSBjb250YWluaW5nIHRoZSBzaW11bGF0ZWQgY2FwdGNoYSBjb2RlXG4gKiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBpZiB0aGUgc2Vzc2lvbi5wcml2YWN5LnJhdGVsaW1pdGVkIGVsZW1lbnQgaXMgcHJlc2VudCB0aGVuIHNob3cgdGhlIG5vdGlmaWNhdGlvblxuICAgICAqIE5PVEU6IFlvdSB3aWxsIHByb2JhYmx5IHdhbnQgdG8gcmVwbGFjZSB0aGlzIHdpdGggYSBjYWxsIHRvIGFuIGFjdHVhbCBDQVBUQ0hBIHN5c3RlbSB0byByZXBsYWNlIHRoZSBzaW1wbGUgb25lIGhlcmVcbiAgICAgKi9cbiAgICBpZiAoU2Vzc2lvbkF0dHJpYnV0ZXMuU0hPV19DQVBUQ0hBKSB7XG4gICAgICAgIGRpYWxvZy5vcGVuKHtcbiAgICAgICAgICAgIGh0bWw6ICc8aDE+JyArIFJlc291cmNlcy5BUkVfWU9VX0hVTUFOICsgJzwvaDE+JyxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBjbG9zZU9uRXNjYXBlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkaWFsb2dDbGFzczogJ25vLWNsb3NlJyxcbiAgICAgICAgICAgICAgICBidXR0b25zOiBbe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBSZXNvdXJjZXMuT0ssXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gdXRpbC5hcHBlbmRQYXJhbXNUb1VybChVcmxzLnJhdGVMaW1pdGVyUmVzZXQsIHtmb3JtYXQ6ICdhamF4J30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmRpYWxvZygnY2xvc2UnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBwYWdlID0gcmVxdWlyZSgnLi9wYWdlJyksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxuICAgIFRQcm9taXNlID0gcmVxdWlyZSgncHJvbWlzZScpO1xuXG52YXIgX2N1cnJlbnRDYXRlZ29yeSA9ICcnLFxuICAgIE1BWF9BQ1RJVkUgPSA2O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvbiBWZXJpZmllcyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBjb21wYXJlIGNvbnRhaW5lciBhbmQgdXBkYXRlcyBpdCB3aXRoIHNlcXVlbnRpYWwgY2xhc3NlcyBmb3IgdWkgdGFyZ2V0aW5nXG4gKi9cbmZ1bmN0aW9uIHJlZnJlc2hDb250YWluZXIoKSB7XG4gICAgdmFyICRjb21wYXJlQ29udGFpbmVyID0gJCgnLmNvbXBhcmUtaXRlbXMnKTtcbiAgICB2YXIgJGNvbXBhcmVJdGVtcyA9ICRjb21wYXJlQ29udGFpbmVyLmZpbmQoJy5jb21wYXJlLWl0ZW0nKTtcbiAgICB2YXIgbnVtQWN0aXZlID0gJGNvbXBhcmVJdGVtcy5maWx0ZXIoJy5hY3RpdmUnKS5sZW5ndGg7XG5cbiAgICBpZiAobnVtQWN0aXZlIDwgMikge1xuICAgICAgICAkKCcjY29tcGFyZS1pdGVtcy1idXR0b24nKS5hdHRyKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgICQoJyNjb21wYXJlLWl0ZW1zLWJ1dHRvbicpLnJlbW92ZUF0dHIoJ2Rpc2FibGVkJyk7XG4gICAgfVxuXG4gICAgJGNvbXBhcmVDb250YWluZXIudG9nZ2xlKG51bUFjdGl2ZSA+IDApO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKiBAZGVzY3JpcHRpb24gQWRkcyBhbiBpdGVtIHRvIHRoZSBjb21wYXJlIGNvbnRhaW5lciBhbmQgcmVmcmVzaGVzIGl0XG4gKi9cbmZ1bmN0aW9uIGFkZFRvTGlzdChkYXRhKSB7XG4gICAgLy8gZ2V0IHRoZSBmaXJzdCBjb21wYXJlLWl0ZW0gbm90IGN1cnJlbnRseSBhY3RpdmVcbiAgICB2YXIgJGl0ZW0gPSAkKCcuY29tcGFyZS1pdGVtcyAuY29tcGFyZS1pdGVtJykubm90KCcuYWN0aXZlJykuZmlyc3QoKSxcbiAgICAgICAgJHByb2R1Y3RUaWxlID0gJCgnIycgKyBkYXRhLnV1aWQpO1xuXG4gICAgaWYgKCRpdGVtLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAoJHByb2R1Y3RUaWxlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICRwcm9kdWN0VGlsZS5maW5kKCcuY29tcGFyZS1jaGVjaycpWzBdLmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cuYWxlcnQoUmVzb3VyY2VzLkNPTVBBUkVfQUREX0ZBSUwpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgYWxyZWFkeSBhZGRlZCBzb21laG93LCByZXR1cm5cbiAgICBpZiAoJCgnW2RhdGEtdXVpZD1cIicgKyBkYXRhLnV1aWQgKyAnXCJdJykubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHNldCBhcyBhY3RpdmUgaXRlbVxuICAgICRpdGVtLmFkZENsYXNzKCdhY3RpdmUnKVxuICAgICAgICAuYXR0cignZGF0YS11dWlkJywgZGF0YS51dWlkKVxuICAgICAgICAuYXR0cignZGF0YS1pdGVtaWQnLCBkYXRhLml0ZW1pZClcbiAgICAgICAgLmRhdGEoJ3V1aWQnLCBkYXRhLnV1aWQpXG4gICAgICAgIC5kYXRhKCdpdGVtaWQnLCBkYXRhLml0ZW1pZClcbiAgICAgICAgLmFwcGVuZCgkKGRhdGEuaW1nKS5jbG9uZSgpLmFkZENsYXNzKCdjb21wYXJlLWl0ZW0taW1hZ2UnKSk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqIGRlc2NyaXB0aW9uIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSBjb21wYXJlIGNvbnRhaW5lciBhbmQgcmVmcmVzaGVzIGl0XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUZyb21MaXN0KCRpdGVtKSB7XG4gICAgaWYgKCRpdGVtLmxlbmd0aCA9PT0gMCkgeyByZXR1cm47IH1cbiAgICAvLyByZW1vdmUgY2xhc3MsIGRhdGEgYW5kIGlkIGZyb20gaXRlbVxuICAgICRpdGVtLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICAgICAgICAucmVtb3ZlQXR0cignZGF0YS11dWlkJylcbiAgICAgICAgLnJlbW92ZUF0dHIoJ2RhdGEtaXRlbWlkJylcbiAgICAgICAgLmRhdGEoJ3V1aWQnLCAnJylcbiAgICAgICAgLmRhdGEoJ2l0ZW1pZCcsICcnKVxuICAgICAgICAvLyByZW1vdmUgdGhlIGltYWdlXG4gICAgICAgIC5maW5kKCcuY29tcGFyZS1pdGVtLWltYWdlJykucmVtb3ZlKCk7XG59XG5cbmZ1bmN0aW9uIGFkZFByb2R1Y3RBamF4KGFyZ3MpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBUUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICB1cmw6IFVybHMuY29tcGFyZUFkZCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBwaWQ6IGFyZ3MuaXRlbWlkLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5OiBfY3VycmVudENhdGVnb3J5XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJ1xuICAgICAgICB9KS5kb25lKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZSB8fCAhcmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoUmVzb3VyY2VzLkNPTVBBUkVfQUREX0ZBSUwpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmZhaWwoZnVuY3Rpb24gKGpxeGhyLCBzdGF0dXMsIGVycikge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnIpKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVByb2R1Y3RBamF4KGFyZ3MpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBUUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICB1cmw6IFVybHMuY29tcGFyZVJlbW92ZSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBwaWQ6IGFyZ3MuaXRlbWlkLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5OiBfY3VycmVudENhdGVnb3J5XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJ1xuICAgICAgICB9KS5kb25lKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZSB8fCAhcmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoUmVzb3VyY2VzLkNPTVBBUkVfUkVNT1ZFX0ZBSUwpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmZhaWwoZnVuY3Rpb24gKGpxeGhyLCBzdGF0dXMsIGVycikge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnIpKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIHNoaWZ0SW1hZ2VzKCkge1xuICAgIHJldHVybiBuZXcgVFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgdmFyICRpdGVtcyA9ICQoJy5jb21wYXJlLWl0ZW1zIC5jb21wYXJlLWl0ZW0nKTtcbiAgICAgICAgJGl0ZW1zLmVhY2goZnVuY3Rpb24gKGksIGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciAkaXRlbSA9ICQoaXRlbSk7XG4gICAgICAgICAgICAvLyBsYXN0IGl0ZW1cbiAgICAgICAgICAgIGlmIChpID09PSAkaXRlbXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVGcm9tTGlzdCgkaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgJG5leHQgPSAkaXRlbXMuZXEoaSArIDEpO1xuICAgICAgICAgICAgaWYgKCRuZXh0Lmhhc0NsYXNzKCdhY3RpdmUnKSkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBpdHMgb3duIGltYWdlXG4gICAgICAgICAgICAgICAgJG5leHQuZmluZCgnLmNvbXBhcmUtaXRlbS1pbWFnZScpLmRldGFjaCgpLmFwcGVuZFRvKCRpdGVtKTtcbiAgICAgICAgICAgICAgICAkaXRlbS5hZGRDbGFzcygnYWN0aXZlJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2RhdGEtdXVpZCcsICRuZXh0LmRhdGEoJ3V1aWQnKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2RhdGEtaXRlbWlkJywgJG5leHQuZGF0YSgnaXRlbWlkJykpXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKCd1dWlkJywgJG5leHQuZGF0YSgndXVpZCcpKVxuICAgICAgICAgICAgICAgICAgICAuZGF0YSgnaXRlbWlkJywgJG5leHQuZGF0YSgnaXRlbWlkJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uIEFkZHMgcHJvZHVjdCB0byB0aGUgY29tcGFyZSB0YWJsZVxuICovXG5mdW5jdGlvbiBhZGRQcm9kdWN0KGFyZ3MpIHtcbiAgICB2YXIgcHJvbWlzZTtcbiAgICB2YXIgJGl0ZW1zID0gJCgnLmNvbXBhcmUtaXRlbXMgLmNvbXBhcmUtaXRlbScpO1xuICAgIHZhciAkY2IgPSAkKGFyZ3MuY2IpO1xuICAgIHZhciBudW1BY3RpdmUgPSAkaXRlbXMuZmlsdGVyKCcuYWN0aXZlJykubGVuZ3RoO1xuICAgIGlmIChudW1BY3RpdmUgPT09IE1BWF9BQ1RJVkUpIHtcbiAgICAgICAgaWYgKCF3aW5kb3cuY29uZmlybShSZXNvdXJjZXMuQ09NUEFSRV9DT05GSVJNQVRJT04pKSB7XG4gICAgICAgICAgICAkY2JbMF0uY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIHByb2R1Y3QgdXNpbmcgaWRcbiAgICAgICAgdmFyICRmaXJzdEl0ZW0gPSAkaXRlbXMuZmlyc3QoKTtcbiAgICAgICAgcHJvbWlzZSA9IHJlbW92ZUl0ZW0oJGZpcnN0SXRlbSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2hpZnRJbWFnZXMoKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZSA9IFRQcm9taXNlLnJlc29sdmUoMCk7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYWRkUHJvZHVjdEFqYXgoYXJncykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhZGRUb0xpc3QoYXJncyk7XG4gICAgICAgICAgICBpZiAoJGNiICYmICRjYi5sZW5ndGggPiAwKSB7ICRjYlswXS5jaGVja2VkID0gdHJ1ZTsgfVxuICAgICAgICAgICAgcmVmcmVzaENvbnRhaW5lcigpO1xuICAgICAgICB9KTtcbiAgICB9KS50aGVuKG51bGwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCRjYiAmJiAkY2IubGVuZ3RoID4gMCkgeyAkY2JbMF0uY2hlY2tlZCA9IGZhbHNlOyB9XG4gICAgfSk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyBwcm9kdWN0IGZyb20gdGhlIGNvbXBhcmUgdGFibGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzIC0gdGhlIGFyZ3VtZW50cyBvYmplY3Qgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOiBpdGVtaWQsIHV1aWQgYW5kIGNiIChjaGVja2JveClcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlUHJvZHVjdChhcmdzKSB7XG4gICAgdmFyICRjYiA9IGFyZ3MuY2IgPyAkKGFyZ3MuY2IpIDogbnVsbDtcbiAgICByZXR1cm4gcmVtb3ZlUHJvZHVjdEFqYXgoYXJncykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkaXRlbSA9ICQoJ1tkYXRhLXV1aWQ9XCInICsgYXJncy51dWlkICsgJ1wiXScpO1xuICAgICAgICByZW1vdmVGcm9tTGlzdCgkaXRlbSk7XG4gICAgICAgIGlmICgkY2IgJiYgJGNiLmxlbmd0aCA+IDApIHsgJGNiWzBdLmNoZWNrZWQgPSBmYWxzZTsgfVxuICAgICAgICByZWZyZXNoQ29udGFpbmVyKCk7XG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoJGNiICYmICRjYi5sZW5ndGggPiAwKSB7ICRjYlswXS5jaGVja2VkID0gdHJ1ZTsgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVJdGVtKCRpdGVtKSB7XG4gICAgdmFyIHV1aWQgPSAkaXRlbS5kYXRhKCd1dWlkJyksXG4gICAgICAgICRwcm9kdWN0VGlsZSA9ICQoJyMnICsgdXVpZCk7XG4gICAgcmV0dXJuIHJlbW92ZVByb2R1Y3Qoe1xuICAgICAgICBpdGVtaWQ6ICRpdGVtLmRhdGEoJ2l0ZW1pZCcpLFxuICAgICAgICB1dWlkOiB1dWlkLFxuICAgICAgICBjYjogKCRwcm9kdWN0VGlsZS5sZW5ndGggPT09IDApID8gbnVsbCA6ICRwcm9kdWN0VGlsZS5maW5kKCcuY29tcGFyZS1jaGVjaycpXG4gICAgfSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uIEluaXRpYWxpemVzIHRoZSBET00tT2JqZWN0IG9mIHRoZSBjb21wYXJlIGNvbnRhaW5lclxuICovXG5mdW5jdGlvbiBpbml0aWFsaXplRG9tKCkge1xuICAgIHZhciAkY29tcGFyZUNvbnRhaW5lciA9ICQoJy5jb21wYXJlLWl0ZW1zJyk7XG4gICAgX2N1cnJlbnRDYXRlZ29yeSA9ICRjb21wYXJlQ29udGFpbmVyLmRhdGEoJ2NhdGVnb3J5JykgfHwgJyc7XG4gICAgdmFyICRhY3RpdmUgPSAkY29tcGFyZUNvbnRhaW5lci5maW5kKCcuY29tcGFyZS1pdGVtJykuZmlsdGVyKCcuYWN0aXZlJyk7XG4gICAgJGFjdGl2ZS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICRwcm9kdWN0VGlsZSA9ICQoJyMnICsgICQodGhpcykuZGF0YSgndXVpZCcpKTtcbiAgICAgICAgaWYgKCRwcm9kdWN0VGlsZS5sZW5ndGggPT09IDApIHtyZXR1cm47fVxuICAgICAgICAkcHJvZHVjdFRpbGUuZmluZCgnLmNvbXBhcmUtY2hlY2snKVswXS5jaGVja2VkID0gdHJ1ZTtcbiAgICB9KTtcbiAgICAvLyBzZXQgY29udGFpbmVyIHN0YXRlXG4gICAgcmVmcmVzaENvbnRhaW5lcigpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvbiBJbml0aWFsaXplcyB0aGUgZXZlbnRzIG9uIHRoZSBjb21wYXJlIGNvbnRhaW5lclxuICovXG5mdW5jdGlvbiBpbml0aWFsaXplRXZlbnRzKCkge1xuICAgIC8vIGFkZCBldmVudCB0byBidXR0b25zIHRvIHJlbW92ZSBwcm9kdWN0c1xuICAgICQoJy5jb21wYXJlLWl0ZW0nKS5vbignY2xpY2snLCAnLmNvbXBhcmUtaXRlbS1yZW1vdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZUl0ZW0oJCh0aGlzKS5jbG9zZXN0KCcuY29tcGFyZS1pdGVtJykpO1xuICAgIH0pO1xuXG4gICAgLy8gQnV0dG9uIHRvIGdvIHRvIGNvbXBhcmUgcGFnZVxuICAgICQoJyNjb21wYXJlLWl0ZW1zLWJ1dHRvbicpLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGFnZS5yZWRpcmVjdCh1dGlsLmFwcGVuZFBhcmFtVG9VUkwoVXJscy5jb21wYXJlU2hvdywgJ2NhdGVnb3J5JywgX2N1cnJlbnRDYXRlZ29yeSkpO1xuICAgIH0pO1xuXG4gICAgLy8gQnV0dG9uIHRvIGNsZWFyIGFsbCBjb21wYXJlZCBpdGVtc1xuICAgIC8vIHJlbHkgb24gcmVmcmVzaENvbnRhaW5lciB0byB0YWtlIGNhcmUgb2YgaGlkaW5nIHRoZSBjb250YWluZXJcbiAgICAkKCcjY2xlYXItY29tcGFyZWQtaXRlbXMnKS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICQoJy5jb21wYXJlLWl0ZW1zIC5hY3RpdmUnKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlbW92ZUl0ZW0oJCh0aGlzKSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaW5pdGlhbGl6ZURvbSgpO1xuICAgIGluaXRpYWxpemVFdmVudHMoKTtcbn07XG5cbmV4cG9ydHMuYWRkUHJvZHVjdCA9IGFkZFByb2R1Y3Q7XG5leHBvcnRzLnJlbW92ZVByb2R1Y3QgPSByZW1vdmVQcm9kdWN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGlhbG9nID0gcmVxdWlyZSgnLi9kaWFsb2cnKTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gY29va2llcHJpdmFjeSAgICBVc2VkIHRvIGRpc3BsYXkvY29udHJvbCB0aGUgc2NyaW0gY29udGFpbmluZyB0aGUgY29va2llIHByaXZhY3kgY29kZVxuICoqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogSWYgd2UgaGF2ZSBub3QgYWNjZXB0ZWQgY29va2llcyBBTkQgd2UncmUgbm90IG9uIHRoZSBQcml2YWN5IFBvbGljeSBwYWdlLCB0aGVuIHNob3cgdGhlIG5vdGlmaWNhdGlvblxuICAgICAqIE5PVEU6IFlvdSB3aWxsIHByb2JhYmx5IHdhbnQgdG8gYWRqdXN0IHRoZSBQcml2YWN5IFBhZ2UgdGVzdCB0byBtYXRjaCB5b3VyIHNpdGUncyBzcGVjaWZpYyBwcml2YWN5IC8gY29va2llIHBhZ2VcbiAgICAgKi9cbiAgICBpZiAoU2l0ZVByZWZlcmVuY2VzLkNPT0tJRV9ISU5UID09PSB0cnVlICYmIGRvY3VtZW50LmNvb2tpZS5pbmRleE9mKCdkd19jb29raWVzX2FjY2VwdGVkJykgPCAwKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBwcml2YWN5IHBvbGljeSBwYWdlXG4gICAgICAgIGlmICgkKCcucHJpdmFjeS1wb2xpY3knKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRpYWxvZy5vcGVuKHtcbiAgICAgICAgICAgICAgICB1cmw6IFVybHMuY29va2llSGludCxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlT25Fc2NhcGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkaWFsb2dDbGFzczogJ25vLWNsb3NlJyxcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IFJlc291cmNlcy5JX0FHUkVFLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmRpYWxvZygnY2xvc2UnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVDb29raWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UsIHdlIGRvbid0IG5lZWQgdG8gc2hvdyB0aGUgYXNzZXQsIGp1c3QgZW5hYmxlIHRoZSBjb29raWVzXG4gICAgICAgIGVuYWJsZUNvb2tpZXMoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmFibGVDb29raWVzKCkge1xuICAgICAgICBpZiAoZG9jdW1lbnQuY29va2llLmluZGV4T2YoJ2R3PTEnKSA8IDApIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9ICdkdz0xOyBwYXRoPS8nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb2N1bWVudC5jb29raWUuaW5kZXhPZignZHdfY29va2llc19hY2NlcHRlZCcpIDwgMCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gJ2R3X2Nvb2tpZXNfYWNjZXB0ZWQ9MTsgcGF0aD0vJztcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uIGluaXQgKCkge1xuICAgICQoJy5jb3VudHJ5LXNlbGVjdG9yIC5jdXJyZW50LWNvdW50cnknKS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICQoJy5jb3VudHJ5LXNlbGVjdG9yIC5zZWxlY3RvcicpLnRvZ2dsZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgJCh0aGlzKS50b2dnbGVDbGFzcygnc2VsZWN0b3ItYWN0aXZlJyk7XG4gICAgfSk7XG4gICAgLy8gc2V0IGN1cnJlbmN5IGZpcnN0IGJlZm9yZSByZWxvYWRcbiAgICAkKCcuY291bnRyeS1zZWxlY3RvciAuc2VsZWN0b3IgLmxvY2FsZScpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIHVybCA9IHRoaXMuaHJlZjtcbiAgICAgICAgdmFyIGN1cnJlbmN5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RhdGEtY3VycmVuY3knKTtcbiAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgICAgICB1cmw6IFVybHMuc2V0U2Vzc2lvbkN1cnJlbmN5LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ2FqYXgnLFxuICAgICAgICAgICAgICAgIGN1cnJlbmN5TW5lbW9uaWM6IGN1cnJlbmN5XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5kb25lKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gc2V0IGN1cnJlbmN5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXHRcbmFwcC5kYXRhbGF5ZXIgPSB7XG5cdGdldEV2ZW50IDogZnVuY3Rpb24oZXZlbnRLZXksIGV2ZW50LCB0eXBlS2V5LCB0eXBlLCBhY3Rpb24sIHByb2R1Y3RzLCBsaXN0KSB7XG5cdFx0cmV0dXJuIF9nZXRFdmVudChldmVudEtleSwgZXZlbnQsIHR5cGVLZXksIHR5cGUsIGFjdGlvbiwgcHJvZHVjdHMsIGxpc3QpO1xuXHR9LFxuXHRnZXRPYmplY3RFeGFtcGxlcyA6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gX2dldE9iamVjdEV4YW1wbGVzKCk7XG5cdH0sXG5cdG9iamVjdHMgOiBfZ2V0T2JqZWN0RXhhbXBsZXMgKCksXG5cdHNlbmRBZGRUb0NhcnRFdmVudCA6IGZ1bmN0aW9uKCl7XG5cdFx0dmFyIGlzUXVpY2tWaWV3ID0gJCgnI1F1aWNrVmlld0RpYWxvZycpLmxlbmd0aCA+IDAgPyB0cnVlIDogZmFsc2U7XG5cdFx0aWYgKHR5cGVvZiBkYXRhTGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2FjdGlvblByb2R1Y3RzID0gW107XG4gICAgICAgICAgICB2YXIgZGxQaWQsIGRsU2t1LCBkbFByb2R1Y3ROYW1lLCBkbENhdGVnb3J5SUQsIGRsUHJpY2UsIGRsVmFyaWFudCwgZGxRdWFudGl0eSwgZGxTaXplLCBkbFNlYXNvbmFsQ29sbGVjdGlvbiwgZGxDb2xvcndheSwgZGxJdGVtQXRGdWxsUHJpY2UsIGRsQXZhaWxhYmlsaXR5LCBkbERpc2NvdW50LCBkbE1vbm9ncmFtbWluZywgZGxCVkF2ZXJhZ2U7XG4gICAgICAgICAgICB2YXIgZWNvbURldGFpbCA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFMYXllci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhTGF5ZXJbaV0uZXZlbnQgPT0gJ2Vjb21EZXRhaWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVjb21EZXRhaWwgPSBkYXRhTGF5ZXJbaV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiBcbiAgICAgICAgICAgIH1cblx0XHRcdHZhciBwcm9kdWN0dGlsZXMgPSAkKCcucHJvZHVjdC10aWxlJyk7XG5cdFx0XHR2YXIgYXZhaWxhYmlsaXR5TXNnQ29udGFpbmVyID0gJChcIi5hdmFpbGFiaWxpdHktbXNnXCIpO1xuICAgICAgICAgICAgZm9yKGk9MDtpPHByb2R1Y3R0aWxlcy5sZW5ndGg7aSsrKXtcbiAgICAgICAgICAgIFx0Y29uc29sZS5sb2cocHJvZHVjdHRpbGVzLmVxKGkpLmF0dHIoJ2RhdGEtY2dpZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlY29tRGV0YWlsICYmICdlY29tbWVyY2UnIGluIGVjb21EZXRhaWxcbiAgICAgICAgICAgICAgICAgICAgJiYgJ2RldGFpbCcgaW4gZWNvbURldGFpbC5lY29tbWVyY2VcbiAgICAgICAgICAgICAgICAgICAgJiYgJ3Byb2R1Y3RzJyBpbiBlY29tRGV0YWlsLmVjb21tZXJjZS5kZXRhaWxcbiAgICAgICAgICAgICAgICAgICAgJiYgZWNvbURldGFpbC5lY29tbWVyY2UuZGV0YWlsLnByb2R1Y3RzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAmJiAnY2F0ZWdvcnknIGluIGVjb21EZXRhaWwuZWNvbW1lcmNlLmRldGFpbC5wcm9kdWN0c1swXSkge1xuICAgICAgICAgICAgICAgIGRsQ2F0ZWdvcnlJRCA9IGVjb21EZXRhaWwuZWNvbW1lcmNlLmRldGFpbC5wcm9kdWN0c1swXS5jYXRlZ29yeTtcbiAgICAgICAgICAgICAgICBkbFBpZCA9IGVjb21EZXRhaWwuZWNvbW1lcmNlLmRldGFpbC5wcm9kdWN0c1swXS5pZDtcbiAgICAgICAgICAgICAgICBkbFByb2R1Y3ROYW1lID0gZWNvbURldGFpbC5lY29tbWVyY2UuZGV0YWlsLnByb2R1Y3RzWzBdLm5hbWVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNtUHJvZHVjdE5hbWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBkbFByb2R1Y3ROYW1lID0gY21Qcm9kdWN0TmFtZTtcbiAgICAgICAgICAgICAgICBkbENhdGVnb3J5SUQgPSBjbUNhdGVnb3J5SUQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXHR2YXIgZm9ybSA9ICQodGhpcykuY2xvc2VzdCgnZm9ybScpO1xuICAgICAgICAgICAgXHRpZihmb3JtLmxlbmd0aCA9PSAwICYmIGlzUXVpY2tWaWV3KXtcbiAgICAgICAgICAgIFx0XHRmb3JtID0gJCgnI1F1aWNrVmlld0RpYWxvZycpO1xuICAgICAgICAgICAgXHR9XG4gICAgICAgICAgICAgICAgZGxQcm9kdWN0TmFtZSA9ICQudHJpbShmb3JtLmZpbmQoJy5wcm9kdWN0LW5hbWUnKS50ZXh0KCkpO1xuICAgICAgICAgICAgICAgIGRsQ2F0ZWdvcnlJRCA9ICQudHJpbSgkKCcucHJvZHVjdC10aWxlJykuZXEoMCkuYXR0cignZGF0YS1jZ2lkJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZvcm0gPSAkKCcucGRwRm9ybScpO1xuICAgICAgICAgICAgZGxRdWFudGl0eSA9IHBhcnNlSW50KCQoJy5xdWFudGl0eS1kcm9wZG93biAuc2VsZWN0Ym94aXQnKS5maW5kKCc6c2VsZWN0ZWQnKS50ZXh0KCkpO1xuXHRcdCAgICBkbFF1YW50aXR5ID0gZGxRdWFudGl0eSA+IDAgPyBkbFF1YW50aXR5IDogMTtcbiAgICAgICAgICAgIGlmIChpc1F1aWNrVmlldykge1xuICAgICAgICAgICAgICAgIHZhciBxdmNvbnRhaW5lciA9ICQoJyNRdWlja1ZpZXdEaWFsb2cnKTtcbiAgICAgICAgICAgICAgICBkbFNrdSA9IHF2Y29udGFpbmVyLmZpbmQoXCIjcGlkXCIpLnZhbCgpO1xuICAgICAgICAgICAgICAgIGRsUGlkID0gZGxQaWQgfHwgcXZjb250YWluZXIuZmluZCgnZGl2W2RhdGEtbWFzdGVyXScpLmF0dHIoJ2RhdGEtbWFzdGVyJyk7XG4gICAgICAgICAgICAgICAgZGxQcm9kdWN0TmFtZSA9ICQudHJpbShxdmNvbnRhaW5lci5maW5kKFwiLnByb2R1Y3QtbmFtZVwiKS50ZXh0KCkpO1xuICAgICAgICAgICAgICAgIGRsQ2F0ZWdvcnlJRCA9ICQudHJpbSgkKCcucHJvZHVjdC10aWxlJykuZXEoMCkuYXR0cignZGF0YS1jZ2lkJykpO1xuICAgICAgICAgICAgICAgIGRsUHJpY2UgPSBxdmNvbnRhaW5lci5maW5kKCcjZ2NBbW91bnQnKS52YWwoKSB8fCAoJC50cmltKHF2Y29udGFpbmVyLmZpbmQoXCIucHJpY2Utc2FsZXNcIikuaHRtbCgpLnRyaW0oKSkucmVwbGFjZShcIiRcIixcIlwiKSk7XG4gICAgICAgICAgICAgICAgZGxWYXJpYW50ID0gJC50cmltKHF2Y29udGFpbmVyLmZpbmQoXCIucHJvZHVjdC12YXJpYXRpb25zIC5zd2F0Y2hlcyAuc2VsZWN0ZWQgLnRpdGxlXCIpLnRleHQoKSk7XG4gICAgICAgICAgICAgICAgZGxTaXplID0gJC50cmltKHF2Y29udGFpbmVyLmZpbmQoXCIucHJvZHVjdC12YXJpYXRpb25zIC5zd2F0Y2hlcy5zaXplIC5zZWxlY3RlZCBhXCIpLnRleHQoKSk7XG4gICAgICAgICAgICAgICAgLy8gZGxTZWFzb25hbENvbGxlY3Rpb24gPSAnJztcbiAgICAgICAgICAgICAgICBkbENvbG9yd2F5ID0gJC50cmltKHF2Y29udGFpbmVyLmZpbmQoXCIucHJvZHVjdC12YXJpYXRpb25zIC5zd2F0Y2hlcy5Db2xvciAuc2VsZWN0ZWQgYVwiKS5hdHRyKCd0aXRsZScpKTtcbiAgICAgICAgICAgICAgICBkbEl0ZW1BdEZ1bGxQcmljZSA9ICQudHJpbShxdmNvbnRhaW5lci5maW5kKFwiLnByb2R1Y3QtcHJpY2Ugc3BhblwiKS5odG1sKCkpLnJlcGxhY2UoXCIkXCIsXCJcIik7XG4gICAgICAgICAgICBcdGlmIChhdmFpbGFiaWxpdHlNc2dDb250YWluZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBcdFx0ZGxBdmFpbGFiaWxpdHkgPSBhdmFpbGFiaWxpdHlNc2dDb250YWluZXIuYXR0cignZGF0YS1hdmFpbGlibGUnKTtcbiAgICAgICAgICAgIFx0XHRpZiAodHlwZW9mIGRsQXZhaWxhYmlsaXR5ICE9ICd1bmRlZmluZWQnICYmIGRsQXZhaWxhYmlsaXR5Lmxlbmd0aCkge1xuICAgICAgICAgICAgXHRcdFx0ZGxBdmFpbGFiaWxpdHkgPSAkLnRyaW0oZGxBdmFpbGFiaWxpdHkucmVwbGFjZSgvX3wtfFxcLi9nLCAnICcpKTtcbiAgICAgICAgICAgIFx0XHR9XG4gICAgICAgICAgICBcdH1cbiAgICAgICAgICAgIFx0aWYgKHR5cGVvZiBkbEF2YWlsYWJpbGl0eSA9PSAndW5kZWZpbmVkJyB8fCAhZGxBdmFpbGFiaWxpdHkubGVuZ3RoKSB7XG4gICAgICAgICAgICBcdFx0ZGxBdmFpbGFiaWxpdHkgPSAnJztcbiAgICAgICAgICAgIFx0fVxuICAgICAgICAgICAgICAgIC8vIGRsRGlzY291bnQgPSAnJztcbiAgICAgICAgICAgICAgICBkbE1vbm9ncmFtbWluZyA9ICcnO1xuICAgICAgICAgICAgICAgIGRsQlZBdmVyYWdlID0gJC50cmltKHF2Y29udGFpbmVyLmZpbmQoXCIjQlZSUlJhdGluZ092ZXJhbGxfIC5CVlJSUmF0aW5nTm9ybWFsT3V0T2ZcIikudGV4dCgpKTsgICBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGxTa3UgPSAkKFwiI3BpZFwiKS52YWwoKTtcbiAgICAgICAgICAgICAgICBkbFBpZCA9IGRsUGlkIHx8ICQoJyNwcm9kdWN0LWNvbnRlbnQnKS5maW5kKCdkaXZbZGF0YS1tYXN0ZXJdJykuYXR0cignZGF0YS1tYXN0ZXInKTtcbiAgICAgICAgICAgICAgICAvLyBJbmNhc2UgZGxQcm9kdWN0TmFtZSB3YXMgbm90IHNldCBwcmV2aW91c2x5XG4gICAgICAgICAgICAgICAgaWYgKGRsUHJvZHVjdE5hbWUgPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBkbFByb2R1Y3ROYW1lID0gJC50cmltKCQoXCIjcHJvZHVjdC1jb250ZW50IC5wcm9kdWN0LW5hbWVcIikudGV4dCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSW5jYXNlIGRsQ2F0ZWdvcnlJRCB3YXMgbm90IHNldCBwcmV2aW91c2x5XG4gICAgICAgICAgICAgICAgaWYgKGRsQ2F0ZWdvcnlJRCA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRsQ2F0ZWdvcnlJRCA9ICQoJyNwZHBNYWluJykuYXR0cignZGF0YS1jYXRlZ29yeScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkbFByaWNlID0gJCgnI2djQW1vdW50JykudmFsKCkgfHwgKCQudHJpbSgkKFwiLnByaWNlLXNhbGVzXCIpLmh0bWwoKS50cmltKCkpLnJlcGxhY2UoXCIkXCIsXCJcIikpO1xuICAgICAgICAgICAgICAgIGRsVmFyaWFudCA9ICQudHJpbSgkKFwiLnByb2R1Y3QtdmFyaWF0aW9ucyAuc3dhdGNoZXMgLnNlbGVjdGVkIC50aXRsZVwiKS50ZXh0KCkpO1xuICAgICAgICAgICAgICAgIGRsU2l6ZSA9ICQudHJpbSgkKFwiLnByb2R1Y3QtdmFyaWF0aW9ucyAuc3dhdGNoZXMuc2l6ZSAuc2VsZWN0ZWQgYVwiKS50ZXh0KCkpO1xuICAgICAgICAgICAgICAgIC8vIGRsU2Vhc29uYWxDb2xsZWN0aW9uID0gJyc7XG4gICAgICAgICAgICAgICAgZGxDb2xvcndheSA9ICQudHJpbSgkKFwiLnByb2R1Y3QtdmFyaWF0aW9ucyAuc3dhdGNoZXMuQ29sb3IgLnNlbGVjdGVkIGFcIikuYXR0cigndGl0bGUnKSk7XG4gICAgICAgICAgICAgICAgZGxJdGVtQXRGdWxsUHJpY2UgPSAkLnRyaW0oJChcIi5wcm9kdWN0LXByaWNlIHNwYW5cIikuaHRtbCgpKS5yZXBsYWNlKFwiJFwiLFwiXCIpO1xuICAgICAgICAgICAgXHRpZiAoYXZhaWxhYmlsaXR5TXNnQ29udGFpbmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgXHRcdGRsQXZhaWxhYmlsaXR5ID0gYXZhaWxhYmlsaXR5TXNnQ29udGFpbmVyLmF0dHIoJ2RhdGEtYXZhaWxpYmxlJyk7XG4gICAgICAgICAgICBcdFx0aWYgKHR5cGVvZiBkbEF2YWlsYWJpbGl0eSAhPSAndW5kZWZpbmVkJyAmJiBkbEF2YWlsYWJpbGl0eS5sZW5ndGgpIHtcbiAgICAgICAgICAgIFx0XHRcdGRsQXZhaWxhYmlsaXR5ID0gJC50cmltKGRsQXZhaWxhYmlsaXR5LnJlcGxhY2UoL198LXxcXC4vZywgJyAnKSk7XG4gICAgICAgICAgICBcdFx0fVxuICAgICAgICAgICAgXHR9XG4gICAgICAgICAgICBcdGlmICh0eXBlb2YgZGxBdmFpbGFiaWxpdHkgPT0gJ3VuZGVmaW5lZCcgfHwgIWRsQXZhaWxhYmlsaXR5Lmxlbmd0aCkge1xuICAgICAgICAgICAgXHRcdGRsQXZhaWxhYmlsaXR5ID0gJyc7XG4gICAgICAgICAgICBcdH1cbiAgICAgICAgICAgICAgICAvLyBkbERpc2NvdW50ID0gJyc7XG4gICAgICAgICAgICAgICAgZGxNb25vZ3JhbW1pbmcgPSAnJztcbiAgICAgICAgICAgICAgICBkbEJWQXZlcmFnZSA9ICQudHJpbSgkKFwiI0JWUlJSYXRpbmdPdmVyYWxsXyAuQlZSUlJhdGluZ05vcm1hbE91dE9mXCIpLnRleHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFuc2FjdGlvblByb2R1Y3RzLnB1c2goe1xuICAgICAgICAgICAgICAgIFwiYnJhbmRcIiA6ICdrYXRlJyxcbiAgICAgICAgICAgICAgICBcInNrdVwiIDogZGxTa3UsXG4gICAgICAgICAgICAgICAgXCJpZFwiIDogZGxQaWQsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCIgOiBkbFByb2R1Y3ROYW1lLFxuICAgICAgICAgICAgICAgIFwiY2F0ZWdvcnlcIiA6IGRsQ2F0ZWdvcnlJRCxcbiAgICAgICAgICAgICAgICBcInByaWNlXCIgOiBkbFByaWNlLFxuICAgICAgICAgICAgICAgIFwicXVhbnRpdHlcIiA6IGRsUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgXCJ2YXJpYW50XCIgOiBkbFZhcmlhbnQsXG4gICAgICAgICAgICAgICAgXCJkaW1lbnNpb241XCIgOiBkbFNpemUsIC8vcHJvZHVjdCBzaXplXG4gICAgICAgICAgICAgICAgLy9cImRpbWVuc2lvbjlcIiA6IGRsU2Vhc29uYWxDb2xsZWN0aW9uLCAvLyBzZWFzb25hbCBjb2xsZWN0aW9uIHRoZSBwcm9kdWN0IGlzIHBhcnQgb2ZcbiAgICAgICAgICAgICAgICBcImRpbWVuc2lvbjEwXCIgOiBkbENvbG9yd2F5LCAvL2NvbG9yd2F5XG4gICAgICAgICAgICAgICAgXCJkaW1lbnNpb24xMVwiIDogZGxJdGVtQXRGdWxsUHJpY2UsIC8vV2FzIHRoZSBpdGVtIGF0IGZ1bGwgcHJpY2VcbiAgICAgICAgICAgICAgICBcImRpbWVuc2lvbjEyXCIgOiBkbEF2YWlsYWJpbGl0eSwgLy9hdmFpbGFiaWxpdHkgb2YgcHJvZHVjdFxuICAgICAgICAgICAgICAgIC8vXCJkaW1lbnNpb24xM1wiIDogZGxEaXNjb3VudCwgZGlzY291bnQgYW1vdW50IGlmIGFwcGxpY2FibGVcbiAgICAgICAgICAgICAgICBcImRpbWVuc2lvbjE0XCIgOiBkbE1vbm9ncmFtbWluZywgLy93YXMgbW9ub2dyYW1taW5nIGFwcGxpZWRcbiAgICAgICAgICAgICAgICAvL1wiZGltZW5zaW9uMTVcIiA6IGRsR2lmdFdyYXAsIC8vd2FzIGdpZnQgd3JhcCBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIFwiZGltZW5zaW9uMTZcIiA6IGRsQlZBdmVyYWdlIC8vYnYgYXZlcmFnZSBzdGFyIHJhdGluZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkYXRhTGF5ZXIucHVzaChhcHAuZGF0YWxheWVyLmdldEV2ZW50KFwiZXZlbnRcIixcImVjb21BZGRcIiwgXCJlY29tbWVyY2VcIiwgXCIgXCIsIFwiYWRkXCIsIHRyYW5zYWN0aW9uUHJvZHVjdHMpKTtcblx0XHR9XG5cdH1cbn07XG5cbmZ1bmN0aW9uIF9nZXRFdmVudChldmVudEtleSwgZXZlbnQsIHR5cGVLZXksIHR5cGUsIGFjdGlvbiwgcHJvZHVjdHMsIGxpc3QpIHtcblx0XG5cdC8vIEV2ZW50IEZvcm1hdHNcblx0XHQvL1x0YXBwLmRhdGFsYXllci5nZXRFdmVudChcImV2ZW50S2V5XCIsXCJldmVudFwiKTtcblx0XHQvL1x0YXBwLmRhdGFsYXllci5nZXRFdmVudChcImV2ZW50S2V5XCIsXCJldmVudFwiLCBcInR5cGVLZXlcIiwgXCJ0eXBlXCIpO1xuXHRcdC8vXHRhcHAuZGF0YWxheWVyLmdldEV2ZW50KFwiZXZlbnRLZXlcIixcImV2ZW50XCIsIFwiZWNvbW1lcmNlXCIsIFwidHlwZVwiLCBcImFkZFwiLCBcInByb2R1Y3RzXCIpO1xuXHRcdC8vXHRhcHAuZGF0YWxheWVyLmdldEV2ZW50KFwiZXZlbnRLZXlcIixcImV2ZW50XCIsIFwidHlwZUtleVwiLCBcInR5cGVcIiwgXCJyZW1vdmVcIiwgXCJwcm9kdWN0c1wiKTtcblx0XHQvL1x0YXBwLmRhdGFsYXllci5nZXRFdmVudChcImV2ZW50S2V5XCIsXCJldmVudFwiLCBcImVjb21tZXJjZVwiLCBcInR5cGVcIiwgXCJjbGlja1wiLCBcInByb2R1Y3RzXCIsIFwibGlzdFwiKTtcblx0XG5cdHZhciBvYmplY3QgPSB7IH07XG5cdFxuXHRpZihldmVudEtleSAmJiBldmVudCAmJiAhdHlwZUtleSkge1xuXHRcdC8vIEhhbmRsZSBvYmplY3Qgc3VjaCBhcyB7IFwiZXZlbnRcIiA6IFwiYWRkVG9DYXJ0XCIgfSBcblx0XHQvL29iamVjdCA9IHsgZXZlbnRLZXkgOiBldmVudCB9O1xuXHRcdG9iamVjdFtldmVudEtleV0gPSBldmVudDtcblx0fVxuXHRlbHNlIGlmKGV2ZW50S2V5ICYmIGV2ZW50ICYmIHR5cGVLZXkgJiYgdHlwZSAmJiB0eXBlS2V5ICE9IFwiZWNvbW1lcmNlXCIpIHtcblx0XHQvLyBIYW5kbGUgb2JqZWN0IHN1Y2ggYXN7IFwiZXZlbnRcIiA6IFwiZW1haWwtc3Vic2NyaWJlXCIsIFwic3Vic2NyaWJlVHlwZVwiOiBcImFjY291bnRDcmVhdGVcIiB9XG5cdFx0Ly9vYmplY3QgPSB7IGV2ZW50S2V5IDogZXZlbnQsIHR5cGVLZXkgOiB0eXBlIH07XG5cdFx0b2JqZWN0W2V2ZW50S2V5XSA9IGV2ZW50O1xuXHRcdG9iamVjdFt0eXBlS2V5XSA9IHR5cGU7XG5cdH1cblx0XG5cdGlmKGV2ZW50S2V5ICYmIGV2ZW50ICYmIHR5cGVLZXkgJiYgdHlwZSAmJiB0eXBlS2V5ID09IFwiZWNvbW1lcmNlXCIgJiYgcHJvZHVjdHMgJiYgKGFjdGlvbiA9PSBcImFkZFwiIHx8IGFjdGlvbiA9PSBcInJlbW92ZVwiKSkge1xuXHRcdC8vIEhhbmRsZSBvYmplY3Qgc3VjaCBhcyBcblx0XHQvLyBcdFx0eyBcImV2ZW50XCIgOiBcImVjb21BZGRcIiwgXCJlY29tbWVyY2VcIiA6IHsgXCJhZGRcIjogeyBcInByb2R1Y3RzXCI6IFwidHJhbnNhY3Rpb25Qcm9kdWN0c09iamVjdFwiIH0gfSB9IFxuXHRcdC8vb2JqZWN0ID0geyBldmVudEtleSA6IGV2ZW50LCB0eXBlS2V5IDogeyBhY3Rpb24gOiB7IFwicHJvZHVjdHNcIjogcHJvZHVjdHMgfSB9IH07XG5cdFx0XG5cdFx0b2JqZWN0W2V2ZW50S2V5XSA9IGV2ZW50O1xuXHRcdHZhciB0eXBlT2JqID0gb2JqZWN0W3R5cGVLZXldID0ge307XG5cdFx0dHlwZU9ialthY3Rpb25dID0geyBcInByb2R1Y3RzXCI6ICBwcm9kdWN0cyAgfTtcblx0XHRcblx0fVxuXHRcblx0aWYoZXZlbnRLZXkgJiYgZXZlbnQgJiYgdHlwZUtleSAmJiB0eXBlICYmIHR5cGVLZXkgPT0gXCJlY29tbWVyY2VcIiAmJiBwcm9kdWN0cyAmJiAoYWN0aW9uID09IFwiY2xpY2tcIikpIHtcblx0XHQvLyBIYW5kbGUgb2JqZWN0IHN1Y2ggYXMgXG5cdFx0Ly8gXHRcdHsgXCJldmVudFwiOiBcImVjb21Qcm9kdWN0SW1wcmVzc2lvbkNsaWNrXCIsIFwiZWNvbW1lcmNlXCIgOiB7IFwiY2xpY2tcIiA6IHsgXCJhY3Rpb25GaWVsZFwiIDoge1wibGlzdFwiIDogbnVsbCB9LCBcInByb2R1Y3RzXCIgOiBudWxsIH0gfSB9IFxuXHRcdC8vb2JqZWN0ID0geyBldmVudEtleSA6IGV2ZW50LCB0eXBlS2V5IDogeyBhY3Rpb24gOiB7IFwiYWN0aW9uRmllbGRcIiA6IHtcImxpc3RcIiA6IGxpc3QgfSwgXCJwcm9kdWN0c1wiIDogcHJvZHVjdHMgfSB9IH0gO1xuXHRcdFxuXHRcdG9iamVjdFtldmVudEtleV0gPSBldmVudDtcblx0XHR2YXIgdHlwZU9iajIgPSBvYmplY3RbdHlwZUtleV0gPSB7fTtcblx0XHR2YXIgdHlwZUlubmVyT2JqID0gdHlwZU9iajJbYWN0aW9uXSA9IHsgXCJwcm9kdWN0c1wiOiBbIHByb2R1Y3RzIF0gfTtcblx0XHR0eXBlSW5uZXJPYmpbXCJhY3Rpb25GaWVsZFwiXSA9IHsgXCJsaXN0XCI6IGxpc3QgfTtcblx0fVxuXHRcblx0cmV0dXJuIG9iamVjdDtcbn07XG5cbmZ1bmN0aW9uIF9nZXRPYmplY3RFeGFtcGxlcyAoKSB7IFxuXHRcblx0dmFyIGRhdGFMYXllck9iamVjdHMgPSBbXTtcblx0XG5cdC8vIEV2ZW50IHdpdGggVHdvIFBhcmFtZXRlcnMgXG5cdGRhdGFMYXllck9iamVjdHMucHVzaCggeyBcImV2ZW50XCIgOiBcImFkZFRvQ2FydFwiIH0gKTtcblx0ZGF0YUxheWVyT2JqZWN0cy5wdXNoKCB7IFwiZXZlbnRcIjogXCJiYXRjaGVkRWNvbVByb2RJbXByZXNzaW9uXCIgfSApO1xuXHRkYXRhTGF5ZXJPYmplY3RzLnB1c2goIHsgXCJldmVudFwiOiBcImVjb21Qcm9kdWN0SW1wcmVzc2lvbkNsaWNrXCIgfSApO1xuXHRcblx0Ly8gRXZlbnQgd2l0aCBGb3VyIFBhcmFtZXRlcnNcblx0ZGF0YUxheWVyT2JqZWN0cy5wdXNoKCB7IFwiZXZlbnRcIiA6IFwiZW1haWwtc3Vic2NyaWJlXCIsIFwic3Vic2NyaWJlVHlwZVwiOiBcImFjY291bnRDcmVhdGVcIiB9ICk7XG5cdGRhdGFMYXllck9iamVjdHMucHVzaCggeyBcImV2ZW50XCIgOiBcImVtYWlsLXN1YnNjcmliZVwiLCBcInN1YnNjcmliZVR5cGVcIjogXCJjaGVja291dFwiIH0gKTtcblx0ZGF0YUxheWVyT2JqZWN0cy5wdXNoKCB7IFwiZXZlbnRcIiA6IFwiZW1haWwtc3Vic2NyaWJlXCIsIFwic3Vic2NyaWJlVHlwZVwiOiBcImN1c3RvbWVyU2VydmljZVwiIH0gKSA7XG5cdGRhdGFMYXllck9iamVjdHMucHVzaCggeyBcImV2ZW50XCIgOiBcImVtYWlsLXN1YnNjcmliZVwiLCBcInN1YnNjcmliZVR5cGVcIjogXCJsaWdodGJveFwiIH0gKTtcblx0ZGF0YUxheWVyT2JqZWN0cy5wdXNoKCB7IFwiZXZlbnRcIiA6IFwiZW1haWwtc3Vic2NyaWJlXCIsIFwic3Vic2NyaWJlVHlwZVwiOiBcImZvb3RlclwiIH0gKSA7XG5cdGRhdGFMYXllck9iamVjdHMucHVzaCggeyBcImV2ZW50XCIgOiBcImFjY291bnQtY3JlYXRpb25cIiwgXCJ0eXBlXCIgOiBcIkthdGUgU3BhZGVcIiB9ICk7XG5cdFxuXHQvLyBFdmVudCB3aXRoIEVjb21tZXJjZSBPYmplY3Rcblx0ZGF0YUxheWVyT2JqZWN0cy5wdXNoKCB7IFwiZXZlbnRcIiA6IFwiZWNvbUFkZFwiLCBcImVjb21tZXJjZVwiIDogeyBcImFkZFwiOiB7IFwicHJvZHVjdHNcIjogXCJ0cmFuc2FjdGlvblByb2R1Y3RzT2JqZWN0XCIgfSB9IH0gKTtcblx0ZGF0YUxheWVyT2JqZWN0cy5wdXNoKCB7IFwiZXZlbnRcIjogXCJlY29tUHJvZHVjdEltcHJlc3Npb25DbGlja1wiLCBcImVjb21tZXJjZVwiIDogeyBcImNsaWNrXCIgOiB7IFwiYWN0aW9uRmllbGRcIiA6IHtcImxpc3RcIiA6IG51bGwgfSwgXCJwcm9kdWN0c1wiIDogbnVsbCB9IH0gfSApO1xuXHRkYXRhTGF5ZXJPYmplY3RzLnB1c2goIHsgXCJldmVudFwiIDogXCJlY29tUmVtb3ZlXCIsIFwiZWNvbW1lcmNlXCIgOiB7IFwicmVtb3ZlXCIgOiB7IFwicHJvZHVjdHNcIjogbnVsbCB9IH0gfSApO1xuXHRcblx0Ly8gVHJhbnNhY3Rpb24gUHJvZHVjdHMgd2l0aCBUd28gUGFyYW1ldGVyc1xuXHRkYXRhTGF5ZXJPYmplY3RzLnB1c2goIHsgXCJ0cmFuc2FjdGlvblByb2R1Y3RzXCIgOiBcInRyYW5zYWN0aW9uUHJvZHVjdHNPYmplY3RcIiB9ICk7XG5cdGRhdGFMYXllck9iamVjdHMucHVzaCggeyBcInRyYW5zYWN0aW9uUHJvZHVjdHNcIiA6IFwiZWNvbVByb2R1Y3RJbXByZXNzaW9uQ2xpY2tcIiB9ICk7XG5cdFx0XG5cdHJldHVybiBkYXRhTGF5ZXJPYmplY3RzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBhcHAuZGF0YWxheWVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWpheCA9IHJlcXVpcmUoJy4vYWpheCcpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKSxcbiAgICBfID0gcmVxdWlyZSgnbG9kYXNoJyksXG4gICAgaW1hZ2VzTG9hZGVkID0gcmVxdWlyZSgnaW1hZ2VzbG9hZGVkJyk7XG5cbnZhciBkaWFsb2cgPSB7XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIEFwcGVuZHMgYSBkaWFsb2cgdG8gYSBnaXZlbiBjb250YWluZXIgKHRhcmdldClcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zICBwYXJhbXMudGFyZ2V0IGNhbiBiZSBhbiBpZCBzZWxlY3RvciBvciBhbiBqcXVlcnkgb2JqZWN0XG4gICAgICovXG4gICAgY3JlYXRlOiBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciAkdGFyZ2V0LCBpZDtcblxuICAgICAgICBpZiAoXy5pc1N0cmluZyhwYXJhbXMudGFyZ2V0KSkge1xuICAgICAgICAgICAgaWYgKHBhcmFtcy50YXJnZXQuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICAkdGFyZ2V0ID0gJChwYXJhbXMudGFyZ2V0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHRhcmdldCA9ICQoJyMnICsgcGFyYW1zLnRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLnRhcmdldCBpbnN0YW5jZW9mIGpRdWVyeSkge1xuICAgICAgICAgICAgJHRhcmdldCA9IHBhcmFtcy50YXJnZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkdGFyZ2V0ID0gJCgnI2RpYWxvZy1jb250YWluZXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vIGVsZW1lbnQgZm91bmQsIGNyZWF0ZSBvbmVcbiAgICAgICAgaWYgKCR0YXJnZXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoJHRhcmdldC5zZWxlY3RvciAmJiAkdGFyZ2V0LnNlbGVjdG9yLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgaWQgPSAkdGFyZ2V0LnNlbGVjdG9yLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICAkdGFyZ2V0ID0gJCgnPGRpdj4nKS5hdHRyKCdpZCcsIGlkKS5hZGRDbGFzcygnZGlhbG9nLWNvbnRlbnQnKS5hcHBlbmRUbygnYm9keScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBkaWFsb2dcbiAgICAgICAgdGhpcy4kY29udGFpbmVyID0gJHRhcmdldDtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLmRpYWxvZyhfLm1lcmdlKHt9LCB0aGlzLnNldHRpbmdzLCBwYXJhbXMub3B0aW9ucyB8fCB7fSkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIE9wZW5zIGEgZGlhbG9nIHVzaW5nIHRoZSBnaXZlbiB1cmwgKHBhcmFtcy51cmwpIG9yIGh0bWwgKHBhcmFtcy5odG1sKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zLnVybCBzaG91bGQgY29udGFpbiB0aGUgdXJsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5odG1sIGNvbnRhaW5zIHRoZSBodG1sIG9mIHRoZSBkaWFsb2cgY29udGVudFxuICAgICAqL1xuICAgIG9wZW46IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgLy8gY2xvc2UgYW55IG9wZW4gZGlhbG9nXG4gICAgICAgIC8vdGhpcy5jbG9zZSgpO1xuICAgICAgICB0aGlzLmNyZWF0ZShwYXJhbXMpO1xuICAgICAgICB0aGlzLnJlcGxhY2UocGFyYW1zKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBwb3B1bGF0ZSB0aGUgZGlhbG9nIHdpdGggaHRtbCBjb250ZW50LCB0aGVuIG9wZW4gaXRcbiAgICAgKiovXG4gICAgb3BlbldpdGhDb250ZW50OiBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBjb250ZW50LCBwb3NpdGlvbiwgY2FsbGJhY2s7XG5cbiAgICAgICAgaWYgKCF0aGlzLiRjb250YWluZXIpIHsgcmV0dXJuOyB9XG4gICAgICAgIGNvbnRlbnQgPSBwYXJhbXMuY29udGVudCB8fCBwYXJhbXMuaHRtbDtcbiAgICAgICAgaWYgKCFjb250ZW50KSB7IHJldHVybjsgfVxuICAgICAgICB0aGlzLiRjb250YWluZXIuZW1wdHkoKS5odG1sKGNvbnRlbnQpO1xuICAgICAgICBpZiAoIXRoaXMuJGNvbnRhaW5lci5kaWFsb2coJ2lzT3BlbicpKSB7XG4gICAgICAgICAgICB0aGlzLiRjb250YWluZXIuZGlhbG9nKCdvcGVuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gcGFyYW1zLm9wdGlvbnMucG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLnNldHRpbmdzLnBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGltYWdlc0xvYWRlZCh0aGlzLiRjb250YWluZXIpLm9uKCdkb25lJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLmRpYWxvZygnb3B0aW9uJywgJ3Bvc2l0aW9uJywgcG9zaXRpb24pO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICBcbiAgICAgICAgaWYodHlwZW9mIHBhcmFtcy5jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAgIFx0Y2FsbGJhY2sgPSBwYXJhbXMuY2FsbGJhY2s7XG4gICAgICAgIH1lbHNlIGlmKHR5cGVvZiBwYXJhbXMub3B0aW9ucy5vcGVuID09PSAnZnVuY3Rpb24nKXtcbiAgICAgICAgXHRjYWxsYmFjayA9IHBhcmFtcy5vcHRpb25zLm9wZW47XG4gICAgICAgIH1lbHNle1xuICAgICAgICBcdGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXBsYWNlIHRoZSBjb250ZW50IG9mIGN1cnJlbnQgZGlhbG9nXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMudXJsIC0gSWYgdGhlIHVybCBwcm9wZXJ0eSBpcyBwcm92aWRlZCwgYW4gYWpheCBjYWxsIGlzIHBlcmZvcm1lZCB0byBnZXQgdGhlIGNvbnRlbnQgdG8gcmVwbGFjZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuaHRtbCAtIElmIG5vIHVybCBwcm9wZXJ0eSBpcyBwcm92aWRlZCwgdXNlIGh0bWwgcHJvdmlkZWQgdG8gcmVwbGFjZVxuICAgICAqL1xuICAgIHJlcGxhY2U6IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy51c2VDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lciA9IHBhcmFtcy51c2VDb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLiRjb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLnVybCkge1xuICAgICAgICAgICAgcGFyYW1zLnVybCA9IHV0aWwuYXBwZW5kUGFyYW1Ub1VSTChwYXJhbXMudXJsLCAnZm9ybWF0JywgJ2FqYXgnKTtcbiAgICAgICAgICAgIGFqYXgubG9hZCh7XG4gICAgICAgICAgICAgICAgdXJsOiBwYXJhbXMudXJsLFxuICAgICAgICAgICAgICAgIGRhdGE6IHBhcmFtcy5kYXRhLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmNvbnRlbnQgPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuV2l0aENvbnRlbnQocGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy5odG1sKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5XaXRoQ29udGVudChwYXJhbXMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gUmVwbGFjZSB0aGUgY29udGVudCBvZiBjdXJyZW50IGRpYWxvZywgZnJvbSBhbm90aGVyIGhhbmRsZWQgYWpheCBjYWxsLlxuICAgICAqIEBwYXJhbSB7aHRtbH0gY29udGVudCB0byByZXBsYWNlLlxuICAgICAqL1xuICAgIHJlcGxhY2VDb250ZW50OiBmdW5jdGlvbihjb250ZW50KSB7XG5cdFx0aWYgKCF0aGlzLiRjb250YWluZXIgfHwgIWNvbnRlbnQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy4kY29udGFpbmVyLmVtcHR5KCkuaHRtbChjb250ZW50KTtcblx0fSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gQ2xvc2VzIHRoZSBkaWFsb2dcbiAgICAgKi9cbiAgICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuJGNvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci5kaWFsb2coJ2Nsb3NlJyk7XG4gICAgfSxcbiAgICBleGlzdHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGNvbnRhaW5lciAmJiAodGhpcy4kY29udGFpbmVyLmxlbmd0aCA+IDApO1xuICAgIH0sXG4gICAgaXNBY3RpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhpc3RzKCkgJiYgKHRoaXMuJGNvbnRhaW5lci5jaGlsZHJlbi5sZW5ndGggPiAwKTtcbiAgICB9LFxuICAgIHNldHRpbmdzOiB7XG4gICAgICAgIGF1dG9PcGVuOiB0cnVlLFxuICAgICAgICBoZWlnaHQ6ICdhdXRvJyxcbiAgICAgICAgbW9kYWw6IHRydWUsXG4gICAgICAgIG92ZXJsYXk6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNSxcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICdibGFjaydcbiAgICAgICAgfSxcbiAgICAgICAgcmVzaXphYmxlOiBmYWxzZSxcbiAgICAgICAgdGl0bGU6ICcnLFxuICAgICAgICB3aWR0aDogJzgwMCcsXG4gICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkKHRoaXMpLmRpYWxvZygnY2xvc2UnKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIG15OiAnY2VudGVyJyxcbiAgICAgICAgICAgIGF0OiAnY2VudGVyJyxcbiAgICAgICAgICAgIG9mOiB3aW5kb3csXG4gICAgICAgICAgICBjb2xsaXNpb246ICdmbGlwZml0J1xuICAgICAgICB9XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBkaWFsb2c7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhamF4ID0gcmVxdWlyZSgnLi9hamF4JyksXG4gICAgZGlhbG9nID0gcmVxdWlyZSgnLi9kaWFsb2cnKSxcbiAgICBzbWFsbE1lZEJyZWFrcG9pbnQgPSAzNjA7XG5cbnZhciBlbWFpbHN1YnNjcmlwdGlvbiA9IHtcbiAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEdFVCBGT1JNIEVMRU1FTlRTXG4gICAgICAgIHZhciBmb3JtXHRcdCA9IHRoaXMuZ2V0RmllbGQoKTtcbiAgICAgICAgdmFyIGVtYWlsQWRkcmVzcyA9IGZvcm0uZmluZChcImlucHV0LmVtYWlsXCIpO1xuICAgICAgICB2YXIgemlwQ29kZSBcdCA9IGZvcm0uZmluZChcImlucHV0LnBvc3RhbEFsbFwiKTtcbiAgICAgICAgdmFyIHVybCBcdFx0ID0gVXJscy5lbWFpbFN1YnNjcmlwdGlvbiArIFwiP2VtYWlsPVwiICsgJChlbWFpbEFkZHJlc3MpLnZhbCgpO1xuXG4gICAgICAgIC8vIFNFVCBCTFVSIEVWRU5UU1xuICAgICAgICB0aGlzLnNldEV2ZW50KFwiYmx1clwiLCBlbWFpbEFkZHJlc3MsIFwiZW1haWwgYWRkcmVzc1wiKTtcbiAgICAgICAgdGhpcy5zZXRFdmVudChcImJsdXJcIiwgemlwQ29kZSwgXCJ6aXBcIik7XG5cbiAgICAgICAgLy8gU0VUIERJQUxPRyBDTE9TRSBFVkVOVFxuICAgICAgICAkKFwidWktaWNvbi1jbG9zZXRoaWNrXCIpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQoIFwiLnVpLWljb24tY2xvc2V0aGlja1wiICkuZGlhbG9nKCkuY2xvc2UoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU0VUIEZPUk0gU1VCTUlTU0lPTiBFVkVOVFxuICAgICAgICAkKGZvcm0pLnN1Ym1pdChmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgICAgICAvLyBEaXNhYmxlIHRoZSBkZWZhdWx0IGZvcm0gYWN0aW9uLlxuICAgICAgICAgICAgLy8gVGhpcyBhbGxvd3MgdXMgdG8gbWFrZSB0aGUgQUpBWCBjYWxsIG9uY2VcbiAgICAgICAgICAgIC8vIHRoaXMgYWN0aW9uIGhhcyBiZWVuIGRpc2FibGVkLlxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgLy8gR0VUIEZPUk0gRUxFTUVOVFNcbiAgICAgICAgICAgIHZhciBmb3JtXHRcdCA9IGVtYWlsc3Vic2NyaXB0aW9uLmdldEZpZWxkKCk7XG4gICAgICAgICAgICB2YXIgZW1haWxBZGRyZXNzID0gZm9ybS5maW5kKFwiaW5wdXQuZW1haWxcIik7XG4gICAgICAgICAgICB2YXIgemlwQ29kZSBcdCA9IGZvcm0uZmluZChcImlucHV0LnBvc3RhbEFsbFwiKTtcblxuICAgICAgICAgICAgaWYoJChlbWFpbEFkZHJlc3MpLnZhbCgpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBHRVQgQUpBWCBVUkxcbiAgICAgICAgICAgICAgICAvLyBUaGlzIFVSTCBpcyBhIGNvbmNhdGVuYXRpb24gb2YgdGhlXG4gICAgICAgICAgICAgICAgLy8gcGlwZWxpbmUsIGVtYWlsIGFkZHJlc3MsIGFuZCBzb3VyY2UgcGFyYW1ldGVycy5cbiAgICAgICAgICAgICAgICB2YXIgdXJsID0gVXJscy5lbWFpbFN1YnNjcmlwdGlvbjtcblxuICAgICAgICAgICAgICAgIC8vIE1BS0UgQUpBWCBDQUxMIFZJQSBFTUFJTCBTVUJTQ1JJUFRJT04gU0lHTiBVUCBGT1JNXG4gICAgICAgICAgICAgICAgYWpheC5nZXRKc29uKHtcbiAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgZGF0YTogZW1haWxzdWJzY3JpcHRpb24uZ2V0RmllbGQoKS5zZXJpYWxpemUoKSxcbiAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvcm0gPSBlbWFpbHN1YnNjcmlwdGlvbi5nZXRGaWVsZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbWFpbEFkZHJlc3MgPSBmb3JtLmZpbmQoXCJpbnB1dC5lbWFpbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3c2xldHRlciA9ICQoXCIjbmV3c2xldHRlci1wb3B1cGxpbmtcIikuYXR0cignaHJlZicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbWFpbEVycm9yRXhpc3RzID0gJChlbWFpbEFkZHJlc3MpLmhhc0NsYXNzKCdlcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB6aXBFcnJvckV4aXN0cyA9IGZvcm0uZmluZChcImlucHV0LnBvc3RhbEFsbFwiKS5oYXNDbGFzcygnZXJyb3InKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9OTFkgT1BFTiBUSEUgRElBTE9HIElGIFRIRVJFIERPRVMgTk9UIEVYSVNUIEFOWSBFUlJPUlNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighZW1haWxFcnJvckV4aXN0cyAmJiAhemlwRXJyb3JFeGlzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YUxheWVyICE9PSAndW5kZWZpbmVkJyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhTGF5ZXIucHVzaChhcHAuZGF0YWxheWVyLmdldEV2ZW50KFwiZXZlbnRcIiwgXCJlbWFpbC1zdWJzY3JpYmVcIiwgXCJzdWJzY3JpYmVUeXBlXCIsIFwiZm9vdGVyXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWFsb2cub3Blbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IG5ld3NsZXR0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZU9uRXNjYXBlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCA8IHNtYWxsTWVkQnJlYWtwb2ludCA/IDMwMCA6IDM0MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogeyBteTogXCJjZW50ZXJcIiwgYXQ6IFwiY2VudGVyXCIsIG9mOiB3aW5kb3cgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWFsb2dDbGFzczogJ2Zvb3Rlci1uZXdzbGV0dGVyLWRpYWxvZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChlbWFpbEFkZHJlc3MpLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoemlwQ29kZSkudmFsKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTRVQgRk9STSAyIFNVQk1JU1NJT04gRVZFTlRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFwiI25ld3NsZXR0ZXItcG9wdXBcIikuZmluZChcImZvcm1cIikub24oJ3N1Ym1pdCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzYWJsZSB0aGUgZGVmYXVsdCBmb3JtIGFjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBhbGxvd3MgdXMgdG8gbWFrZSB0aGUgQUpBWCBjYWxsIG9uY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBhY3Rpb24gaGFzIGJlZW4gZGlzYWJsZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR0VUIEFKQVggVVJMIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBVUkwgaXMgYSBjb25jYXRlbmF0aW9uIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwaXBlbGluZSwgZW1haWwgYWRkcmVzcywgYW5kIHNvdXJjZSBwYXJhbWV0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXJsMiA9IFVybHMuZW1haWxTaWdudXBBbHRMaXN0cyArIFwiP2V0X2VtYWlsPVwiICsgJChlbWFpbEFkZHJlc3MpLnZhbCgpICsgXCImZXRfcG9zdGFsPVwiICsgJCh6aXBDb2RlKS52YWwoKSArIFwiJmpzcD1cIiArICQoXCIjanNwLXJlY2VpdmVFbWFpbFwiKS5pcyhcIjpjaGVja2VkXCIpICsgXCImc291cmNlPWFqYXhcIjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNQUtFIEFKQVggQ0FMTCBWSUEgRU1BSUwgU1VCU0NSSVBUSU9OIFNJR04gVVAgRk9STSAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFqYXguZ2V0SnNvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChkYXRhMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDTEVBUiBFTUFJTCBBTkQgWklQIENPREUgRklFTERTXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoZW1haWxBZGRyZXNzKS52YWwoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHppcENvZGUpLnZhbCgnJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ0xPU0UgVEhFIERJQUxPRyBNT0RBTFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNFVCBESUFMT0cgQ0xPU0UgRVZFTlQgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFwiLm5vdGhhbmtzXCIpLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoZW1haWxBZGRyZXNzKS52YWwoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh6aXBDb2RlKS52YWwoJycpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCcuZm9vdGVyLW5ld3NsZXR0ZXItZGlhbG9nJykuY2VudGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJFTU9WRSBUSEUgQ0xBU1MgRVJST1IgRlJPTSBUSEUgRU1BSUwgRklFTERcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChlbWFpbEFkZHJlc3MpLnJlbW92ZUNsYXNzKFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5lcnJvci5zaG93QW50aVNwYW1EaWFsb2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwLnZhbGlkYXRvci5hc2xDb25maXJtKGVtYWlsc3Vic2NyaXB0aW9uLmdldEZpZWxkKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3JtID0gZW1haWxzdWJzY3JpcHRpb24uZ2V0RmllbGQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVtYWlsQWRkcmVzcyA9IGZvcm0uZmluZChcImlucHV0LmVtYWlsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKGVtYWlsQWRkcmVzcykudmFsKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKGVtYWlsQWRkcmVzcykuYWRkQ2xhc3MoXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChlbWFpbEFkZHJlc3MpLmF0dHIoXCJwbGFjZWhvbGRlclwiLCBkYXRhLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvL0lFIG5ld3NsZXR0ZXIgcGxhY2Vob2xkZXIgZml4XG4gICAgICAgIGlmKCEod2luZG93LkFjdGl2ZVhPYmplY3QpICYmIFwiQWN0aXZlWE9iamVjdFwiIGluIHdpbmRvdykge1xuICAgICAgICAgICAgd2Vic2hpbXMuc2V0T3B0aW9ucyhcImZvcm1zXCIsIHtcbiAgICAgICAgICAgICAgICBvdmVycmlkZVBsYWNlaG9sZGVyOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHdlYnNoaW1zLnBvbHlmaWxsKFwiZm9ybXNcIik7XG4gICAgICAgICAgICAkKFwiLm5ld3NsZXR0ZXIgaW5wdXRbdHlwZT0nc3VibWl0J11cIikub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAkKCcucGxhY2Vob2xkZXItZm9jdXNlZCcpLmJsdXIoKS5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH0sMjAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXRGaWVsZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJChcIiNmb290ZXItd3JhcHBlclwiKS5maW5kKFwiLmNvbnRlbnQtYXNzZXRcIikuZmluZChcIiNmb290ZXJcIikuZmluZChcImZvcm1cIik7XG4gICAgfSxcbiAgICBzZXRFdmVudDogZnVuY3Rpb24gKHR5cGUsIGZpZWxkLCBwaHJhc2UpIHtcbiAgICAgICAgJChmaWVsZCkub24odHlwZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYoJCh0aGlzKS52YWwoKS5sZW5ndGggPT0gMCApIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmF0dHIoXCJwbGFjZWhvbGRlclwiLCBwaHJhc2UgKyBcIiByZXF1aXJlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbWFpbHN1YnNjcmlwdGlvbjsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAZGVzY3JpcHRpb24gSW5pdGlhbGl6ZXMgaW5wdXQgZmxvYXQgbGFiZWxzXG4gKi9cbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgICQoJy5mb3JtLXJvdy5oYXMtZmxvYXQtbGFiZWwnKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gJCh0aGlzKS5maW5kKCcudGV4dC1pbnB1dC1sYWJlbCcpLFxuICAgICAgICAgICAgaW5wdXQgPSAkKHRoaXMpLmZpbmQoJ2lucHV0LCB0ZXh0YXJlYScpO1xuXG4gICAgICAgIC8vIGF1dG8gZXhwYW5kIHRleHRhcmVhIGlucHV0cyBzbyB0ZXh0IGRvZXMgbm90IG92ZXJsYXAgbGFiZWxcbiAgICAgICAgaWYgKGlucHV0Lmhhc0NsYXNzKCdpbnB1dC10ZXh0YXJlYScpICYmICQuZm4uYXV0b2dyb3cpIHtcbiAgICAgICAgICAgIGlucHV0LmNzcygnb3ZlcmZsb3cnLCAnaGlkZGVuJykuYXV0b2dyb3coe1xuICAgICAgICAgICAgICAgIHZlcnRpY2FsOiB0cnVlLFxuICAgICAgICAgICAgICAgIGhvcml6b250YWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZsaWNrZXJpbmc6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVzZSB0aGUgbGFiZWwgYXMgYSBwbGFjZWhvbGRlciwgdGhpcyBhZGRzIChvcHRpb25hbCkgaWYgbm90IHJlcXVpcmVkXG4gICAgICAgIGlmKGxhYmVsWzBdICYmIGxhYmVsWzBdLmlubmVyVGV4dCkge1xuICAgICAgICAgICAgaW5wdXQuYXR0cigncGxhY2Vob2xkZXInLCBsYWJlbFswXS5pbm5lclRleHQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpbnB1dC5vbignZm9jdXMga2V5dXAnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsYWJlbC5hZGRDbGFzcygnZmxvYXQnKTtcbiAgICAgICAgICAgIGlucHV0LmFkZENsYXNzKCdmbG9hdCcpO1xuICAgICAgICAgICAgaW5wdXQuY3NzKCd0ZXh0LXRyYW5zZm9ybScsICdub25lJyk7XG4gICAgICAgICAgICBpbnB1dC5jc3MoJ2NvbG9yJywgJyMwMDAnKTtcbiAgICAgICAgfSkub24oJ2JsdXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWlucHV0LnZhbCgpKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwucmVtb3ZlQ2xhc3MoJ2Zsb2F0Jyk7XG4gICAgICAgICAgICAgICAgaW5wdXQucmVtb3ZlQ2xhc3MoJ2Zsb2F0Jyk7XG4gICAgICAgICAgICAgICAgaW5wdXQuY3NzKCd0ZXh0LXRyYW5zZm9ybScsICd1cHBlcmNhc2UnKTtcbiAgICAgICAgICAgICAgICBpbnB1dC5jc3MoJ2NvbG9yJywgJyM4RjkxOTQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFiZWwuYWRkQ2xhc3MoJ2Zsb2F0Jyk7XG4gICAgICAgICAgICAgICAgaW5wdXQuYWRkQ2xhc3MoJ2Zsb2F0Jyk7XG4gICAgICAgICAgICAgICAgaW5wdXQuY3NzKCd0ZXh0LXRyYW5zZm9ybScsICdub25lJyk7XG4gICAgICAgICAgICAgICAgaW5wdXQuY3NzKCdjb2xvcicsICcjMDAwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaWYoaW5wdXQuYXR0cigndmFsdWUnKSAmJiBpbnB1dC5hdHRyKCd2YWx1ZScpLmxlbmd0aCl7XG4gICAgICAgIFx0bGFiZWwuYWRkQ2xhc3MoJ2Zsb2F0Jyk7XG4gICAgICAgICAgICBpbnB1dC5hZGRDbGFzcygnZmxvYXQnKTtcbiAgICAgICAgICAgIGlucHV0LmNzcygndGV4dC10cmFuc2Zvcm0nLCAnbm9uZScpO1xuICAgICAgICAgICAgaW5wdXQuY3NzKCdjb2xvcicsICcjMDAwJyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhamF4ID0gcmVxdWlyZSgnLi9hamF4JyksXG5cdHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKSxcblx0dmFsaWRhdG9yID0gcmVxdWlyZSgnLi92YWxpZGF0b3InKTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gSW5pdGlhbGl6ZSBldmVudCBoYW5kbGVycyBvbiBnaWZ0Y2FyZCBkZXRhaWwgcGFnZVxuICovXG5mdW5jdGlvbiBpbml0aWFsaXplRXZlbnRzKCkge1xuICAgIHZhciAkcGRwTWFpbiA9ICQoJyNwZHBNYWluJyksXG4gICAgICAgIHBkcEZvcm0gPSAkKCcucGRwRm9ybScpLFxuICAgICAgICAkYXRjID0gJCgnI2FkZC10by1jYXJ0Jyk7XG4gICAgXG4gICAgLypHaWZ0IENhcmQgY2hlY2sgaW5wdXRzKi9cbiAgICAkcGRwTWFpbi5vbiAoJ2ZvY3VzIGJsdXInLCAnLmdpZnQtY2FyZC1hdHRyaWJ1dGUgaW5wdXQsIC5naWZ0LWNhcmQtYXR0cmlidXRlIHRleHRhcmVhJywgZnVuY3Rpb24oZSl7XG4gICAgXHR2YXIgb3BhY2l0eSA9IDE7XG4gICAgXHR2YXIgc3BlZWQgPSA1MDA7XG4gICAgXHR2YXIgJHRoaXMgPSAkKHRoaXMpO1xuICAgIFx0aWYgKCR0aGlzLnZhbCgpIHx8IGUudHlwZSA9PSAnZm9jdXNpbicpIHtcbiAgICBcdFx0b3BhY2l0eSA9IDA7XG4gICAgXHRcdHNwZWVkID0gMDtcbiAgICBcdH1cbiAgICBcdCR0aGlzLmNsb3Nlc3QoJy5naWZ0LWNhcmQtYXR0cmlidXRlJykuZmluZCgnbGFiZWwnKS5mYWRlVG8oc3BlZWQgLCBvcGFjaXR5KTtcbiAgICB9KTtcbiAgICBpZiAoJCgnLmdpZnQtY2FyZC1pbmZvJykubGVuZ3RoID4gMCkge1xuICAgICAgICAkKCcuZ2lmdC1jYXJkLWF0dHJpYnV0ZScpLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgXHR2YXIgJHRoaXMgPSAkKHRoaXMpO1xuICAgICAgICBcdHZhciBfdGhpc2luID0gJHRoaXMuZmluZCgnaW5wdXQnKTtcbiAgICAgICAgXHR2YXIgX3RoaXN0eCA9ICR0aGlzLmZpbmQoJ3RleHRhcmVhJyk7XG4gICAgICAgIFx0aWYgKF90aGlzaW4udmFsKCkgfHwgX3RoaXN0eC52YWwoKSkge1xuICAgICAgICBcdFx0JHRoaXMuZmluZCgnbGFiZWwnKS5mYWRlVG8oMCAsIDApO1xuICAgICAgICBcdH1cbiAgICAgICAgfSlcbiAgICB9XG4gICAgLypHaWZ0IENhcmQgc2V0IGFtb3VudCovXG4gICAgJCgnYm9keScpLm9uKCdjbGljaycsICcjZ2NBbW91bnRzZWxlY3QgYS5zd2F0Y2hhbmNob3InLCBmdW5jdGlvbigpIHtcblx0XHQkKCdib2R5JykuZmluZCgnaW5wdXQjZ2NBbW91bnQnKS52YWwoJCh0aGlzKS5kYXRhKCd2YWx1ZScpKTtcbiAgICB9KTtcblx0JCgnYm9keScpLm9uKCdjbGljaycsICcudWktZGlhbG9nICNnY0Ftb3VudHNlbGVjdCBhLnN3YXRjaGFuY2hvcicsIGZ1bmN0aW9uKCkge1xuXHRcdGlmICghJCh0aGlzKS5oYXNDbGFzcygnc2VsZWN0ZWQnKSkge1xuXHRcdFx0JCh0aGlzKS5wYXJlbnQoKS5hZGRDbGFzcygnc2VsZWN0ZWQnKTtcblx0XHRcdCQodGhpcykucGFyZW50KCkuc2libGluZ3MoKS5yZW1vdmVDbGFzcygnc2VsZWN0ZWQnKTtcblx0XHR9XG5cdH0pO1xuXG4gICAgaWYgKCQoJ2lucHV0I2djQW1vdW50JykubGVuZ3RoKSB7XG4gICAgXHQkKCcjZ2NBbW91bnQnKS52YWwoJCgnI2djQW1vdW50c2VsZWN0IC5zZWxlY3RlZCBhLnN3YXRjaGFuY2hvcicpLmRhdGEoJ3ZhbHVlJykpO1xuICAgIH1cbiAgICBcbiAgICAkcGRwTWFpbi5maW5kKCdkaXYucHJvZHVjdC1kZXRhaWwgLmdpZnQtY2FyZC1pbWFnZSBhLnN3YXRjaGFuY2hvcicpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgXHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0dmFyICR0aGlzID0gJCh0aGlzKSxcblx0XHRcdHN0b3JlZnJvbnRJbWFnZSA9ICQoJyNnY1N0b3JlZnJvbnRJbWFnZScpLFxuXHRcdFx0JHZhbCA9ICR0aGlzLmF0dHIoJ2RhdGEtc3JjJyk7IC8vIHVzZSBkYXRhLXNyYyBmb3IgZ3NpIGltYWdlXG5cdFx0XG5cdFx0aWYgKCEkdmFsKSB7XG5cdFx0XHQkdmFsID0gJHRoaXMuYXR0cignaHJlZicpOyAvLyBmYWxsIGJhY2sgdG8gaHJlZiAod2hpY2ggaXMgdXNlZCBmb3IgcGRwIGltYWdlKVxuXHRcdH1cblx0XHRcblx0XHQkKCcuZ2lmdC1jYXJkLWltYWdlIC5zd2F0Y2hlcyBsaScpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHQkKHRoaXMpLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xuXHRcdH0pO1xuXHRcdFxuXHRcdCR0aGlzLnBhcmVudCgpLmFkZENsYXNzKCdzZWxlY3RlZCcpO1xuXHRcdFxuXHRcdCQoJy5naWZ0LWNhcmQtaW1hZ2UgLnN3YXRjaGVzIGxpLnNlbGVjdGVkLXZhbHVlJykudGV4dCgkdGhpcy5hdHRyKCd0aXRsZScpKTtcblx0XHQkKCcjZ2NJbWFnZScpLnZhbCgkdmFsKTtcblx0XHRcblx0XHRpZiAoc3RvcmVmcm9udEltYWdlLmxlbmd0aCl7XG5cdFx0XHRzdG9yZWZyb250SW1hZ2UudmFsKCR0aGlzLmF0dHIoJ2hyZWYnKSk7XG5cdFx0fVxuXHRcdFxuXHRcdCRwZHBNYWluLmZpbmQoJy5wcm9kdWN0LXByaW1hcnktaW1hZ2UnKS5odG1sKCc8aW1nIGNsYXNzPVwiZ2lmdC1jYXJkLW1haW4taW1hZ2VcIiBzcmM9XCInICsgJHRoaXMuYXR0cignaHJlZicpICsgJ1wiLz4nKTtcblx0XHQkcGRwTWFpbi5maW5kKCcudGh1bWJuYWlsLWxpbms6Zmlyc3QgaW1nJykuYXR0cignc3JjJywgJHRoaXMuYXR0cignaHJlZicpKTtcblx0fSk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAZGVzY3JpcHRpb24gUHVibGljIG5hbWVzcGFjZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Y2hlY2tCYWxhbmNlOiBmdW5jdGlvbiAoaWQsIHBpbiwgY2FsbGJhY2spIHtcblx0XHQvKipcblx0XHQgKiBAZnVuY3Rpb25cblx0XHQgKiBAZGVzY3JpcHRpb24gTG9hZCBkZXRhaWxzIHRvIGEgZ2l2ZW4gZ2lmdCBjZXJ0aWZpY2F0ZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhlIGdpZnQgY2VydGlmaWNhdGVcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBBIGZ1bmN0aW9uIHRvIGNhbGxlZFxuXHRcdCAqL1xuXHRcdHZhciB1cmwgPSB1dGlsLmFwcGVuZFBhcmFtVG9VUkwoVXJscy5naWZ0Q2FyZENoZWNrQmFsYW5jZSwgXCJnaWZ0Q2FyZE51bWJlclwiLCBpZCk7XG5cdFx0dXJsID0gdXRpbC5hcHBlbmRQYXJhbVRvVVJMKHVybCwgXCJnaWZ0Q2FyZFBpblwiLCBwaW4pO1xuXHRcdGFqYXguZ2V0SnNvbih7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdGNhbGxiYWNrOiBjYWxsYmFja1xuXHRcdH0pO1xuXHR9LFxuXHQvKipcblx0ICogR2V0IHRoZSBwYXJ0eSBzdGFydGVkLlxuXHQgKi9cblx0aW5pdDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIEN1c3RvbSBHQyBsb2dpY1xuXHRcdGlmICgkKCcuZ2lmdC1jYXJkJykubGVuZ3RoIHx8ICQoJy5lLWdpZnQtY2FyZCcpLmxlbmd0aCkge1xuXHRcdFx0IGluaXRpYWxpemVFdmVudHMoKTtcblx0XHRcdCB2YWxpZGF0b3IuaW5pdEZvcm0oJ2Zvcm0ucGRwRm9ybScpO1xuXHRcdFx0IHV0aWwubGltaXRDaGFyYWN0ZXJzKCk7XG5cdFx0fVxuXHR9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWpheCA9IHJlcXVpcmUoJy4vYWpheCcpLFxuICAgIG1pbmljYXJ0ID0gcmVxdWlyZSgnLi9taW5pY2FydCcpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIHNldEFkZFRvQ2FydEhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgZm9ybSA9ICQodGhpcykuY2xvc2VzdCgnZm9ybScpO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIHVybDogdXRpbC5hamF4VXJsKGZvcm0uYXR0cignYWN0aW9uJykpLFxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgY2FjaGU6IGZhbHNlLFxuICAgICAgICBkYXRhOiBmb3JtLnNlcmlhbGl6ZSgpXG4gICAgfTtcbiAgICAkLmFqYXgob3B0aW9ucykuZG9uZShmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGFqYXgubG9hZCh7XG4gICAgICAgICAgICAgICAgdXJsOiBVcmxzLm1pbmljYXJ0R0MsXG4gICAgICAgICAgICAgICAgZGF0YToge2xpbmVJdGVtSWQ6IHJlc3BvbnNlLnJlc3VsdC5saW5lSXRlbUlkfSxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbmljYXJ0LnNob3cocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICBmb3JtLmZpbmQoJ2lucHV0LHRleHRhcmVhJykudmFsKCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcm0uZmluZCgnc3Bhbi5lcnJvcicpLmhpZGUoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGlkIGluIHJlc3BvbnNlLmVycm9ycy5Gb3JtRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgdmFyICRlcnJvckVsID0gJCgnIycgKyBpZCkuYWRkQ2xhc3MoJ2Vycm9yJykucmVtb3ZlQ2xhc3MoJ3ZhbGlkJykubmV4dCgnLmVycm9yJyk7XG4gICAgICAgICAgICAgICAgaWYgKCEkZXJyb3JFbCB8fCAkZXJyb3JFbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgJGVycm9yRWwgPSAkKCc8c3BhbiBmb3I9XCInICsgaWQgKyAnXCIgZ2VuZXJhdGVkPVwidHJ1ZVwiIGNsYXNzPVwiZXJyb3JcIiBzdHlsZT1cIlwiPjwvc3Bhbj4nKTtcbiAgICAgICAgICAgICAgICAgICAgJCgnIycgKyBpZCkuYWZ0ZXIoJGVycm9yRWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkZXJyb3JFbC50ZXh0KHJlc3BvbnNlLmVycm9ycy5Gb3JtRXJyb3JzW2lkXS5yZXBsYWNlKC9cXFxcJy9nLCAnXFwnJykpLnNob3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pLmZhaWwoZnVuY3Rpb24gKHhociwgdGV4dFN0YXR1cykge1xuICAgICAgICAvLyBmYWlsZWRcbiAgICAgICAgaWYgKHRleHRTdGF0dXMgPT09ICdwYXJzZXJlcnJvcicpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hbGVydChSZXNvdXJjZXMuQkFEX1JFU1BPTlNFKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5hbGVydChSZXNvdXJjZXMuU0VSVkVSX0NPTk5FQ1RJT05fRVJST1IpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgJCgnI0FkZFRvQmFza2V0QnV0dG9uJykub24oJ2NsaWNrJywgc2V0QWRkVG9DYXJ0SGFuZGxlcik7XG59O1xuIiwiLyohIEltYWdlIE1hcCBSZXNpemVyXG4gKiAgRGVzYzogUmVzaXplIEhUTUwgaW1hZ2VNYXAgdG8gc2NhbGVkIGltYWdlLlxuICogIENvcHlyaWdodDogKGMpIDIwMTQtMTUgRGF2aWQgSi4gQnJhZHNoYXcgLSBkYXZlQGJyYWRzaGF3Lm5ldFxuICogIExpY2Vuc2U6IE1JVFxuICovXG5cbihmdW5jdGlvbigpe1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGZ1bmN0aW9uIHNjYWxlSW1hZ2VNYXAoKXtcblxuICAgICAgICBmdW5jdGlvbiByZXNpemVNYXAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiByZXNpemVBcmVhVGFnKGNhY2hlZEFyZWFDb29yZHMsaWR4KXtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzY2FsZShjb29yZCl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaW1lbnNpb24gPSAoIDEgPT09IChpc1dpZHRoID0gMS1pc1dpZHRoKSA/ICd3aWR0aCcgOiAnaGVpZ2h0JyApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihOdW1iZXIoY29vcmQpICogc2NhbGxpbmdGYWN0b3JbZGltZW5zaW9uXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGlzV2lkdGggPSAwO1xuXG4gICAgICAgICAgICAgICAgYXJlYXNbaWR4XS5jb29yZHMgPSBjYWNoZWRBcmVhQ29vcmRzLnNwbGl0KCcsJykubWFwKHNjYWxlKS5qb2luKCcsJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzY2FsbGluZ0ZhY3RvciA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aCAgOiBpbWFnZS53aWR0aCAgLyBpbWFnZS5uYXR1cmFsV2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0IDogaW1hZ2UuaGVpZ2h0IC8gaW1hZ2UubmF0dXJhbEhlaWdodFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY2FjaGVkQXJlYUNvb3Jkc0FycmF5LmZvckVhY2gocmVzaXplQXJlYVRhZyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRDb29yZHMoZSl7XG4gICAgICAgICAgICAvL05vcm1hbGl6ZSBjb29yZC1zdHJpbmcgdG8gY3N2IGZvcm1hdCB3aXRob3V0IGFueSBzcGFjZSBjaGFyc1xuICAgICAgICAgICAgcmV0dXJuIGUuY29vcmRzLnJlcGxhY2UoLyAqLCAqL2csJywnKS5yZXBsYWNlKC8gKy9nLCcsJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkZWJvdW5jZSgpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQocmVzaXplTWFwLCAyNTApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc3RhcnQoKXtcbiAgICAgICAgICAgIGlmICgoaW1hZ2Uud2lkdGggIT09IGltYWdlLm5hdHVyYWxXaWR0aCkgfHwgKGltYWdlLmhlaWdodCAhPT0gaW1hZ2UubmF0dXJhbEhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICByZXNpemVNYXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJzKCl7XG4gICAgICAgICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgIHJlc2l6ZU1hcCwgZmFsc2UpOyAvL0RldGVjdCBsYXRlIGltYWdlIGxvYWRzIGluIElFMTFcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsICByZXNpemVNYXAsIGZhbHNlKTsgLy9Db3BlIHdpdGggd2luZG93IGJlaW5nIHJlc2l6ZWQgd2hpbHN0IG9uIGFub3RoZXIgdGFiXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZGVib3VuY2UsICBmYWxzZSk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVhZHlzdGF0ZWNoYW5nZScsIHJlc2l6ZU1hcCwgIGZhbHNlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnLCByZXNpemVNYXAsICBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBiZWVuSGVyZSgpe1xuICAgICAgICAgICAgcmV0dXJuICgnZnVuY3Rpb24nID09PSB0eXBlb2YgbWFwLl9yZXNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0dXAoKXtcbiAgICAgICAgICAgIGFyZWFzICAgICAgICAgICAgICAgICA9IG1hcC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYXJlYScpO1xuICAgICAgICAgICAgY2FjaGVkQXJlYUNvb3Jkc0FycmF5ID0gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGFyZWFzLCBnZXRDb29yZHMpO1xuICAgICAgICAgICAgaW1hZ2UgICAgICAgICAgICAgICAgID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW1nW3VzZW1hcD1cIiMnK21hcC5uYW1lKydcIl0nKTtcbiAgICAgICAgICAgIG1hcC5fcmVzaXplICAgICAgICAgICA9IHJlc2l6ZU1hcDsgLy9CaW5kIHJlc2l6ZSBtZXRob2QgdG8gSFRNTCBtYXAgZWxlbWVudFxuICAgICAgICB9XG5cbiAgICAgICAgdmFyXG4gICAgICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICAgICAgbWFwICAgPSB0aGlzLFxuICAgICAgICAgICAgYXJlYXMgPSBudWxsLCBjYWNoZWRBcmVhQ29vcmRzQXJyYXkgPSBudWxsLCBpbWFnZSA9IG51bGwsIHRpbWVyID0gbnVsbDtcblxuICAgICAgICBpZiAoIWJlZW5IZXJlKCkpe1xuICAgICAgICAgICAgc2V0dXAoKTtcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBzdGFydCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFwLl9yZXNpemUoKTsgLy9BbHJlYWR5IHNldHVwLCBzbyBqdXN0IHJlc2l6ZSBtYXBcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbiAgICBmdW5jdGlvbiBmYWN0b3J5KCl7XG4gICAgICAgIGZ1bmN0aW9uIGNoa01hcChlbGVtZW50KXtcbiAgICAgICAgICAgIGlmKCFlbGVtZW50LnRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QgaXMgbm90IGEgdmFsaWQgRE9NIGVsZW1lbnQnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJ01BUCcgIT09IGVsZW1lbnQudGFnTmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgPE1BUD4gdGFnLCBmb3VuZCA8JytlbGVtZW50LnRhZ05hbWUrJz4uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbml0KGVsZW1lbnQpe1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQpe1xuICAgICAgICAgICAgICAgIGNoa01hcChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBzY2FsZUltYWdlTWFwLmNhbGwoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgbWFwcy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hcHM7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGltYWdlTWFwUmVzaXplRih0YXJnZXQpe1xuICAgICAgICAgICAgbWFwcyA9IFtdOyAgLy8gT25seSByZXR1cm4gbWFwcyBmcm9tIHRoaXMgY2FsbFxuXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZih0YXJnZXQpKXtcbiAgICAgICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0YXJnZXR8fCdtYXAnKSxpbml0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgaW5pdCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGRhdGEgdHlwZSAoJyt0eXBlb2YgdGFyZ2V0KycpLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWFwcztcbiAgICAgICAgfTtcbiAgICB9XG5cblxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtdLGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSAnb2JqZWN0Jyl7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpOyAvL05vZGUgZm9yIGJyb3dzZXJmeVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5pbWFnZU1hcFJlc2l6ZSA9IGZhY3RvcnkoKTtcbiAgICB9XG5cblxuICAgIGlmKCdqUXVlcnknIGluIHdpbmRvdykge1xuICAgICAgICBqUXVlcnkuZm4uaW1hZ2VNYXBSZXNpemUgPSBmdW5jdGlvbiAkaW1hZ2VNYXBSZXNpemVGKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoJ21hcCcpLmVhY2goc2NhbGVJbWFnZU1hcCkuZW5kKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG59KSgpOyIsIi8qKlxuICogaW50ZXJhY3QuanMgdjEuMi42XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTUgVGF5ZSBBZGV5ZW1pIDxkZXZAdGF5ZS5tZT5cbiAqIE9wZW4gc291cmNlIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vdGF5ZS9pbnRlcmFjdC5qcy9tYXN0ZXIvTElDRU5TRVxuICovXG4oZnVuY3Rpb24gKHJlYWxXaW5kb3cpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLyByZXR1cm4gZWFybHkgaWYgdGhlcmUncyBubyB3aW5kb3cgdG8gd29yayB3aXRoIChlZy4gTm9kZS5qcylcbiAgICBpZiAoIXJlYWxXaW5kb3cpIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgLy8gZ2V0IHdyYXBwZWQgd2luZG93IGlmIHVzaW5nIFNoYWRvdyBET00gcG9seWZpbGxcbiAgICAgICAgd2luZG93ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIFRleHROb2RlXG4gICAgICAgICAgICB2YXIgZWwgPSByZWFsV2luZG93LmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgaXQncyB3cmFwcGVkIGJ5IGEgcG9seWZpbGxcbiAgICAgICAgICAgIGlmIChlbC5vd25lckRvY3VtZW50ICE9PSByZWFsV2luZG93LmRvY3VtZW50XG4gICAgICAgICAgICAgICAgJiYgdHlwZW9mIHJlYWxXaW5kb3cud3JhcCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICYmIHJlYWxXaW5kb3cud3JhcChlbCkgPT09IGVsKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHdyYXBwZWQgd2luZG93XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWxXaW5kb3cud3JhcChyZWFsV2luZG93KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm8gU2hhZG93IERPTSBwb2x5ZmlsIG9yIG5hdGl2ZSBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgcmV0dXJuIHJlYWxXaW5kb3c7XG4gICAgICAgIH0oKSksXG5cbiAgICAgICAgZG9jdW1lbnQgICAgICAgICAgID0gd2luZG93LmRvY3VtZW50LFxuICAgICAgICBEb2N1bWVudEZyYWdtZW50ICAgPSB3aW5kb3cuRG9jdW1lbnRGcmFnbWVudCAgIHx8IGJsYW5rLFxuICAgICAgICBTVkdFbGVtZW50ICAgICAgICAgPSB3aW5kb3cuU1ZHRWxlbWVudCAgICAgICAgIHx8IGJsYW5rLFxuICAgICAgICBTVkdTVkdFbGVtZW50ICAgICAgPSB3aW5kb3cuU1ZHU1ZHRWxlbWVudCAgICAgIHx8IGJsYW5rLFxuICAgICAgICBTVkdFbGVtZW50SW5zdGFuY2UgPSB3aW5kb3cuU1ZHRWxlbWVudEluc3RhbmNlIHx8IGJsYW5rLFxuICAgICAgICBIVE1MRWxlbWVudCAgICAgICAgPSB3aW5kb3cuSFRNTEVsZW1lbnQgICAgICAgIHx8IHdpbmRvdy5FbGVtZW50LFxuXG4gICAgICAgIFBvaW50ZXJFdmVudCA9ICh3aW5kb3cuUG9pbnRlckV2ZW50IHx8IHdpbmRvdy5NU1BvaW50ZXJFdmVudCksXG4gICAgICAgIHBFdmVudFR5cGVzLFxuXG4gICAgICAgIGh5cG90ID0gTWF0aC5oeXBvdCB8fCBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpOyB9LFxuXG4gICAgICAgIHRtcFhZID0ge30sICAgICAvLyByZWR1Y2Ugb2JqZWN0IGNyZWF0aW9uIGluIGdldFhZKClcblxuICAgICAgICBkb2N1bWVudHMgICAgICAgPSBbXSwgICAvLyBhbGwgZG9jdW1lbnRzIGJlaW5nIGxpc3RlbmVkIHRvXG5cbiAgICAgICAgaW50ZXJhY3RhYmxlcyAgID0gW10sICAgLy8gYWxsIHNldCBpbnRlcmFjdGFibGVzXG4gICAgICAgIGludGVyYWN0aW9ucyAgICA9IFtdLCAgIC8vIGFsbCBpbnRlcmFjdGlvbnNcblxuICAgICAgICBkeW5hbWljRHJvcCAgICAgPSBmYWxzZSxcblxuICAgICAgICAvLyB7XG4gICAgICAgIC8vICAgICAgdHlwZToge1xuICAgICAgICAvLyAgICAgICAgICBzZWxlY3RvcnM6IFsnc2VsZWN0b3InLCAuLi5dLFxuICAgICAgICAvLyAgICAgICAgICBjb250ZXh0cyA6IFtkb2N1bWVudCwgLi4uXSxcbiAgICAgICAgLy8gICAgICAgICAgbGlzdGVuZXJzOiBbW2xpc3RlbmVyLCB1c2VDYXB0dXJlXSwgLi4uXVxuICAgICAgICAvLyAgICAgIH1cbiAgICAgICAgLy8gIH1cbiAgICAgICAgZGVsZWdhdGVkRXZlbnRzID0ge30sXG5cbiAgICAgICAgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBiYXNlOiB7XG4gICAgICAgICAgICAgICAgYWNjZXB0ICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgYWN0aW9uQ2hlY2tlciA6IG51bGwsXG4gICAgICAgICAgICAgICAgc3R5bGVDdXJzb3IgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICBvcmlnaW4gICAgICAgIDogeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgICAgICAgZGVsdGFTb3VyY2UgICA6ICdwYWdlJyxcbiAgICAgICAgICAgICAgICBhbGxvd0Zyb20gICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBpZ25vcmVGcm9tICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBfY29udGV4dCAgICAgIDogZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgZHJvcENoZWNrZXIgICA6IG51bGxcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGRyYWc6IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtYW51YWxTdGFydDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtYXg6IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIG1heFBlckVsZW1lbnQ6IDEsXG5cbiAgICAgICAgICAgICAgICBzbmFwOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlc3RyaWN0OiBudWxsLFxuICAgICAgICAgICAgICAgIGluZXJ0aWE6IG51bGwsXG4gICAgICAgICAgICAgICAgYXV0b1Njcm9sbDogbnVsbCxcblxuICAgICAgICAgICAgICAgIGF4aXM6ICd4eSdcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGRyb3A6IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhY2NlcHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgb3ZlcmxhcDogJ3BvaW50ZXInXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICByZXNpemU6IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtYW51YWxTdGFydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWF4OiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICBtYXhQZXJFbGVtZW50OiAxLFxuXG4gICAgICAgICAgICAgICAgc25hcDogbnVsbCxcbiAgICAgICAgICAgICAgICByZXN0cmljdDogbnVsbCxcbiAgICAgICAgICAgICAgICBpbmVydGlhOiBudWxsLFxuICAgICAgICAgICAgICAgIGF1dG9TY3JvbGw6IG51bGwsXG5cbiAgICAgICAgICAgICAgICBzcXVhcmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IGZhbHNlLFxuICAgICAgICAgICAgICAgIGF4aXM6ICd4eScsXG5cbiAgICAgICAgICAgICAgICAvLyB1c2UgZGVmYXVsdCBtYXJnaW5cbiAgICAgICAgICAgICAgICBtYXJnaW46IE5hTixcblxuICAgICAgICAgICAgICAgIC8vIG9iamVjdCB3aXRoIHByb3BzIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSB3aGljaCBhcmVcbiAgICAgICAgICAgICAgICAvLyB0cnVlL2ZhbHNlIHZhbHVlcyB0byByZXNpemUgd2hlbiB0aGUgcG9pbnRlciBpcyBvdmVyIHRoYXQgZWRnZSxcbiAgICAgICAgICAgICAgICAvLyBDU1Mgc2VsZWN0b3JzIHRvIG1hdGNoIHRoZSBoYW5kbGVzIGZvciBlYWNoIGRpcmVjdGlvblxuICAgICAgICAgICAgICAgIC8vIG9yIHRoZSBFbGVtZW50cyBmb3IgZWFjaCBoYW5kbGVcbiAgICAgICAgICAgICAgICBlZGdlczogbnVsbCxcblxuICAgICAgICAgICAgICAgIC8vIGEgdmFsdWUgb2YgJ25vbmUnIHdpbGwgbGltaXQgdGhlIHJlc2l6ZSByZWN0IHRvIGEgbWluaW11bSBvZiAweDBcbiAgICAgICAgICAgICAgICAvLyAnbmVnYXRlJyB3aWxsIGFsb3cgdGhlIHJlY3QgdG8gaGF2ZSBuZWdhdGl2ZSB3aWR0aC9oZWlnaHRcbiAgICAgICAgICAgICAgICAvLyAncmVwb3NpdGlvbicgd2lsbCBrZWVwIHRoZSB3aWR0aC9oZWlnaHQgcG9zaXRpdmUgYnkgc3dhcHBpbmdcbiAgICAgICAgICAgICAgICAvLyB0aGUgdG9wIGFuZCBib3R0b20gZWRnZXMgYW5kL29yIHN3YXBwaW5nIHRoZSBsZWZ0IGFuZCByaWdodCBlZGdlc1xuICAgICAgICAgICAgICAgIGludmVydDogJ25vbmUnXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXN0dXJlOiB7XG4gICAgICAgICAgICAgICAgbWFudWFsU3RhcnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1heDogSW5maW5pdHksXG4gICAgICAgICAgICAgICAgbWF4UGVyRWxlbWVudDogMSxcblxuICAgICAgICAgICAgICAgIHJlc3RyaWN0OiBudWxsXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwZXJBY3Rpb246IHtcbiAgICAgICAgICAgICAgICBtYW51YWxTdGFydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWF4OiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICBtYXhQZXJFbGVtZW50OiAxLFxuXG4gICAgICAgICAgICAgICAgc25hcDoge1xuICAgICAgICAgICAgICAgICAgICBlbmFibGVkICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlbmRPbmx5ICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByYW5nZSAgICAgICA6IEluZmluaXR5LFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRzICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldHMgICAgIDogbnVsbCxcblxuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVBvaW50czogbnVsbFxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICByZXN0cmljdDoge1xuICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kT25seTogZmFsc2VcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgYXV0b1Njcm9sbDoge1xuICAgICAgICAgICAgICAgICAgICBlbmFibGVkICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIgICA6IG51bGwsICAgICAvLyB0aGUgaXRlbSB0aGF0IGlzIHNjcm9sbGVkIChXaW5kb3cgb3IgSFRNTEVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbiAgICAgIDogNjAsXG4gICAgICAgICAgICAgICAgICAgIHNwZWVkICAgICAgIDogMzAwICAgICAgIC8vIHRoZSBzY3JvbGwgc3BlZWQgaW4gcGl4ZWxzIHBlciBzZWNvbmRcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgaW5lcnRpYToge1xuICAgICAgICAgICAgICAgICAgICBlbmFibGVkICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlc2lzdGFuY2UgICAgICAgOiAxMCwgICAgLy8gdGhlIGxhbWJkYSBpbiBleHBvbmVudGlhbCBkZWNheVxuICAgICAgICAgICAgICAgICAgICBtaW5TcGVlZCAgICAgICAgIDogMTAwLCAgIC8vIHRhcmdldCBzcGVlZCBtdXN0IGJlIGFib3ZlIHRoaXMgZm9yIGluZXJ0aWEgdG8gc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgZW5kU3BlZWQgICAgICAgICA6IDEwLCAgICAvLyB0aGUgc3BlZWQgYXQgd2hpY2ggaW5lcnRpYSBpcyBzbG93IGVub3VnaCB0byBzdG9wXG4gICAgICAgICAgICAgICAgICAgIGFsbG93UmVzdW1lICAgICAgOiB0cnVlLCAgLy8gYWxsb3cgcmVzdW1pbmcgYW4gYWN0aW9uIGluIGluZXJ0aWEgcGhhc2VcbiAgICAgICAgICAgICAgICAgICAgemVyb1Jlc3VtZURlbHRhICA6IHRydWUsICAvLyBpZiBhbiBhY3Rpb24gaXMgcmVzdW1lZCBhZnRlciBsYXVuY2gsIHNldCBkeC9keSB0byAwXG4gICAgICAgICAgICAgICAgICAgIHNtb290aEVuZER1cmF0aW9uOiAzMDAgICAgLy8gYW5pbWF0ZSB0byBzbmFwL3Jlc3RyaWN0IGVuZE9ubHkgaWYgdGhlcmUncyBubyBpbmVydGlhXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgX2hvbGREdXJhdGlvbjogNjAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVGhpbmdzIHJlbGF0ZWQgdG8gYXV0b1Njcm9sbFxuICAgICAgICBhdXRvU2Nyb2xsID0ge1xuICAgICAgICAgICAgaW50ZXJhY3Rpb246IG51bGwsXG4gICAgICAgICAgICBpOiBudWxsLCAgICAvLyB0aGUgaGFuZGxlIHJldHVybmVkIGJ5IHdpbmRvdy5zZXRJbnRlcnZhbFxuICAgICAgICAgICAgeDogMCwgeTogMCwgLy8gRGlyZWN0aW9uIGVhY2ggcHVsc2UgaXMgdG8gc2Nyb2xsIGluXG5cbiAgICAgICAgICAgIC8vIHNjcm9sbCB0aGUgd2luZG93IGJ5IHRoZSB2YWx1ZXMgaW4gc2Nyb2xsLngveVxuICAgICAgICAgICAgc2Nyb2xsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBhdXRvU2Nyb2xsLmludGVyYWN0aW9uLnRhcmdldC5vcHRpb25zW2F1dG9TY3JvbGwuaW50ZXJhY3Rpb24ucHJlcGFyZWQubmFtZV0uYXV0b1Njcm9sbCxcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXIgfHwgZ2V0V2luZG93KGF1dG9TY3JvbGwuaW50ZXJhY3Rpb24uZWxlbWVudCksXG4gICAgICAgICAgICAgICAgICAgIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2UgaW4gdGltZSBpbiBzZWNvbmRzXG4gICAgICAgICAgICAgICAgICAgIGR0eCA9IChub3cgLSBhdXRvU2Nyb2xsLnByZXZUaW1lWCkgLyAxMDAwLFxuICAgICAgICAgICAgICAgICAgICBkdHkgPSAobm93IC0gYXV0b1Njcm9sbC5wcmV2VGltZVkpIC8gMTAwMCxcbiAgICAgICAgICAgICAgICAgICAgdngsIHZ5LCBzeCwgc3k7XG5cbiAgICAgICAgICAgICAgICAvLyBkaXNwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy52ZWxvY2l0eSkge1xuICAgICAgICAgICAgICAgICAgdnggPSBvcHRpb25zLnZlbG9jaXR5Lng7XG4gICAgICAgICAgICAgICAgICB2eSA9IG9wdGlvbnMudmVsb2NpdHkueTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2eCA9IHZ5ID0gb3B0aW9ucy5zcGVlZFxuICAgICAgICAgICAgICAgIH1cbiBcbiAgICAgICAgICAgICAgICBzeCA9IHZ4ICogZHR4O1xuICAgICAgICAgICAgICAgIHN5ID0gdnkgKiBkdHk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3ggPj0gMSB8fCBzeSA+PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvdyhjb250YWluZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuc2Nyb2xsQnkoYXV0b1Njcm9sbC54ICogc3gsIGF1dG9TY3JvbGwueSAqIHN5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zY3JvbGxMZWZ0ICs9IGF1dG9TY3JvbGwueCAqIHN4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCAgKz0gYXV0b1Njcm9sbC55ICogc3k7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3ggPj0xKSBhdXRvU2Nyb2xsLnByZXZUaW1lWCA9IG5vdztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN5ID49IDEpIGF1dG9TY3JvbGwucHJldlRpbWVZID0gbm93O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhdXRvU2Nyb2xsLmlzU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEZyYW1lKGF1dG9TY3JvbGwuaSk7XG4gICAgICAgICAgICAgICAgICAgIGF1dG9TY3JvbGwuaSA9IHJlcUZyYW1lKGF1dG9TY3JvbGwuc2Nyb2xsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpc1Njcm9sbGluZzogZmFsc2UsXG4gICAgICAgICAgICBwcmV2VGltZVg6IDAsXG4gICAgICAgICAgICBwcmV2VGltZVk6IDAsXG5cbiAgICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBhdXRvU2Nyb2xsLmlzU2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYW5jZWxGcmFtZShhdXRvU2Nyb2xsLmkpO1xuXG4gICAgICAgICAgICAgICAgYXV0b1Njcm9sbC5pbnRlcmFjdGlvbiA9IGludGVyYWN0aW9uO1xuICAgICAgICAgICAgICAgIGF1dG9TY3JvbGwucHJldlRpbWVYID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgYXV0b1Njcm9sbC5wcmV2VGltZVkgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICBhdXRvU2Nyb2xsLmkgPSByZXFGcmFtZShhdXRvU2Nyb2xsLnNjcm9sbCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgYXV0b1Njcm9sbC5pc1Njcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNhbmNlbEZyYW1lKGF1dG9TY3JvbGwuaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRG9lcyB0aGUgYnJvd3NlciBzdXBwb3J0IHRvdWNoIGlucHV0P1xuICAgICAgICBzdXBwb3J0c1RvdWNoID0gKCgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHx8IHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2gpLFxuXG4gICAgICAgIC8vIERvZXMgdGhlIGJyb3dzZXIgc3VwcG9ydCBQb2ludGVyRXZlbnRzXG4gICAgICAgIHN1cHBvcnRzUG9pbnRlckV2ZW50ID0gISFQb2ludGVyRXZlbnQsXG5cbiAgICAgICAgLy8gTGVzcyBQcmVjaXNpb24gd2l0aCB0b3VjaCBpbnB1dFxuICAgICAgICBtYXJnaW4gPSBzdXBwb3J0c1RvdWNoIHx8IHN1cHBvcnRzUG9pbnRlckV2ZW50PyAyMDogMTAsXG5cbiAgICAgICAgcG9pbnRlck1vdmVUb2xlcmFuY2UgPSAxLFxuXG4gICAgICAgIC8vIGZvciBpZ25vcmluZyBicm93c2VyJ3Mgc2ltdWxhdGVkIG1vdXNlIGV2ZW50c1xuICAgICAgICBwcmV2VG91Y2hUaW1lID0gMCxcblxuICAgICAgICAvLyBBbGxvdyB0aGlzIG1hbnkgaW50ZXJhY3Rpb25zIHRvIGhhcHBlbiBzaW11bHRhbmVvdXNseVxuICAgICAgICBtYXhJbnRlcmFjdGlvbnMgPSBJbmZpbml0eSxcblxuICAgICAgICAvLyBDaGVjayBpZiBpcyBJRTkgb3Igb2xkZXJcbiAgICAgICAgYWN0aW9uQ3Vyc29ycyA9IChkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKSA/IHtcbiAgICAgICAgICAgIGRyYWcgICAgOiAnbW92ZScsXG4gICAgICAgICAgICByZXNpemV4IDogJ2UtcmVzaXplJyxcbiAgICAgICAgICAgIHJlc2l6ZXkgOiAncy1yZXNpemUnLFxuICAgICAgICAgICAgcmVzaXpleHk6ICdzZS1yZXNpemUnLFxuXG4gICAgICAgICAgICByZXNpemV0b3AgICAgICAgIDogJ24tcmVzaXplJyxcbiAgICAgICAgICAgIHJlc2l6ZWxlZnQgICAgICAgOiAndy1yZXNpemUnLFxuICAgICAgICAgICAgcmVzaXplYm90dG9tICAgICA6ICdzLXJlc2l6ZScsXG4gICAgICAgICAgICByZXNpemVyaWdodCAgICAgIDogJ2UtcmVzaXplJyxcbiAgICAgICAgICAgIHJlc2l6ZXRvcGxlZnQgICAgOiAnc2UtcmVzaXplJyxcbiAgICAgICAgICAgIHJlc2l6ZWJvdHRvbXJpZ2h0OiAnc2UtcmVzaXplJyxcbiAgICAgICAgICAgIHJlc2l6ZXRvcHJpZ2h0ICAgOiAnbmUtcmVzaXplJyxcbiAgICAgICAgICAgIHJlc2l6ZWJvdHRvbWxlZnQgOiAnbmUtcmVzaXplJyxcblxuICAgICAgICAgICAgZ2VzdHVyZSA6ICcnXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgICBkcmFnICAgIDogJ21vdmUnLFxuICAgICAgICAgICAgcmVzaXpleCA6ICdldy1yZXNpemUnLFxuICAgICAgICAgICAgcmVzaXpleSA6ICducy1yZXNpemUnLFxuICAgICAgICAgICAgcmVzaXpleHk6ICdud3NlLXJlc2l6ZScsXG5cbiAgICAgICAgICAgIHJlc2l6ZXRvcCAgICAgICAgOiAnbnMtcmVzaXplJyxcbiAgICAgICAgICAgIHJlc2l6ZWxlZnQgICAgICAgOiAnZXctcmVzaXplJyxcbiAgICAgICAgICAgIHJlc2l6ZWJvdHRvbSAgICAgOiAnbnMtcmVzaXplJyxcbiAgICAgICAgICAgIHJlc2l6ZXJpZ2h0ICAgICAgOiAnZXctcmVzaXplJyxcbiAgICAgICAgICAgIHJlc2l6ZXRvcGxlZnQgICAgOiAnbndzZS1yZXNpemUnLFxuICAgICAgICAgICAgcmVzaXplYm90dG9tcmlnaHQ6ICdud3NlLXJlc2l6ZScsXG4gICAgICAgICAgICByZXNpemV0b3ByaWdodCAgIDogJ25lc3ctcmVzaXplJyxcbiAgICAgICAgICAgIHJlc2l6ZWJvdHRvbWxlZnQgOiAnbmVzdy1yZXNpemUnLFxuXG4gICAgICAgICAgICBnZXN0dXJlIDogJydcbiAgICAgICAgfSxcblxuICAgICAgICBhY3Rpb25Jc0VuYWJsZWQgPSB7XG4gICAgICAgICAgICBkcmFnICAgOiB0cnVlLFxuICAgICAgICAgICAgcmVzaXplIDogdHJ1ZSxcbiAgICAgICAgICAgIGdlc3R1cmU6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBiZWNhdXNlIFdlYmtpdCBhbmQgT3BlcmEgc3RpbGwgdXNlICdtb3VzZXdoZWVsJyBldmVudCB0eXBlXG4gICAgICAgIHdoZWVsRXZlbnQgPSAnb25tb3VzZXdoZWVsJyBpbiBkb2N1bWVudD8gJ21vdXNld2hlZWwnOiAnd2hlZWwnLFxuXG4gICAgICAgIGV2ZW50VHlwZXMgPSBbXG4gICAgICAgICAgICAnZHJhZ3N0YXJ0JyxcbiAgICAgICAgICAgICdkcmFnbW92ZScsXG4gICAgICAgICAgICAnZHJhZ2luZXJ0aWFzdGFydCcsXG4gICAgICAgICAgICAnZHJhZ2VuZCcsXG4gICAgICAgICAgICAnZHJhZ2VudGVyJyxcbiAgICAgICAgICAgICdkcmFnbGVhdmUnLFxuICAgICAgICAgICAgJ2Ryb3BhY3RpdmF0ZScsXG4gICAgICAgICAgICAnZHJvcGRlYWN0aXZhdGUnLFxuICAgICAgICAgICAgJ2Ryb3Btb3ZlJyxcbiAgICAgICAgICAgICdkcm9wJyxcbiAgICAgICAgICAgICdyZXNpemVzdGFydCcsXG4gICAgICAgICAgICAncmVzaXplbW92ZScsXG4gICAgICAgICAgICAncmVzaXplaW5lcnRpYXN0YXJ0JyxcbiAgICAgICAgICAgICdyZXNpemVlbmQnLFxuICAgICAgICAgICAgJ2dlc3R1cmVzdGFydCcsXG4gICAgICAgICAgICAnZ2VzdHVyZW1vdmUnLFxuICAgICAgICAgICAgJ2dlc3R1cmVpbmVydGlhc3RhcnQnLFxuICAgICAgICAgICAgJ2dlc3R1cmVlbmQnLFxuXG4gICAgICAgICAgICAnZG93bicsXG4gICAgICAgICAgICAnbW92ZScsXG4gICAgICAgICAgICAndXAnLFxuICAgICAgICAgICAgJ2NhbmNlbCcsXG4gICAgICAgICAgICAndGFwJyxcbiAgICAgICAgICAgICdkb3VibGV0YXAnLFxuICAgICAgICAgICAgJ2hvbGQnXG4gICAgICAgIF0sXG5cbiAgICAgICAgZ2xvYmFsRXZlbnRzID0ge30sXG5cbiAgICAgICAgLy8gT3BlcmEgTW9iaWxlIG11c3QgYmUgaGFuZGxlZCBkaWZmZXJlbnRseVxuICAgICAgICBpc09wZXJhTW9iaWxlID0gbmF2aWdhdG9yLmFwcE5hbWUgPT0gJ09wZXJhJyAmJlxuICAgICAgICAgICAgc3VwcG9ydHNUb3VjaCAmJlxuICAgICAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgnUHJlc3RvJyksXG5cbiAgICAgICAgLy8gc2Nyb2xsaW5nIGRvZXNuJ3QgY2hhbmdlIHRoZSByZXN1bHQgb2YgZ2V0Q2xpZW50UmVjdHMgb24gaU9TIDdcbiAgICAgICAgaXNJT1M3ID0gKC9pUChob25lfG9kfGFkKS8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgJiYgL09TIDdbXlxcZF0vLnRlc3QobmF2aWdhdG9yLmFwcFZlcnNpb24pKSxcblxuICAgICAgICAvLyBwcmVmaXggbWF0Y2hlc1NlbGVjdG9yXG4gICAgICAgIHByZWZpeGVkTWF0Y2hlc1NlbGVjdG9yID0gJ21hdGNoZXMnIGluIEVsZW1lbnQucHJvdG90eXBlP1xuICAgICAgICAgICAgICAgICdtYXRjaGVzJzogJ3dlYmtpdE1hdGNoZXNTZWxlY3RvcicgaW4gRWxlbWVudC5wcm90b3R5cGU/XG4gICAgICAgICAgICAgICAgICAgICd3ZWJraXRNYXRjaGVzU2VsZWN0b3InOiAnbW96TWF0Y2hlc1NlbGVjdG9yJyBpbiBFbGVtZW50LnByb3RvdHlwZT9cbiAgICAgICAgICAgICAgICAgICAgICAgICdtb3pNYXRjaGVzU2VsZWN0b3InOiAnb01hdGNoZXNTZWxlY3RvcicgaW4gRWxlbWVudC5wcm90b3R5cGU/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29NYXRjaGVzU2VsZWN0b3InOiAnbXNNYXRjaGVzU2VsZWN0b3InLFxuXG4gICAgICAgIC8vIHdpbGwgYmUgcG9seWZpbGwgZnVuY3Rpb24gaWYgYnJvd3NlciBpcyBJRThcbiAgICAgICAgaWU4TWF0Y2hlc1NlbGVjdG9yLFxuXG4gICAgICAgIC8vIG5hdGl2ZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgb3IgcG9seWZpbGxcbiAgICAgICAgcmVxRnJhbWUgPSByZWFsV2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSxcbiAgICAgICAgY2FuY2VsRnJhbWUgPSByZWFsV2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lLFxuXG4gICAgICAgIC8vIEV2ZW50cyB3cmFwcGVyXG4gICAgICAgIGV2ZW50cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdXNlQXR0YWNoRXZlbnQgPSAoJ2F0dGFjaEV2ZW50JyBpbiB3aW5kb3cpICYmICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIHdpbmRvdyksXG4gICAgICAgICAgICAgICAgYWRkRXZlbnQgICAgICAgPSB1c2VBdHRhY2hFdmVudD8gICdhdHRhY2hFdmVudCc6ICdhZGRFdmVudExpc3RlbmVyJyxcbiAgICAgICAgICAgICAgICByZW1vdmVFdmVudCAgICA9IHVzZUF0dGFjaEV2ZW50PyAgJ2RldGFjaEV2ZW50JzogJ3JlbW92ZUV2ZW50TGlzdGVuZXInLFxuICAgICAgICAgICAgICAgIG9uICAgICAgICAgICAgID0gdXNlQXR0YWNoRXZlbnQ/ICdvbic6ICcnLFxuXG4gICAgICAgICAgICAgICAgZWxlbWVudHMgICAgICAgICAgPSBbXSxcbiAgICAgICAgICAgICAgICB0YXJnZXRzICAgICAgICAgICA9IFtdLFxuICAgICAgICAgICAgICAgIGF0dGFjaGVkTGlzdGVuZXJzID0gW107XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZCAoZWxlbWVudCwgdHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudEluZGV4ID0gaW5kZXhPZihlbGVtZW50cywgZWxlbWVudCksXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldHNbZWxlbWVudEluZGV4XTtcblxuICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50czoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlQ291bnQ6IDBcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50SW5kZXggPSBlbGVtZW50cy5wdXNoKGVsZW1lbnQpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0cy5wdXNoKHRhcmdldCk7XG5cbiAgICAgICAgICAgICAgICAgICAgYXR0YWNoZWRMaXN0ZW5lcnMucHVzaCgodXNlQXR0YWNoRXZlbnQgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VwcGxpZWQ6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZWQgOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VDb3VudDogW11cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gOiBudWxsKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQuZXZlbnRzW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5ldmVudHNbdHlwZV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnR5cGVDb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghY29udGFpbnModGFyZ2V0LmV2ZW50c1t0eXBlXSwgbGlzdGVuZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZUF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gYXR0YWNoZWRMaXN0ZW5lcnNbZWxlbWVudEluZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lckluZGV4ID0gaW5kZXhPZihsaXN0ZW5lcnMuc3VwcGxpZWQsIGxpc3RlbmVyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdyYXBwZWQgPSBsaXN0ZW5lcnMud3JhcHBlZFtsaXN0ZW5lckluZGV4XSB8fCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50LmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC50YXJnZXQgPSBldmVudC5zcmNFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gZWxlbWVudDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCA9IGV2ZW50LnByZXZlbnREZWZhdWx0IHx8IHByZXZlbnREZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IGV2ZW50LnN0b3BQcm9wYWdhdGlvbiB8fCBzdG9wUHJvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIHx8IHN0b3BJbW1Qcm9wO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvbW91c2V8Y2xpY2svLnRlc3QoZXZlbnQudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnBhZ2VYID0gZXZlbnQuY2xpZW50WCArIGdldFdpbmRvdyhlbGVtZW50KS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnBhZ2VZID0gZXZlbnQuY2xpZW50WSArIGdldFdpbmRvdyhlbGVtZW50KS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IGVsZW1lbnRbYWRkRXZlbnRdKG9uICsgdHlwZSwgd3JhcHBlZCwgQm9vbGVhbih1c2VDYXB0dXJlKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lckluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zdXBwbGllZC5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMud3JhcHBlZC5wdXNoKHdyYXBwZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy51c2VDb3VudC5wdXNoKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnVzZUNvdW50W2xpc3RlbmVySW5kZXhdKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBlbGVtZW50W2FkZEV2ZW50XSh0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSB8fCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmV2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlIChlbGVtZW50LCB0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICAgICAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50SW5kZXggPSBpbmRleE9mKGVsZW1lbnRzLCBlbGVtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0c1tlbGVtZW50SW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMsXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVySW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZWQgPSBsaXN0ZW5lcjtcblxuICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0IHx8ICF0YXJnZXQuZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodXNlQXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gYXR0YWNoZWRMaXN0ZW5lcnNbZWxlbWVudEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJJbmRleCA9IGluZGV4T2YobGlzdGVuZXJzLnN1cHBsaWVkLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZWQgPSBsaXN0ZW5lcnMud3JhcHBlZFtsaXN0ZW5lckluZGV4XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh0eXBlIGluIHRhcmdldC5ldmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuZXZlbnRzLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKGVsZW1lbnQsIHR5cGUsICdhbGwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5ldmVudHNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHRhcmdldC5ldmVudHNbdHlwZV0ubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lciA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShlbGVtZW50LCB0eXBlLCB0YXJnZXQuZXZlbnRzW3R5cGVdW2ldLCBCb29sZWFuKHVzZUNhcHR1cmUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuZXZlbnRzW3R5cGVdW2ldID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50W3JlbW92ZUV2ZW50XShvbiArIHR5cGUsIHdyYXBwZWQsIHVzZUNhcHR1cmUgfHwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuZXZlbnRzW3R5cGVdLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlQXR0YWNoRXZlbnQgJiYgbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMudXNlQ291bnRbbGlzdGVuZXJJbmRleF0tLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMudXNlQ291bnRbbGlzdGVuZXJJbmRleF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3VwcGxpZWQuc3BsaWNlKGxpc3RlbmVySW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy53cmFwcGVkLnNwbGljZShsaXN0ZW5lckluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMudXNlQ291bnQuc3BsaWNlKGxpc3RlbmVySW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC5ldmVudHNbdHlwZV0gJiYgdGFyZ2V0LmV2ZW50c1t0eXBlXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5ldmVudHNbdHlwZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnR5cGVDb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQudHlwZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldHMuc3BsaWNlKGVsZW1lbnRJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnNwbGljZShlbGVtZW50SW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBhdHRhY2hlZExpc3RlbmVycy5zcGxpY2UoZWxlbWVudEluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHByZXZlbnREZWYgKCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc3RvcFByb3AgKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc3RvcEltbVByb3AgKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWRkOiBhZGQsXG4gICAgICAgICAgICAgICAgcmVtb3ZlOiByZW1vdmUsXG4gICAgICAgICAgICAgICAgdXNlQXR0YWNoRXZlbnQ6IHVzZUF0dGFjaEV2ZW50LFxuXG4gICAgICAgICAgICAgICAgX2VsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICBfdGFyZ2V0czogdGFyZ2V0cyxcbiAgICAgICAgICAgICAgICBfYXR0YWNoZWRMaXN0ZW5lcnM6IGF0dGFjaGVkTGlzdGVuZXJzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KCkpO1xuXG4gICAgZnVuY3Rpb24gYmxhbmsgKCkge31cblxuICAgIGZ1bmN0aW9uIGlzRWxlbWVudCAobykge1xuICAgICAgICBpZiAoIW8gfHwgKHR5cGVvZiBvICE9PSAnb2JqZWN0JykpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgICAgdmFyIF93aW5kb3cgPSBnZXRXaW5kb3cobykgfHwgd2luZG93O1xuXG4gICAgICAgIHJldHVybiAoL29iamVjdHxmdW5jdGlvbi8udGVzdCh0eXBlb2YgX3dpbmRvdy5FbGVtZW50KVxuICAgICAgICAgICAgPyBvIGluc3RhbmNlb2YgX3dpbmRvdy5FbGVtZW50IC8vRE9NMlxuICAgICAgICAgICAgOiBvLm5vZGVUeXBlID09PSAxICYmIHR5cGVvZiBvLm5vZGVOYW1lID09PSBcInN0cmluZ1wiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNXaW5kb3cgKHRoaW5nKSB7IHJldHVybiB0aGluZyA9PT0gd2luZG93IHx8ICEhKHRoaW5nICYmIHRoaW5nLldpbmRvdykgJiYgKHRoaW5nIGluc3RhbmNlb2YgdGhpbmcuV2luZG93KTsgfVxuICAgIGZ1bmN0aW9uIGlzRG9jRnJhZyAodGhpbmcpIHsgcmV0dXJuICEhdGhpbmcgJiYgdGhpbmcgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50OyB9XG4gICAgZnVuY3Rpb24gaXNBcnJheSAodGhpbmcpIHtcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHRoaW5nKVxuICAgICAgICAgICAgICAgICYmICh0eXBlb2YgdGhpbmcubGVuZ3RoICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgJiYgaXNGdW5jdGlvbih0aGluZy5zcGxpY2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc09iamVjdCAgICh0aGluZykgeyByZXR1cm4gISF0aGluZyAmJiAodHlwZW9mIHRoaW5nID09PSAnb2JqZWN0Jyk7IH1cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uICh0aGluZykgeyByZXR1cm4gdHlwZW9mIHRoaW5nID09PSAnZnVuY3Rpb24nOyB9XG4gICAgZnVuY3Rpb24gaXNOdW1iZXIgICAodGhpbmcpIHsgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gJ251bWJlcicgIDsgfVxuICAgIGZ1bmN0aW9uIGlzQm9vbCAgICAgKHRoaW5nKSB7IHJldHVybiB0eXBlb2YgdGhpbmcgPT09ICdib29sZWFuJyA7IH1cbiAgICBmdW5jdGlvbiBpc1N0cmluZyAgICh0aGluZykgeyByZXR1cm4gdHlwZW9mIHRoaW5nID09PSAnc3RyaW5nJyAgOyB9XG5cbiAgICBmdW5jdGlvbiB0cnlTZWxlY3RvciAodmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc1N0cmluZyh2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgICAgLy8gYW4gZXhjZXB0aW9uIHdpbGwgYmUgcmFpc2VkIGlmIGl0IGlzIGludmFsaWRcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZCAoZGVzdCwgc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBkZXN0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cblxuICAgIHZhciBwcmVmaXhlZFByb3BSRXMgPSB7XG4gICAgICB3ZWJraXQ6IC8oTW92ZW1lbnRbWFldfFJhZGl1c1tYWV18Um90YXRpb25BbmdsZXxGb3JjZSkkL1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwb2ludGVyRXh0ZW5kIChkZXN0LCBzb3VyY2UpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICB2YXIgZGVwcmVjYXRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgLy8gc2tpcCBkZXByZWNhdGVkIHByZWZpeGVkIHByb3BlcnRpZXNcbiAgICAgICAgICBmb3IgKHZhciB2ZW5kb3IgaW4gcHJlZml4ZWRQcm9wUkVzKSB7XG4gICAgICAgICAgICBpZiAocHJvcC5pbmRleE9mKHZlbmRvcikgPT09IDAgJiYgcHJlZml4ZWRQcm9wUkVzW3ZlbmRvcl0udGVzdChwcm9wKSkge1xuICAgICAgICAgICAgICBkZXByZWNhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFkZXByZWNhdGVkKSB7XG4gICAgICAgICAgICBkZXN0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb3B5Q29vcmRzIChkZXN0LCBzcmMpIHtcbiAgICAgICAgZGVzdC5wYWdlID0gZGVzdC5wYWdlIHx8IHt9O1xuICAgICAgICBkZXN0LnBhZ2UueCA9IHNyYy5wYWdlLng7XG4gICAgICAgIGRlc3QucGFnZS55ID0gc3JjLnBhZ2UueTtcblxuICAgICAgICBkZXN0LmNsaWVudCA9IGRlc3QuY2xpZW50IHx8IHt9O1xuICAgICAgICBkZXN0LmNsaWVudC54ID0gc3JjLmNsaWVudC54O1xuICAgICAgICBkZXN0LmNsaWVudC55ID0gc3JjLmNsaWVudC55O1xuXG4gICAgICAgIGRlc3QudGltZVN0YW1wID0gc3JjLnRpbWVTdGFtcDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRFdmVudFhZICh0YXJnZXRPYmosIHBvaW50ZXJzLCBpbnRlcmFjdGlvbikge1xuICAgICAgICB2YXIgcG9pbnRlciA9IChwb2ludGVycy5sZW5ndGggPiAxXG4gICAgICAgICAgICAgICAgICAgICAgID8gcG9pbnRlckF2ZXJhZ2UocG9pbnRlcnMpXG4gICAgICAgICAgICAgICAgICAgICAgIDogcG9pbnRlcnNbMF0pO1xuXG4gICAgICAgIGdldFBhZ2VYWShwb2ludGVyLCB0bXBYWSwgaW50ZXJhY3Rpb24pO1xuICAgICAgICB0YXJnZXRPYmoucGFnZS54ID0gdG1wWFkueDtcbiAgICAgICAgdGFyZ2V0T2JqLnBhZ2UueSA9IHRtcFhZLnk7XG5cbiAgICAgICAgZ2V0Q2xpZW50WFkocG9pbnRlciwgdG1wWFksIGludGVyYWN0aW9uKTtcbiAgICAgICAgdGFyZ2V0T2JqLmNsaWVudC54ID0gdG1wWFkueDtcbiAgICAgICAgdGFyZ2V0T2JqLmNsaWVudC55ID0gdG1wWFkueTtcblxuICAgICAgICB0YXJnZXRPYmoudGltZVN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0RXZlbnREZWx0YXMgKHRhcmdldE9iaiwgcHJldiwgY3VyKSB7XG4gICAgICAgIHRhcmdldE9iai5wYWdlLnggICAgID0gY3VyLnBhZ2UueCAgICAgIC0gcHJldi5wYWdlLng7XG4gICAgICAgIHRhcmdldE9iai5wYWdlLnkgICAgID0gY3VyLnBhZ2UueSAgICAgIC0gcHJldi5wYWdlLnk7XG4gICAgICAgIHRhcmdldE9iai5jbGllbnQueCAgID0gY3VyLmNsaWVudC54ICAgIC0gcHJldi5jbGllbnQueDtcbiAgICAgICAgdGFyZ2V0T2JqLmNsaWVudC55ICAgPSBjdXIuY2xpZW50LnkgICAgLSBwcmV2LmNsaWVudC55O1xuICAgICAgICB0YXJnZXRPYmoudGltZVN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBwcmV2LnRpbWVTdGFtcDtcblxuICAgICAgICAvLyBzZXQgcG9pbnRlciB2ZWxvY2l0eVxuICAgICAgICB2YXIgZHQgPSBNYXRoLm1heCh0YXJnZXRPYmoudGltZVN0YW1wIC8gMTAwMCwgMC4wMDEpO1xuICAgICAgICB0YXJnZXRPYmoucGFnZS5zcGVlZCAgID0gaHlwb3QodGFyZ2V0T2JqLnBhZ2UueCwgdGFyZ2V0T2JqLnBhZ2UueSkgLyBkdDtcbiAgICAgICAgdGFyZ2V0T2JqLnBhZ2UudnggICAgICA9IHRhcmdldE9iai5wYWdlLnggLyBkdDtcbiAgICAgICAgdGFyZ2V0T2JqLnBhZ2UudnkgICAgICA9IHRhcmdldE9iai5wYWdlLnkgLyBkdDtcblxuICAgICAgICB0YXJnZXRPYmouY2xpZW50LnNwZWVkID0gaHlwb3QodGFyZ2V0T2JqLmNsaWVudC54LCB0YXJnZXRPYmoucGFnZS55KSAvIGR0O1xuICAgICAgICB0YXJnZXRPYmouY2xpZW50LnZ4ICAgID0gdGFyZ2V0T2JqLmNsaWVudC54IC8gZHQ7XG4gICAgICAgIHRhcmdldE9iai5jbGllbnQudnkgICAgPSB0YXJnZXRPYmouY2xpZW50LnkgLyBkdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc05hdGl2ZVBvaW50ZXIgKHBvaW50ZXIpIHtcbiAgICAgICAgcmV0dXJuIChwb2ludGVyIGluc3RhbmNlb2Ygd2luZG93LkV2ZW50XG4gICAgICAgICAgICB8fCAoc3VwcG9ydHNUb3VjaCAmJiB3aW5kb3cuVG91Y2ggJiYgcG9pbnRlciBpbnN0YW5jZW9mIHdpbmRvdy5Ub3VjaCkpO1xuICAgIH1cblxuICAgIC8vIEdldCBzcGVjaWZpZWQgWC9ZIGNvb3JkcyBmb3IgbW91c2Ugb3IgZXZlbnQudG91Y2hlc1swXVxuICAgIGZ1bmN0aW9uIGdldFhZICh0eXBlLCBwb2ludGVyLCB4eSkge1xuICAgICAgICB4eSA9IHh5IHx8IHt9O1xuICAgICAgICB0eXBlID0gdHlwZSB8fCAncGFnZSc7XG5cbiAgICAgICAgeHkueCA9IHBvaW50ZXJbdHlwZSArICdYJ107XG4gICAgICAgIHh5LnkgPSBwb2ludGVyW3R5cGUgKyAnWSddO1xuXG4gICAgICAgIHJldHVybiB4eTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYWdlWFkgKHBvaW50ZXIsIHBhZ2UpIHtcbiAgICAgICAgcGFnZSA9IHBhZ2UgfHwge307XG5cbiAgICAgICAgLy8gT3BlcmEgTW9iaWxlIGhhbmRsZXMgdGhlIHZpZXdwb3J0IGFuZCBzY3JvbGxpbmcgb2RkbHlcbiAgICAgICAgaWYgKGlzT3BlcmFNb2JpbGUgJiYgaXNOYXRpdmVQb2ludGVyKHBvaW50ZXIpKSB7XG4gICAgICAgICAgICBnZXRYWSgnc2NyZWVuJywgcG9pbnRlciwgcGFnZSk7XG5cbiAgICAgICAgICAgIHBhZ2UueCArPSB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgICAgICAgIHBhZ2UueSArPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdldFhZKCdwYWdlJywgcG9pbnRlciwgcGFnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFnZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDbGllbnRYWSAocG9pbnRlciwgY2xpZW50KSB7XG4gICAgICAgIGNsaWVudCA9IGNsaWVudCB8fCB7fTtcblxuICAgICAgICBpZiAoaXNPcGVyYU1vYmlsZSAmJiBpc05hdGl2ZVBvaW50ZXIocG9pbnRlcikpIHtcbiAgICAgICAgICAgIC8vIE9wZXJhIE1vYmlsZSBoYW5kbGVzIHRoZSB2aWV3cG9ydCBhbmQgc2Nyb2xsaW5nIG9kZGx5XG4gICAgICAgICAgICBnZXRYWSgnc2NyZWVuJywgcG9pbnRlciwgY2xpZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBnZXRYWSgnY2xpZW50JywgcG9pbnRlciwgY2xpZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbGllbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2Nyb2xsWFkgKHdpbikge1xuICAgICAgICB3aW4gPSB3aW4gfHwgd2luZG93O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogd2luLnNjcm9sbFggfHwgd2luLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgeTogd2luLnNjcm9sbFkgfHwgd2luLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQb2ludGVySWQgKHBvaW50ZXIpIHtcbiAgICAgICAgcmV0dXJuIGlzTnVtYmVyKHBvaW50ZXIucG9pbnRlcklkKT8gcG9pbnRlci5wb2ludGVySWQgOiBwb2ludGVyLmlkZW50aWZpZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QWN0dWFsRWxlbWVudCAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gKGVsZW1lbnQgaW5zdGFuY2VvZiBTVkdFbGVtZW50SW5zdGFuY2VcbiAgICAgICAgICAgID8gZWxlbWVudC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudFxuICAgICAgICAgICAgOiBlbGVtZW50KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXaW5kb3cgKG5vZGUpIHtcbiAgICAgICAgaWYgKGlzV2luZG93KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByb290Tm9kZSA9IChub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSk7XG5cbiAgICAgICAgcmV0dXJuIHJvb3ROb2RlLmRlZmF1bHRWaWV3IHx8IHJvb3ROb2RlLnBhcmVudFdpbmRvdyB8fCB3aW5kb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RWxlbWVudENsaWVudFJlY3QgKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGNsaWVudFJlY3QgPSAoZWxlbWVudCBpbnN0YW5jZW9mIFNWR0VsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKVswXSk7XG5cbiAgICAgICAgcmV0dXJuIGNsaWVudFJlY3QgJiYge1xuICAgICAgICAgICAgbGVmdCAgOiBjbGllbnRSZWN0LmxlZnQsXG4gICAgICAgICAgICByaWdodCA6IGNsaWVudFJlY3QucmlnaHQsXG4gICAgICAgICAgICB0b3AgICA6IGNsaWVudFJlY3QudG9wLFxuICAgICAgICAgICAgYm90dG9tOiBjbGllbnRSZWN0LmJvdHRvbSxcbiAgICAgICAgICAgIHdpZHRoIDogY2xpZW50UmVjdC53aWR0aCB8fCBjbGllbnRSZWN0LnJpZ2h0IC0gY2xpZW50UmVjdC5sZWZ0LFxuICAgICAgICAgICAgaGVpZ2h0OiBjbGllbnRSZWN0LmhlaWdodCB8fCBjbGllbnRSZWN0LmJvdHRvbSAtIGNsaWVudFJlY3QudG9wXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RWxlbWVudFJlY3QgKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGNsaWVudFJlY3QgPSBnZXRFbGVtZW50Q2xpZW50UmVjdChlbGVtZW50KTtcblxuICAgICAgICBpZiAoIWlzSU9TNyAmJiBjbGllbnRSZWN0KSB7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsID0gZ2V0U2Nyb2xsWFkoZ2V0V2luZG93KGVsZW1lbnQpKTtcblxuICAgICAgICAgICAgY2xpZW50UmVjdC5sZWZ0ICAgKz0gc2Nyb2xsLng7XG4gICAgICAgICAgICBjbGllbnRSZWN0LnJpZ2h0ICArPSBzY3JvbGwueDtcbiAgICAgICAgICAgIGNsaWVudFJlY3QudG9wICAgICs9IHNjcm9sbC55O1xuICAgICAgICAgICAgY2xpZW50UmVjdC5ib3R0b20gKz0gc2Nyb2xsLnk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xpZW50UmVjdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUb3VjaFBhaXIgKGV2ZW50KSB7XG4gICAgICAgIHZhciB0b3VjaGVzID0gW107XG5cbiAgICAgICAgLy8gYXJyYXkgb2YgdG91Y2hlcyBpcyBzdXBwbGllZFxuICAgICAgICBpZiAoaXNBcnJheShldmVudCkpIHtcbiAgICAgICAgICAgIHRvdWNoZXNbMF0gPSBldmVudFswXTtcbiAgICAgICAgICAgIHRvdWNoZXNbMV0gPSBldmVudFsxXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbiBldmVudFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAndG91Y2hlbmQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoZXNbMF0gPSBldmVudC50b3VjaGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICB0b3VjaGVzWzFdID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoZXNbMF0gPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2hlc1sxXSA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvdWNoZXNbMF0gPSBldmVudC50b3VjaGVzWzBdO1xuICAgICAgICAgICAgICAgIHRvdWNoZXNbMV0gPSBldmVudC50b3VjaGVzWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvdWNoZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9pbnRlckF2ZXJhZ2UgKHBvaW50ZXJzKSB7XG4gICAgICAgIHZhciBhdmVyYWdlID0ge1xuICAgICAgICAgICAgcGFnZVggIDogMCxcbiAgICAgICAgICAgIHBhZ2VZICA6IDAsXG4gICAgICAgICAgICBjbGllbnRYOiAwLFxuICAgICAgICAgICAgY2xpZW50WTogMCxcbiAgICAgICAgICAgIHNjcmVlblg6IDAsXG4gICAgICAgICAgICBzY3JlZW5ZOiAwXG4gICAgICAgIH07XG4gICAgICAgIHZhciBwcm9wO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAocHJvcCBpbiBhdmVyYWdlKSB7XG4gICAgICAgICAgICAgICAgYXZlcmFnZVtwcm9wXSArPSBwb2ludGVyc1tpXVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHByb3AgaW4gYXZlcmFnZSkge1xuICAgICAgICAgICAgYXZlcmFnZVtwcm9wXSAvPSBwb2ludGVycy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXZlcmFnZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b3VjaEJCb3ggKGV2ZW50KSB7XG4gICAgICAgIGlmICghZXZlbnQubGVuZ3RoICYmICEoZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDEpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG91Y2hlcyA9IGdldFRvdWNoUGFpcihldmVudCksXG4gICAgICAgICAgICBtaW5YID0gTWF0aC5taW4odG91Y2hlc1swXS5wYWdlWCwgdG91Y2hlc1sxXS5wYWdlWCksXG4gICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4odG91Y2hlc1swXS5wYWdlWSwgdG91Y2hlc1sxXS5wYWdlWSksXG4gICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgodG91Y2hlc1swXS5wYWdlWCwgdG91Y2hlc1sxXS5wYWdlWCksXG4gICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgodG91Y2hlc1swXS5wYWdlWSwgdG91Y2hlc1sxXS5wYWdlWSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IG1pblgsXG4gICAgICAgICAgICB5OiBtaW5ZLFxuICAgICAgICAgICAgbGVmdDogbWluWCxcbiAgICAgICAgICAgIHRvcDogbWluWSxcbiAgICAgICAgICAgIHdpZHRoOiBtYXhYIC0gbWluWCxcbiAgICAgICAgICAgIGhlaWdodDogbWF4WSAtIG1pbllcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b3VjaERpc3RhbmNlIChldmVudCwgZGVsdGFTb3VyY2UpIHtcbiAgICAgICAgZGVsdGFTb3VyY2UgPSBkZWx0YVNvdXJjZSB8fCBkZWZhdWx0T3B0aW9ucy5kZWx0YVNvdXJjZTtcblxuICAgICAgICB2YXIgc291cmNlWCA9IGRlbHRhU291cmNlICsgJ1gnLFxuICAgICAgICAgICAgc291cmNlWSA9IGRlbHRhU291cmNlICsgJ1knLFxuICAgICAgICAgICAgdG91Y2hlcyA9IGdldFRvdWNoUGFpcihldmVudCk7XG5cblxuICAgICAgICB2YXIgZHggPSB0b3VjaGVzWzBdW3NvdXJjZVhdIC0gdG91Y2hlc1sxXVtzb3VyY2VYXSxcbiAgICAgICAgICAgIGR5ID0gdG91Y2hlc1swXVtzb3VyY2VZXSAtIHRvdWNoZXNbMV1bc291cmNlWV07XG5cbiAgICAgICAgcmV0dXJuIGh5cG90KGR4LCBkeSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG91Y2hBbmdsZSAoZXZlbnQsIHByZXZBbmdsZSwgZGVsdGFTb3VyY2UpIHtcbiAgICAgICAgZGVsdGFTb3VyY2UgPSBkZWx0YVNvdXJjZSB8fCBkZWZhdWx0T3B0aW9ucy5kZWx0YVNvdXJjZTtcblxuICAgICAgICB2YXIgc291cmNlWCA9IGRlbHRhU291cmNlICsgJ1gnLFxuICAgICAgICAgICAgc291cmNlWSA9IGRlbHRhU291cmNlICsgJ1knLFxuICAgICAgICAgICAgdG91Y2hlcyA9IGdldFRvdWNoUGFpcihldmVudCksXG4gICAgICAgICAgICBkeCA9IHRvdWNoZXNbMF1bc291cmNlWF0gLSB0b3VjaGVzWzFdW3NvdXJjZVhdLFxuICAgICAgICAgICAgZHkgPSB0b3VjaGVzWzBdW3NvdXJjZVldIC0gdG91Y2hlc1sxXVtzb3VyY2VZXSxcbiAgICAgICAgICAgIGFuZ2xlID0gMTgwICogTWF0aC5hdGFuKGR5IC8gZHgpIC8gTWF0aC5QSTtcblxuICAgICAgICBpZiAoaXNOdW1iZXIocHJldkFuZ2xlKSkge1xuICAgICAgICAgICAgdmFyIGRyID0gYW5nbGUgLSBwcmV2QW5nbGUsXG4gICAgICAgICAgICAgICAgZHJDbGFtcGVkID0gZHIgJSAzNjA7XG5cbiAgICAgICAgICAgIGlmIChkckNsYW1wZWQgPiAzMTUpIHtcbiAgICAgICAgICAgICAgICBhbmdsZSAtPSAzNjAgKyAoYW5nbGUgLyAzNjApfDAgKiAzNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkckNsYW1wZWQgPiAxMzUpIHtcbiAgICAgICAgICAgICAgICBhbmdsZSAtPSAxODAgKyAoYW5nbGUgLyAzNjApfDAgKiAzNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkckNsYW1wZWQgPCAtMzE1KSB7XG4gICAgICAgICAgICAgICAgYW5nbGUgKz0gMzYwICsgKGFuZ2xlIC8gMzYwKXwwICogMzYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZHJDbGFtcGVkIDwgLTEzNSkge1xuICAgICAgICAgICAgICAgIGFuZ2xlICs9IDE4MCArIChhbmdsZSAvIDM2MCl8MCAqIDM2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAgYW5nbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0T3JpZ2luWFkgKGludGVyYWN0YWJsZSwgZWxlbWVudCkge1xuICAgICAgICB2YXIgb3JpZ2luID0gaW50ZXJhY3RhYmxlXG4gICAgICAgICAgICAgICAgPyBpbnRlcmFjdGFibGUub3B0aW9ucy5vcmlnaW5cbiAgICAgICAgICAgICAgICA6IGRlZmF1bHRPcHRpb25zLm9yaWdpbjtcblxuICAgICAgICBpZiAob3JpZ2luID09PSAncGFyZW50Jykge1xuICAgICAgICAgICAgb3JpZ2luID0gcGFyZW50RWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcmlnaW4gPT09ICdzZWxmJykge1xuICAgICAgICAgICAgb3JpZ2luID0gaW50ZXJhY3RhYmxlLmdldFJlY3QoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHJ5U2VsZWN0b3Iob3JpZ2luKSkge1xuICAgICAgICAgICAgb3JpZ2luID0gY2xvc2VzdChlbGVtZW50LCBvcmlnaW4pIHx8IHsgeDogMCwgeTogMCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ob3JpZ2luKSkge1xuICAgICAgICAgICAgb3JpZ2luID0gb3JpZ2luKGludGVyYWN0YWJsZSAmJiBlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0VsZW1lbnQob3JpZ2luKSkgIHtcbiAgICAgICAgICAgIG9yaWdpbiA9IGdldEVsZW1lbnRSZWN0KG9yaWdpbik7XG4gICAgICAgIH1cblxuICAgICAgICBvcmlnaW4ueCA9ICgneCcgaW4gb3JpZ2luKT8gb3JpZ2luLnggOiBvcmlnaW4ubGVmdDtcbiAgICAgICAgb3JpZ2luLnkgPSAoJ3knIGluIG9yaWdpbik/IG9yaWdpbi55IDogb3JpZ2luLnRvcDtcblxuICAgICAgICByZXR1cm4gb3JpZ2luO1xuICAgIH1cblxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzU2MzQ1MjgvMjI4MDg4OFxuICAgIGZ1bmN0aW9uIF9nZXRRQmV6aWVyVmFsdWUodCwgcDEsIHAyLCBwMykge1xuICAgICAgICB2YXIgaVQgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIGlUICogaVQgKiBwMSArIDIgKiBpVCAqIHQgKiBwMiArIHQgKiB0ICogcDM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UXVhZHJhdGljQ3VydmVQb2ludChzdGFydFgsIHN0YXJ0WSwgY3BYLCBjcFksIGVuZFgsIGVuZFksIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiAgX2dldFFCZXppZXJWYWx1ZShwb3NpdGlvbiwgc3RhcnRYLCBjcFgsIGVuZFgpLFxuICAgICAgICAgICAgeTogIF9nZXRRQmV6aWVyVmFsdWUocG9zaXRpb24sIHN0YXJ0WSwgY3BZLCBlbmRZKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGh0dHA6Ly9naXptYS5jb20vZWFzaW5nL1xuICAgIGZ1bmN0aW9uIGVhc2VPdXRRdWFkICh0LCBiLCBjLCBkKSB7XG4gICAgICAgIHQgLz0gZDtcbiAgICAgICAgcmV0dXJuIC1jICogdCoodC0yKSArIGI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9kZUNvbnRhaW5zIChwYXJlbnQsIGNoaWxkKSB7XG4gICAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5wYXJlbnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb3Nlc3QgKGNoaWxkLCBzZWxlY3Rvcikge1xuICAgICAgICB2YXIgcGFyZW50ID0gcGFyZW50RWxlbWVudChjaGlsZCk7XG5cbiAgICAgICAgd2hpbGUgKGlzRWxlbWVudChwYXJlbnQpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hlc1NlbGVjdG9yKHBhcmVudCwgc2VsZWN0b3IpKSB7IHJldHVybiBwYXJlbnQ7IH1cblxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50RWxlbWVudChwYXJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyZW50RWxlbWVudCAobm9kZSkge1xuICAgICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuXG4gICAgICAgIGlmIChpc0RvY0ZyYWcocGFyZW50KSkge1xuICAgICAgICAgICAgLy8gc2tpcCBwYXN0ICNzaGFkby1yb290IGZyYWdtZW50c1xuICAgICAgICAgICAgd2hpbGUgKChwYXJlbnQgPSBwYXJlbnQuaG9zdCkgJiYgaXNEb2NGcmFnKHBhcmVudCkpIHt9XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluQ29udGV4dCAoaW50ZXJhY3RhYmxlLCBlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBpbnRlcmFjdGFibGUuX2NvbnRleHQgPT09IGVsZW1lbnQub3duZXJEb2N1bWVudFxuICAgICAgICAgICAgICAgIHx8IG5vZGVDb250YWlucyhpbnRlcmFjdGFibGUuX2NvbnRleHQsIGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RJZ25vcmUgKGludGVyYWN0YWJsZSwgaW50ZXJhY3RhYmxlRWxlbWVudCwgZWxlbWVudCkge1xuICAgICAgICB2YXIgaWdub3JlRnJvbSA9IGludGVyYWN0YWJsZS5vcHRpb25zLmlnbm9yZUZyb207XG5cbiAgICAgICAgaWYgKCFpZ25vcmVGcm9tIHx8ICFpc0VsZW1lbnQoZWxlbWVudCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgICAgaWYgKGlzU3RyaW5nKGlnbm9yZUZyb20pKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlc1VwVG8oZWxlbWVudCwgaWdub3JlRnJvbSwgaW50ZXJhY3RhYmxlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNFbGVtZW50KGlnbm9yZUZyb20pKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZUNvbnRhaW5zKGlnbm9yZUZyb20sIGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RBbGxvdyAoaW50ZXJhY3RhYmxlLCBpbnRlcmFjdGFibGVFbGVtZW50LCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBhbGxvd0Zyb20gPSBpbnRlcmFjdGFibGUub3B0aW9ucy5hbGxvd0Zyb207XG5cbiAgICAgICAgaWYgKCFhbGxvd0Zyb20pIHsgcmV0dXJuIHRydWU7IH1cblxuICAgICAgICBpZiAoIWlzRWxlbWVudChlbGVtZW50KSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgICBpZiAoaXNTdHJpbmcoYWxsb3dGcm9tKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNVcFRvKGVsZW1lbnQsIGFsbG93RnJvbSwgaW50ZXJhY3RhYmxlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNFbGVtZW50KGFsbG93RnJvbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlQ29udGFpbnMoYWxsb3dGcm9tLCBlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0F4aXMgKGF4aXMsIGludGVyYWN0YWJsZSkge1xuICAgICAgICBpZiAoIWludGVyYWN0YWJsZSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgICB2YXIgdGhpc0F4aXMgPSBpbnRlcmFjdGFibGUub3B0aW9ucy5kcmFnLmF4aXM7XG5cbiAgICAgICAgcmV0dXJuIChheGlzID09PSAneHknIHx8IHRoaXNBeGlzID09PSAneHknIHx8IHRoaXNBeGlzID09PSBheGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja1NuYXAgKGludGVyYWN0YWJsZSwgYWN0aW9uKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gaW50ZXJhY3RhYmxlLm9wdGlvbnM7XG5cbiAgICAgICAgaWYgKC9ecmVzaXplLy50ZXN0KGFjdGlvbikpIHtcbiAgICAgICAgICAgIGFjdGlvbiA9ICdyZXNpemUnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnNbYWN0aW9uXS5zbmFwICYmIG9wdGlvbnNbYWN0aW9uXS5zbmFwLmVuYWJsZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tSZXN0cmljdCAoaW50ZXJhY3RhYmxlLCBhY3Rpb24pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBpbnRlcmFjdGFibGUub3B0aW9ucztcblxuICAgICAgICBpZiAoL15yZXNpemUvLnRlc3QoYWN0aW9uKSkge1xuICAgICAgICAgICAgYWN0aW9uID0gJ3Jlc2l6ZSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gIG9wdGlvbnNbYWN0aW9uXS5yZXN0cmljdCAmJiBvcHRpb25zW2FjdGlvbl0ucmVzdHJpY3QuZW5hYmxlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0F1dG9TY3JvbGwgKGludGVyYWN0YWJsZSwgYWN0aW9uKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gaW50ZXJhY3RhYmxlLm9wdGlvbnM7XG5cbiAgICAgICAgaWYgKC9ecmVzaXplLy50ZXN0KGFjdGlvbikpIHtcbiAgICAgICAgICAgIGFjdGlvbiA9ICdyZXNpemUnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICBvcHRpb25zW2FjdGlvbl0uYXV0b1Njcm9sbCAmJiBvcHRpb25zW2FjdGlvbl0uYXV0b1Njcm9sbC5lbmFibGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdpdGhpbkludGVyYWN0aW9uTGltaXQgKGludGVyYWN0YWJsZSwgZWxlbWVudCwgYWN0aW9uKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gaW50ZXJhY3RhYmxlLm9wdGlvbnMsXG4gICAgICAgICAgICBtYXhBY3Rpb25zID0gb3B0aW9uc1thY3Rpb24ubmFtZV0ubWF4LFxuICAgICAgICAgICAgbWF4UGVyRWxlbWVudCA9IG9wdGlvbnNbYWN0aW9uLm5hbWVdLm1heFBlckVsZW1lbnQsXG4gICAgICAgICAgICBhY3RpdmVJbnRlcmFjdGlvbnMgPSAwLFxuICAgICAgICAgICAgdGFyZ2V0Q291bnQgPSAwLFxuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudENvdW50ID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaW50ZXJhY3Rpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW50ZXJhY3Rpb24gPSBpbnRlcmFjdGlvbnNbaV0sXG4gICAgICAgICAgICAgICAgb3RoZXJBY3Rpb24gPSBpbnRlcmFjdGlvbi5wcmVwYXJlZC5uYW1lLFxuICAgICAgICAgICAgICAgIGFjdGl2ZSA9IGludGVyYWN0aW9uLmludGVyYWN0aW5nKCk7XG5cbiAgICAgICAgICAgIGlmICghYWN0aXZlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICAgIGFjdGl2ZUludGVyYWN0aW9ucysrO1xuXG4gICAgICAgICAgICBpZiAoYWN0aXZlSW50ZXJhY3Rpb25zID49IG1heEludGVyYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGludGVyYWN0aW9uLnRhcmdldCAhPT0gaW50ZXJhY3RhYmxlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICAgIHRhcmdldENvdW50ICs9IChvdGhlckFjdGlvbiA9PT0gYWN0aW9uLm5hbWUpfDA7XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXRDb3VudCA+PSBtYXhBY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW50ZXJhY3Rpb24uZWxlbWVudCA9PT0gZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnRDb3VudCsrO1xuXG4gICAgICAgICAgICAgICAgaWYgKG90aGVyQWN0aW9uICE9PSBhY3Rpb24ubmFtZSB8fCB0YXJnZXRFbGVtZW50Q291bnQgPj0gbWF4UGVyRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1heEludGVyYWN0aW9ucyA+IDA7XG4gICAgfVxuXG4gICAgLy8gVGVzdCBmb3IgdGhlIGVsZW1lbnQgdGhhdCdzIFwiYWJvdmVcIiBhbGwgb3RoZXIgcXVhbGlmaWVyc1xuICAgIGZ1bmN0aW9uIGluZGV4T2ZEZWVwZXN0RWxlbWVudCAoZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIGRyb3B6b25lLFxuICAgICAgICAgICAgZGVlcGVzdFpvbmUgPSBlbGVtZW50c1swXSxcbiAgICAgICAgICAgIGluZGV4ID0gZGVlcGVzdFpvbmU/IDA6IC0xLFxuICAgICAgICAgICAgcGFyZW50LFxuICAgICAgICAgICAgZGVlcGVzdFpvbmVQYXJlbnRzID0gW10sXG4gICAgICAgICAgICBkcm9wem9uZVBhcmVudHMgPSBbXSxcbiAgICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG47XG5cbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkcm9wem9uZSA9IGVsZW1lbnRzW2ldO1xuXG4gICAgICAgICAgICAvLyBhbiBlbGVtZW50IG1pZ2h0IGJlbG9uZyB0byBtdWx0aXBsZSBzZWxlY3RvciBkcm9wem9uZXNcbiAgICAgICAgICAgIGlmICghZHJvcHpvbmUgfHwgZHJvcHpvbmUgPT09IGRlZXBlc3Rab25lKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZGVlcGVzdFpvbmUpIHtcbiAgICAgICAgICAgICAgICBkZWVwZXN0Wm9uZSA9IGRyb3B6b25lO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGRlZXBlc3Qgb3IgY3VycmVudCBhcmUgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IG9yIGRvY3VtZW50LnJvb3RFbGVtZW50XG4gICAgICAgICAgICAvLyAtIGlmIHRoZSBjdXJyZW50IGRyb3B6b25lIGlzLCBkbyBub3RoaW5nIGFuZCBjb250aW51ZVxuICAgICAgICAgICAgaWYgKGRyb3B6b25lLnBhcmVudE5vZGUgPT09IGRyb3B6b25lLm93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIC0gaWYgZGVlcGVzdCBpcywgdXBkYXRlIHdpdGggdGhlIGN1cnJlbnQgZHJvcHpvbmUgYW5kIGNvbnRpbnVlIHRvIG5leHRcbiAgICAgICAgICAgIGVsc2UgaWYgKGRlZXBlc3Rab25lLnBhcmVudE5vZGUgPT09IGRyb3B6b25lLm93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICBkZWVwZXN0Wm9uZSA9IGRyb3B6b25lO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFkZWVwZXN0Wm9uZVBhcmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gZGVlcGVzdFpvbmU7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBhcmVudC5wYXJlbnROb2RlICYmIHBhcmVudC5wYXJlbnROb2RlICE9PSBwYXJlbnQub3duZXJEb2N1bWVudCkge1xuICAgICAgICAgICAgICAgICAgICBkZWVwZXN0Wm9uZVBhcmVudHMudW5zaGlmdChwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgZWxlbWVudCBpcyBhbiBzdmcgZWxlbWVudCBhbmQgdGhlIGN1cnJlbnQgZGVlcGVzdCBpc1xuICAgICAgICAgICAgLy8gYW4gSFRNTEVsZW1lbnRcbiAgICAgICAgICAgIGlmIChkZWVwZXN0Wm9uZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50XG4gICAgICAgICAgICAgICAgJiYgZHJvcHpvbmUgaW5zdGFuY2VvZiBTVkdFbGVtZW50XG4gICAgICAgICAgICAgICAgJiYgIShkcm9wem9uZSBpbnN0YW5jZW9mIFNWR1NWR0VsZW1lbnQpKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoZHJvcHpvbmUgPT09IGRlZXBlc3Rab25lLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gZHJvcHpvbmUub3duZXJTVkdFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gZHJvcHpvbmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRyb3B6b25lUGFyZW50cyA9IFtdO1xuXG4gICAgICAgICAgICB3aGlsZSAocGFyZW50LnBhcmVudE5vZGUgIT09IHBhcmVudC5vd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgZHJvcHpvbmVQYXJlbnRzLnVuc2hpZnQocGFyZW50KTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbiA9IDA7XG5cbiAgICAgICAgICAgIC8vIGdldCAocG9zaXRpb24gb2YgbGFzdCBjb21tb24gYW5jZXN0b3IpICsgMVxuICAgICAgICAgICAgd2hpbGUgKGRyb3B6b25lUGFyZW50c1tuXSAmJiBkcm9wem9uZVBhcmVudHNbbl0gPT09IGRlZXBlc3Rab25lUGFyZW50c1tuXSkge1xuICAgICAgICAgICAgICAgIG4rKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcmVudHMgPSBbXG4gICAgICAgICAgICAgICAgZHJvcHpvbmVQYXJlbnRzW24gLSAxXSxcbiAgICAgICAgICAgICAgICBkcm9wem9uZVBhcmVudHNbbl0sXG4gICAgICAgICAgICAgICAgZGVlcGVzdFpvbmVQYXJlbnRzW25dXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBjaGlsZCA9IHBhcmVudHNbMF0ubGFzdENoaWxkO1xuXG4gICAgICAgICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgPT09IHBhcmVudHNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVlcGVzdFpvbmUgPSBkcm9wem9uZTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICBkZWVwZXN0Wm9uZVBhcmVudHMgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQgPT09IHBhcmVudHNbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSW50ZXJhY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRhcmdldCAgICAgICAgICA9IG51bGw7IC8vIGN1cnJlbnQgaW50ZXJhY3RhYmxlIGJlaW5nIGludGVyYWN0ZWQgd2l0aFxuICAgICAgICB0aGlzLmVsZW1lbnQgICAgICAgICA9IG51bGw7IC8vIHRoZSB0YXJnZXQgZWxlbWVudCBvZiB0aGUgaW50ZXJhY3RhYmxlXG4gICAgICAgIHRoaXMuZHJvcFRhcmdldCAgICAgID0gbnVsbDsgLy8gdGhlIGRyb3B6b25lIGEgZHJhZyB0YXJnZXQgbWlnaHQgYmUgZHJvcHBlZCBpbnRvXG4gICAgICAgIHRoaXMuZHJvcEVsZW1lbnQgICAgID0gbnVsbDsgLy8gdGhlIGVsZW1lbnQgYXQgdGhlIHRpbWUgb2YgY2hlY2tpbmdcbiAgICAgICAgdGhpcy5wcmV2RHJvcFRhcmdldCAgPSBudWxsOyAvLyB0aGUgZHJvcHpvbmUgdGhhdCB3YXMgcmVjZW50bHkgZHJhZ2dlZCBhd2F5IGZyb21cbiAgICAgICAgdGhpcy5wcmV2RHJvcEVsZW1lbnQgPSBudWxsOyAvLyB0aGUgZWxlbWVudCBhdCB0aGUgdGltZSBvZiBjaGVja2luZ1xuXG4gICAgICAgIHRoaXMucHJlcGFyZWQgICAgICAgID0geyAgICAgLy8gYWN0aW9uIHRoYXQncyByZWFkeSB0byBiZSBmaXJlZCBvbiBuZXh0IG1vdmUgZXZlbnRcbiAgICAgICAgICAgIG5hbWUgOiBudWxsLFxuICAgICAgICAgICAgYXhpcyA6IG51bGwsXG4gICAgICAgICAgICBlZGdlczogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMubWF0Y2hlcyAgICAgICAgID0gW107ICAgLy8gYWxsIHNlbGVjdG9ycyB0aGF0IGFyZSBtYXRjaGVkIGJ5IHRhcmdldCBlbGVtZW50XG4gICAgICAgIHRoaXMubWF0Y2hFbGVtZW50cyAgID0gW107ICAgLy8gY29ycmVzcG9uZGluZyBlbGVtZW50c1xuXG4gICAgICAgIHRoaXMuaW5lcnRpYVN0YXR1cyA9IHtcbiAgICAgICAgICAgIGFjdGl2ZSAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgc21vb3RoRW5kICAgIDogZmFsc2UsXG4gICAgICAgICAgICBlbmRpbmcgICAgICAgOiBmYWxzZSxcblxuICAgICAgICAgICAgc3RhcnRFdmVudDogbnVsbCxcbiAgICAgICAgICAgIHVwQ29vcmRzOiB7fSxcblxuICAgICAgICAgICAgeGU6IDAsIHllOiAwLFxuICAgICAgICAgICAgc3g6IDAsIHN5OiAwLFxuXG4gICAgICAgICAgICB0MDogMCxcbiAgICAgICAgICAgIHZ4MDogMCwgdnlzOiAwLFxuICAgICAgICAgICAgZHVyYXRpb246IDAsXG5cbiAgICAgICAgICAgIHJlc3VtZUR4OiAwLFxuICAgICAgICAgICAgcmVzdW1lRHk6IDAsXG5cbiAgICAgICAgICAgIGxhbWJkYV92MDogMCxcbiAgICAgICAgICAgIG9uZV92ZV92MDogMCxcbiAgICAgICAgICAgIGkgIDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSkge1xuICAgICAgICAgICAgdGhpcy5ib3VuZEluZXJ0aWFGcmFtZSA9IHRoaXMuaW5lcnRpYUZyYW1lLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmJvdW5kU21vb3RoRW5kRnJhbWUgPSB0aGlzLnNtb290aEVuZEZyYW1lLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMuYm91bmRJbmVydGlhRnJhbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGF0LmluZXJ0aWFGcmFtZSgpOyB9O1xuICAgICAgICAgICAgdGhpcy5ib3VuZFNtb290aEVuZEZyYW1lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhhdC5zbW9vdGhFbmRGcmFtZSgpOyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hY3RpdmVEcm9wcyA9IHtcbiAgICAgICAgICAgIGRyb3B6b25lczogW10sICAgICAgLy8gdGhlIGRyb3B6b25lcyB0aGF0IGFyZSBtZW50aW9uZWQgYmVsb3dcbiAgICAgICAgICAgIGVsZW1lbnRzIDogW10sICAgICAgLy8gZWxlbWVudHMgb2YgZHJvcHpvbmVzIHRoYXQgYWNjZXB0IHRoZSB0YXJnZXQgZHJhZ2dhYmxlXG4gICAgICAgICAgICByZWN0cyAgICA6IFtdICAgICAgIC8vIHRoZSByZWN0cyBvZiB0aGUgZWxlbWVudHMgbWVudGlvbmVkIGFib3ZlXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8ga2VlcCB0cmFjayBvZiBhZGRlZCBwb2ludGVyc1xuICAgICAgICB0aGlzLnBvaW50ZXJzICAgID0gW107XG4gICAgICAgIHRoaXMucG9pbnRlcklkcyAgPSBbXTtcbiAgICAgICAgdGhpcy5kb3duVGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLmRvd25UaW1lcyAgID0gW107XG4gICAgICAgIHRoaXMuaG9sZFRpbWVycyAgPSBbXTtcblxuICAgICAgICAvLyBQcmV2aW91cyBuYXRpdmUgcG9pbnRlciBtb3ZlIGV2ZW50IGNvb3JkaW5hdGVzXG4gICAgICAgIHRoaXMucHJldkNvb3JkcyA9IHtcbiAgICAgICAgICAgIHBhZ2UgICAgIDogeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgICBjbGllbnQgICA6IHsgeDogMCwgeTogMCB9LFxuICAgICAgICAgICAgdGltZVN0YW1wOiAwXG4gICAgICAgIH07XG4gICAgICAgIC8vIGN1cnJlbnQgbmF0aXZlIHBvaW50ZXIgbW92ZSBldmVudCBjb29yZGluYXRlc1xuICAgICAgICB0aGlzLmN1ckNvb3JkcyA9IHtcbiAgICAgICAgICAgIHBhZ2UgICAgIDogeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgICBjbGllbnQgICA6IHsgeDogMCwgeTogMCB9LFxuICAgICAgICAgICAgdGltZVN0YW1wOiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU3RhcnRpbmcgSW50ZXJhY3RFdmVudCBwb2ludGVyIGNvb3JkaW5hdGVzXG4gICAgICAgIHRoaXMuc3RhcnRDb29yZHMgPSB7XG4gICAgICAgICAgICBwYWdlICAgICA6IHsgeDogMCwgeTogMCB9LFxuICAgICAgICAgICAgY2xpZW50ICAgOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgIHRpbWVTdGFtcDogMFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENoYW5nZSBpbiBjb29yZGluYXRlcyBhbmQgdGltZSBvZiB0aGUgcG9pbnRlclxuICAgICAgICB0aGlzLnBvaW50ZXJEZWx0YSA9IHtcbiAgICAgICAgICAgIHBhZ2UgICAgIDogeyB4OiAwLCB5OiAwLCB2eDogMCwgdnk6IDAsIHNwZWVkOiAwIH0sXG4gICAgICAgICAgICBjbGllbnQgICA6IHsgeDogMCwgeTogMCwgdng6IDAsIHZ5OiAwLCBzcGVlZDogMCB9LFxuICAgICAgICAgICAgdGltZVN0YW1wOiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kb3duRXZlbnQgICA9IG51bGw7ICAgIC8vIHBvaW50ZXJkb3duL21vdXNlZG93bi90b3VjaHN0YXJ0IGV2ZW50XG4gICAgICAgIHRoaXMuZG93blBvaW50ZXIgPSB7fTtcblxuICAgICAgICB0aGlzLl9ldmVudFRhcmdldCAgICA9IG51bGw7XG4gICAgICAgIHRoaXMuX2N1ckV2ZW50VGFyZ2V0ID0gbnVsbDtcblxuICAgICAgICB0aGlzLnByZXZFdmVudCA9IG51bGw7ICAgICAgLy8gcHJldmlvdXMgYWN0aW9uIGV2ZW50XG4gICAgICAgIHRoaXMudGFwVGltZSAgID0gMDsgICAgICAgICAvLyB0aW1lIG9mIHRoZSBtb3N0IHJlY2VudCB0YXAgZXZlbnRcbiAgICAgICAgdGhpcy5wcmV2VGFwICAgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuc3RhcnRPZmZzZXQgICAgPSB7IGxlZnQ6IDAsIHJpZ2h0OiAwLCB0b3A6IDAsIGJvdHRvbTogMCB9O1xuICAgICAgICB0aGlzLnJlc3RyaWN0T2Zmc2V0ID0geyBsZWZ0OiAwLCByaWdodDogMCwgdG9wOiAwLCBib3R0b206IDAgfTtcbiAgICAgICAgdGhpcy5zbmFwT2Zmc2V0cyAgICA9IFtdO1xuXG4gICAgICAgIHRoaXMuZ2VzdHVyZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiB7IHg6IDAsIHk6IDAgfSxcblxuICAgICAgICAgICAgc3RhcnREaXN0YW5jZTogMCwgICAvLyBkaXN0YW5jZSBiZXR3ZWVuIHR3byB0b3VjaGVzIG9mIHRvdWNoU3RhcnRcbiAgICAgICAgICAgIHByZXZEaXN0YW5jZSA6IDAsXG4gICAgICAgICAgICBkaXN0YW5jZSAgICAgOiAwLFxuXG4gICAgICAgICAgICBzY2FsZTogMSwgICAgICAgICAgIC8vIGdlc3R1cmUuZGlzdGFuY2UgLyBnZXN0dXJlLnN0YXJ0RGlzdGFuY2VcblxuICAgICAgICAgICAgc3RhcnRBbmdsZTogMCwgICAgICAvLyBhbmdsZSBvZiBsaW5lIGpvaW5pbmcgdHdvIHRvdWNoZXNcbiAgICAgICAgICAgIHByZXZBbmdsZSA6IDAgICAgICAgLy8gYW5nbGUgb2YgdGhlIHByZXZpb3VzIGdlc3R1cmUgZXZlbnRcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnNuYXBTdGF0dXMgPSB7XG4gICAgICAgICAgICB4ICAgICAgIDogMCwgeSAgICAgICA6IDAsXG4gICAgICAgICAgICBkeCAgICAgIDogMCwgZHkgICAgICA6IDAsXG4gICAgICAgICAgICByZWFsWCAgIDogMCwgcmVhbFkgICA6IDAsXG4gICAgICAgICAgICBzbmFwcGVkWDogMCwgc25hcHBlZFk6IDAsXG4gICAgICAgICAgICB0YXJnZXRzIDogW10sXG4gICAgICAgICAgICBsb2NrZWQgIDogZmFsc2UsXG4gICAgICAgICAgICBjaGFuZ2VkIDogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJlc3RyaWN0U3RhdHVzID0ge1xuICAgICAgICAgICAgZHggICAgICAgICA6IDAsIGR5ICAgICAgICAgOiAwLFxuICAgICAgICAgICAgcmVzdHJpY3RlZFg6IDAsIHJlc3RyaWN0ZWRZOiAwLFxuICAgICAgICAgICAgc25hcCAgICAgICA6IG51bGwsXG4gICAgICAgICAgICByZXN0cmljdGVkIDogZmFsc2UsXG4gICAgICAgICAgICBjaGFuZ2VkICAgIDogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJlc3RyaWN0U3RhdHVzLnNuYXAgPSB0aGlzLnNuYXBTdGF0dXM7XG5cbiAgICAgICAgdGhpcy5wb2ludGVySXNEb3duICAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wb2ludGVyV2FzTW92ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5nZXN0dXJpbmcgICAgICAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyAgICAgICAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXNpemluZyAgICAgICAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXNpemVBeGVzICAgICAgPSAneHknO1xuXG4gICAgICAgIHRoaXMubW91c2UgPSBmYWxzZTtcblxuICAgICAgICBpbnRlcmFjdGlvbnMucHVzaCh0aGlzKTtcbiAgICB9XG5cbiAgICBJbnRlcmFjdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgICAgIGdldFBhZ2VYWSAgOiBmdW5jdGlvbiAocG9pbnRlciwgeHkpIHsgcmV0dXJuICAgZ2V0UGFnZVhZKHBvaW50ZXIsIHh5LCB0aGlzKTsgfSxcbiAgICAgICAgZ2V0Q2xpZW50WFk6IGZ1bmN0aW9uIChwb2ludGVyLCB4eSkgeyByZXR1cm4gZ2V0Q2xpZW50WFkocG9pbnRlciwgeHksIHRoaXMpOyB9LFxuICAgICAgICBzZXRFdmVudFhZIDogZnVuY3Rpb24gKHRhcmdldCwgcHRyKSB7IHJldHVybiAgc2V0RXZlbnRYWSh0YXJnZXQsIHB0ciwgdGhpcyk7IH0sXG5cbiAgICAgICAgcG9pbnRlck92ZXI6IGZ1bmN0aW9uIChwb2ludGVyLCBldmVudCwgZXZlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXBhcmVkLm5hbWUgfHwgIXRoaXMubW91c2UpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgIHZhciBjdXJNYXRjaGVzID0gW10sXG4gICAgICAgICAgICAgICAgY3VyTWF0Y2hFbGVtZW50cyA9IFtdLFxuICAgICAgICAgICAgICAgIHByZXZUYXJnZXRFbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG4gICAgICAgICAgICB0aGlzLmFkZFBvaW50ZXIocG9pbnRlcik7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnRhcmdldFxuICAgICAgICAgICAgICAgICYmICh0ZXN0SWdub3JlKHRoaXMudGFyZ2V0LCB0aGlzLmVsZW1lbnQsIGV2ZW50VGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICB8fCAhdGVzdEFsbG93KHRoaXMudGFyZ2V0LCB0aGlzLmVsZW1lbnQsIGV2ZW50VGFyZ2V0KSkpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZXZlbnRUYXJnZXQgc2hvdWxkIGJlIGlnbm9yZWQgb3Igc2hvdWxkbid0IGJlIGFsbG93ZWRcbiAgICAgICAgICAgICAgICAvLyBjbGVhciB0aGUgcHJldmlvdXMgdGFyZ2V0XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaEVsZW1lbnRzID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBlbGVtZW50SW50ZXJhY3RhYmxlID0gaW50ZXJhY3RhYmxlcy5nZXQoZXZlbnRUYXJnZXQpLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRBY3Rpb24gPSAoZWxlbWVudEludGVyYWN0YWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgIXRlc3RJZ25vcmUoZWxlbWVudEludGVyYWN0YWJsZSwgZXZlbnRUYXJnZXQsIGV2ZW50VGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgdGVzdEFsbG93KGVsZW1lbnRJbnRlcmFjdGFibGUsIGV2ZW50VGFyZ2V0LCBldmVudFRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHZhbGlkYXRlQWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRJbnRlcmFjdGFibGUuZ2V0QWN0aW9uKHBvaW50ZXIsIGV2ZW50LCB0aGlzLCBldmVudFRhcmdldCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudEludGVyYWN0YWJsZSkpO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudEFjdGlvbiAmJiAhd2l0aGluSW50ZXJhY3Rpb25MaW1pdChlbGVtZW50SW50ZXJhY3RhYmxlLCBldmVudFRhcmdldCwgZWxlbWVudEFjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgZWxlbWVudEFjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHB1c2hDdXJNYXRjaGVzIChpbnRlcmFjdGFibGUsIHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGludGVyYWN0YWJsZVxuICAgICAgICAgICAgICAgICAgICAmJiBpbkNvbnRleHQoaW50ZXJhY3RhYmxlLCBldmVudFRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgJiYgIXRlc3RJZ25vcmUoaW50ZXJhY3RhYmxlLCBldmVudFRhcmdldCwgZXZlbnRUYXJnZXQpXG4gICAgICAgICAgICAgICAgICAgICYmIHRlc3RBbGxvdyhpbnRlcmFjdGFibGUsIGV2ZW50VGFyZ2V0LCBldmVudFRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgJiYgbWF0Y2hlc1NlbGVjdG9yKGV2ZW50VGFyZ2V0LCBzZWxlY3RvcikpIHtcblxuICAgICAgICAgICAgICAgICAgICBjdXJNYXRjaGVzLnB1c2goaW50ZXJhY3RhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VyTWF0Y2hFbGVtZW50cy5wdXNoKGV2ZW50VGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50QWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBlbGVtZW50SW50ZXJhY3RhYmxlO1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IGV2ZW50VGFyZ2V0O1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hFbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW50ZXJhY3RhYmxlcy5mb3JFYWNoU2VsZWN0b3IocHVzaEN1ck1hdGNoZXMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsaWRhdGVTZWxlY3Rvcihwb2ludGVyLCBldmVudCwgY3VyTWF0Y2hlcywgY3VyTWF0Y2hFbGVtZW50cykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzID0gY3VyTWF0Y2hlcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaEVsZW1lbnRzID0gY3VyTWF0Y2hFbGVtZW50cztcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50ZXJIb3Zlcihwb2ludGVyLCBldmVudCwgdGhpcy5tYXRjaGVzLCB0aGlzLm1hdGNoRWxlbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBldmVudHMuYWRkKGV2ZW50VGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvaW50ZXJFdmVudD8gcEV2ZW50VHlwZXMubW92ZSA6ICdtb3VzZW1vdmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wb2ludGVySG92ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZUNvbnRhaW5zKHByZXZUYXJnZXRFbGVtZW50LCBldmVudFRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlckhvdmVyKHBvaW50ZXIsIGV2ZW50LCB0aGlzLm1hdGNoZXMsIHRoaXMubWF0Y2hFbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHMuYWRkKHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9pbnRlckV2ZW50PyBwRXZlbnRUeXBlcy5tb3ZlIDogJ21vdXNlbW92ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wb2ludGVySG92ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaEVsZW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQ2hlY2sgd2hhdCBhY3Rpb24gd291bGQgYmUgcGVyZm9ybWVkIG9uIHBvaW50ZXJNb3ZlIHRhcmdldCBpZiBhIG1vdXNlXG4gICAgICAgIC8vIGJ1dHRvbiB3ZXJlIHByZXNzZWQgYW5kIGNoYW5nZSB0aGUgY3Vyc29yIGFjY29yZGluZ2x5XG4gICAgICAgIHBvaW50ZXJIb3ZlcjogZnVuY3Rpb24gKHBvaW50ZXIsIGV2ZW50LCBldmVudFRhcmdldCwgY3VyRXZlbnRUYXJnZXQsIG1hdGNoZXMsIG1hdGNoRWxlbWVudHMpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldDtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnByZXBhcmVkLm5hbWUgJiYgdGhpcy5tb3VzZSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGFjdGlvbjtcblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBwb2ludGVyIGNvb3JkcyBmb3IgZGVmYXVsdEFjdGlvbkNoZWNrZXIgdG8gdXNlXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFdmVudFhZKHRoaXMuY3VyQ29vcmRzLCBbcG9pbnRlcl0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gdGhpcy52YWxpZGF0ZVNlbGVjdG9yKHBvaW50ZXIsIGV2ZW50LCBtYXRjaGVzLCBtYXRjaEVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9IHZhbGlkYXRlQWN0aW9uKHRhcmdldC5nZXRBY3Rpb24odGhpcy5wb2ludGVyc1swXSwgZXZlbnQsIHRoaXMsIHRoaXMuZWxlbWVudCksIHRoaXMudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5vcHRpb25zLnN0eWxlQ3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5fZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZS5jdXJzb3IgPSBnZXRBY3Rpb25DdXJzb3IoYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5fZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZS5jdXJzb3IgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucHJlcGFyZWQubmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tBbmRQcmV2ZW50RGVmYXVsdChldmVudCwgdGFyZ2V0LCB0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBvaW50ZXJPdXQ6IGZ1bmN0aW9uIChwb2ludGVyLCBldmVudCwgZXZlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXBhcmVkLm5hbWUpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0ZW1wb3JhcnkgZXZlbnQgbGlzdGVuZXJzIGZvciBzZWxlY3RvciBJbnRlcmFjdGFibGVzXG4gICAgICAgICAgICBpZiAoIWludGVyYWN0YWJsZXMuZ2V0KGV2ZW50VGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGV2ZW50cy5yZW1vdmUoZXZlbnRUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb2ludGVyRXZlbnQ/IHBFdmVudFR5cGVzLm1vdmUgOiAnbW91c2Vtb3ZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wb2ludGVySG92ZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy50YXJnZXQgJiYgdGhpcy50YXJnZXQub3B0aW9ucy5zdHlsZUN1cnNvciAmJiAhdGhpcy5pbnRlcmFjdGluZygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQuX2RvYy5kb2N1bWVudEVsZW1lbnQuc3R5bGUuY3Vyc29yID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2VsZWN0b3JEb3duOiBmdW5jdGlvbiAocG9pbnRlciwgZXZlbnQsIGV2ZW50VGFyZ2V0LCBjdXJFdmVudFRhcmdldCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIC8vIGNvcHkgZXZlbnQgdG8gYmUgdXNlZCBpbiB0aW1lb3V0IGZvciBJRThcbiAgICAgICAgICAgICAgICBldmVudENvcHkgPSBldmVudHMudXNlQXR0YWNoRXZlbnQ/IGV4dGVuZCh7fSwgZXZlbnQpIDogZXZlbnQsXG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGV2ZW50VGFyZ2V0LFxuICAgICAgICAgICAgICAgIHBvaW50ZXJJbmRleCA9IHRoaXMuYWRkUG9pbnRlcihwb2ludGVyKSxcbiAgICAgICAgICAgICAgICBhY3Rpb247XG5cbiAgICAgICAgICAgIHRoaXMuaG9sZFRpbWVyc1twb2ludGVySW5kZXhdID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5wb2ludGVySG9sZChldmVudHMudXNlQXR0YWNoRXZlbnQ/IGV2ZW50Q29weSA6IHBvaW50ZXIsIGV2ZW50Q29weSwgZXZlbnRUYXJnZXQsIGN1ckV2ZW50VGFyZ2V0KTtcbiAgICAgICAgICAgIH0sIGRlZmF1bHRPcHRpb25zLl9ob2xkRHVyYXRpb24pO1xuXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJJc0Rvd24gPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZG93biBldmVudCBoaXRzIHRoZSBjdXJyZW50IGluZXJ0aWEgdGFyZ2V0XG4gICAgICAgICAgICBpZiAodGhpcy5pbmVydGlhU3RhdHVzLmFjdGl2ZSAmJiB0aGlzLnRhcmdldC5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIC8vIGNsaW1iIHVwIHRoZSBET00gdHJlZSBmcm9tIHRoZSBldmVudCB0YXJnZXRcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXNFbGVtZW50KGVsZW1lbnQpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBlbGVtZW50IGlzIHRoZSBjdXJyZW50IGluZXJ0aWEgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHRoaXMuZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRoZSBwcm9zcGVjdGl2ZSBhY3Rpb24gaXMgdGhlIHNhbWUgYXMgdGhlIG9uZ29pbmcgb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiB2YWxpZGF0ZUFjdGlvbih0aGlzLnRhcmdldC5nZXRBY3Rpb24ocG9pbnRlciwgZXZlbnQsIHRoaXMsIHRoaXMuZWxlbWVudCksIHRoaXMudGFyZ2V0KS5uYW1lID09PSB0aGlzLnByZXBhcmVkLm5hbWUpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBpbmVydGlhIHNvIHRoYXQgdGhlIG5leHQgbW92ZSB3aWxsIGJlIGEgbm9ybWFsIG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsRnJhbWUodGhpcy5pbmVydGlhU3RhdHVzLmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmVydGlhU3RhdHVzLmFjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbGxlY3RFdmVudFRhcmdldHMocG9pbnRlciwgZXZlbnQsIGV2ZW50VGFyZ2V0LCAnZG93bicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBwYXJlbnRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZG8gbm90aGluZyBpZiBpbnRlcmFjdGluZ1xuICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJhY3RpbmcoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGVjdEV2ZW50VGFyZ2V0cyhwb2ludGVyLCBldmVudCwgZXZlbnRUYXJnZXQsICdkb3duJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBwdXNoTWF0Y2hlcyAoaW50ZXJhY3RhYmxlLCBzZWxlY3RvciwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IGllOE1hdGNoZXNTZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICA/IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcilcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5Db250ZXh0KGludGVyYWN0YWJsZSwgZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgJiYgIXRlc3RJZ25vcmUoaW50ZXJhY3RhYmxlLCBlbGVtZW50LCBldmVudFRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgJiYgdGVzdEFsbG93KGludGVyYWN0YWJsZSwgZWxlbWVudCwgZXZlbnRUYXJnZXQpXG4gICAgICAgICAgICAgICAgICAgICYmIG1hdGNoZXNTZWxlY3RvcihlbGVtZW50LCBzZWxlY3RvciwgZWxlbWVudHMpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhhdC5tYXRjaGVzLnB1c2goaW50ZXJhY3RhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5tYXRjaEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB1cGRhdGUgcG9pbnRlciBjb29yZHMgZm9yIGRlZmF1bHRBY3Rpb25DaGVja2VyIHRvIHVzZVxuICAgICAgICAgICAgdGhpcy5zZXRFdmVudFhZKHRoaXMuY3VyQ29vcmRzLCBbcG9pbnRlcl0pO1xuICAgICAgICAgICAgdGhpcy5kb3duRXZlbnQgPSBldmVudDtcblxuICAgICAgICAgICAgd2hpbGUgKGlzRWxlbWVudChlbGVtZW50KSAmJiAhYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaEVsZW1lbnRzID0gW107XG5cbiAgICAgICAgICAgICAgICBpbnRlcmFjdGFibGVzLmZvckVhY2hTZWxlY3RvcihwdXNoTWF0Y2hlcyk7XG5cbiAgICAgICAgICAgICAgICBhY3Rpb24gPSB0aGlzLnZhbGlkYXRlU2VsZWN0b3IocG9pbnRlciwgZXZlbnQsIHRoaXMubWF0Y2hlcywgdGhpcy5tYXRjaEVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gcGFyZW50RWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJlcGFyZWQubmFtZSAgPSBhY3Rpb24ubmFtZTtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXBhcmVkLmF4aXMgID0gYWN0aW9uLmF4aXM7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmVwYXJlZC5lZGdlcyA9IGFjdGlvbi5lZGdlcztcblxuICAgICAgICAgICAgICAgIHRoaXMuY29sbGVjdEV2ZW50VGFyZ2V0cyhwb2ludGVyLCBldmVudCwgZXZlbnRUYXJnZXQsICdkb3duJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wb2ludGVyRG93bihwb2ludGVyLCBldmVudCwgZXZlbnRUYXJnZXQsIGN1ckV2ZW50VGFyZ2V0LCBhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gdGhlc2Ugbm93IHNpbmNlIHBvaW50ZXJEb3duIGlzbid0IGJlaW5nIGNhbGxlZCBmcm9tIGhlcmVcbiAgICAgICAgICAgICAgICB0aGlzLmRvd25UaW1lc1twb2ludGVySW5kZXhdID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kb3duVGFyZ2V0c1twb2ludGVySW5kZXhdID0gZXZlbnRUYXJnZXQ7XG4gICAgICAgICAgICAgICAgcG9pbnRlckV4dGVuZCh0aGlzLmRvd25Qb2ludGVyLCBwb2ludGVyKTtcblxuICAgICAgICAgICAgICAgIGNvcHlDb29yZHModGhpcy5wcmV2Q29vcmRzLCB0aGlzLmN1ckNvb3Jkcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludGVyV2FzTW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jb2xsZWN0RXZlbnRUYXJnZXRzKHBvaW50ZXIsIGV2ZW50LCBldmVudFRhcmdldCwgJ2Rvd24nKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBEZXRlcm1pbmUgYWN0aW9uIHRvIGJlIHBlcmZvcm1lZCBvbiBuZXh0IHBvaW50ZXJNb3ZlIGFuZCBhZGQgYXBwcm9wcmlhdGVcbiAgICAgICAgLy8gc3R5bGUgYW5kIGV2ZW50IExpc3RlbmVyc1xuICAgICAgICBwb2ludGVyRG93bjogZnVuY3Rpb24gKHBvaW50ZXIsIGV2ZW50LCBldmVudFRhcmdldCwgY3VyRXZlbnRUYXJnZXQsIGZvcmNlQWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIWZvcmNlQWN0aW9uICYmICF0aGlzLmluZXJ0aWFTdGF0dXMuYWN0aXZlICYmIHRoaXMucG9pbnRlcldhc01vdmVkICYmIHRoaXMucHJlcGFyZWQubmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tBbmRQcmV2ZW50RGVmYXVsdChldmVudCwgdGhpcy50YXJnZXQsIHRoaXMuZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucG9pbnRlcklzRG93biA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRvd25FdmVudCA9IGV2ZW50O1xuXG4gICAgICAgICAgICB2YXIgcG9pbnRlckluZGV4ID0gdGhpcy5hZGRQb2ludGVyKHBvaW50ZXIpLFxuICAgICAgICAgICAgICAgIGFjdGlvbjtcblxuICAgICAgICAgICAgLy8gSWYgaXQgaXMgdGhlIHNlY29uZCB0b3VjaCBvZiBhIG11bHRpLXRvdWNoIGdlc3R1cmUsIGtlZXAgdGhlXG4gICAgICAgICAgICAvLyB0YXJnZXQgdGhlIHNhbWUgYW5kIGdldCBhIG5ldyBhY3Rpb24gaWYgYSB0YXJnZXQgd2FzIHNldCBieSB0aGVcbiAgICAgICAgICAgIC8vIGZpcnN0IHRvdWNoXG4gICAgICAgICAgICBpZiAodGhpcy5wb2ludGVySWRzLmxlbmd0aCA+IDEgJiYgdGhpcy50YXJnZXQuX2VsZW1lbnQgPT09IHRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdBY3Rpb24gPSB2YWxpZGF0ZUFjdGlvbihmb3JjZUFjdGlvbiB8fCB0aGlzLnRhcmdldC5nZXRBY3Rpb24ocG9pbnRlciwgZXZlbnQsIHRoaXMsIHRoaXMuZWxlbWVudCksIHRoaXMudGFyZ2V0KTtcblxuICAgICAgICAgICAgICAgIGlmICh3aXRoaW5JbnRlcmFjdGlvbkxpbWl0KHRoaXMudGFyZ2V0LCB0aGlzLmVsZW1lbnQsIG5ld0FjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gbmV3QWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMucHJlcGFyZWQubmFtZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHNldCB0aGUgdGFyZ2V0IGlmIHRoZXJlIGlzIG5vIGFjdGlvbiBwcmVwYXJlZFxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMucHJlcGFyZWQubmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBpbnRlcmFjdGFibGUgPSBpbnRlcmFjdGFibGVzLmdldChjdXJFdmVudFRhcmdldCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJhY3RhYmxlXG4gICAgICAgICAgICAgICAgICAgICYmICF0ZXN0SWdub3JlKGludGVyYWN0YWJsZSwgY3VyRXZlbnRUYXJnZXQsIGV2ZW50VGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICAmJiB0ZXN0QWxsb3coaW50ZXJhY3RhYmxlLCBjdXJFdmVudFRhcmdldCwgZXZlbnRUYXJnZXQpXG4gICAgICAgICAgICAgICAgICAgICYmIChhY3Rpb24gPSB2YWxpZGF0ZUFjdGlvbihmb3JjZUFjdGlvbiB8fCBpbnRlcmFjdGFibGUuZ2V0QWN0aW9uKHBvaW50ZXIsIGV2ZW50LCB0aGlzLCBjdXJFdmVudFRhcmdldCksIGludGVyYWN0YWJsZSwgZXZlbnRUYXJnZXQpKVxuICAgICAgICAgICAgICAgICAgICAmJiB3aXRoaW5JbnRlcmFjdGlvbkxpbWl0KGludGVyYWN0YWJsZSwgY3VyRXZlbnRUYXJnZXQsIGFjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBpbnRlcmFjdGFibGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IGN1ckV2ZW50VGFyZ2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0LFxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB0YXJnZXQgJiYgdGFyZ2V0Lm9wdGlvbnM7XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXQgJiYgKGZvcmNlQWN0aW9uIHx8ICF0aGlzLnByZXBhcmVkLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uID0gYWN0aW9uIHx8IHZhbGlkYXRlQWN0aW9uKGZvcmNlQWN0aW9uIHx8IHRhcmdldC5nZXRBY3Rpb24ocG9pbnRlciwgZXZlbnQsIHRoaXMsIGN1ckV2ZW50VGFyZ2V0KSwgdGFyZ2V0LCB0aGlzLmVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFdmVudFhZKHRoaXMuc3RhcnRDb29yZHMsIHRoaXMucG9pbnRlcnMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFhY3Rpb24pIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdHlsZUN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuX2RvYy5kb2N1bWVudEVsZW1lbnQuc3R5bGUuY3Vyc29yID0gZ2V0QWN0aW9uQ3Vyc29yKGFjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemVBeGVzID0gYWN0aW9uLm5hbWUgPT09ICdyZXNpemUnPyBhY3Rpb24uYXhpcyA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uID09PSAnZ2VzdHVyZScgJiYgdGhpcy5wb2ludGVySWRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnByZXBhcmVkLm5hbWUgID0gYWN0aW9uLm5hbWU7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmVwYXJlZC5heGlzICA9IGFjdGlvbi5heGlzO1xuICAgICAgICAgICAgICAgIHRoaXMucHJlcGFyZWQuZWRnZXMgPSBhY3Rpb24uZWRnZXM7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNuYXBTdGF0dXMuc25hcHBlZFggPSB0aGlzLnNuYXBTdGF0dXMuc25hcHBlZFkgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3RyaWN0U3RhdHVzLnJlc3RyaWN0ZWRYID0gdGhpcy5yZXN0cmljdFN0YXR1cy5yZXN0cmljdGVkWSA9IE5hTjtcblxuICAgICAgICAgICAgICAgIHRoaXMuZG93blRpbWVzW3BvaW50ZXJJbmRleF0gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvd25UYXJnZXRzW3BvaW50ZXJJbmRleF0gPSBldmVudFRhcmdldDtcbiAgICAgICAgICAgICAgICBwb2ludGVyRXh0ZW5kKHRoaXMuZG93blBvaW50ZXIsIHBvaW50ZXIpO1xuXG4gICAgICAgICAgICAgICAgY29weUNvb3Jkcyh0aGlzLnByZXZDb29yZHMsIHRoaXMuc3RhcnRDb29yZHMpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlcldhc01vdmVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQW5kUHJldmVudERlZmF1bHQoZXZlbnQsIHRhcmdldCwgdGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGluZXJ0aWEgaXMgYWN0aXZlIHRyeSB0byByZXN1bWUgYWN0aW9uXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmluZXJ0aWFTdGF0dXMuYWN0aXZlXG4gICAgICAgICAgICAgICAgJiYgY3VyRXZlbnRUYXJnZXQgPT09IHRoaXMuZWxlbWVudFxuICAgICAgICAgICAgICAgICYmIHZhbGlkYXRlQWN0aW9uKHRhcmdldC5nZXRBY3Rpb24ocG9pbnRlciwgZXZlbnQsIHRoaXMsIHRoaXMuZWxlbWVudCksIHRhcmdldCkubmFtZSA9PT0gdGhpcy5wcmVwYXJlZC5uYW1lKSB7XG5cbiAgICAgICAgICAgICAgICBjYW5jZWxGcmFtZSh0aGlzLmluZXJ0aWFTdGF0dXMuaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmVydGlhU3RhdHVzLmFjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0FuZFByZXZlbnREZWZhdWx0KGV2ZW50LCB0YXJnZXQsIHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0TW9kaWZpY2F0aW9uczogZnVuY3Rpb24gKGNvb3JkcywgcHJlRW5kKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ICAgICAgICAgPSB0aGlzLnRhcmdldCxcbiAgICAgICAgICAgICAgICBzaG91bGRNb3ZlICAgICA9IHRydWUsXG4gICAgICAgICAgICAgICAgc2hvdWxkU25hcCAgICAgPSBjaGVja1NuYXAodGFyZ2V0LCB0aGlzLnByZXBhcmVkLm5hbWUpICAgICAmJiAoIXRhcmdldC5vcHRpb25zW3RoaXMucHJlcGFyZWQubmFtZV0uc25hcC5lbmRPbmx5ICAgICB8fCBwcmVFbmQpLFxuICAgICAgICAgICAgICAgIHNob3VsZFJlc3RyaWN0ID0gY2hlY2tSZXN0cmljdCh0YXJnZXQsIHRoaXMucHJlcGFyZWQubmFtZSkgJiYgKCF0YXJnZXQub3B0aW9uc1t0aGlzLnByZXBhcmVkLm5hbWVdLnJlc3RyaWN0LmVuZE9ubHkgfHwgcHJlRW5kKTtcblxuICAgICAgICAgICAgaWYgKHNob3VsZFNuYXAgICAgKSB7IHRoaXMuc2V0U25hcHBpbmcgICAoY29vcmRzKTsgfSBlbHNlIHsgdGhpcy5zbmFwU3RhdHVzICAgIC5sb2NrZWQgICAgID0gZmFsc2U7IH1cbiAgICAgICAgICAgIGlmIChzaG91bGRSZXN0cmljdCkgeyB0aGlzLnNldFJlc3RyaWN0aW9uKGNvb3Jkcyk7IH0gZWxzZSB7IHRoaXMucmVzdHJpY3RTdGF0dXMucmVzdHJpY3RlZCA9IGZhbHNlOyB9XG5cbiAgICAgICAgICAgIGlmIChzaG91bGRTbmFwICYmIHRoaXMuc25hcFN0YXR1cy5sb2NrZWQgJiYgIXRoaXMuc25hcFN0YXR1cy5jaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkTW92ZSA9IHNob3VsZFJlc3RyaWN0ICYmIHRoaXMucmVzdHJpY3RTdGF0dXMucmVzdHJpY3RlZCAmJiB0aGlzLnJlc3RyaWN0U3RhdHVzLmNoYW5nZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaG91bGRSZXN0cmljdCAmJiB0aGlzLnJlc3RyaWN0U3RhdHVzLnJlc3RyaWN0ZWQgJiYgIXRoaXMucmVzdHJpY3RTdGF0dXMuY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHNob3VsZE1vdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNob3VsZE1vdmU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0U3RhcnRPZmZzZXRzOiBmdW5jdGlvbiAoYWN0aW9uLCBpbnRlcmFjdGFibGUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gaW50ZXJhY3RhYmxlLmdldFJlY3QoZWxlbWVudCksXG4gICAgICAgICAgICAgICAgb3JpZ2luID0gZ2V0T3JpZ2luWFkoaW50ZXJhY3RhYmxlLCBlbGVtZW50KSxcbiAgICAgICAgICAgICAgICBzbmFwID0gaW50ZXJhY3RhYmxlLm9wdGlvbnNbdGhpcy5wcmVwYXJlZC5uYW1lXS5zbmFwLFxuICAgICAgICAgICAgICAgIHJlc3RyaWN0ID0gaW50ZXJhY3RhYmxlLm9wdGlvbnNbdGhpcy5wcmVwYXJlZC5uYW1lXS5yZXN0cmljdCxcbiAgICAgICAgICAgICAgICB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAocmVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRPZmZzZXQubGVmdCA9IHRoaXMuc3RhcnRDb29yZHMucGFnZS54IC0gcmVjdC5sZWZ0O1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRPZmZzZXQudG9wICA9IHRoaXMuc3RhcnRDb29yZHMucGFnZS55IC0gcmVjdC50b3A7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0T2Zmc2V0LnJpZ2h0ICA9IHJlY3QucmlnaHQgIC0gdGhpcy5zdGFydENvb3Jkcy5wYWdlLng7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydE9mZnNldC5ib3R0b20gPSByZWN0LmJvdHRvbSAtIHRoaXMuc3RhcnRDb29yZHMucGFnZS55O1xuXG4gICAgICAgICAgICAgICAgaWYgKCd3aWR0aCcgaW4gcmVjdCkgeyB3aWR0aCA9IHJlY3Qud2lkdGg7IH1cbiAgICAgICAgICAgICAgICBlbHNlIHsgd2lkdGggPSByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0OyB9XG4gICAgICAgICAgICAgICAgaWYgKCdoZWlnaHQnIGluIHJlY3QpIHsgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7IH1cbiAgICAgICAgICAgICAgICBlbHNlIHsgaGVpZ2h0ID0gcmVjdC5ib3R0b20gLSByZWN0LnRvcDsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydE9mZnNldC5sZWZ0ID0gdGhpcy5zdGFydE9mZnNldC50b3AgPSB0aGlzLnN0YXJ0T2Zmc2V0LnJpZ2h0ID0gdGhpcy5zdGFydE9mZnNldC5ib3R0b20gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNuYXBPZmZzZXRzLnNwbGljZSgwKTtcblxuICAgICAgICAgICAgdmFyIHNuYXBPZmZzZXQgPSBzbmFwICYmIHNuYXAub2Zmc2V0ID09PSAnc3RhcnRDb29yZHMnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogdGhpcy5zdGFydENvb3Jkcy5wYWdlLnggLSBvcmlnaW4ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRoaXMuc3RhcnRDb29yZHMucGFnZS55IC0gb3JpZ2luLnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHNuYXAgJiYgc25hcC5vZmZzZXQgfHwgeyB4OiAwLCB5OiAwIH07XG5cbiAgICAgICAgICAgIGlmIChyZWN0ICYmIHNuYXAgJiYgc25hcC5yZWxhdGl2ZVBvaW50cyAmJiBzbmFwLnJlbGF0aXZlUG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc25hcC5yZWxhdGl2ZVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNuYXBPZmZzZXRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogdGhpcy5zdGFydE9mZnNldC5sZWZ0IC0gKHdpZHRoICAqIHNuYXAucmVsYXRpdmVQb2ludHNbaV0ueCkgKyBzbmFwT2Zmc2V0LngsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB0aGlzLnN0YXJ0T2Zmc2V0LnRvcCAgLSAoaGVpZ2h0ICogc25hcC5yZWxhdGl2ZVBvaW50c1tpXS55KSArIHNuYXBPZmZzZXQueVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNuYXBPZmZzZXRzLnB1c2goc25hcE9mZnNldCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZWN0ICYmIHJlc3RyaWN0LmVsZW1lbnRSZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0cmljdE9mZnNldC5sZWZ0ID0gdGhpcy5zdGFydE9mZnNldC5sZWZ0IC0gKHdpZHRoICAqIHJlc3RyaWN0LmVsZW1lbnRSZWN0LmxlZnQpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdHJpY3RPZmZzZXQudG9wICA9IHRoaXMuc3RhcnRPZmZzZXQudG9wICAtIChoZWlnaHQgKiByZXN0cmljdC5lbGVtZW50UmVjdC50b3ApO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0cmljdE9mZnNldC5yaWdodCAgPSB0aGlzLnN0YXJ0T2Zmc2V0LnJpZ2h0ICAtICh3aWR0aCAgKiAoMSAtIHJlc3RyaWN0LmVsZW1lbnRSZWN0LnJpZ2h0KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0cmljdE9mZnNldC5ib3R0b20gPSB0aGlzLnN0YXJ0T2Zmc2V0LmJvdHRvbSAtIChoZWlnaHQgKiAoMSAtIHJlc3RyaWN0LmVsZW1lbnRSZWN0LmJvdHRvbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0cmljdE9mZnNldC5sZWZ0ID0gdGhpcy5yZXN0cmljdE9mZnNldC50b3AgPSB0aGlzLnJlc3RyaWN0T2Zmc2V0LnJpZ2h0ID0gdGhpcy5yZXN0cmljdE9mZnNldC5ib3R0b20gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qXFxcbiAgICAgICAgICogSW50ZXJhY3Rpb24uc3RhcnRcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICpcbiAgICAgICAgICogU3RhcnQgYW4gYWN0aW9uIHdpdGggdGhlIGdpdmVuIEludGVyYWN0YWJsZSBhbmQgRWxlbWVudCBhcyB0YXJ0Z2V0cy4gVGhlXG4gICAgICAgICAqIGFjdGlvbiBtdXN0IGJlIGVuYWJsZWQgZm9yIHRoZSB0YXJnZXQgSW50ZXJhY3RhYmxlIGFuZCBhbiBhcHByb3ByaWF0ZSBudW1iZXJcbiAgICAgICAgICogb2YgcG9pbnRlcnMgbXVzdCBiZSBoZWxkIGRvd24g4oCTIDEgZm9yIGRyYWcvcmVzaXplLCAyIGZvciBnZXN0dXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBVc2UgaXQgd2l0aCBgaW50ZXJhY3RhYmxlLjxhY3Rpb24+YWJsZSh7IG1hbnVhbFN0YXJ0OiBmYWxzZSB9KWAgdG8gYWx3YXlzXG4gICAgICAgICAqIFtzdGFydCBhY3Rpb25zIG1hbnVhbGx5XShodHRwczovL2dpdGh1Yi5jb20vdGF5ZS9pbnRlcmFjdC5qcy9pc3N1ZXMvMTE0KVxuICAgICAgICAgKlxuICAgICAgICAgLSBhY3Rpb24gICAgICAgKG9iamVjdCkgIFRoZSBhY3Rpb24gdG8gYmUgcGVyZm9ybWVkIC0gZHJhZywgcmVzaXplLCBldGMuXG4gICAgICAgICAtIGludGVyYWN0YWJsZSAoSW50ZXJhY3RhYmxlKSBUaGUgSW50ZXJhY3RhYmxlIHRvIHRhcmdldFxuICAgICAgICAgLSBlbGVtZW50ICAgICAgKEVsZW1lbnQpIFRoZSBET00gRWxlbWVudCB0byB0YXJnZXRcbiAgICAgICAgID0gKG9iamVjdCkgaW50ZXJhY3RcbiAgICAgICAgICoqXG4gICAgICAgICB8IGludGVyYWN0KHRhcmdldClcbiAgICAgICAgIHwgICAuZHJhZ2dhYmxlKHtcbiAgICAgICAgIHwgICAgIC8vIGRpc2FibGUgdGhlIGRlZmF1bHQgZHJhZyBzdGFydCBieSBkb3duLT5tb3ZlXG4gICAgICAgICB8ICAgICBtYW51YWxTdGFydDogdHJ1ZVxuICAgICAgICAgfCAgIH0pXG4gICAgICAgICB8ICAgLy8gc3RhcnQgZHJhZ2dpbmcgYWZ0ZXIgdGhlIHVzZXIgaG9sZHMgdGhlIHBvaW50ZXIgZG93blxuICAgICAgICAgfCAgIC5vbignaG9sZCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgfCAgICAgdmFyIGludGVyYWN0aW9uID0gZXZlbnQuaW50ZXJhY3Rpb247XG4gICAgICAgICB8XG4gICAgICAgICB8ICAgICBpZiAoIWludGVyYWN0aW9uLmludGVyYWN0aW5nKCkpIHtcbiAgICAgICAgIHwgICAgICAgaW50ZXJhY3Rpb24uc3RhcnQoeyBuYW1lOiAnZHJhZycgfSxcbiAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuaW50ZXJhY3RhYmxlLFxuICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgIHwgICAgIH1cbiAgICAgICAgIHwgfSk7XG4gICAgICAgIFxcKi9cbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uIChhY3Rpb24sIGludGVyYWN0YWJsZSwgZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJhY3RpbmcoKVxuICAgICAgICAgICAgICAgIHx8ICF0aGlzLnBvaW50ZXJJc0Rvd25cbiAgICAgICAgICAgICAgICB8fCB0aGlzLnBvaW50ZXJJZHMubGVuZ3RoIDwgKGFjdGlvbi5uYW1lID09PSAnZ2VzdHVyZSc/IDIgOiAxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhpcyBpbnRlcmFjdGlvbiBoYWQgYmVlbiByZW1vdmVkIGFmdGVyIHN0b3BwaW5nXG4gICAgICAgICAgICAvLyBhZGQgaXQgYmFja1xuICAgICAgICAgICAgaWYgKGluZGV4T2YoaW50ZXJhY3Rpb25zLCB0aGlzKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbnMucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2V0IHRoZSBzdGFydENvb3JkcyBpZiB0aGVyZSB3YXMgbm8gcHJlcGFyZWQgYWN0aW9uXG4gICAgICAgICAgICBpZiAoIXRoaXMucHJlcGFyZWQubmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RXZlbnRYWSh0aGlzLnN0YXJ0Q29vcmRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wcmVwYXJlZC5uYW1lICA9IGFjdGlvbi5uYW1lO1xuICAgICAgICAgICAgdGhpcy5wcmVwYXJlZC5heGlzICA9IGFjdGlvbi5heGlzO1xuICAgICAgICAgICAgdGhpcy5wcmVwYXJlZC5lZGdlcyA9IGFjdGlvbi5lZGdlcztcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ICAgICAgICAgPSBpbnRlcmFjdGFibGU7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgICAgICAgID0gZWxlbWVudDtcblxuICAgICAgICAgICAgdGhpcy5zZXRTdGFydE9mZnNldHMoYWN0aW9uLm5hbWUsIGludGVyYWN0YWJsZSwgZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLnNldE1vZGlmaWNhdGlvbnModGhpcy5zdGFydENvb3Jkcy5wYWdlKTtcblxuICAgICAgICAgICAgdGhpcy5wcmV2RXZlbnQgPSB0aGlzW3RoaXMucHJlcGFyZWQubmFtZSArICdTdGFydCddKHRoaXMuZG93bkV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBwb2ludGVyTW92ZTogZnVuY3Rpb24gKHBvaW50ZXIsIGV2ZW50LCBldmVudFRhcmdldCwgY3VyRXZlbnRUYXJnZXQsIHByZUVuZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5lcnRpYVN0YXR1cy5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFnZVVwICAgPSB0aGlzLmluZXJ0aWFTdGF0dXMudXBDb29yZHMucGFnZTtcbiAgICAgICAgICAgICAgICB2YXIgY2xpZW50VXAgPSB0aGlzLmluZXJ0aWFTdGF0dXMudXBDb29yZHMuY2xpZW50O1xuXG4gICAgICAgICAgICAgICAgdmFyIGluZXJ0aWFQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZVggIDogcGFnZVVwLnggICArIHRoaXMuaW5lcnRpYVN0YXR1cy5zeCxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVkgIDogcGFnZVVwLnkgICArIHRoaXMuaW5lcnRpYVN0YXR1cy5zeSxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50WDogY2xpZW50VXAueCArIHRoaXMuaW5lcnRpYVN0YXR1cy5zeCxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50WTogY2xpZW50VXAueSArIHRoaXMuaW5lcnRpYVN0YXR1cy5zeVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNldEV2ZW50WFkodGhpcy5jdXJDb29yZHMsIFtpbmVydGlhUG9zaXRpb25dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVjb3JkUG9pbnRlcihwb2ludGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEV2ZW50WFkodGhpcy5jdXJDb29yZHMsIHRoaXMucG9pbnRlcnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZHVwbGljYXRlTW92ZSA9ICh0aGlzLmN1ckNvb3Jkcy5wYWdlLnggPT09IHRoaXMucHJldkNvb3Jkcy5wYWdlLnhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHRoaXMuY3VyQ29vcmRzLnBhZ2UueSA9PT0gdGhpcy5wcmV2Q29vcmRzLnBhZ2UueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgdGhpcy5jdXJDb29yZHMuY2xpZW50LnggPT09IHRoaXMucHJldkNvb3Jkcy5jbGllbnQueFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgdGhpcy5jdXJDb29yZHMuY2xpZW50LnkgPT09IHRoaXMucHJldkNvb3Jkcy5jbGllbnQueSk7XG5cbiAgICAgICAgICAgIHZhciBkeCwgZHksXG4gICAgICAgICAgICAgICAgcG9pbnRlckluZGV4ID0gdGhpcy5tb3VzZT8gMCA6IGluZGV4T2YodGhpcy5wb2ludGVySWRzLCBnZXRQb2ludGVySWQocG9pbnRlcikpO1xuXG4gICAgICAgICAgICAvLyByZWdpc3RlciBtb3ZlbWVudCBncmVhdGVyIHRoYW4gcG9pbnRlck1vdmVUb2xlcmFuY2VcbiAgICAgICAgICAgIGlmICh0aGlzLnBvaW50ZXJJc0Rvd24gJiYgIXRoaXMucG9pbnRlcldhc01vdmVkKSB7XG4gICAgICAgICAgICAgICAgZHggPSB0aGlzLmN1ckNvb3Jkcy5jbGllbnQueCAtIHRoaXMuc3RhcnRDb29yZHMuY2xpZW50Lng7XG4gICAgICAgICAgICAgICAgZHkgPSB0aGlzLmN1ckNvb3Jkcy5jbGllbnQueSAtIHRoaXMuc3RhcnRDb29yZHMuY2xpZW50Lnk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50ZXJXYXNNb3ZlZCA9IGh5cG90KGR4LCBkeSkgPiBwb2ludGVyTW92ZVRvbGVyYW5jZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFkdXBsaWNhdGVNb3ZlICYmICghdGhpcy5wb2ludGVySXNEb3duIHx8IHRoaXMucG9pbnRlcldhc01vdmVkKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvaW50ZXJJc0Rvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaG9sZFRpbWVyc1twb2ludGVySW5kZXhdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxlY3RFdmVudFRhcmdldHMocG9pbnRlciwgZXZlbnQsIGV2ZW50VGFyZ2V0LCAnbW92ZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMucG9pbnRlcklzRG93bikgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgaWYgKGR1cGxpY2F0ZU1vdmUgJiYgdGhpcy5wb2ludGVyV2FzTW92ZWQgJiYgIXByZUVuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tBbmRQcmV2ZW50RGVmYXVsdChldmVudCwgdGhpcy50YXJnZXQsIHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZXQgcG9pbnRlciBjb29yZGluYXRlLCB0aW1lIGNoYW5nZXMgYW5kIHNwZWVkc1xuICAgICAgICAgICAgc2V0RXZlbnREZWx0YXModGhpcy5wb2ludGVyRGVsdGEsIHRoaXMucHJldkNvb3JkcywgdGhpcy5jdXJDb29yZHMpO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMucHJlcGFyZWQubmFtZSkgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgaWYgKHRoaXMucG9pbnRlcldhc01vdmVkXG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIG1vdmVtZW50IHdoaWxlIGluZXJ0aWEgaXMgYWN0aXZlXG4gICAgICAgICAgICAgICAgJiYgKCF0aGlzLmluZXJ0aWFTdGF0dXMuYWN0aXZlIHx8IChwb2ludGVyIGluc3RhbmNlb2YgSW50ZXJhY3RFdmVudCAmJiAvaW5lcnRpYXN0YXJ0Ly50ZXN0KHBvaW50ZXIudHlwZSkpKSkge1xuXG4gICAgICAgICAgICAgICAgLy8gaWYganVzdCBzdGFydGluZyBhbiBhY3Rpb24sIGNhbGN1bGF0ZSB0aGUgcG9pbnRlciBzcGVlZCBub3dcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaW50ZXJhY3RpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRFdmVudERlbHRhcyh0aGlzLnBvaW50ZXJEZWx0YSwgdGhpcy5wcmV2Q29vcmRzLCB0aGlzLmN1ckNvb3Jkcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgYSBkcmFnIGlzIGluIHRoZSBjb3JyZWN0IGF4aXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJlcGFyZWQubmFtZSA9PT0gJ2RyYWcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWJzWCA9IE1hdGguYWJzKGR4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYnNZID0gTWF0aC5hYnMoZHkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEF4aXMgPSB0aGlzLnRhcmdldC5vcHRpb25zLmRyYWcuYXhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzID0gKGFic1ggPiBhYnNZID8gJ3gnIDogYWJzWCA8IGFic1kgPyAneScgOiAneHknKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIG1vdmVtZW50IGlzbid0IGluIHRoZSBheGlzIG9mIHRoZSBpbnRlcmFjdGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChheGlzICE9PSAneHknICYmIHRhcmdldEF4aXMgIT09ICd4eScgJiYgdGFyZ2V0QXhpcyAhPT0gYXhpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbmNlbCB0aGUgcHJlcGFyZWQgYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmVwYXJlZC5uYW1lID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gdHJ5IHRvIGdldCBhIGRyYWcgZnJvbSBhbm90aGVyIGluZXJhY3RhYmxlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGV2ZW50VGFyZ2V0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZWxlbWVudCBpbnRlcmFjdGFibGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGlzRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudEludGVyYWN0YWJsZSA9IGludGVyYWN0YWJsZXMuZ2V0KGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50SW50ZXJhY3RhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBlbGVtZW50SW50ZXJhY3RhYmxlICE9PSB0aGlzLnRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgIWVsZW1lbnRJbnRlcmFjdGFibGUub3B0aW9ucy5kcmFnLm1hbnVhbFN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBlbGVtZW50SW50ZXJhY3RhYmxlLmdldEFjdGlvbih0aGlzLmRvd25Qb2ludGVyLCB0aGlzLmRvd25FdmVudCwgdGhpcywgZWxlbWVudCkubmFtZSA9PT0gJ2RyYWcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBjaGVja0F4aXMoYXhpcywgZWxlbWVudEludGVyYWN0YWJsZSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmVwYXJlZC5uYW1lID0gJ2RyYWcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBlbGVtZW50SW50ZXJhY3RhYmxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IHBhcmVudEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBubyBkcmFnIGZyb20gZWxlbWVudCBpbnRlcmFjdGFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoZSBzZWxlY3RvciBpbnRlcmFjdGFibGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByZXBhcmVkLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoaXNJbnRlcmFjdGlvbiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdldERyYWdnYWJsZSA9IGZ1bmN0aW9uIChpbnRlcmFjdGFibGUsIHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBpZThNYXRjaGVzU2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGludGVyYWN0YWJsZSA9PT0gdGhpc0ludGVyYWN0aW9uLnRhcmdldCkgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluQ29udGV4dChpbnRlcmFjdGFibGUsIGV2ZW50VGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmICFpbnRlcmFjdGFibGUub3B0aW9ucy5kcmFnLm1hbnVhbFN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgIXRlc3RJZ25vcmUoaW50ZXJhY3RhYmxlLCBlbGVtZW50LCBldmVudFRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiB0ZXN0QWxsb3coaW50ZXJhY3RhYmxlLCBlbGVtZW50LCBldmVudFRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBtYXRjaGVzU2VsZWN0b3IoZWxlbWVudCwgc2VsZWN0b3IsIGVsZW1lbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGludGVyYWN0YWJsZS5nZXRBY3Rpb24odGhpc0ludGVyYWN0aW9uLmRvd25Qb2ludGVyLCB0aGlzSW50ZXJhY3Rpb24uZG93bkV2ZW50LCB0aGlzSW50ZXJhY3Rpb24sIGVsZW1lbnQpLm5hbWUgPT09ICdkcmFnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGNoZWNrQXhpcyhheGlzLCBpbnRlcmFjdGFibGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgd2l0aGluSW50ZXJhY3Rpb25MaW1pdChpbnRlcmFjdGFibGUsIGVsZW1lbnQsICdkcmFnJykpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcmFjdGFibGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGV2ZW50VGFyZ2V0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpc0VsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvckludGVyYWN0YWJsZSA9IGludGVyYWN0YWJsZXMuZm9yRWFjaFNlbGVjdG9yKGdldERyYWdnYWJsZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvckludGVyYWN0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJlcGFyZWQubmFtZSA9ICdkcmFnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldCA9IHNlbGVjdG9ySW50ZXJhY3RhYmxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBwYXJlbnRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0aW5nID0gISF0aGlzLnByZXBhcmVkLm5hbWUgJiYgIXRoaXMuaW50ZXJhY3RpbmcoKTtcblxuICAgICAgICAgICAgICAgIGlmIChzdGFydGluZ1xuICAgICAgICAgICAgICAgICAgICAmJiAodGhpcy50YXJnZXQub3B0aW9uc1t0aGlzLnByZXBhcmVkLm5hbWVdLm1hbnVhbFN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICB8fCAhd2l0aGluSW50ZXJhY3Rpb25MaW1pdCh0aGlzLnRhcmdldCwgdGhpcy5lbGVtZW50LCB0aGlzLnByZXBhcmVkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXBhcmVkLm5hbWUgJiYgdGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0KHRoaXMucHJlcGFyZWQsIHRoaXMudGFyZ2V0LCB0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNob3VsZE1vdmUgPSB0aGlzLnNldE1vZGlmaWNhdGlvbnModGhpcy5jdXJDb29yZHMucGFnZSwgcHJlRW5kKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIGlmIHNuYXBwaW5nIG9yIHJlc3RyaWN0aW9uIGRvZXNuJ3QgcHJldmVudCBpdFxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkTW92ZSB8fCBzdGFydGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2RXZlbnQgPSB0aGlzW3RoaXMucHJlcGFyZWQubmFtZSArICdNb3ZlJ10oZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja0FuZFByZXZlbnREZWZhdWx0KGV2ZW50LCB0aGlzLnRhcmdldCwgdGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvcHlDb29yZHModGhpcy5wcmV2Q29vcmRzLCB0aGlzLmN1ckNvb3Jkcyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmRyYWdnaW5nIHx8IHRoaXMucmVzaXppbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9TY3JvbGxNb3ZlKHBvaW50ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRyYWdTdGFydDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZHJhZ0V2ZW50ID0gbmV3IEludGVyYWN0RXZlbnQodGhpcywgZXZlbnQsICdkcmFnJywgJ3N0YXJ0JywgdGhpcy5lbGVtZW50KTtcblxuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC5maXJlKGRyYWdFdmVudCk7XG5cbiAgICAgICAgICAgIC8vIHJlc2V0IGFjdGl2ZSBkcm9wem9uZXNcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlRHJvcHMuZHJvcHpvbmVzID0gW107XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZURyb3BzLmVsZW1lbnRzICA9IFtdO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVEcm9wcy5yZWN0cyAgICAgPSBbXTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmR5bmFtaWNEcm9wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBY3RpdmVEcm9wcyh0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZHJvcEV2ZW50cyA9IHRoaXMuZ2V0RHJvcEV2ZW50cyhldmVudCwgZHJhZ0V2ZW50KTtcblxuICAgICAgICAgICAgaWYgKGRyb3BFdmVudHMuYWN0aXZhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVBY3RpdmVEcm9wcyhkcm9wRXZlbnRzLmFjdGl2YXRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRyYWdFdmVudDtcbiAgICAgICAgfSxcblxuICAgICAgICBkcmFnTW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQsXG4gICAgICAgICAgICAgICAgZHJhZ0V2ZW50ICA9IG5ldyBJbnRlcmFjdEV2ZW50KHRoaXMsIGV2ZW50LCAnZHJhZycsICdtb3ZlJywgdGhpcy5lbGVtZW50KSxcbiAgICAgICAgICAgICAgICBkcmFnZ2FibGVFbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgICAgICAgICAgIGRyb3AgPSB0aGlzLmdldERyb3AoZHJhZ0V2ZW50LCBldmVudCwgZHJhZ2dhYmxlRWxlbWVudCk7XG5cbiAgICAgICAgICAgIHRoaXMuZHJvcFRhcmdldCA9IGRyb3AuZHJvcHpvbmU7XG4gICAgICAgICAgICB0aGlzLmRyb3BFbGVtZW50ID0gZHJvcC5lbGVtZW50O1xuXG4gICAgICAgICAgICB2YXIgZHJvcEV2ZW50cyA9IHRoaXMuZ2V0RHJvcEV2ZW50cyhldmVudCwgZHJhZ0V2ZW50KTtcblxuICAgICAgICAgICAgdGFyZ2V0LmZpcmUoZHJhZ0V2ZW50KTtcblxuICAgICAgICAgICAgaWYgKGRyb3BFdmVudHMubGVhdmUpIHsgdGhpcy5wcmV2RHJvcFRhcmdldC5maXJlKGRyb3BFdmVudHMubGVhdmUpOyB9XG4gICAgICAgICAgICBpZiAoZHJvcEV2ZW50cy5lbnRlcikgeyAgICAgdGhpcy5kcm9wVGFyZ2V0LmZpcmUoZHJvcEV2ZW50cy5lbnRlcik7IH1cbiAgICAgICAgICAgIGlmIChkcm9wRXZlbnRzLm1vdmUgKSB7ICAgICB0aGlzLmRyb3BUYXJnZXQuZmlyZShkcm9wRXZlbnRzLm1vdmUgKTsgfVxuXG4gICAgICAgICAgICB0aGlzLnByZXZEcm9wVGFyZ2V0ICA9IHRoaXMuZHJvcFRhcmdldDtcbiAgICAgICAgICAgIHRoaXMucHJldkRyb3BFbGVtZW50ID0gdGhpcy5kcm9wRWxlbWVudDtcblxuICAgICAgICAgICAgcmV0dXJuIGRyYWdFdmVudDtcbiAgICAgICAgfSxcblxuICAgICAgICByZXNpemVTdGFydDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcmVzaXplRXZlbnQgPSBuZXcgSW50ZXJhY3RFdmVudCh0aGlzLCBldmVudCwgJ3Jlc2l6ZScsICdzdGFydCcsIHRoaXMuZWxlbWVudCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnByZXBhcmVkLmVkZ2VzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0UmVjdCA9IHRoaXMudGFyZ2V0LmdldFJlY3QodGhpcy5lbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogV2hlbiB1c2luZyB0aGUgYHJlc2l6YWJsZS5zcXVhcmVgIG9yIGByZXNpemFibGUucHJlc2VydmVBc3BlY3RSYXRpb2Agb3B0aW9ucywgcmVzaXppbmcgZnJvbSBvbmUgZWRnZVxuICAgICAgICAgICAgICAgICAqIHdpbGwgYWZmZWN0IGFub3RoZXIuIEUuZy4gd2l0aCBgcmVzaXphYmxlLnNxdWFyZWAsIHJlc2l6aW5nIHRvIG1ha2UgdGhlIHJpZ2h0IGVkZ2UgbGFyZ2VyIHdpbGwgbWFrZVxuICAgICAgICAgICAgICAgICAqIHRoZSBib3R0b20gZWRnZSBsYXJnZXIgYnkgdGhlIHNhbWUgYW1vdW50LiBXZSBjYWxsIHRoZXNlICdsaW5rZWQnIGVkZ2VzLiBBbnkgbGlua2VkIGVkZ2VzIHdpbGwgZGVwZW5kXG4gICAgICAgICAgICAgICAgICogb24gdGhlIGFjdGl2ZSBlZGdlcyBhbmQgdGhlIGVkZ2UgYmVpbmcgaW50ZXJhY3RlZCB3aXRoLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRhcmdldC5vcHRpb25zLnJlc2l6ZS5zcXVhcmUgfHwgdGhpcy50YXJnZXQub3B0aW9ucy5yZXNpemUucHJlc2VydmVBc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGlua2VkRWRnZXMgPSBleHRlbmQoe30sIHRoaXMucHJlcGFyZWQuZWRnZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxpbmtlZEVkZ2VzLnRvcCAgICA9IGxpbmtlZEVkZ2VzLnRvcCAgICB8fCAobGlua2VkRWRnZXMubGVmdCAgICYmICFsaW5rZWRFZGdlcy5ib3R0b20pO1xuICAgICAgICAgICAgICAgICAgICBsaW5rZWRFZGdlcy5sZWZ0ICAgPSBsaW5rZWRFZGdlcy5sZWZ0ICAgfHwgKGxpbmtlZEVkZ2VzLnRvcCAgICAmJiAhbGlua2VkRWRnZXMucmlnaHQgKTtcbiAgICAgICAgICAgICAgICAgICAgbGlua2VkRWRnZXMuYm90dG9tID0gbGlua2VkRWRnZXMuYm90dG9tIHx8IChsaW5rZWRFZGdlcy5yaWdodCAgJiYgIWxpbmtlZEVkZ2VzLnRvcCAgICk7XG4gICAgICAgICAgICAgICAgICAgIGxpbmtlZEVkZ2VzLnJpZ2h0ICA9IGxpbmtlZEVkZ2VzLnJpZ2h0ICB8fCAobGlua2VkRWRnZXMuYm90dG9tICYmICFsaW5rZWRFZGdlcy5sZWZ0ICApO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJlcGFyZWQuX2xpbmtlZEVkZ2VzID0gbGlua2VkRWRnZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXBhcmVkLl9saW5rZWRFZGdlcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgdXNpbmcgYHJlc2l6YWJsZS5wcmVzZXJ2ZUFzcGVjdFJhdGlvYCBvcHRpb24sIHJlY29yZCBhc3BlY3QgcmF0aW8gYXQgdGhlIHN0YXJ0IG9mIHRoZSByZXNpemVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50YXJnZXQub3B0aW9ucy5yZXNpemUucHJlc2VydmVBc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZVN0YXJ0QXNwZWN0UmF0aW8gPSBzdGFydFJlY3Qud2lkdGggLyBzdGFydFJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplUmVjdHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ICAgICA6IHN0YXJ0UmVjdCxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCAgIDogZXh0ZW5kKHt9LCBzdGFydFJlY3QpLFxuICAgICAgICAgICAgICAgICAgICByZXN0cmljdGVkOiBleHRlbmQoe30sIHN0YXJ0UmVjdCksXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzICA6IGV4dGVuZCh7fSwgc3RhcnRSZWN0KSxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogMCwgcmlnaHQgOiAwLCB3aWR0aCA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgOiAwLCBib3R0b206IDAsIGhlaWdodDogMFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJlc2l6ZUV2ZW50LnJlY3QgPSB0aGlzLnJlc2l6ZVJlY3RzLnJlc3RyaWN0ZWQ7XG4gICAgICAgICAgICAgICAgcmVzaXplRXZlbnQuZGVsdGFSZWN0ID0gdGhpcy5yZXNpemVSZWN0cy5kZWx0YTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy50YXJnZXQuZmlyZShyZXNpemVFdmVudCk7XG5cbiAgICAgICAgICAgIHRoaXMucmVzaXppbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzaXplRXZlbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzaXplTW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcmVzaXplRXZlbnQgPSBuZXcgSW50ZXJhY3RFdmVudCh0aGlzLCBldmVudCwgJ3Jlc2l6ZScsICdtb3ZlJywgdGhpcy5lbGVtZW50KTtcblxuICAgICAgICAgICAgdmFyIGVkZ2VzID0gdGhpcy5wcmVwYXJlZC5lZGdlcyxcbiAgICAgICAgICAgICAgICBpbnZlcnQgPSB0aGlzLnRhcmdldC5vcHRpb25zLnJlc2l6ZS5pbnZlcnQsXG4gICAgICAgICAgICAgICAgaW52ZXJ0aWJsZSA9IGludmVydCA9PT0gJ3JlcG9zaXRpb24nIHx8IGludmVydCA9PT0gJ25lZ2F0ZSc7XG5cbiAgICAgICAgICAgIGlmIChlZGdlcykge1xuICAgICAgICAgICAgICAgIHZhciBkeCA9IHJlc2l6ZUV2ZW50LmR4LFxuICAgICAgICAgICAgICAgICAgICBkeSA9IHJlc2l6ZUV2ZW50LmR5LFxuXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgPSB0aGlzLnJlc2l6ZVJlY3RzLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ICAgID0gdGhpcy5yZXNpemVSZWN0cy5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICByZXN0cmljdGVkID0gdGhpcy5yZXNpemVSZWN0cy5yZXN0cmljdGVkLFxuICAgICAgICAgICAgICAgICAgICBkZWx0YSAgICAgID0gdGhpcy5yZXNpemVSZWN0cy5kZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMgICA9IGV4dGVuZCh0aGlzLnJlc2l6ZVJlY3RzLnByZXZpb3VzLCByZXN0cmljdGVkKSxcblxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVkZ2VzID0gZWRnZXM7XG5cbiAgICAgICAgICAgICAgICAvLyBgcmVzaXplLnByZXNlcnZlQXNwZWN0UmF0aW9gIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgcmVzaXplLnNxdWFyZWBcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50YXJnZXQub3B0aW9ucy5yZXNpemUucHJlc2VydmVBc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzaXplU3RhcnRBc3BlY3RSYXRpbyA9IHRoaXMucmVzaXplU3RhcnRBc3BlY3RSYXRpbztcblxuICAgICAgICAgICAgICAgICAgICBlZGdlcyA9IHRoaXMucHJlcGFyZWQuX2xpbmtlZEVkZ2VzO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgob3JpZ2luYWxFZGdlcy5sZWZ0ICYmIG9yaWdpbmFsRWRnZXMuYm90dG9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKG9yaWdpbmFsRWRnZXMucmlnaHQgJiYgb3JpZ2luYWxFZGdlcy50b3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkeSA9IC1keCAvIHJlc2l6ZVN0YXJ0QXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3JpZ2luYWxFZGdlcy5sZWZ0IHx8IG9yaWdpbmFsRWRnZXMucmlnaHQpIHsgZHkgPSBkeCAvIHJlc2l6ZVN0YXJ0QXNwZWN0UmF0aW87IH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3JpZ2luYWxFZGdlcy50b3AgfHwgb3JpZ2luYWxFZGdlcy5ib3R0b20pIHsgZHggPSBkeSAqIHJlc2l6ZVN0YXJ0QXNwZWN0UmF0aW87IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy50YXJnZXQub3B0aW9ucy5yZXNpemUuc3F1YXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2VzID0gdGhpcy5wcmVwYXJlZC5fbGlua2VkRWRnZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKChvcmlnaW5hbEVkZ2VzLmxlZnQgJiYgb3JpZ2luYWxFZGdlcy5ib3R0b20pXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCAob3JpZ2luYWxFZGdlcy5yaWdodCAmJiBvcmlnaW5hbEVkZ2VzLnRvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5ID0gLWR4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9yaWdpbmFsRWRnZXMubGVmdCB8fCBvcmlnaW5hbEVkZ2VzLnJpZ2h0KSB7IGR5ID0gZHg7IH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3JpZ2luYWxFZGdlcy50b3AgfHwgb3JpZ2luYWxFZGdlcy5ib3R0b20pIHsgZHggPSBkeTsgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgJ2N1cnJlbnQnIHJlY3Qgd2l0aG91dCBtb2RpZmljYXRpb25zXG4gICAgICAgICAgICAgICAgaWYgKGVkZ2VzLnRvcCAgICkgeyBjdXJyZW50LnRvcCAgICArPSBkeTsgfVxuICAgICAgICAgICAgICAgIGlmIChlZGdlcy5ib3R0b20pIHsgY3VycmVudC5ib3R0b20gKz0gZHk7IH1cbiAgICAgICAgICAgICAgICBpZiAoZWRnZXMubGVmdCAgKSB7IGN1cnJlbnQubGVmdCAgICs9IGR4OyB9XG4gICAgICAgICAgICAgICAgaWYgKGVkZ2VzLnJpZ2h0ICkgeyBjdXJyZW50LnJpZ2h0ICArPSBkeDsgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGludmVydGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaW52ZXJ0aWJsZSwgY29weSB0aGUgY3VycmVudCByZWN0XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXN0cmljdGVkLCBjdXJyZW50KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW52ZXJ0ID09PSAncmVwb3NpdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN3YXAgZWRnZSB2YWx1ZXMgaWYgbmVjZXNzYXJ5IHRvIGtlZXAgd2lkdGgvaGVpZ2h0IHBvc2l0aXZlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3dhcDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3RyaWN0ZWQudG9wID4gcmVzdHJpY3RlZC5ib3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2FwID0gcmVzdHJpY3RlZC50b3A7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0cmljdGVkLnRvcCA9IHJlc3RyaWN0ZWQuYm90dG9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RyaWN0ZWQuYm90dG9tID0gc3dhcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN0cmljdGVkLmxlZnQgPiByZXN0cmljdGVkLnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dhcCA9IHJlc3RyaWN0ZWQubGVmdDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RyaWN0ZWQubGVmdCA9IHJlc3RyaWN0ZWQucmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdHJpY3RlZC5yaWdodCA9IHN3YXA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vdCBpbnZlcnRpYmxlLCByZXN0cmljdCB0byBtaW5pbXVtIG9mIDB4MCByZWN0XG4gICAgICAgICAgICAgICAgICAgIHJlc3RyaWN0ZWQudG9wICAgID0gTWF0aC5taW4oY3VycmVudC50b3AsIHN0YXJ0LmJvdHRvbSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RyaWN0ZWQuYm90dG9tID0gTWF0aC5tYXgoY3VycmVudC5ib3R0b20sIHN0YXJ0LnRvcCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RyaWN0ZWQubGVmdCAgID0gTWF0aC5taW4oY3VycmVudC5sZWZ0LCBzdGFydC5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RyaWN0ZWQucmlnaHQgID0gTWF0aC5tYXgoY3VycmVudC5yaWdodCwgc3RhcnQubGVmdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdHJpY3RlZC53aWR0aCAgPSByZXN0cmljdGVkLnJpZ2h0ICAtIHJlc3RyaWN0ZWQubGVmdDtcbiAgICAgICAgICAgICAgICByZXN0cmljdGVkLmhlaWdodCA9IHJlc3RyaWN0ZWQuYm90dG9tIC0gcmVzdHJpY3RlZC50b3AgO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZWRnZSBpbiByZXN0cmljdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhW2VkZ2VdID0gcmVzdHJpY3RlZFtlZGdlXSAtIHByZXZpb3VzW2VkZ2VdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc2l6ZUV2ZW50LmVkZ2VzID0gdGhpcy5wcmVwYXJlZC5lZGdlcztcbiAgICAgICAgICAgICAgICByZXNpemVFdmVudC5yZWN0ID0gcmVzdHJpY3RlZDtcbiAgICAgICAgICAgICAgICByZXNpemVFdmVudC5kZWx0YVJlY3QgPSBkZWx0YTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy50YXJnZXQuZmlyZShyZXNpemVFdmVudCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXNpemVFdmVudDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXN0dXJlU3RhcnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGdlc3R1cmVFdmVudCA9IG5ldyBJbnRlcmFjdEV2ZW50KHRoaXMsIGV2ZW50LCAnZ2VzdHVyZScsICdzdGFydCcsIHRoaXMuZWxlbWVudCk7XG5cbiAgICAgICAgICAgIGdlc3R1cmVFdmVudC5kcyA9IDA7XG5cbiAgICAgICAgICAgIHRoaXMuZ2VzdHVyZS5zdGFydERpc3RhbmNlID0gdGhpcy5nZXN0dXJlLnByZXZEaXN0YW5jZSA9IGdlc3R1cmVFdmVudC5kaXN0YW5jZTtcbiAgICAgICAgICAgIHRoaXMuZ2VzdHVyZS5zdGFydEFuZ2xlID0gdGhpcy5nZXN0dXJlLnByZXZBbmdsZSA9IGdlc3R1cmVFdmVudC5hbmdsZTtcbiAgICAgICAgICAgIHRoaXMuZ2VzdHVyZS5zY2FsZSA9IDE7XG5cbiAgICAgICAgICAgIHRoaXMuZ2VzdHVyaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy50YXJnZXQuZmlyZShnZXN0dXJlRXZlbnQpO1xuXG4gICAgICAgICAgICByZXR1cm4gZ2VzdHVyZUV2ZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdlc3R1cmVNb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wb2ludGVySWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZFdmVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGdlc3R1cmVFdmVudDtcblxuICAgICAgICAgICAgZ2VzdHVyZUV2ZW50ID0gbmV3IEludGVyYWN0RXZlbnQodGhpcywgZXZlbnQsICdnZXN0dXJlJywgJ21vdmUnLCB0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgZ2VzdHVyZUV2ZW50LmRzID0gZ2VzdHVyZUV2ZW50LnNjYWxlIC0gdGhpcy5nZXN0dXJlLnNjYWxlO1xuXG4gICAgICAgICAgICB0aGlzLnRhcmdldC5maXJlKGdlc3R1cmVFdmVudCk7XG5cbiAgICAgICAgICAgIHRoaXMuZ2VzdHVyZS5wcmV2QW5nbGUgPSBnZXN0dXJlRXZlbnQuYW5nbGU7XG4gICAgICAgICAgICB0aGlzLmdlc3R1cmUucHJldkRpc3RhbmNlID0gZ2VzdHVyZUV2ZW50LmRpc3RhbmNlO1xuXG4gICAgICAgICAgICBpZiAoZ2VzdHVyZUV2ZW50LnNjYWxlICE9PSBJbmZpbml0eSAmJlxuICAgICAgICAgICAgICAgIGdlc3R1cmVFdmVudC5zY2FsZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIGdlc3R1cmVFdmVudC5zY2FsZSAhPT0gdW5kZWZpbmVkICAmJlxuICAgICAgICAgICAgICAgICFpc05hTihnZXN0dXJlRXZlbnQuc2NhbGUpKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmdlc3R1cmUuc2NhbGUgPSBnZXN0dXJlRXZlbnQuc2NhbGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBnZXN0dXJlRXZlbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9pbnRlckhvbGQ6IGZ1bmN0aW9uIChwb2ludGVyLCBldmVudCwgZXZlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdEV2ZW50VGFyZ2V0cyhwb2ludGVyLCBldmVudCwgZXZlbnRUYXJnZXQsICdob2xkJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9pbnRlclVwOiBmdW5jdGlvbiAocG9pbnRlciwgZXZlbnQsIGV2ZW50VGFyZ2V0LCBjdXJFdmVudFRhcmdldCkge1xuICAgICAgICAgICAgdmFyIHBvaW50ZXJJbmRleCA9IHRoaXMubW91c2U/IDAgOiBpbmRleE9mKHRoaXMucG9pbnRlcklkcywgZ2V0UG9pbnRlcklkKHBvaW50ZXIpKTtcblxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaG9sZFRpbWVyc1twb2ludGVySW5kZXhdKTtcblxuICAgICAgICAgICAgdGhpcy5jb2xsZWN0RXZlbnRUYXJnZXRzKHBvaW50ZXIsIGV2ZW50LCBldmVudFRhcmdldCwgJ3VwJyApO1xuICAgICAgICAgICAgdGhpcy5jb2xsZWN0RXZlbnRUYXJnZXRzKHBvaW50ZXIsIGV2ZW50LCBldmVudFRhcmdldCwgJ3RhcCcpO1xuXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJFbmQocG9pbnRlciwgZXZlbnQsIGV2ZW50VGFyZ2V0LCBjdXJFdmVudFRhcmdldCk7XG5cbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUG9pbnRlcihwb2ludGVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwb2ludGVyQ2FuY2VsOiBmdW5jdGlvbiAocG9pbnRlciwgZXZlbnQsIGV2ZW50VGFyZ2V0LCBjdXJFdmVudFRhcmdldCkge1xuICAgICAgICAgICAgdmFyIHBvaW50ZXJJbmRleCA9IHRoaXMubW91c2U/IDAgOiBpbmRleE9mKHRoaXMucG9pbnRlcklkcywgZ2V0UG9pbnRlcklkKHBvaW50ZXIpKTtcblxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaG9sZFRpbWVyc1twb2ludGVySW5kZXhdKTtcblxuICAgICAgICAgICAgdGhpcy5jb2xsZWN0RXZlbnRUYXJnZXRzKHBvaW50ZXIsIGV2ZW50LCBldmVudFRhcmdldCwgJ2NhbmNlbCcpO1xuICAgICAgICAgICAgdGhpcy5wb2ludGVyRW5kKHBvaW50ZXIsIGV2ZW50LCBldmVudFRhcmdldCwgY3VyRXZlbnRUYXJnZXQpO1xuXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVBvaW50ZXIocG9pbnRlcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL2NsaWNrLmh0bWxcbiAgICAgICAgLy8gPkV2ZW50cyBsZWFkaW5nIHRvIGRibGNsaWNrXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElFOCBkb2Vzbid0IGZpcmUgZG93biBldmVudCBiZWZvcmUgZGJsY2xpY2suXG4gICAgICAgIC8vIFRoaXMgd29ya2Fyb3VuZCB0cmllcyB0byBmaXJlIGEgdGFwIGFuZCBkb3VibGV0YXAgYWZ0ZXIgZGJsY2xpY2tcbiAgICAgICAgaWU4RGJsY2xpY2s6IGZ1bmN0aW9uIChwb2ludGVyLCBldmVudCwgZXZlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXZUYXBcbiAgICAgICAgICAgICAgICAmJiBldmVudC5jbGllbnRYID09PSB0aGlzLnByZXZUYXAuY2xpZW50WFxuICAgICAgICAgICAgICAgICYmIGV2ZW50LmNsaWVudFkgPT09IHRoaXMucHJldlRhcC5jbGllbnRZXG4gICAgICAgICAgICAgICAgJiYgZXZlbnRUYXJnZXQgICA9PT0gdGhpcy5wcmV2VGFwLnRhcmdldCkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kb3duVGFyZ2V0c1swXSA9IGV2ZW50VGFyZ2V0O1xuICAgICAgICAgICAgICAgIHRoaXMuZG93blRpbWVzWzBdID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsZWN0RXZlbnRUYXJnZXRzKHBvaW50ZXIsIGV2ZW50LCBldmVudFRhcmdldCwgJ3RhcCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEVuZCBpbnRlcmFjdCBtb3ZlIGV2ZW50cyBhbmQgc3RvcCBhdXRvLXNjcm9sbCB1bmxlc3MgaW5lcnRpYSBpcyBlbmFibGVkXG4gICAgICAgIHBvaW50ZXJFbmQ6IGZ1bmN0aW9uIChwb2ludGVyLCBldmVudCwgZXZlbnRUYXJnZXQsIGN1ckV2ZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICB2YXIgZW5kRXZlbnQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy50YXJnZXQsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHRhcmdldCAmJiB0YXJnZXQub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBpbmVydGlhT3B0aW9ucyA9IG9wdGlvbnMgJiYgdGhpcy5wcmVwYXJlZC5uYW1lICYmIG9wdGlvbnNbdGhpcy5wcmVwYXJlZC5uYW1lXS5pbmVydGlhLFxuICAgICAgICAgICAgICAgIGluZXJ0aWFTdGF0dXMgPSB0aGlzLmluZXJ0aWFTdGF0dXM7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmludGVyYWN0aW5nKCkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChpbmVydGlhU3RhdHVzLmFjdGl2ZSAmJiAhaW5lcnRpYVN0YXR1cy5lbmRpbmcpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRlclNwZWVkLFxuICAgICAgICAgICAgICAgICAgICBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgaW5lcnRpYVBvc3NpYmxlID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGluZXJ0aWEgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc21vb3RoRW5kID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVuZFNuYXAgPSBjaGVja1NuYXAodGFyZ2V0LCB0aGlzLnByZXBhcmVkLm5hbWUpICYmIG9wdGlvbnNbdGhpcy5wcmVwYXJlZC5uYW1lXS5zbmFwLmVuZE9ubHksXG4gICAgICAgICAgICAgICAgICAgIGVuZFJlc3RyaWN0ID0gY2hlY2tSZXN0cmljdCh0YXJnZXQsIHRoaXMucHJlcGFyZWQubmFtZSkgJiYgb3B0aW9uc1t0aGlzLnByZXBhcmVkLm5hbWVdLnJlc3RyaWN0LmVuZE9ubHksXG4gICAgICAgICAgICAgICAgICAgIGR4ID0gMCxcbiAgICAgICAgICAgICAgICAgICAgZHkgPSAwLFxuICAgICAgICAgICAgICAgICAgICBzdGFydEV2ZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgICAgICAob3B0aW9ucy5kcmFnLmF4aXMgPT09ICd4JyApIHsgcG9pbnRlclNwZWVkID0gTWF0aC5hYnModGhpcy5wb2ludGVyRGVsdGEuY2xpZW50LnZ4KTsgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmRyYWcuYXhpcyA9PT0gJ3knICkgeyBwb2ludGVyU3BlZWQgPSBNYXRoLmFicyh0aGlzLnBvaW50ZXJEZWx0YS5jbGllbnQudnkpOyB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgICAvKm9wdGlvbnMuZHJhZy5heGlzID09PSAneHknKi97IHBvaW50ZXJTcGVlZCA9IHRoaXMucG9pbnRlckRlbHRhLmNsaWVudC5zcGVlZDsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlclNwZWVkID0gdGhpcy5wb2ludGVyRGVsdGEuY2xpZW50LnNwZWVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGluZXJ0aWEgc2hvdWxkIGJlIHN0YXJ0ZWRcbiAgICAgICAgICAgICAgICBpbmVydGlhUG9zc2libGUgPSAoaW5lcnRpYU9wdGlvbnMgJiYgaW5lcnRpYU9wdGlvbnMuZW5hYmxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLnByZXBhcmVkLm5hbWUgIT09ICdnZXN0dXJlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBldmVudCAhPT0gaW5lcnRpYVN0YXR1cy5zdGFydEV2ZW50KTtcblxuICAgICAgICAgICAgICAgIGluZXJ0aWEgPSAoaW5lcnRpYVBvc3NpYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAobm93IC0gdGhpcy5jdXJDb29yZHMudGltZVN0YW1wKSA8IDUwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBwb2ludGVyU3BlZWQgPiBpbmVydGlhT3B0aW9ucy5taW5TcGVlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9pbnRlclNwZWVkID4gaW5lcnRpYU9wdGlvbnMuZW5kU3BlZWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZXJ0aWFQb3NzaWJsZSAmJiAhaW5lcnRpYSAmJiAoZW5kU25hcCB8fCBlbmRSZXN0cmljdCkpIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgc25hcFJlc3RyaWN0ID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgc25hcFJlc3RyaWN0LnNuYXAgPSBzbmFwUmVzdHJpY3QucmVzdHJpY3QgPSBzbmFwUmVzdHJpY3Q7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZFNuYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U25hcHBpbmcodGhpcy5jdXJDb29yZHMucGFnZSwgc25hcFJlc3RyaWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbmFwUmVzdHJpY3QubG9ja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHggKz0gc25hcFJlc3RyaWN0LmR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR5ICs9IHNuYXBSZXN0cmljdC5keTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmRSZXN0cmljdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRSZXN0cmljdGlvbih0aGlzLmN1ckNvb3Jkcy5wYWdlLCBzbmFwUmVzdHJpY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNuYXBSZXN0cmljdC5yZXN0cmljdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHggKz0gc25hcFJlc3RyaWN0LmR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR5ICs9IHNuYXBSZXN0cmljdC5keTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkeCB8fCBkeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc21vb3RoRW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbmVydGlhIHx8IHNtb290aEVuZCkge1xuICAgICAgICAgICAgICAgICAgICBjb3B5Q29vcmRzKGluZXJ0aWFTdGF0dXMudXBDb29yZHMsIHRoaXMuY3VyQ29vcmRzKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50ZXJzWzBdID0gaW5lcnRpYVN0YXR1cy5zdGFydEV2ZW50ID0gc3RhcnRFdmVudCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgSW50ZXJhY3RFdmVudCh0aGlzLCBldmVudCwgdGhpcy5wcmVwYXJlZC5uYW1lLCAnaW5lcnRpYXN0YXJ0JywgdGhpcy5lbGVtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICBpbmVydGlhU3RhdHVzLnQwID0gbm93O1xuXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5maXJlKGluZXJ0aWFTdGF0dXMuc3RhcnRFdmVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZXJ0aWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZXJ0aWFTdGF0dXMudngwID0gdGhpcy5wb2ludGVyRGVsdGEuY2xpZW50LnZ4O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5lcnRpYVN0YXR1cy52eTAgPSB0aGlzLnBvaW50ZXJEZWx0YS5jbGllbnQudnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmVydGlhU3RhdHVzLnYwID0gcG9pbnRlclNwZWVkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGNJbmVydGlhKGluZXJ0aWFTdGF0dXMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFnZSA9IGV4dGVuZCh7fSwgdGhpcy5jdXJDb29yZHMucGFnZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luID0gZ2V0T3JpZ2luWFkodGFyZ2V0LCB0aGlzLmVsZW1lbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c09iamVjdDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZS54ID0gcGFnZS54ICsgaW5lcnRpYVN0YXR1cy54ZSAtIG9yaWdpbi54O1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZS55ID0gcGFnZS55ICsgaW5lcnRpYVN0YXR1cy55ZSAtIG9yaWdpbi55O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNPYmplY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlU3RhdHVzWFk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogcGFnZS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHBhZ2UueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbmFwOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNPYmplY3Quc25hcCA9IHN0YXR1c09iamVjdDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZHggPSBkeSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmRTbmFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNuYXAgPSB0aGlzLnNldFNuYXBwaW5nKHRoaXMuY3VyQ29vcmRzLnBhZ2UsIHN0YXR1c09iamVjdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc25hcC5sb2NrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHggKz0gc25hcC5keDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHkgKz0gc25hcC5keTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmRSZXN0cmljdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN0cmljdCA9IHRoaXMuc2V0UmVzdHJpY3Rpb24odGhpcy5jdXJDb29yZHMucGFnZSwgc3RhdHVzT2JqZWN0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN0cmljdC5yZXN0cmljdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR4ICs9IHJlc3RyaWN0LmR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeSArPSByZXN0cmljdC5keTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGluZXJ0aWFTdGF0dXMubW9kaWZpZWRYZSArPSBkeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZXJ0aWFTdGF0dXMubW9kaWZpZWRZZSArPSBkeTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaW5lcnRpYVN0YXR1cy5pID0gcmVxRnJhbWUodGhpcy5ib3VuZEluZXJ0aWFGcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmVydGlhU3RhdHVzLnNtb290aEVuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmVydGlhU3RhdHVzLnhlID0gZHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmVydGlhU3RhdHVzLnllID0gZHk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGluZXJ0aWFTdGF0dXMuc3ggPSBpbmVydGlhU3RhdHVzLnN5ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaW5lcnRpYVN0YXR1cy5pID0gcmVxRnJhbWUodGhpcy5ib3VuZFNtb290aEVuZEZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGluZXJ0aWFTdGF0dXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChlbmRTbmFwIHx8IGVuZFJlc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpcmUgYSBtb3ZlIGV2ZW50IGF0IHRoZSBzbmFwcGVkIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlck1vdmUocG9pbnRlciwgZXZlbnQsIGV2ZW50VGFyZ2V0LCBjdXJFdmVudFRhcmdldCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIGVuZEV2ZW50ID0gbmV3IEludGVyYWN0RXZlbnQodGhpcywgZXZlbnQsICdkcmFnJywgJ2VuZCcsIHRoaXMuZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZHJhZ2dhYmxlRWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgZHJvcCA9IHRoaXMuZ2V0RHJvcChlbmRFdmVudCwgZXZlbnQsIGRyYWdnYWJsZUVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kcm9wVGFyZ2V0ID0gZHJvcC5kcm9wem9uZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3BFbGVtZW50ID0gZHJvcC5lbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgdmFyIGRyb3BFdmVudHMgPSB0aGlzLmdldERyb3BFdmVudHMoZXZlbnQsIGVuZEV2ZW50KTtcblxuICAgICAgICAgICAgICAgIGlmIChkcm9wRXZlbnRzLmxlYXZlKSB7IHRoaXMucHJldkRyb3BUYXJnZXQuZmlyZShkcm9wRXZlbnRzLmxlYXZlKTsgfVxuICAgICAgICAgICAgICAgIGlmIChkcm9wRXZlbnRzLmVudGVyKSB7ICAgICB0aGlzLmRyb3BUYXJnZXQuZmlyZShkcm9wRXZlbnRzLmVudGVyKTsgfVxuICAgICAgICAgICAgICAgIGlmIChkcm9wRXZlbnRzLmRyb3AgKSB7ICAgICB0aGlzLmRyb3BUYXJnZXQuZmlyZShkcm9wRXZlbnRzLmRyb3AgKTsgfVxuICAgICAgICAgICAgICAgIGlmIChkcm9wRXZlbnRzLmRlYWN0aXZhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlQWN0aXZlRHJvcHMoZHJvcEV2ZW50cy5kZWFjdGl2YXRlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0YXJnZXQuZmlyZShlbmRFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnJlc2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgZW5kRXZlbnQgPSBuZXcgSW50ZXJhY3RFdmVudCh0aGlzLCBldmVudCwgJ3Jlc2l6ZScsICdlbmQnLCB0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHRhcmdldC5maXJlKGVuZEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZ2VzdHVyaW5nKSB7XG4gICAgICAgICAgICAgICAgZW5kRXZlbnQgPSBuZXcgSW50ZXJhY3RFdmVudCh0aGlzLCBldmVudCwgJ2dlc3R1cmUnLCAnZW5kJywgdGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICB0YXJnZXQuZmlyZShlbmRFdmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3RvcChldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29sbGVjdERyb3BzOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGRyb3BzID0gW10sXG4gICAgICAgICAgICAgICAgZWxlbWVudHMgPSBbXSxcbiAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudCB8fCB0aGlzLmVsZW1lbnQ7XG5cbiAgICAgICAgICAgIC8vIGNvbGxlY3QgYWxsIGRyb3B6b25lcyBhbmQgdGhlaXIgZWxlbWVudHMgd2hpY2ggcXVhbGlmeSBmb3IgYSBkcm9wXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW50ZXJhY3RhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghaW50ZXJhY3RhYmxlc1tpXS5vcHRpb25zLmRyb3AuZW5hYmxlZCkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBpbnRlcmFjdGFibGVzW2ldLFxuICAgICAgICAgICAgICAgICAgICBhY2NlcHQgPSBjdXJyZW50Lm9wdGlvbnMuZHJvcC5hY2NlcHQ7XG5cbiAgICAgICAgICAgICAgICAvLyB0ZXN0IHRoZSBkcmFnZ2FibGUgZWxlbWVudCBhZ2FpbnN0IHRoZSBkcm9wem9uZSdzIGFjY2VwdCBzZXR0aW5nXG4gICAgICAgICAgICAgICAgaWYgKChpc0VsZW1lbnQoYWNjZXB0KSAmJiBhY2NlcHQgIT09IGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIHx8IChpc1N0cmluZyhhY2NlcHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAhbWF0Y2hlc1NlbGVjdG9yKGVsZW1lbnQsIGFjY2VwdCkpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcXVlcnkgZm9yIG5ldyBlbGVtZW50cyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICB2YXIgZHJvcEVsZW1lbnRzID0gY3VycmVudC5zZWxlY3Rvcj8gY3VycmVudC5fY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKGN1cnJlbnQuc2VsZWN0b3IpIDogW2N1cnJlbnQuX2VsZW1lbnRdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IGRyb3BFbGVtZW50cy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudEVsZW1lbnQgPSBkcm9wRWxlbWVudHNbal07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRFbGVtZW50ID09PSBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRyb3BzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goY3VycmVudEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkcm9wem9uZXM6IGRyb3BzLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBmaXJlQWN0aXZlRHJvcHM6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICBjdXJyZW50RWxlbWVudCxcbiAgICAgICAgICAgICAgICBwcmV2RWxlbWVudDtcblxuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGFsbCBhY3RpdmUgZHJvcHpvbmVzIGFuZCB0cmlnZ2VyIGV2ZW50XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5hY3RpdmVEcm9wcy5kcm9wem9uZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy5hY3RpdmVEcm9wcy5kcm9wem9uZXNbaV07XG4gICAgICAgICAgICAgICAgY3VycmVudEVsZW1lbnQgPSB0aGlzLmFjdGl2ZURyb3BzLmVsZW1lbnRzIFtpXTtcblxuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgdHJpZ2dlciBvZiBkdXBsaWNhdGUgZXZlbnRzIG9uIHNhbWUgZWxlbWVudFxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RWxlbWVudCAhPT0gcHJldkVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IGN1cnJlbnQgZWxlbWVudCBhcyBldmVudCB0YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0gY3VycmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuZmlyZShldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZFbGVtZW50ID0gY3VycmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQ29sbGVjdCBhIG5ldyBzZXQgb2YgcG9zc2libGUgZHJvcHMgYW5kIHNhdmUgdGhlbSBpbiBhY3RpdmVEcm9wcy5cbiAgICAgICAgLy8gc2V0QWN0aXZlRHJvcHMgc2hvdWxkIGFsd2F5cyBiZSBjYWxsZWQgd2hlbiBhIGRyYWcgaGFzIGp1c3Qgc3RhcnRlZCBvciBhXG4gICAgICAgIC8vIGRyYWcgZXZlbnQgaGFwcGVucyB3aGlsZSBkeW5hbWljRHJvcCBpcyB0cnVlXG4gICAgICAgIHNldEFjdGl2ZURyb3BzOiBmdW5jdGlvbiAoZHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIGdldCBkcm9wem9uZXMgYW5kIHRoZWlyIGVsZW1lbnRzIHRoYXQgY291bGQgcmVjZWl2ZSB0aGUgZHJhZ2dhYmxlXG4gICAgICAgICAgICB2YXIgcG9zc2libGVEcm9wcyA9IHRoaXMuY29sbGVjdERyb3BzKGRyYWdFbGVtZW50LCB0cnVlKTtcblxuICAgICAgICAgICAgdGhpcy5hY3RpdmVEcm9wcy5kcm9wem9uZXMgPSBwb3NzaWJsZURyb3BzLmRyb3B6b25lcztcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlRHJvcHMuZWxlbWVudHMgID0gcG9zc2libGVEcm9wcy5lbGVtZW50cztcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlRHJvcHMucmVjdHMgICAgID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmVEcm9wcy5kcm9wem9uZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZURyb3BzLnJlY3RzW2ldID0gdGhpcy5hY3RpdmVEcm9wcy5kcm9wem9uZXNbaV0uZ2V0UmVjdCh0aGlzLmFjdGl2ZURyb3BzLmVsZW1lbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXREcm9wOiBmdW5jdGlvbiAoZHJhZ0V2ZW50LCBldmVudCwgZHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZERyb3BzID0gW107XG5cbiAgICAgICAgICAgIGlmIChkeW5hbWljRHJvcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlRHJvcHMoZHJhZ0VsZW1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjb2xsZWN0IGFsbCBkcm9wem9uZXMgYW5kIHRoZWlyIGVsZW1lbnRzIHdoaWNoIHF1YWxpZnkgZm9yIGEgZHJvcFxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmFjdGl2ZURyb3BzLmRyb3B6b25lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ICAgICAgICA9IHRoaXMuYWN0aXZlRHJvcHMuZHJvcHpvbmVzW2pdLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RWxlbWVudCA9IHRoaXMuYWN0aXZlRHJvcHMuZWxlbWVudHMgW2pdLFxuICAgICAgICAgICAgICAgICAgICByZWN0ICAgICAgICAgICA9IHRoaXMuYWN0aXZlRHJvcHMucmVjdHMgICAgW2pdO1xuXG4gICAgICAgICAgICAgICAgdmFsaWREcm9wcy5wdXNoKGN1cnJlbnQuZHJvcENoZWNrKGRyYWdFdmVudCwgZXZlbnQsIHRoaXMudGFyZ2V0LCBkcmFnRWxlbWVudCwgY3VycmVudEVsZW1lbnQsIHJlY3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY3VycmVudEVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBtb3N0IGFwcHJvcHJpYXRlIGRyb3B6b25lIGJhc2VkIG9uIERPTSBkZXB0aCBhbmQgb3JkZXJcbiAgICAgICAgICAgIHZhciBkcm9wSW5kZXggPSBpbmRleE9mRGVlcGVzdEVsZW1lbnQodmFsaWREcm9wcyksXG4gICAgICAgICAgICAgICAgZHJvcHpvbmUgID0gdGhpcy5hY3RpdmVEcm9wcy5kcm9wem9uZXNbZHJvcEluZGV4XSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQgICA9IHRoaXMuYWN0aXZlRHJvcHMuZWxlbWVudHMgW2Ryb3BJbmRleF0gfHwgbnVsbDtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkcm9wem9uZTogZHJvcHpvbmUsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXREcm9wRXZlbnRzOiBmdW5jdGlvbiAocG9pbnRlckV2ZW50LCBkcmFnRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBkcm9wRXZlbnRzID0ge1xuICAgICAgICAgICAgICAgIGVudGVyICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgbGVhdmUgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBhY3RpdmF0ZSAgOiBudWxsLFxuICAgICAgICAgICAgICAgIGRlYWN0aXZhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgbW92ZSAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBkcm9wICAgICAgOiBudWxsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5kcm9wRWxlbWVudCAhPT0gdGhpcy5wcmV2RHJvcEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSB3YXMgYSBwcmV2RHJvcFRhcmdldCwgY3JlYXRlIGEgZHJhZ2xlYXZlIGV2ZW50XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldkRyb3BUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJvcEV2ZW50cy5sZWF2ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCAgICAgICA6IHRoaXMucHJldkRyb3BFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZHJvcHpvbmUgICAgIDogdGhpcy5wcmV2RHJvcFRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IGRyYWdFdmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGUgICAgOiBkcmFnRXZlbnQuaW50ZXJhY3RhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ0V2ZW50ICAgIDogZHJhZ0V2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24gIDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVTdGFtcCAgICA6IGRyYWdFdmVudC50aW1lU3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlICAgICAgICAgOiAnZHJhZ2xlYXZlJ1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGRyYWdFdmVudC5kcmFnTGVhdmUgPSB0aGlzLnByZXZEcm9wRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0V2ZW50LnByZXZEcm9wem9uZSA9IHRoaXMucHJldkRyb3BUYXJnZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBkcm9wVGFyZ2V0IGlzIG5vdCBudWxsLCBjcmVhdGUgYSBkcmFnZW50ZXIgZXZlbnRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRyb3BFdmVudHMuZW50ZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgICAgICAgOiB0aGlzLmRyb3BFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZHJvcHpvbmUgICAgIDogdGhpcy5kcm9wVGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZFRhcmdldDogZHJhZ0V2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnYWJsZSAgICA6IGRyYWdFdmVudC5pbnRlcmFjdGFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnRXZlbnQgICAgOiBkcmFnRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbiAgOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZVN0YW1wICAgIDogZHJhZ0V2ZW50LnRpbWVTdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgICAgICAgICA6ICdkcmFnZW50ZXInXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgZHJhZ0V2ZW50LmRyYWdFbnRlciA9IHRoaXMuZHJvcEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdFdmVudC5kcm9wem9uZSA9IHRoaXMuZHJvcFRhcmdldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkcmFnRXZlbnQudHlwZSA9PT0gJ2RyYWdlbmQnICYmIHRoaXMuZHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgIGRyb3BFdmVudHMuZHJvcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ICAgICAgIDogdGhpcy5kcm9wRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgZHJvcHpvbmUgICAgIDogdGhpcy5kcm9wVGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICByZWxhdGVkVGFyZ2V0OiBkcmFnRXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGUgICAgOiBkcmFnRXZlbnQuaW50ZXJhY3RhYmxlLFxuICAgICAgICAgICAgICAgICAgICBkcmFnRXZlbnQgICAgOiBkcmFnRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uICA6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVTdGFtcCAgICA6IGRyYWdFdmVudC50aW1lU3RhbXAsXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgICAgICAgICA6ICdkcm9wJ1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBkcmFnRXZlbnQuZHJvcHpvbmUgPSB0aGlzLmRyb3BUYXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHJhZ0V2ZW50LnR5cGUgPT09ICdkcmFnc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgZHJvcEV2ZW50cy5hY3RpdmF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZHJvcHpvbmUgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRlZFRhcmdldDogZHJhZ0V2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dhYmxlICAgIDogZHJhZ0V2ZW50LmludGVyYWN0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0V2ZW50ICAgIDogZHJhZ0V2ZW50LFxuICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbiAgOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICB0aW1lU3RhbXAgICAgOiBkcmFnRXZlbnQudGltZVN0YW1wLFxuICAgICAgICAgICAgICAgICAgICB0eXBlICAgICAgICAgOiAnZHJvcGFjdGl2YXRlJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHJhZ0V2ZW50LnR5cGUgPT09ICdkcmFnZW5kJykge1xuICAgICAgICAgICAgICAgIGRyb3BFdmVudHMuZGVhY3RpdmF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZHJvcHpvbmUgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRlZFRhcmdldDogZHJhZ0V2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dhYmxlICAgIDogZHJhZ0V2ZW50LmludGVyYWN0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0V2ZW50ICAgIDogZHJhZ0V2ZW50LFxuICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbiAgOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICB0aW1lU3RhbXAgICAgOiBkcmFnRXZlbnQudGltZVN0YW1wLFxuICAgICAgICAgICAgICAgICAgICB0eXBlICAgICAgICAgOiAnZHJvcGRlYWN0aXZhdGUnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkcmFnRXZlbnQudHlwZSA9PT0gJ2RyYWdtb3ZlJyAmJiB0aGlzLmRyb3BUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBkcm9wRXZlbnRzLm1vdmUgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCAgICAgICA6IHRoaXMuZHJvcEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGRyb3B6b25lICAgICA6IHRoaXMuZHJvcFRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRlZFRhcmdldDogZHJhZ0V2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dhYmxlICAgIDogZHJhZ0V2ZW50LmludGVyYWN0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0V2ZW50ICAgIDogZHJhZ0V2ZW50LFxuICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbiAgOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBkcmFnbW92ZSAgICAgOiBkcmFnRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVTdGFtcCAgICA6IGRyYWdFdmVudC50aW1lU3RhbXAsXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgICAgICAgICA6ICdkcm9wbW92ZSdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRyYWdFdmVudC5kcm9wem9uZSA9IHRoaXMuZHJvcFRhcmdldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRyb3BFdmVudHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3VycmVudEFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmRyYWdnaW5nICYmICdkcmFnJykgfHwgKHRoaXMucmVzaXppbmcgJiYgJ3Jlc2l6ZScpIHx8ICh0aGlzLmdlc3R1cmluZyAmJiAnZ2VzdHVyZScpIHx8IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW50ZXJhY3Rpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRyYWdnaW5nIHx8IHRoaXMucmVzaXppbmcgfHwgdGhpcy5nZXN0dXJpbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJUYXJnZXRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IHRoaXMuZWxlbWVudCA9IG51bGw7XG5cbiAgICAgICAgICAgIHRoaXMuZHJvcFRhcmdldCA9IHRoaXMuZHJvcEVsZW1lbnQgPSB0aGlzLnByZXZEcm9wVGFyZ2V0ID0gdGhpcy5wcmV2RHJvcEVsZW1lbnQgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJhY3RpbmcoKSkge1xuICAgICAgICAgICAgICAgIGF1dG9TY3JvbGwuc3RvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hFbGVtZW50cyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5vcHRpb25zLnN0eWxlQ3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5fZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZS5jdXJzb3IgPSAnJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IERlZmF1bHQgb25seSBpZiB3ZXJlIHByZXZpb3VzbHkgaW50ZXJhY3RpbmdcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQgJiYgaXNGdW5jdGlvbihldmVudC5wcmV2ZW50RGVmYXVsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja0FuZFByZXZlbnREZWZhdWx0KGV2ZW50LCB0YXJnZXQsIHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVEcm9wcy5kcm9wem9uZXMgPSB0aGlzLmFjdGl2ZURyb3BzLmVsZW1lbnRzID0gdGhpcy5hY3RpdmVEcm9wcy5yZWN0cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNsZWFyVGFyZ2V0cygpO1xuXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJJc0Rvd24gPSB0aGlzLnNuYXBTdGF0dXMubG9ja2VkID0gdGhpcy5kcmFnZ2luZyA9IHRoaXMucmVzaXppbmcgPSB0aGlzLmdlc3R1cmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wcmVwYXJlZC5uYW1lID0gdGhpcy5wcmV2RXZlbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5pbmVydGlhU3RhdHVzLnJlc3VtZUR4ID0gdGhpcy5pbmVydGlhU3RhdHVzLnJlc3VtZUR5ID0gMDtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHBvaW50ZXJzIGlmIHRoZWlyIElEIGlzbid0IGluIHRoaXMucG9pbnRlcklkc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvaW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4T2YodGhpcy5wb2ludGVySWRzLCBnZXRQb2ludGVySWQodGhpcy5wb2ludGVyc1tpXSkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50ZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5lcnRpYUZyYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5lcnRpYVN0YXR1cyA9IHRoaXMuaW5lcnRpYVN0YXR1cyxcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gdGhpcy50YXJnZXQub3B0aW9uc1t0aGlzLnByZXBhcmVkLm5hbWVdLmluZXJ0aWEsXG4gICAgICAgICAgICAgICAgbGFtYmRhID0gb3B0aW9ucy5yZXNpc3RhbmNlLFxuICAgICAgICAgICAgICAgIHQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDAgLSBpbmVydGlhU3RhdHVzLnQwO1xuXG4gICAgICAgICAgICBpZiAodCA8IGluZXJ0aWFTdGF0dXMudGUpIHtcblxuICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9ICAxIC0gKE1hdGguZXhwKC1sYW1iZGEgKiB0KSAtIGluZXJ0aWFTdGF0dXMubGFtYmRhX3YwKSAvIGluZXJ0aWFTdGF0dXMub25lX3ZlX3YwO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZXJ0aWFTdGF0dXMubW9kaWZpZWRYZSA9PT0gaW5lcnRpYVN0YXR1cy54ZSAmJiBpbmVydGlhU3RhdHVzLm1vZGlmaWVkWWUgPT09IGluZXJ0aWFTdGF0dXMueWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5lcnRpYVN0YXR1cy5zeCA9IGluZXJ0aWFTdGF0dXMueGUgKiBwcm9ncmVzcztcbiAgICAgICAgICAgICAgICAgICAgaW5lcnRpYVN0YXR1cy5zeSA9IGluZXJ0aWFTdGF0dXMueWUgKiBwcm9ncmVzcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBxdWFkUG9pbnQgPSBnZXRRdWFkcmF0aWNDdXJ2ZVBvaW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5lcnRpYVN0YXR1cy54ZSwgaW5lcnRpYVN0YXR1cy55ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmVydGlhU3RhdHVzLm1vZGlmaWVkWGUsIGluZXJ0aWFTdGF0dXMubW9kaWZpZWRZZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaW5lcnRpYVN0YXR1cy5zeCA9IHF1YWRQb2ludC54O1xuICAgICAgICAgICAgICAgICAgICBpbmVydGlhU3RhdHVzLnN5ID0gcXVhZFBvaW50Lnk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludGVyTW92ZShpbmVydGlhU3RhdHVzLnN0YXJ0RXZlbnQsIGluZXJ0aWFTdGF0dXMuc3RhcnRFdmVudCk7XG5cbiAgICAgICAgICAgICAgICBpbmVydGlhU3RhdHVzLmkgPSByZXFGcmFtZSh0aGlzLmJvdW5kSW5lcnRpYUZyYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZXJ0aWFTdGF0dXMuZW5kaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGluZXJ0aWFTdGF0dXMuc3ggPSBpbmVydGlhU3RhdHVzLm1vZGlmaWVkWGU7XG4gICAgICAgICAgICAgICAgaW5lcnRpYVN0YXR1cy5zeSA9IGluZXJ0aWFTdGF0dXMubW9kaWZpZWRZZTtcblxuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlck1vdmUoaW5lcnRpYVN0YXR1cy5zdGFydEV2ZW50LCBpbmVydGlhU3RhdHVzLnN0YXJ0RXZlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlckVuZChpbmVydGlhU3RhdHVzLnN0YXJ0RXZlbnQsIGluZXJ0aWFTdGF0dXMuc3RhcnRFdmVudCk7XG5cbiAgICAgICAgICAgICAgICBpbmVydGlhU3RhdHVzLmFjdGl2ZSA9IGluZXJ0aWFTdGF0dXMuZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc21vb3RoRW5kRnJhbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbmVydGlhU3RhdHVzID0gdGhpcy5pbmVydGlhU3RhdHVzLFxuICAgICAgICAgICAgICAgIHQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIGluZXJ0aWFTdGF0dXMudDAsXG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSB0aGlzLnRhcmdldC5vcHRpb25zW3RoaXMucHJlcGFyZWQubmFtZV0uaW5lcnRpYS5zbW9vdGhFbmREdXJhdGlvbjtcblxuICAgICAgICAgICAgaWYgKHQgPCBkdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGluZXJ0aWFTdGF0dXMuc3ggPSBlYXNlT3V0UXVhZCh0LCAwLCBpbmVydGlhU3RhdHVzLnhlLCBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgaW5lcnRpYVN0YXR1cy5zeSA9IGVhc2VPdXRRdWFkKHQsIDAsIGluZXJ0aWFTdGF0dXMueWUsIGR1cmF0aW9uKTtcblxuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlck1vdmUoaW5lcnRpYVN0YXR1cy5zdGFydEV2ZW50LCBpbmVydGlhU3RhdHVzLnN0YXJ0RXZlbnQpO1xuXG4gICAgICAgICAgICAgICAgaW5lcnRpYVN0YXR1cy5pID0gcmVxRnJhbWUodGhpcy5ib3VuZFNtb290aEVuZEZyYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZXJ0aWFTdGF0dXMuZW5kaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGluZXJ0aWFTdGF0dXMuc3ggPSBpbmVydGlhU3RhdHVzLnhlO1xuICAgICAgICAgICAgICAgIGluZXJ0aWFTdGF0dXMuc3kgPSBpbmVydGlhU3RhdHVzLnllO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludGVyTW92ZShpbmVydGlhU3RhdHVzLnN0YXJ0RXZlbnQsIGluZXJ0aWFTdGF0dXMuc3RhcnRFdmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludGVyRW5kKGluZXJ0aWFTdGF0dXMuc3RhcnRFdmVudCwgaW5lcnRpYVN0YXR1cy5zdGFydEV2ZW50KTtcblxuICAgICAgICAgICAgICAgIGluZXJ0aWFTdGF0dXMuc21vb3RoRW5kID1cbiAgICAgICAgICAgICAgICAgIGluZXJ0aWFTdGF0dXMuYWN0aXZlID0gaW5lcnRpYVN0YXR1cy5lbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhZGRQb2ludGVyOiBmdW5jdGlvbiAocG9pbnRlcikge1xuICAgICAgICAgICAgdmFyIGlkID0gZ2V0UG9pbnRlcklkKHBvaW50ZXIpLFxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5tb3VzZT8gMCA6IGluZGV4T2YodGhpcy5wb2ludGVySWRzLCBpZCk7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMucG9pbnRlcklkcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucG9pbnRlcklkc1tpbmRleF0gPSBpZDtcbiAgICAgICAgICAgIHRoaXMucG9pbnRlcnNbaW5kZXhdID0gcG9pbnRlcjtcblxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZVBvaW50ZXI6IGZ1bmN0aW9uIChwb2ludGVyKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBnZXRQb2ludGVySWQocG9pbnRlciksXG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLm1vdXNlPyAwIDogaW5kZXhPZih0aGlzLnBvaW50ZXJJZHMsIGlkKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgdGhpcy5wb2ludGVycyAgIC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5wb2ludGVySWRzIC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5kb3duVGFyZ2V0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5kb3duVGltZXMgIC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5ob2xkVGltZXJzIC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlY29yZFBvaW50ZXI6IGZ1bmN0aW9uIChwb2ludGVyKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLm1vdXNlPyAwOiBpbmRleE9mKHRoaXMucG9pbnRlcklkcywgZ2V0UG9pbnRlcklkKHBvaW50ZXIpKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgdGhpcy5wb2ludGVyc1tpbmRleF0gPSBwb2ludGVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbGxlY3RFdmVudFRhcmdldHM6IGZ1bmN0aW9uIChwb2ludGVyLCBldmVudCwgZXZlbnRUYXJnZXQsIGV2ZW50VHlwZSkge1xuICAgICAgICAgICAgdmFyIHBvaW50ZXJJbmRleCA9IHRoaXMubW91c2U/IDAgOiBpbmRleE9mKHRoaXMucG9pbnRlcklkcywgZ2V0UG9pbnRlcklkKHBvaW50ZXIpKTtcblxuICAgICAgICAgICAgLy8gZG8gbm90IGZpcmUgYSB0YXAgZXZlbnQgaWYgdGhlIHBvaW50ZXIgd2FzIG1vdmVkIGJlZm9yZSBiZWluZyBsaWZ0ZWRcbiAgICAgICAgICAgIGlmIChldmVudFR5cGUgPT09ICd0YXAnICYmICh0aGlzLnBvaW50ZXJXYXNNb3ZlZFxuICAgICAgICAgICAgICAgIC8vIG9yIGlmIHRoZSBwb2ludGVydXAgdGFyZ2V0IGlzIGRpZmZlcmVudCB0byB0aGUgcG9pbnRlcmRvd24gdGFyZ2V0XG4gICAgICAgICAgICAgICAgfHwgISh0aGlzLmRvd25UYXJnZXRzW3BvaW50ZXJJbmRleF0gJiYgdGhpcy5kb3duVGFyZ2V0c1twb2ludGVySW5kZXhdID09PSBldmVudFRhcmdldCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGFyZ2V0cyA9IFtdLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gW10sXG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGV2ZW50VGFyZ2V0O1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBjb2xsZWN0U2VsZWN0b3JzIChpbnRlcmFjdGFibGUsIHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVscyA9IGllOE1hdGNoZXNTZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcmFjdGFibGUuX2lFdmVudHNbZXZlbnRUeXBlXVxuICAgICAgICAgICAgICAgICAgICAmJiBpc0VsZW1lbnQoZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgJiYgaW5Db250ZXh0KGludGVyYWN0YWJsZSwgZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgJiYgIXRlc3RJZ25vcmUoaW50ZXJhY3RhYmxlLCBlbGVtZW50LCBldmVudFRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgJiYgdGVzdEFsbG93KGludGVyYWN0YWJsZSwgZWxlbWVudCwgZXZlbnRUYXJnZXQpXG4gICAgICAgICAgICAgICAgICAgICYmIG1hdGNoZXNTZWxlY3RvcihlbGVtZW50LCBzZWxlY3RvciwgZWxzKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldHMucHVzaChpbnRlcmFjdGFibGUpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJhY3QuaXNTZXQoZWxlbWVudCkgJiYgaW50ZXJhY3QoZWxlbWVudCkuX2lFdmVudHNbZXZlbnRUeXBlXSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRzLnB1c2goaW50ZXJhY3QoZWxlbWVudCkpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGludGVyYWN0YWJsZXMuZm9yRWFjaFNlbGVjdG9yKGNvbGxlY3RTZWxlY3RvcnMpO1xuXG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHBhcmVudEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgdGFwIGV2ZW50IGV2ZW4gaWYgdGhlcmUgYXJlIG5vIGxpc3RlbmVycyBzbyB0aGF0XG4gICAgICAgICAgICAvLyBkb3VibGV0YXAgY2FuIHN0aWxsIGJlIGNyZWF0ZWQgYW5kIGZpcmVkXG4gICAgICAgICAgICBpZiAodGFyZ2V0cy5sZW5ndGggfHwgZXZlbnRUeXBlID09PSAndGFwJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZVBvaW50ZXJzKHBvaW50ZXIsIGV2ZW50LCBldmVudFRhcmdldCwgdGFyZ2V0cywgZWxlbWVudHMsIGV2ZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlyZVBvaW50ZXJzOiBmdW5jdGlvbiAocG9pbnRlciwgZXZlbnQsIGV2ZW50VGFyZ2V0LCB0YXJnZXRzLCBlbGVtZW50cywgZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRlckluZGV4ID0gdGhpcy5tb3VzZT8gMCA6IGluZGV4T2YodGhpcy5wb2ludGVySWRzLCBnZXRQb2ludGVySWQocG9pbnRlcikpLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudCA9IHt9LFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgLy8gZm9yIHRhcCBldmVudHNcbiAgICAgICAgICAgICAgICBpbnRlcnZhbCwgY3JlYXRlTmV3RG91YmxlVGFwO1xuXG4gICAgICAgICAgICAvLyBpZiBpdCdzIGEgZG91YmxldGFwIHRoZW4gdGhlIGV2ZW50IHByb3BlcnRpZXMgd291bGQgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBjb3BpZWQgZnJvbSB0aGUgdGFwIGV2ZW50IGFuZCBwcm92aWRlZCBhcyB0aGUgcG9pbnRlciBhcmd1bWVudFxuICAgICAgICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gJ2RvdWJsZXRhcCcpIHtcbiAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnQgPSBwb2ludGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlckV4dGVuZChwb2ludGVyRXZlbnQsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQgIT09IHBvaW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlckV4dGVuZChwb2ludGVyRXZlbnQsIHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudC5wcmV2ZW50RGVmYXVsdCAgICAgICAgICAgPSBwcmV2ZW50T3JpZ2luYWxEZWZhdWx0O1xuICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudC5zdG9wUHJvcGFnYXRpb24gICAgICAgICAgPSBJbnRlcmFjdEV2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb247XG4gICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9IEludGVyYWN0RXZlbnQucHJvdG90eXBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjtcbiAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnQuaW50ZXJhY3Rpb24gICAgICAgICAgICAgID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudC50aW1lU3RhbXAgICAgICAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnQub3JpZ2luYWxFdmVudCAgID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50Lm9yaWdpbmFsUG9pbnRlciA9IHBvaW50ZXI7XG4gICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50LnR5cGUgICAgICAgICAgICA9IGV2ZW50VHlwZTtcbiAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnQucG9pbnRlcklkICAgICAgID0gZ2V0UG9pbnRlcklkKHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudC5wb2ludGVyVHlwZSAgICAgPSB0aGlzLm1vdXNlPyAnbW91c2UnIDogIXN1cHBvcnRzUG9pbnRlckV2ZW50PyAndG91Y2gnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBpc1N0cmluZyhwb2ludGVyLnBvaW50ZXJUeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHBvaW50ZXIucG9pbnRlclR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBbLCwndG91Y2gnLCAncGVuJywgJ21vdXNlJ11bcG9pbnRlci5wb2ludGVyVHlwZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChldmVudFR5cGUgPT09ICd0YXAnKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50LmR0ID0gcG9pbnRlckV2ZW50LnRpbWVTdGFtcCAtIHRoaXMuZG93blRpbWVzW3BvaW50ZXJJbmRleF07XG5cbiAgICAgICAgICAgICAgICBpbnRlcnZhbCA9IHBvaW50ZXJFdmVudC50aW1lU3RhbXAgLSB0aGlzLnRhcFRpbWU7XG4gICAgICAgICAgICAgICAgY3JlYXRlTmV3RG91YmxlVGFwID0gISEodGhpcy5wcmV2VGFwICYmIHRoaXMucHJldlRhcC50eXBlICE9PSAnZG91YmxldGFwJ1xuICAgICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLnByZXZUYXAudGFyZ2V0ID09PSBwb2ludGVyRXZlbnQudGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICYmIGludGVydmFsIDwgNTAwKTtcblxuICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudC5kb3VibGUgPSBjcmVhdGVOZXdEb3VibGVUYXA7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnRhcFRpbWUgPSBwb2ludGVyRXZlbnQudGltZVN0YW1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudC5jdXJyZW50VGFyZ2V0ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50LmludGVyYWN0YWJsZSA9IHRhcmdldHNbaV07XG4gICAgICAgICAgICAgICAgdGFyZ2V0c1tpXS5maXJlKHBvaW50ZXJFdmVudCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocG9pbnRlckV2ZW50LmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZFxuICAgICAgICAgICAgICAgICAgICB8fChwb2ludGVyRXZlbnQucHJvcGFnYXRpb25TdG9wcGVkICYmIGVsZW1lbnRzW2kgKyAxXSAhPT0gcG9pbnRlckV2ZW50LmN1cnJlbnRUYXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNyZWF0ZU5ld0RvdWJsZVRhcCkge1xuICAgICAgICAgICAgICAgIHZhciBkb3VibGVUYXAgPSB7fTtcblxuICAgICAgICAgICAgICAgIGV4dGVuZChkb3VibGVUYXAsIHBvaW50ZXJFdmVudCk7XG5cbiAgICAgICAgICAgICAgICBkb3VibGVUYXAuZHQgICA9IGludGVydmFsO1xuICAgICAgICAgICAgICAgIGRvdWJsZVRhcC50eXBlID0gJ2RvdWJsZXRhcCc7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxlY3RFdmVudFRhcmdldHMoZG91YmxlVGFwLCBldmVudCwgZXZlbnRUYXJnZXQsICdkb3VibGV0YXAnKTtcblxuICAgICAgICAgICAgICAgIHRoaXMucHJldlRhcCA9IGRvdWJsZVRhcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gJ3RhcCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZUYXAgPSBwb2ludGVyRXZlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdmFsaWRhdGVTZWxlY3RvcjogZnVuY3Rpb24gKHBvaW50ZXIsIGV2ZW50LCBtYXRjaGVzLCBtYXRjaEVsZW1lbnRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWF0Y2hlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IG1hdGNoZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoRWxlbWVudCA9IG1hdGNoRWxlbWVudHNbaV0sXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9IHZhbGlkYXRlQWN0aW9uKG1hdGNoLmdldEFjdGlvbihwb2ludGVyLCBldmVudCwgdGhpcywgbWF0Y2hFbGVtZW50KSwgbWF0Y2gpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAmJiB3aXRoaW5JbnRlcmFjdGlvbkxpbWl0KG1hdGNoLCBtYXRjaEVsZW1lbnQsIGFjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBtYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gbWF0Y2hFbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNldFNuYXBwaW5nOiBmdW5jdGlvbiAocGFnZUNvb3Jkcywgc3RhdHVzKSB7XG4gICAgICAgICAgICB2YXIgc25hcCA9IHRoaXMudGFyZ2V0Lm9wdGlvbnNbdGhpcy5wcmVwYXJlZC5uYW1lXS5zbmFwLFxuICAgICAgICAgICAgICAgIHRhcmdldHMgPSBbXSxcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgcGFnZSxcbiAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICBzdGF0dXMgPSBzdGF0dXMgfHwgdGhpcy5zbmFwU3RhdHVzO1xuXG4gICAgICAgICAgICBpZiAoc3RhdHVzLnVzZVN0YXR1c1hZKSB7XG4gICAgICAgICAgICAgICAgcGFnZSA9IHsgeDogc3RhdHVzLngsIHk6IHN0YXR1cy55IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID0gZ2V0T3JpZ2luWFkodGhpcy50YXJnZXQsIHRoaXMuZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICBwYWdlID0gZXh0ZW5kKHt9LCBwYWdlQ29vcmRzKTtcblxuICAgICAgICAgICAgICAgIHBhZ2UueCAtPSBvcmlnaW4ueDtcbiAgICAgICAgICAgICAgICBwYWdlLnkgLT0gb3JpZ2luLnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXR1cy5yZWFsWCA9IHBhZ2UueDtcbiAgICAgICAgICAgIHN0YXR1cy5yZWFsWSA9IHBhZ2UueTtcblxuICAgICAgICAgICAgcGFnZS54ID0gcGFnZS54IC0gdGhpcy5pbmVydGlhU3RhdHVzLnJlc3VtZUR4O1xuICAgICAgICAgICAgcGFnZS55ID0gcGFnZS55IC0gdGhpcy5pbmVydGlhU3RhdHVzLnJlc3VtZUR5O1xuXG4gICAgICAgICAgICB2YXIgbGVuID0gc25hcC50YXJnZXRzPyBzbmFwLnRhcmdldHMubGVuZ3RoIDogMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgcmVsSW5kZXggPSAwOyByZWxJbmRleCA8IHRoaXMuc25hcE9mZnNldHMubGVuZ3RoOyByZWxJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlbGF0aXZlID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBwYWdlLnggLSB0aGlzLnNuYXBPZmZzZXRzW3JlbEluZGV4XS54LFxuICAgICAgICAgICAgICAgICAgICB5OiBwYWdlLnkgLSB0aGlzLnNuYXBPZmZzZXRzW3JlbEluZGV4XS55XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihzbmFwLnRhcmdldHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBzbmFwLnRhcmdldHNbaV0ocmVsYXRpdmUueCwgcmVsYXRpdmUueSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBzbmFwLnRhcmdldHNbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldCkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBpc051bWJlcih0YXJnZXQueCkgPyAodGFyZ2V0LnggKyB0aGlzLnNuYXBPZmZzZXRzW3JlbEluZGV4XS54KSA6IHJlbGF0aXZlLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBpc051bWJlcih0YXJnZXQueSkgPyAodGFyZ2V0LnkgKyB0aGlzLnNuYXBPZmZzZXRzW3JlbEluZGV4XS55KSA6IHJlbGF0aXZlLnksXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBpc051bWJlcih0YXJnZXQucmFuZ2UpPyB0YXJnZXQucmFuZ2U6IHNuYXAucmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2xvc2VzdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBpblJhbmdlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiAwLFxuICAgICAgICAgICAgICAgICAgICBkeDogMCxcbiAgICAgICAgICAgICAgICAgICAgZHk6IDBcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcblxuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHRhcmdldC5yYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgZHggPSB0YXJnZXQueCAtIHBhZ2UueCxcbiAgICAgICAgICAgICAgICAgICAgZHkgPSB0YXJnZXQueSAtIHBhZ2UueSxcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBoeXBvdChkeCwgZHkpLFxuICAgICAgICAgICAgICAgICAgICBpblJhbmdlID0gZGlzdGFuY2UgPD0gcmFuZ2U7XG5cbiAgICAgICAgICAgICAgICAvLyBJbmZpbml0ZSB0YXJnZXRzIGNvdW50IGFzIGJlaW5nIG91dCBvZiByYW5nZVxuICAgICAgICAgICAgICAgIC8vIGNvbXBhcmVkIHRvIG5vbiBpbmZpbml0ZSBvbmVzIHRoYXQgYXJlIGluIHJhbmdlXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlID09PSBJbmZpbml0eSAmJiBjbG9zZXN0LmluUmFuZ2UgJiYgY2xvc2VzdC5yYW5nZSAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5SYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghY2xvc2VzdC50YXJnZXQgfHwgKGluUmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgdGhlIGNsb3Nlc3QgdGFyZ2V0IGluIHJhbmdlP1xuICAgICAgICAgICAgICAgICAgICA/IChjbG9zZXN0LmluUmFuZ2UgJiYgcmFuZ2UgIT09IEluZmluaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcG9pbnRlciBpcyByZWxhdGl2ZWx5IGRlZXBlciBpbiB0aGlzIHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBkaXN0YW5jZSAvIHJhbmdlIDwgY2xvc2VzdC5kaXN0YW5jZSAvIGNsb3Nlc3QucmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgdGFyZ2V0IGhhcyBJbmZpbml0ZSByYW5nZSBhbmQgdGhlIGNsb3Nlc3QgZG9lc24ndFxuICAgICAgICAgICAgICAgICAgICAgICAgOiAocmFuZ2UgPT09IEluZmluaXR5ICYmIGNsb3Nlc3QucmFuZ2UgIT09IEluZmluaXR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9SIHRoaXMgdGFyZ2V0IGlzIGNsb3NlciB0aGF0IHRoZSBwcmV2aW91cyBjbG9zZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgZGlzdGFuY2UgPCBjbG9zZXN0LmRpc3RhbmNlKVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb3RoZXIgaXMgbm90IGluIHJhbmdlIGFuZCB0aGUgcG9pbnRlciBpcyBjbG9zZXIgdG8gdGhpcyB0YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgOiAoIWNsb3Nlc3QuaW5SYW5nZSAmJiBkaXN0YW5jZSA8IGNsb3Nlc3QuZGlzdGFuY2UpKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluUmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdC50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3QuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdC5yYW5nZSA9IHJhbmdlO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0LmluUmFuZ2UgPSBpblJhbmdlO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0LmR4ID0gZHg7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3QuZHkgPSBkeTtcblxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMucmFuZ2UgPSByYW5nZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzbmFwQ2hhbmdlZDtcblxuICAgICAgICAgICAgaWYgKGNsb3Nlc3QudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgc25hcENoYW5nZWQgPSAoc3RhdHVzLnNuYXBwZWRYICE9PSBjbG9zZXN0LnRhcmdldC54IHx8IHN0YXR1cy5zbmFwcGVkWSAhPT0gY2xvc2VzdC50YXJnZXQueSk7XG5cbiAgICAgICAgICAgICAgICBzdGF0dXMuc25hcHBlZFggPSBjbG9zZXN0LnRhcmdldC54O1xuICAgICAgICAgICAgICAgIHN0YXR1cy5zbmFwcGVkWSA9IGNsb3Nlc3QudGFyZ2V0Lnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzbmFwQ2hhbmdlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBzdGF0dXMuc25hcHBlZFggPSBOYU47XG4gICAgICAgICAgICAgICAgc3RhdHVzLnNuYXBwZWRZID0gTmFOO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0dXMuZHggPSBjbG9zZXN0LmR4O1xuICAgICAgICAgICAgc3RhdHVzLmR5ID0gY2xvc2VzdC5keTtcblxuICAgICAgICAgICAgc3RhdHVzLmNoYW5nZWQgPSAoc25hcENoYW5nZWQgfHwgKGNsb3Nlc3QuaW5SYW5nZSAmJiAhc3RhdHVzLmxvY2tlZCkpO1xuICAgICAgICAgICAgc3RhdHVzLmxvY2tlZCA9IGNsb3Nlc3QuaW5SYW5nZTtcblxuICAgICAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRSZXN0cmljdGlvbjogZnVuY3Rpb24gKHBhZ2VDb29yZHMsIHN0YXR1cykge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0LFxuICAgICAgICAgICAgICAgIHJlc3RyaWN0ID0gdGFyZ2V0ICYmIHRhcmdldC5vcHRpb25zW3RoaXMucHJlcGFyZWQubmFtZV0ucmVzdHJpY3QsXG4gICAgICAgICAgICAgICAgcmVzdHJpY3Rpb24gPSByZXN0cmljdCAmJiByZXN0cmljdC5yZXN0cmljdGlvbixcbiAgICAgICAgICAgICAgICBwYWdlO1xuXG4gICAgICAgICAgICBpZiAoIXJlc3RyaWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdHVzID0gc3RhdHVzIHx8IHRoaXMucmVzdHJpY3RTdGF0dXM7XG5cbiAgICAgICAgICAgIHBhZ2UgPSBzdGF0dXMudXNlU3RhdHVzWFlcbiAgICAgICAgICAgICAgICAgICAgPyBwYWdlID0geyB4OiBzdGF0dXMueCwgeTogc3RhdHVzLnkgfVxuICAgICAgICAgICAgICAgICAgICA6IHBhZ2UgPSBleHRlbmQoe30sIHBhZ2VDb29yZHMpO1xuXG4gICAgICAgICAgICBpZiAoc3RhdHVzLnNuYXAgJiYgc3RhdHVzLnNuYXAubG9ja2VkKSB7XG4gICAgICAgICAgICAgICAgcGFnZS54ICs9IHN0YXR1cy5zbmFwLmR4IHx8IDA7XG4gICAgICAgICAgICAgICAgcGFnZS55ICs9IHN0YXR1cy5zbmFwLmR5IHx8IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhZ2UueCAtPSB0aGlzLmluZXJ0aWFTdGF0dXMucmVzdW1lRHg7XG4gICAgICAgICAgICBwYWdlLnkgLT0gdGhpcy5pbmVydGlhU3RhdHVzLnJlc3VtZUR5O1xuXG4gICAgICAgICAgICBzdGF0dXMuZHggPSAwO1xuICAgICAgICAgICAgc3RhdHVzLmR5ID0gMDtcbiAgICAgICAgICAgIHN0YXR1cy5yZXN0cmljdGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHZhciByZWN0LCByZXN0cmljdGVkWCwgcmVzdHJpY3RlZFk7XG5cbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhyZXN0cmljdGlvbikpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdHJpY3Rpb24gPT09ICdwYXJlbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RyaWN0aW9uID0gcGFyZW50RWxlbWVudCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXN0cmljdGlvbiA9PT0gJ3NlbGYnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RyaWN0aW9uID0gdGFyZ2V0LmdldFJlY3QodGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RyaWN0aW9uID0gY2xvc2VzdCh0aGlzLmVsZW1lbnQsIHJlc3RyaWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJlc3RyaWN0aW9uKSB7IHJldHVybiBzdGF0dXM7IH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocmVzdHJpY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgcmVzdHJpY3Rpb24gPSByZXN0cmljdGlvbihwYWdlLngsIHBhZ2UueSwgdGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzRWxlbWVudChyZXN0cmljdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXN0cmljdGlvbiA9IGdldEVsZW1lbnRSZWN0KHJlc3RyaWN0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVjdCA9IHJlc3RyaWN0aW9uO1xuXG4gICAgICAgICAgICBpZiAoIXJlc3RyaWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmVzdHJpY3RlZFggPSBwYWdlLng7XG4gICAgICAgICAgICAgICAgcmVzdHJpY3RlZFkgPSBwYWdlLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvYmplY3QgaXMgYXNzdW1lZCB0byBoYXZlXG4gICAgICAgICAgICAvLyB4LCB5LCB3aWR0aCwgaGVpZ2h0IG9yXG4gICAgICAgICAgICAvLyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21cbiAgICAgICAgICAgIGVsc2UgaWYgKCd4JyBpbiByZXN0cmljdGlvbiAmJiAneScgaW4gcmVzdHJpY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXN0cmljdGVkWCA9IE1hdGgubWF4KE1hdGgubWluKHJlY3QueCArIHJlY3Qud2lkdGggIC0gdGhpcy5yZXN0cmljdE9mZnNldC5yaWdodCAsIHBhZ2UueCksIHJlY3QueCArIHRoaXMucmVzdHJpY3RPZmZzZXQubGVmdCk7XG4gICAgICAgICAgICAgICAgcmVzdHJpY3RlZFkgPSBNYXRoLm1heChNYXRoLm1pbihyZWN0LnkgKyByZWN0LmhlaWdodCAtIHRoaXMucmVzdHJpY3RPZmZzZXQuYm90dG9tLCBwYWdlLnkpLCByZWN0LnkgKyB0aGlzLnJlc3RyaWN0T2Zmc2V0LnRvcCApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdHJpY3RlZFggPSBNYXRoLm1heChNYXRoLm1pbihyZWN0LnJpZ2h0ICAtIHRoaXMucmVzdHJpY3RPZmZzZXQucmlnaHQgLCBwYWdlLngpLCByZWN0LmxlZnQgKyB0aGlzLnJlc3RyaWN0T2Zmc2V0LmxlZnQpO1xuICAgICAgICAgICAgICAgIHJlc3RyaWN0ZWRZID0gTWF0aC5tYXgoTWF0aC5taW4ocmVjdC5ib3R0b20gLSB0aGlzLnJlc3RyaWN0T2Zmc2V0LmJvdHRvbSwgcGFnZS55KSwgcmVjdC50b3AgICsgdGhpcy5yZXN0cmljdE9mZnNldC50b3AgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdHVzLmR4ID0gcmVzdHJpY3RlZFggLSBwYWdlLng7XG4gICAgICAgICAgICBzdGF0dXMuZHkgPSByZXN0cmljdGVkWSAtIHBhZ2UueTtcblxuICAgICAgICAgICAgc3RhdHVzLmNoYW5nZWQgPSBzdGF0dXMucmVzdHJpY3RlZFggIT09IHJlc3RyaWN0ZWRYIHx8IHN0YXR1cy5yZXN0cmljdGVkWSAhPT0gcmVzdHJpY3RlZFk7XG4gICAgICAgICAgICBzdGF0dXMucmVzdHJpY3RlZCA9ICEhKHN0YXR1cy5keCB8fCBzdGF0dXMuZHkpO1xuXG4gICAgICAgICAgICBzdGF0dXMucmVzdHJpY3RlZFggPSByZXN0cmljdGVkWDtcbiAgICAgICAgICAgIHN0YXR1cy5yZXN0cmljdGVkWSA9IHJlc3RyaWN0ZWRZO1xuXG4gICAgICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNoZWNrQW5kUHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uIChldmVudCwgaW50ZXJhY3RhYmxlLCBlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoIShpbnRlcmFjdGFibGUgPSBpbnRlcmFjdGFibGUgfHwgdGhpcy50YXJnZXQpKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGludGVyYWN0YWJsZS5vcHRpb25zLFxuICAgICAgICAgICAgICAgIHByZXZlbnQgPSBvcHRpb25zLnByZXZlbnREZWZhdWx0O1xuXG4gICAgICAgICAgICBpZiAocHJldmVudCA9PT0gJ2F1dG8nICYmIGVsZW1lbnQgJiYgIS9eKGlucHV0fHNlbGVjdHx0ZXh0YXJlYSkkL2kudGVzdChldmVudC50YXJnZXQubm9kZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IHByZXZlbnREZWZhdWx0IG9uIHBvaW50ZXJkb3duIGlmIHRoZSBwcmVwYXJlZCBhY3Rpb24gaXMgYSBkcmFnXG4gICAgICAgICAgICAgICAgLy8gYW5kIGRyYWdnaW5nIGNhbiBvbmx5IHN0YXJ0IGZyb20gYSBjZXJ0YWluIGRpcmVjdGlvbiAtIHRoaXMgYWxsb3dzXG4gICAgICAgICAgICAgICAgLy8gYSB0b3VjaCB0byBwYW4gdGhlIHZpZXdwb3J0IGlmIGEgZHJhZyBpc24ndCBpbiB0aGUgcmlnaHQgZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKC9kb3dufHN0YXJ0L2kudGVzdChldmVudC50eXBlKVxuICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLnByZXBhcmVkLm5hbWUgPT09ICdkcmFnJyAmJiBvcHRpb25zLmRyYWcuYXhpcyAhPT0gJ3h5Jykge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB3aXRoIG1hbnVhbFN0YXJ0LCBvbmx5IHByZXZlbnREZWZhdWx0IHdoaWxlIGludGVyYWN0aW5nXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNbdGhpcy5wcmVwYXJlZC5uYW1lXSAmJiBvcHRpb25zW3RoaXMucHJlcGFyZWQubmFtZV0ubWFudWFsU3RhcnRcbiAgICAgICAgICAgICAgICAgICAgJiYgIXRoaXMuaW50ZXJhY3RpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcmV2ZW50ID09PSAnYWx3YXlzJykge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNhbGNJbmVydGlhOiBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gICAgICAgICAgICB2YXIgaW5lcnRpYU9wdGlvbnMgPSB0aGlzLnRhcmdldC5vcHRpb25zW3RoaXMucHJlcGFyZWQubmFtZV0uaW5lcnRpYSxcbiAgICAgICAgICAgICAgICBsYW1iZGEgPSBpbmVydGlhT3B0aW9ucy5yZXNpc3RhbmNlLFxuICAgICAgICAgICAgICAgIGluZXJ0aWFEdXIgPSAtTWF0aC5sb2coaW5lcnRpYU9wdGlvbnMuZW5kU3BlZWQgLyBzdGF0dXMudjApIC8gbGFtYmRhO1xuXG4gICAgICAgICAgICBzdGF0dXMueDAgPSB0aGlzLnByZXZFdmVudC5wYWdlWDtcbiAgICAgICAgICAgIHN0YXR1cy55MCA9IHRoaXMucHJldkV2ZW50LnBhZ2VZO1xuICAgICAgICAgICAgc3RhdHVzLnQwID0gc3RhdHVzLnN0YXJ0RXZlbnQudGltZVN0YW1wIC8gMTAwMDtcbiAgICAgICAgICAgIHN0YXR1cy5zeCA9IHN0YXR1cy5zeSA9IDA7XG5cbiAgICAgICAgICAgIHN0YXR1cy5tb2RpZmllZFhlID0gc3RhdHVzLnhlID0gKHN0YXR1cy52eDAgLSBpbmVydGlhRHVyKSAvIGxhbWJkYTtcbiAgICAgICAgICAgIHN0YXR1cy5tb2RpZmllZFllID0gc3RhdHVzLnllID0gKHN0YXR1cy52eTAgLSBpbmVydGlhRHVyKSAvIGxhbWJkYTtcbiAgICAgICAgICAgIHN0YXR1cy50ZSA9IGluZXJ0aWFEdXI7XG5cbiAgICAgICAgICAgIHN0YXR1cy5sYW1iZGFfdjAgPSBsYW1iZGEgLyBzdGF0dXMudjA7XG4gICAgICAgICAgICBzdGF0dXMub25lX3ZlX3YwID0gMSAtIGluZXJ0aWFPcHRpb25zLmVuZFNwZWVkIC8gc3RhdHVzLnYwO1xuICAgICAgICB9LFxuXG4gICAgICAgIGF1dG9TY3JvbGxNb3ZlOiBmdW5jdGlvbiAocG9pbnRlcikge1xuICAgICAgICAgICAgaWYgKCEodGhpcy5pbnRlcmFjdGluZygpXG4gICAgICAgICAgICAgICAgJiYgY2hlY2tBdXRvU2Nyb2xsKHRoaXMudGFyZ2V0LCB0aGlzLnByZXBhcmVkLm5hbWUpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuaW5lcnRpYVN0YXR1cy5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBhdXRvU2Nyb2xsLnggPSBhdXRvU2Nyb2xsLnkgPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRvcCxcbiAgICAgICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gdGhpcy50YXJnZXQub3B0aW9uc1t0aGlzLnByZXBhcmVkLm5hbWVdLmF1dG9TY3JvbGwsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXIgfHwgZ2V0V2luZG93KHRoaXMuZWxlbWVudCk7XG5cbiAgICAgICAgICAgIGlmIChpc1dpbmRvdyhjb250YWluZXIpKSB7XG4gICAgICAgICAgICAgICAgbGVmdCAgID0gcG9pbnRlci5jbGllbnRYIDwgYXV0b1Njcm9sbC5tYXJnaW47XG4gICAgICAgICAgICAgICAgdG9wICAgID0gcG9pbnRlci5jbGllbnRZIDwgYXV0b1Njcm9sbC5tYXJnaW47XG4gICAgICAgICAgICAgICAgcmlnaHQgID0gcG9pbnRlci5jbGllbnRYID4gY29udGFpbmVyLmlubmVyV2lkdGggIC0gYXV0b1Njcm9sbC5tYXJnaW47XG4gICAgICAgICAgICAgICAgYm90dG9tID0gcG9pbnRlci5jbGllbnRZID4gY29udGFpbmVyLmlubmVySGVpZ2h0IC0gYXV0b1Njcm9sbC5tYXJnaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGdldEVsZW1lbnRDbGllbnRSZWN0KGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgICAgICBsZWZ0ICAgPSBwb2ludGVyLmNsaWVudFggPCByZWN0LmxlZnQgICArIGF1dG9TY3JvbGwubWFyZ2luO1xuICAgICAgICAgICAgICAgIHRvcCAgICA9IHBvaW50ZXIuY2xpZW50WSA8IHJlY3QudG9wICAgICsgYXV0b1Njcm9sbC5tYXJnaW47XG4gICAgICAgICAgICAgICAgcmlnaHQgID0gcG9pbnRlci5jbGllbnRYID4gcmVjdC5yaWdodCAgLSBhdXRvU2Nyb2xsLm1hcmdpbjtcbiAgICAgICAgICAgICAgICBib3R0b20gPSBwb2ludGVyLmNsaWVudFkgPiByZWN0LmJvdHRvbSAtIGF1dG9TY3JvbGwubWFyZ2luO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhdXRvU2Nyb2xsLnggPSAocmlnaHQgPyAxOiBsZWZ0PyAtMTogMCk7XG4gICAgICAgICAgICBhdXRvU2Nyb2xsLnkgPSAoYm90dG9tPyAxOiAgdG9wPyAtMTogMCk7XG5cbiAgICAgICAgICAgIGlmICghYXV0b1Njcm9sbC5pc1Njcm9sbGluZykge1xuICAgICAgICAgICAgICAgIC8vIHNldCB0aGUgYXV0b1Njcm9sbCBwcm9wZXJ0aWVzIHRvIHRob3NlIG9mIHRoZSB0YXJnZXRcbiAgICAgICAgICAgICAgICBhdXRvU2Nyb2xsLm1hcmdpbiA9IG9wdGlvbnMubWFyZ2luO1xuICAgICAgICAgICAgICAgIGF1dG9TY3JvbGwuc3BlZWQgID0gb3B0aW9ucy5zcGVlZDtcblxuICAgICAgICAgICAgICAgIGF1dG9TY3JvbGwuc3RhcnQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3VwZGF0ZUV2ZW50VGFyZ2V0czogZnVuY3Rpb24gKHRhcmdldCwgY3VycmVudFRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRUYXJnZXQgICAgPSB0YXJnZXQ7XG4gICAgICAgICAgICB0aGlzLl9jdXJFdmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRJbnRlcmFjdGlvbkZyb21Qb2ludGVyIChwb2ludGVyLCBldmVudFR5cGUsIGV2ZW50VGFyZ2V0KSB7XG4gICAgICAgIHZhciBpID0gMCwgbGVuID0gaW50ZXJhY3Rpb25zLmxlbmd0aCxcbiAgICAgICAgICAgIG1vdXNlRXZlbnQgPSAoL21vdXNlL2kudGVzdChwb2ludGVyLnBvaW50ZXJUeXBlIHx8IGV2ZW50VHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTVNQb2ludGVyRXZlbnQuTVNQT0lOVEVSX1RZUEVfTU9VU0VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgcG9pbnRlci5wb2ludGVyVHlwZSA9PT0gNCksXG4gICAgICAgICAgICBpbnRlcmFjdGlvbjtcblxuICAgICAgICB2YXIgaWQgPSBnZXRQb2ludGVySWQocG9pbnRlcik7XG5cbiAgICAgICAgLy8gdHJ5IHRvIHJlc3VtZSBpbmVydGlhIHdpdGggYSBuZXcgcG9pbnRlclxuICAgICAgICBpZiAoL2Rvd258c3RhcnQvaS50ZXN0KGV2ZW50VHlwZSkpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uID0gaW50ZXJhY3Rpb25zW2ldO1xuXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBldmVudFRhcmdldDtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcmFjdGlvbi5pbmVydGlhU3RhdHVzLmFjdGl2ZSAmJiBpbnRlcmFjdGlvbi50YXJnZXQub3B0aW9uc1tpbnRlcmFjdGlvbi5wcmVwYXJlZC5uYW1lXS5pbmVydGlhLmFsbG93UmVzdW1lXG4gICAgICAgICAgICAgICAgICAgICYmIChpbnRlcmFjdGlvbi5tb3VzZSA9PT0gbW91c2VFdmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGlzIHRoZSBpbnRlcmFjdGlvbiBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gaW50ZXJhY3Rpb24uZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcmFjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBwYXJlbnRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgaXQncyBhIG1vdXNlIGludGVyYWN0aW9uXG4gICAgICAgIGlmIChtb3VzZUV2ZW50IHx8ICEoc3VwcG9ydHNUb3VjaCB8fCBzdXBwb3J0c1BvaW50ZXJFdmVudCkpIHtcblxuICAgICAgICAgICAgLy8gZmluZCBhIG1vdXNlIGludGVyYWN0aW9uIHRoYXQncyBub3QgaW4gaW5lcnRpYSBwaGFzZVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGludGVyYWN0aW9uc1tpXS5tb3VzZSAmJiAhaW50ZXJhY3Rpb25zW2ldLmluZXJ0aWFTdGF0dXMuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcmFjdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmaW5kIGFueSBpbnRlcmFjdGlvbiBzcGVjaWZpY2FsbHkgZm9yIG1vdXNlLlxuICAgICAgICAgICAgLy8gaWYgdGhlIGV2ZW50VHlwZSBpcyBhIG1vdXNlZG93biwgYW5kIGluZXJ0aWEgaXMgYWN0aXZlXG4gICAgICAgICAgICAvLyBpZ25vcmUgdGhlIGludGVyYWN0aW9uXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJhY3Rpb25zW2ldLm1vdXNlICYmICEoL2Rvd24vLnRlc3QoZXZlbnRUeXBlKSAmJiBpbnRlcmFjdGlvbnNbaV0uaW5lcnRpYVN0YXR1cy5hY3RpdmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcmFjdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBpbnRlcmFjdGlvbiBmb3IgbW91c2VcbiAgICAgICAgICAgIGludGVyYWN0aW9uID0gbmV3IEludGVyYWN0aW9uKCk7XG4gICAgICAgICAgICBpbnRlcmFjdGlvbi5tb3VzZSA9IHRydWU7XG5cbiAgICAgICAgICAgIHJldHVybiBpbnRlcmFjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBpbnRlcmFjdGlvbiB0aGF0IGhhcyB0aGlzIHBvaW50ZXJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbnMoaW50ZXJhY3Rpb25zW2ldLnBvaW50ZXJJZHMsIGlkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcmFjdGlvbnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhdCB0aGlzIHN0YWdlLCBhIHBvaW50ZXJVcCBzaG91bGQgbm90IHJldHVybiBhbiBpbnRlcmFjdGlvblxuICAgICAgICBpZiAoL3VwfGVuZHxvdXQvaS50ZXN0KGV2ZW50VHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGZpcnN0IGlkbGUgaW50ZXJhY3Rpb25cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpbnRlcmFjdGlvbiA9IGludGVyYWN0aW9uc1tpXTtcblxuICAgICAgICAgICAgaWYgKCghaW50ZXJhY3Rpb24ucHJlcGFyZWQubmFtZSB8fCAoaW50ZXJhY3Rpb24udGFyZ2V0Lm9wdGlvbnMuZ2VzdHVyZS5lbmFibGVkKSlcbiAgICAgICAgICAgICAgICAmJiAhaW50ZXJhY3Rpb24uaW50ZXJhY3RpbmcoKVxuICAgICAgICAgICAgICAgICYmICEoIW1vdXNlRXZlbnQgJiYgaW50ZXJhY3Rpb24ubW91c2UpKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJhY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IEludGVyYWN0aW9uKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9PbkludGVyYWN0aW9ucyAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaW50ZXJhY3Rpb24sXG4gICAgICAgICAgICAgICAgZXZlbnRUYXJnZXQgPSBnZXRBY3R1YWxFbGVtZW50KGV2ZW50LnBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBldmVudC5wYXRoWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZXZlbnQudGFyZ2V0KSxcbiAgICAgICAgICAgICAgICBjdXJFdmVudFRhcmdldCA9IGdldEFjdHVhbEVsZW1lbnQoZXZlbnQuY3VycmVudFRhcmdldCksXG4gICAgICAgICAgICAgICAgaTtcblxuICAgICAgICAgICAgaWYgKHN1cHBvcnRzVG91Y2ggJiYgL3RvdWNoLy50ZXN0KGV2ZW50LnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcHJldlRvdWNoVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2ludGVyID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24gPSBnZXRJbnRlcmFjdGlvbkZyb21Qb2ludGVyKHBvaW50ZXIsIGV2ZW50LnR5cGUsIGV2ZW50VGFyZ2V0KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWludGVyYWN0aW9uKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24uX3VwZGF0ZUV2ZW50VGFyZ2V0cyhldmVudFRhcmdldCwgY3VyRXZlbnRUYXJnZXQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uW21ldGhvZF0ocG9pbnRlciwgZXZlbnQsIGV2ZW50VGFyZ2V0LCBjdXJFdmVudFRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0c1BvaW50ZXJFdmVudCAmJiAvbW91c2UvLnRlc3QoZXZlbnQudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIG1vdXNlIGV2ZW50cyB3aGlsZSB0b3VjaCBpbnRlcmFjdGlvbnMgYXJlIGFjdGl2ZVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW50ZXJhY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWludGVyYWN0aW9uc1tpXS5tb3VzZSAmJiBpbnRlcmFjdGlvbnNbaV0ucG9pbnRlcklzRG93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0byBpZ25vcmUgbW91c2UgZXZlbnRzIHRoYXQgYXJlIHNpbXVsYXRlZCBieSB0aGUgYnJvd3NlclxuICAgICAgICAgICAgICAgICAgICAvLyBhZnRlciBhIHRvdWNoIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHByZXZUb3VjaFRpbWUgPCA1MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uID0gZ2V0SW50ZXJhY3Rpb25Gcm9tUG9pbnRlcihldmVudCwgZXZlbnQudHlwZSwgZXZlbnRUYXJnZXQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpbnRlcmFjdGlvbikgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLl91cGRhdGVFdmVudFRhcmdldHMoZXZlbnRUYXJnZXQsIGN1ckV2ZW50VGFyZ2V0KTtcblxuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uW21ldGhvZF0oZXZlbnQsIGV2ZW50LCBldmVudFRhcmdldCwgY3VyRXZlbnRUYXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBJbnRlcmFjdEV2ZW50IChpbnRlcmFjdGlvbiwgZXZlbnQsIGFjdGlvbiwgcGhhc2UsIGVsZW1lbnQsIHJlbGF0ZWQpIHtcbiAgICAgICAgdmFyIGNsaWVudCxcbiAgICAgICAgICAgIHBhZ2UsXG4gICAgICAgICAgICB0YXJnZXQgICAgICA9IGludGVyYWN0aW9uLnRhcmdldCxcbiAgICAgICAgICAgIHNuYXBTdGF0dXMgID0gaW50ZXJhY3Rpb24uc25hcFN0YXR1cyxcbiAgICAgICAgICAgIHJlc3RyaWN0U3RhdHVzICA9IGludGVyYWN0aW9uLnJlc3RyaWN0U3RhdHVzLFxuICAgICAgICAgICAgcG9pbnRlcnMgICAgPSBpbnRlcmFjdGlvbi5wb2ludGVycyxcbiAgICAgICAgICAgIGRlbHRhU291cmNlID0gKHRhcmdldCAmJiB0YXJnZXQub3B0aW9ucyB8fCBkZWZhdWx0T3B0aW9ucykuZGVsdGFTb3VyY2UsXG4gICAgICAgICAgICBzb3VyY2VYICAgICA9IGRlbHRhU291cmNlICsgJ1gnLFxuICAgICAgICAgICAgc291cmNlWSAgICAgPSBkZWx0YVNvdXJjZSArICdZJyxcbiAgICAgICAgICAgIG9wdGlvbnMgICAgID0gdGFyZ2V0PyB0YXJnZXQub3B0aW9uczogZGVmYXVsdE9wdGlvbnMsXG4gICAgICAgICAgICBvcmlnaW4gICAgICA9IGdldE9yaWdpblhZKHRhcmdldCwgZWxlbWVudCksXG4gICAgICAgICAgICBzdGFydGluZyAgICA9IHBoYXNlID09PSAnc3RhcnQnLFxuICAgICAgICAgICAgZW5kaW5nICAgICAgPSBwaGFzZSA9PT0gJ2VuZCcsXG4gICAgICAgICAgICBjb29yZHMgICAgICA9IHN0YXJ0aW5nPyBpbnRlcmFjdGlvbi5zdGFydENvb3JkcyA6IGludGVyYWN0aW9uLmN1ckNvb3JkcztcblxuICAgICAgICBlbGVtZW50ID0gZWxlbWVudCB8fCBpbnRlcmFjdGlvbi5lbGVtZW50O1xuXG4gICAgICAgIHBhZ2UgICA9IGV4dGVuZCh7fSwgY29vcmRzLnBhZ2UpO1xuICAgICAgICBjbGllbnQgPSBleHRlbmQoe30sIGNvb3Jkcy5jbGllbnQpO1xuXG4gICAgICAgIHBhZ2UueCAtPSBvcmlnaW4ueDtcbiAgICAgICAgcGFnZS55IC09IG9yaWdpbi55O1xuXG4gICAgICAgIGNsaWVudC54IC09IG9yaWdpbi54O1xuICAgICAgICBjbGllbnQueSAtPSBvcmlnaW4ueTtcblxuICAgICAgICB2YXIgcmVsYXRpdmVQb2ludHMgPSBvcHRpb25zW2FjdGlvbl0uc25hcCAmJiBvcHRpb25zW2FjdGlvbl0uc25hcC5yZWxhdGl2ZVBvaW50cyA7XG5cbiAgICAgICAgaWYgKGNoZWNrU25hcCh0YXJnZXQsIGFjdGlvbikgJiYgIShzdGFydGluZyAmJiByZWxhdGl2ZVBvaW50cyAmJiByZWxhdGl2ZVBvaW50cy5sZW5ndGgpKSB7XG4gICAgICAgICAgICB0aGlzLnNuYXAgPSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UgIDogc25hcFN0YXR1cy5yYW5nZSxcbiAgICAgICAgICAgICAgICBsb2NrZWQgOiBzbmFwU3RhdHVzLmxvY2tlZCxcbiAgICAgICAgICAgICAgICB4ICAgICAgOiBzbmFwU3RhdHVzLnNuYXBwZWRYLFxuICAgICAgICAgICAgICAgIHkgICAgICA6IHNuYXBTdGF0dXMuc25hcHBlZFksXG4gICAgICAgICAgICAgICAgcmVhbFggIDogc25hcFN0YXR1cy5yZWFsWCxcbiAgICAgICAgICAgICAgICByZWFsWSAgOiBzbmFwU3RhdHVzLnJlYWxZLFxuICAgICAgICAgICAgICAgIGR4ICAgICA6IHNuYXBTdGF0dXMuZHgsXG4gICAgICAgICAgICAgICAgZHkgICAgIDogc25hcFN0YXR1cy5keVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHNuYXBTdGF0dXMubG9ja2VkKSB7XG4gICAgICAgICAgICAgICAgcGFnZS54ICs9IHNuYXBTdGF0dXMuZHg7XG4gICAgICAgICAgICAgICAgcGFnZS55ICs9IHNuYXBTdGF0dXMuZHk7XG4gICAgICAgICAgICAgICAgY2xpZW50LnggKz0gc25hcFN0YXR1cy5keDtcbiAgICAgICAgICAgICAgICBjbGllbnQueSArPSBzbmFwU3RhdHVzLmR5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoZWNrUmVzdHJpY3QodGFyZ2V0LCBhY3Rpb24pICYmICEoc3RhcnRpbmcgJiYgb3B0aW9uc1thY3Rpb25dLnJlc3RyaWN0LmVsZW1lbnRSZWN0KSAmJiByZXN0cmljdFN0YXR1cy5yZXN0cmljdGVkKSB7XG4gICAgICAgICAgICBwYWdlLnggKz0gcmVzdHJpY3RTdGF0dXMuZHg7XG4gICAgICAgICAgICBwYWdlLnkgKz0gcmVzdHJpY3RTdGF0dXMuZHk7XG4gICAgICAgICAgICBjbGllbnQueCArPSByZXN0cmljdFN0YXR1cy5keDtcbiAgICAgICAgICAgIGNsaWVudC55ICs9IHJlc3RyaWN0U3RhdHVzLmR5O1xuXG4gICAgICAgICAgICB0aGlzLnJlc3RyaWN0ID0ge1xuICAgICAgICAgICAgICAgIGR4OiByZXN0cmljdFN0YXR1cy5keCxcbiAgICAgICAgICAgICAgICBkeTogcmVzdHJpY3RTdGF0dXMuZHlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhZ2VYICAgICA9IHBhZ2UueDtcbiAgICAgICAgdGhpcy5wYWdlWSAgICAgPSBwYWdlLnk7XG4gICAgICAgIHRoaXMuY2xpZW50WCAgID0gY2xpZW50Lng7XG4gICAgICAgIHRoaXMuY2xpZW50WSAgID0gY2xpZW50Lnk7XG5cbiAgICAgICAgdGhpcy54MCAgICAgICAgPSBpbnRlcmFjdGlvbi5zdGFydENvb3Jkcy5wYWdlLnggLSBvcmlnaW4ueDtcbiAgICAgICAgdGhpcy55MCAgICAgICAgPSBpbnRlcmFjdGlvbi5zdGFydENvb3Jkcy5wYWdlLnkgLSBvcmlnaW4ueTtcbiAgICAgICAgdGhpcy5jbGllbnRYMCAgPSBpbnRlcmFjdGlvbi5zdGFydENvb3Jkcy5jbGllbnQueCAtIG9yaWdpbi54O1xuICAgICAgICB0aGlzLmNsaWVudFkwICA9IGludGVyYWN0aW9uLnN0YXJ0Q29vcmRzLmNsaWVudC55IC0gb3JpZ2luLnk7XG4gICAgICAgIHRoaXMuY3RybEtleSAgID0gZXZlbnQuY3RybEtleTtcbiAgICAgICAgdGhpcy5hbHRLZXkgICAgPSBldmVudC5hbHRLZXk7XG4gICAgICAgIHRoaXMuc2hpZnRLZXkgID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgICAgIHRoaXMubWV0YUtleSAgID0gZXZlbnQubWV0YUtleTtcbiAgICAgICAgdGhpcy5idXR0b24gICAgPSBldmVudC5idXR0b247XG4gICAgICAgIHRoaXMuYnV0dG9ucyAgID0gZXZlbnQuYnV0dG9ucztcbiAgICAgICAgdGhpcy50YXJnZXQgICAgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnQwICAgICAgICA9IGludGVyYWN0aW9uLmRvd25UaW1lc1swXTtcbiAgICAgICAgdGhpcy50eXBlICAgICAgPSBhY3Rpb24gKyAocGhhc2UgfHwgJycpO1xuXG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb24gPSBpbnRlcmFjdGlvbjtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGFibGUgPSB0YXJnZXQ7XG5cbiAgICAgICAgdmFyIGluZXJ0aWFTdGF0dXMgPSBpbnRlcmFjdGlvbi5pbmVydGlhU3RhdHVzO1xuXG4gICAgICAgIGlmIChpbmVydGlhU3RhdHVzLmFjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5kZXRhaWwgPSAnaW5lcnRpYSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVsYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5yZWxhdGVkVGFyZ2V0ID0gcmVsYXRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuZCBldmVudCBkeCwgZHkgaXMgZGlmZmVyZW5jZSBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQgcG9pbnRzXG4gICAgICAgIGlmIChlbmRpbmcpIHtcbiAgICAgICAgICAgIGlmIChkZWx0YVNvdXJjZSA9PT0gJ2NsaWVudCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmR4ID0gY2xpZW50LnggLSBpbnRlcmFjdGlvbi5zdGFydENvb3Jkcy5jbGllbnQueDtcbiAgICAgICAgICAgICAgICB0aGlzLmR5ID0gY2xpZW50LnkgLSBpbnRlcmFjdGlvbi5zdGFydENvb3Jkcy5jbGllbnQueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZHggPSBwYWdlLnggLSBpbnRlcmFjdGlvbi5zdGFydENvb3Jkcy5wYWdlLng7XG4gICAgICAgICAgICAgICAgdGhpcy5keSA9IHBhZ2UueSAtIGludGVyYWN0aW9uLnN0YXJ0Q29vcmRzLnBhZ2UueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGFydGluZykge1xuICAgICAgICAgICAgdGhpcy5keCA9IDA7XG4gICAgICAgICAgICB0aGlzLmR5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3B5IHByb3BlcnRpZXMgZnJvbSBwcmV2aW91c21vdmUgaWYgc3RhcnRpbmcgaW5lcnRpYVxuICAgICAgICBlbHNlIGlmIChwaGFzZSA9PT0gJ2luZXJ0aWFzdGFydCcpIHtcbiAgICAgICAgICAgIHRoaXMuZHggPSBpbnRlcmFjdGlvbi5wcmV2RXZlbnQuZHg7XG4gICAgICAgICAgICB0aGlzLmR5ID0gaW50ZXJhY3Rpb24ucHJldkV2ZW50LmR5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRlbHRhU291cmNlID09PSAnY2xpZW50Jykge1xuICAgICAgICAgICAgICAgIHRoaXMuZHggPSBjbGllbnQueCAtIGludGVyYWN0aW9uLnByZXZFdmVudC5jbGllbnRYO1xuICAgICAgICAgICAgICAgIHRoaXMuZHkgPSBjbGllbnQueSAtIGludGVyYWN0aW9uLnByZXZFdmVudC5jbGllbnRZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5keCA9IHBhZ2UueCAtIGludGVyYWN0aW9uLnByZXZFdmVudC5wYWdlWDtcbiAgICAgICAgICAgICAgICB0aGlzLmR5ID0gcGFnZS55IC0gaW50ZXJhY3Rpb24ucHJldkV2ZW50LnBhZ2VZO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcmFjdGlvbi5wcmV2RXZlbnQgJiYgaW50ZXJhY3Rpb24ucHJldkV2ZW50LmRldGFpbCA9PT0gJ2luZXJ0aWEnXG4gICAgICAgICAgICAmJiAhaW5lcnRpYVN0YXR1cy5hY3RpdmVcbiAgICAgICAgICAgICYmIG9wdGlvbnNbYWN0aW9uXS5pbmVydGlhICYmIG9wdGlvbnNbYWN0aW9uXS5pbmVydGlhLnplcm9SZXN1bWVEZWx0YSkge1xuXG4gICAgICAgICAgICBpbmVydGlhU3RhdHVzLnJlc3VtZUR4ICs9IHRoaXMuZHg7XG4gICAgICAgICAgICBpbmVydGlhU3RhdHVzLnJlc3VtZUR5ICs9IHRoaXMuZHk7XG5cbiAgICAgICAgICAgIHRoaXMuZHggPSB0aGlzLmR5ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY3Rpb24gPT09ICdyZXNpemUnICYmIGludGVyYWN0aW9uLnJlc2l6ZUF4ZXMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlc2l6ZS5zcXVhcmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJhY3Rpb24ucmVzaXplQXhlcyA9PT0gJ3knKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHggPSB0aGlzLmR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5keSA9IHRoaXMuZHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYXhlcyA9ICd4eSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF4ZXMgPSBpbnRlcmFjdGlvbi5yZXNpemVBeGVzO1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVyYWN0aW9uLnJlc2l6ZUF4ZXMgPT09ICd4Jykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmR5ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaW50ZXJhY3Rpb24ucmVzaXplQXhlcyA9PT0gJ3knKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhY3Rpb24gPT09ICdnZXN0dXJlJykge1xuICAgICAgICAgICAgdGhpcy50b3VjaGVzID0gW3BvaW50ZXJzWzBdLCBwb2ludGVyc1sxXV07XG5cbiAgICAgICAgICAgIGlmIChzdGFydGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSB0b3VjaERpc3RhbmNlKHBvaW50ZXJzLCBkZWx0YVNvdXJjZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ib3ggICAgICA9IHRvdWNoQkJveChwb2ludGVycyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZSAgICA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5kcyAgICAgICA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmdsZSAgICA9IHRvdWNoQW5nbGUocG9pbnRlcnMsIHVuZGVmaW5lZCwgZGVsdGFTb3VyY2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGEgICAgICAgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW5kaW5nIHx8IGV2ZW50IGluc3RhbmNlb2YgSW50ZXJhY3RFdmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSBpbnRlcmFjdGlvbi5wcmV2RXZlbnQuZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5ib3ggICAgICA9IGludGVyYWN0aW9uLnByZXZFdmVudC5ib3g7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZSAgICA9IGludGVyYWN0aW9uLnByZXZFdmVudC5zY2FsZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRzICAgICAgID0gdGhpcy5zY2FsZSAtIDE7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmdsZSAgICA9IGludGVyYWN0aW9uLnByZXZFdmVudC5hbmdsZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhICAgICAgID0gdGhpcy5hbmdsZSAtIGludGVyYWN0aW9uLmdlc3R1cmUuc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSB0b3VjaERpc3RhbmNlKHBvaW50ZXJzLCBkZWx0YVNvdXJjZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ib3ggICAgICA9IHRvdWNoQkJveChwb2ludGVycyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZSAgICA9IHRoaXMuZGlzdGFuY2UgLyBpbnRlcmFjdGlvbi5nZXN0dXJlLnN0YXJ0RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmdsZSAgICA9IHRvdWNoQW5nbGUocG9pbnRlcnMsIGludGVyYWN0aW9uLmdlc3R1cmUucHJldkFuZ2xlLCBkZWx0YVNvdXJjZSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRzID0gdGhpcy5zY2FsZSAtIGludGVyYWN0aW9uLmdlc3R1cmUucHJldlNjYWxlO1xuICAgICAgICAgICAgICAgIHRoaXMuZGEgPSB0aGlzLmFuZ2xlIC0gaW50ZXJhY3Rpb24uZ2VzdHVyZS5wcmV2QW5nbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMudGltZVN0YW1wID0gaW50ZXJhY3Rpb24uZG93blRpbWVzWzBdO1xuICAgICAgICAgICAgdGhpcy5kdCAgICAgICAgPSAwO1xuICAgICAgICAgICAgdGhpcy5kdXJhdGlvbiAgPSAwO1xuICAgICAgICAgICAgdGhpcy5zcGVlZCAgICAgPSAwO1xuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eVggPSAwO1xuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eVkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBoYXNlID09PSAnaW5lcnRpYXN0YXJ0Jykge1xuICAgICAgICAgICAgdGhpcy50aW1lU3RhbXAgPSBpbnRlcmFjdGlvbi5wcmV2RXZlbnQudGltZVN0YW1wO1xuICAgICAgICAgICAgdGhpcy5kdCAgICAgICAgPSBpbnRlcmFjdGlvbi5wcmV2RXZlbnQuZHQ7XG4gICAgICAgICAgICB0aGlzLmR1cmF0aW9uICA9IGludGVyYWN0aW9uLnByZXZFdmVudC5kdXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuc3BlZWQgICAgID0gaW50ZXJhY3Rpb24ucHJldkV2ZW50LnNwZWVkO1xuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eVggPSBpbnRlcmFjdGlvbi5wcmV2RXZlbnQudmVsb2NpdHlYO1xuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eVkgPSBpbnRlcmFjdGlvbi5wcmV2RXZlbnQudmVsb2NpdHlZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50aW1lU3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHRoaXMuZHQgICAgICAgID0gdGhpcy50aW1lU3RhbXAgLSBpbnRlcmFjdGlvbi5wcmV2RXZlbnQudGltZVN0YW1wO1xuICAgICAgICAgICAgdGhpcy5kdXJhdGlvbiAgPSB0aGlzLnRpbWVTdGFtcCAtIGludGVyYWN0aW9uLmRvd25UaW1lc1swXTtcblxuICAgICAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgSW50ZXJhY3RFdmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkeCA9IHRoaXNbc291cmNlWF0gLSBpbnRlcmFjdGlvbi5wcmV2RXZlbnRbc291cmNlWF0sXG4gICAgICAgICAgICAgICAgICAgIGR5ID0gdGhpc1tzb3VyY2VZXSAtIGludGVyYWN0aW9uLnByZXZFdmVudFtzb3VyY2VZXSxcbiAgICAgICAgICAgICAgICAgICAgZHQgPSB0aGlzLmR0IC8gMTAwMDtcblxuICAgICAgICAgICAgICAgIHRoaXMuc3BlZWQgPSBoeXBvdChkeCwgZHkpIC8gZHQ7XG4gICAgICAgICAgICAgICAgdGhpcy52ZWxvY2l0eVggPSBkeCAvIGR0O1xuICAgICAgICAgICAgICAgIHRoaXMudmVsb2NpdHlZID0gZHkgLyBkdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIG5vcm1hbCBtb3ZlIG9yIGVuZCBldmVudCwgdXNlIHByZXZpb3VzIHVzZXIgZXZlbnQgY29vcmRzXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzcGVlZCBhbmQgdmVsb2NpdHkgaW4gcGl4ZWxzIHBlciBzZWNvbmRcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWVkID0gaW50ZXJhY3Rpb24ucG9pbnRlckRlbHRhW2RlbHRhU291cmNlXS5zcGVlZDtcbiAgICAgICAgICAgICAgICB0aGlzLnZlbG9jaXR5WCA9IGludGVyYWN0aW9uLnBvaW50ZXJEZWx0YVtkZWx0YVNvdXJjZV0udng7XG4gICAgICAgICAgICAgICAgdGhpcy52ZWxvY2l0eVkgPSBpbnRlcmFjdGlvbi5wb2ludGVyRGVsdGFbZGVsdGFTb3VyY2VdLnZ5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChlbmRpbmcgfHwgcGhhc2UgPT09ICdpbmVydGlhc3RhcnQnKVxuICAgICAgICAgICAgJiYgaW50ZXJhY3Rpb24ucHJldkV2ZW50LnNwZWVkID4gNjAwICYmIHRoaXMudGltZVN0YW1wIC0gaW50ZXJhY3Rpb24ucHJldkV2ZW50LnRpbWVTdGFtcCA8IDE1MCkge1xuXG4gICAgICAgICAgICB2YXIgYW5nbGUgPSAxODAgKiBNYXRoLmF0YW4yKGludGVyYWN0aW9uLnByZXZFdmVudC52ZWxvY2l0eVksIGludGVyYWN0aW9uLnByZXZFdmVudC52ZWxvY2l0eVgpIC8gTWF0aC5QSSxcbiAgICAgICAgICAgICAgICBvdmVybGFwID0gMjIuNTtcblxuICAgICAgICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgICAgIGFuZ2xlICs9IDM2MDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxlZnQgPSAxMzUgLSBvdmVybGFwIDw9IGFuZ2xlICYmIGFuZ2xlIDwgMjI1ICsgb3ZlcmxhcCxcbiAgICAgICAgICAgICAgICB1cCAgID0gMjI1IC0gb3ZlcmxhcCA8PSBhbmdsZSAmJiBhbmdsZSA8IDMxNSArIG92ZXJsYXAsXG5cbiAgICAgICAgICAgICAgICByaWdodCA9ICFsZWZ0ICYmICgzMTUgLSBvdmVybGFwIDw9IGFuZ2xlIHx8IGFuZ2xlIDwgIDQ1ICsgb3ZlcmxhcCksXG4gICAgICAgICAgICAgICAgZG93biAgPSAhdXAgICAmJiAgIDQ1IC0gb3ZlcmxhcCA8PSBhbmdsZSAmJiBhbmdsZSA8IDEzNSArIG92ZXJsYXA7XG5cbiAgICAgICAgICAgIHRoaXMuc3dpcGUgPSB7XG4gICAgICAgICAgICAgICAgdXAgICA6IHVwLFxuICAgICAgICAgICAgICAgIGRvd24gOiBkb3duLFxuICAgICAgICAgICAgICAgIGxlZnQgOiBsZWZ0LFxuICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgICAgICAgICBhbmdsZTogYW5nbGUsXG4gICAgICAgICAgICAgICAgc3BlZWQ6IGludGVyYWN0aW9uLnByZXZFdmVudC5zcGVlZCxcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eToge1xuICAgICAgICAgICAgICAgICAgICB4OiBpbnRlcmFjdGlvbi5wcmV2RXZlbnQudmVsb2NpdHlYLFxuICAgICAgICAgICAgICAgICAgICB5OiBpbnRlcmFjdGlvbi5wcmV2RXZlbnQudmVsb2NpdHlZXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEludGVyYWN0RXZlbnQucHJvdG90eXBlID0ge1xuICAgICAgICBwcmV2ZW50RGVmYXVsdDogYmxhbmssXG4gICAgICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHByZXZlbnRPcmlnaW5hbERlZmF1bHQgKCkge1xuICAgICAgICB0aGlzLm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRBY3Rpb25DdXJzb3IgKGFjdGlvbikge1xuICAgICAgICB2YXIgY3Vyc29yID0gJyc7XG5cbiAgICAgICAgaWYgKGFjdGlvbi5uYW1lID09PSAnZHJhZycpIHtcbiAgICAgICAgICAgIGN1cnNvciA9ICBhY3Rpb25DdXJzb3JzLmRyYWc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbi5uYW1lID09PSAncmVzaXplJykge1xuICAgICAgICAgICAgaWYgKGFjdGlvbi5heGlzKSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yID0gIGFjdGlvbkN1cnNvcnNbYWN0aW9uLm5hbWUgKyBhY3Rpb24uYXhpc107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY3Rpb24uZWRnZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3Vyc29yS2V5ID0gJ3Jlc2l6ZScsXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VOYW1lcyA9IFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0J107XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uLmVkZ2VzW2VkZ2VOYW1lc1tpXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcktleSArPSBlZGdlTmFtZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdXJzb3IgPSBhY3Rpb25DdXJzb3JzW2N1cnNvcktleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3Vyc29yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrUmVzaXplRWRnZSAobmFtZSwgdmFsdWUsIHBhZ2UsIGVsZW1lbnQsIGludGVyYWN0YWJsZUVsZW1lbnQsIHJlY3QsIG1hcmdpbikge1xuICAgICAgICAvLyBmYWxzZSwgJycsIHVuZGVmaW5lZCwgbnVsbFxuICAgICAgICBpZiAoIXZhbHVlKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICAgIC8vIHRydWUgdmFsdWUsIHVzZSBwb2ludGVyIGNvb3JkcyBhbmQgZWxlbWVudCByZWN0XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gaWYgZGltZW5zaW9ucyBhcmUgbmVnYXRpdmUsIFwic3dpdGNoXCIgZWRnZXNcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGlzTnVtYmVyKHJlY3Qud2lkdGgpPyByZWN0LndpZHRoIDogcmVjdC5yaWdodCAtIHJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBpc051bWJlcihyZWN0LmhlaWdodCk/IHJlY3QuaGVpZ2h0IDogcmVjdC5ib3R0b20gLSByZWN0LnRvcDtcblxuICAgICAgICAgICAgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICAgICAgICAgIGlmICAgICAgKG5hbWUgPT09ICdsZWZ0JyApIHsgbmFtZSA9ICdyaWdodCc7IH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAncmlnaHQnKSB7IG5hbWUgPSAnbGVmdCcgOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgICAgIGlmICAgICAgKG5hbWUgPT09ICd0b3AnICAgKSB7IG5hbWUgPSAnYm90dG9tJzsgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdib3R0b20nKSB7IG5hbWUgPSAndG9wJyAgIDsgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2xlZnQnICApIHsgcmV0dXJuIHBhZ2UueCA8ICgod2lkdGggID49IDA/IHJlY3QubGVmdDogcmVjdC5yaWdodCApICsgbWFyZ2luKTsgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICd0b3AnICAgKSB7IHJldHVybiBwYWdlLnkgPCAoKGhlaWdodCA+PSAwPyByZWN0LnRvcCA6IHJlY3QuYm90dG9tKSArIG1hcmdpbik7IH1cblxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdyaWdodCcgKSB7IHJldHVybiBwYWdlLnggPiAoKHdpZHRoICA+PSAwPyByZWN0LnJpZ2h0IDogcmVjdC5sZWZ0KSAtIG1hcmdpbik7IH1cbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnYm90dG9tJykgeyByZXR1cm4gcGFnZS55ID4gKChoZWlnaHQgPj0gMD8gcmVjdC5ib3R0b206IHJlY3QudG9wICkgLSBtYXJnaW4pOyB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgcmVtYWluaW5nIGNoZWNrcyByZXF1aXJlIGFuIGVsZW1lbnRcbiAgICAgICAgaWYgKCFpc0VsZW1lbnQoZWxlbWVudCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgICAgcmV0dXJuIGlzRWxlbWVudCh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHZhbHVlIGlzIGFuIGVsZW1lbnQgdG8gdXNlIGFzIGEgcmVzaXplIGhhbmRsZVxuICAgICAgICAgICAgICAgICAgICA/IHZhbHVlID09PSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjaGVjayBpZiBlbGVtZW50IG1hdGNoZXMgdmFsdWUgYXMgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgOiBtYXRjaGVzVXBUbyhlbGVtZW50LCB2YWx1ZSwgaW50ZXJhY3RhYmxlRWxlbWVudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdEFjdGlvbkNoZWNrZXIgKHBvaW50ZXIsIGludGVyYWN0aW9uLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRSZWN0KGVsZW1lbnQpLFxuICAgICAgICAgICAgc2hvdWxkUmVzaXplID0gZmFsc2UsXG4gICAgICAgICAgICBhY3Rpb24gPSBudWxsLFxuICAgICAgICAgICAgcmVzaXplQXhlcyA9IG51bGwsXG4gICAgICAgICAgICByZXNpemVFZGdlcyxcbiAgICAgICAgICAgIHBhZ2UgPSBleHRlbmQoe30sIGludGVyYWN0aW9uLmN1ckNvb3Jkcy5wYWdlKSxcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgaWYgKCFyZWN0KSB7IHJldHVybiBudWxsOyB9XG5cbiAgICAgICAgaWYgKGFjdGlvbklzRW5hYmxlZC5yZXNpemUgJiYgb3B0aW9ucy5yZXNpemUuZW5hYmxlZCkge1xuICAgICAgICAgICAgdmFyIHJlc2l6ZU9wdGlvbnMgPSBvcHRpb25zLnJlc2l6ZTtcblxuICAgICAgICAgICAgcmVzaXplRWRnZXMgPSB7XG4gICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsIHJpZ2h0OiBmYWxzZSwgdG9wOiBmYWxzZSwgYm90dG9tOiBmYWxzZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gaWYgdXNpbmcgcmVzaXplLmVkZ2VzXG4gICAgICAgICAgICBpZiAoaXNPYmplY3QocmVzaXplT3B0aW9ucy5lZGdlcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBlZGdlIGluIHJlc2l6ZUVkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZUVkZ2VzW2VkZ2VdID0gY2hlY2tSZXNpemVFZGdlKGVkZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6ZU9wdGlvbnMuZWRnZXNbZWRnZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLl9ldmVudFRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXplT3B0aW9ucy5tYXJnaW4gfHwgbWFyZ2luKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXNpemVFZGdlcy5sZWZ0ID0gcmVzaXplRWRnZXMubGVmdCAmJiAhcmVzaXplRWRnZXMucmlnaHQ7XG4gICAgICAgICAgICAgICAgcmVzaXplRWRnZXMudG9wICA9IHJlc2l6ZUVkZ2VzLnRvcCAgJiYgIXJlc2l6ZUVkZ2VzLmJvdHRvbTtcblxuICAgICAgICAgICAgICAgIHNob3VsZFJlc2l6ZSA9IHJlc2l6ZUVkZ2VzLmxlZnQgfHwgcmVzaXplRWRnZXMucmlnaHQgfHwgcmVzaXplRWRnZXMudG9wIHx8IHJlc2l6ZUVkZ2VzLmJvdHRvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByaWdodCAgPSBvcHRpb25zLnJlc2l6ZS5heGlzICE9PSAneScgJiYgcGFnZS54ID4gKHJlY3QucmlnaHQgIC0gbWFyZ2luKSxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tID0gb3B0aW9ucy5yZXNpemUuYXhpcyAhPT0gJ3gnICYmIHBhZ2UueSA+IChyZWN0LmJvdHRvbSAtIG1hcmdpbik7XG5cbiAgICAgICAgICAgICAgICBzaG91bGRSZXNpemUgPSByaWdodCB8fCBib3R0b207XG4gICAgICAgICAgICAgICAgcmVzaXplQXhlcyA9IChyaWdodD8gJ3gnIDogJycpICsgKGJvdHRvbT8gJ3knIDogJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWN0aW9uID0gc2hvdWxkUmVzaXplXG4gICAgICAgICAgICA/ICdyZXNpemUnXG4gICAgICAgICAgICA6IGFjdGlvbklzRW5hYmxlZC5kcmFnICYmIG9wdGlvbnMuZHJhZy5lbmFibGVkXG4gICAgICAgICAgICAgICAgPyAnZHJhZydcbiAgICAgICAgICAgICAgICA6IG51bGw7XG5cbiAgICAgICAgaWYgKGFjdGlvbklzRW5hYmxlZC5nZXN0dXJlXG4gICAgICAgICAgICAmJiBpbnRlcmFjdGlvbi5wb2ludGVySWRzLmxlbmd0aCA+PTJcbiAgICAgICAgICAgICYmICEoaW50ZXJhY3Rpb24uZHJhZ2dpbmcgfHwgaW50ZXJhY3Rpb24ucmVzaXppbmcpKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSAnZ2VzdHVyZSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGFjdGlvbixcbiAgICAgICAgICAgICAgICBheGlzOiByZXNpemVBeGVzLFxuICAgICAgICAgICAgICAgIGVkZ2VzOiByZXNpemVFZGdlc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGFjdGlvbiBpcyBlbmFibGVkIGdsb2JhbGx5IGFuZCB0aGUgY3VycmVudCB0YXJnZXQgc3VwcG9ydHMgaXRcbiAgICAvLyBJZiBzbywgcmV0dXJuIHRoZSB2YWxpZGF0ZWQgYWN0aW9uLiBPdGhlcndpc2UsIHJldHVybiBudWxsXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVBY3Rpb24gKGFjdGlvbiwgaW50ZXJhY3RhYmxlKSB7XG4gICAgICAgIGlmICghaXNPYmplY3QoYWN0aW9uKSkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgICAgIHZhciBhY3Rpb25OYW1lID0gYWN0aW9uLm5hbWUsXG4gICAgICAgICAgICBvcHRpb25zID0gaW50ZXJhY3RhYmxlLm9wdGlvbnM7XG5cbiAgICAgICAgaWYgKCggIChhY3Rpb25OYW1lICA9PT0gJ3Jlc2l6ZScgICAmJiBvcHRpb25zLnJlc2l6ZS5lbmFibGVkIClcbiAgICAgICAgICAgIHx8IChhY3Rpb25OYW1lICAgICAgPT09ICdkcmFnJyAgICAgJiYgb3B0aW9ucy5kcmFnLmVuYWJsZWQgIClcbiAgICAgICAgICAgIHx8IChhY3Rpb25OYW1lICAgICAgPT09ICdnZXN0dXJlJyAgJiYgb3B0aW9ucy5nZXN0dXJlLmVuYWJsZWQpKVxuICAgICAgICAgICAgJiYgYWN0aW9uSXNFbmFibGVkW2FjdGlvbk5hbWVdKSB7XG5cbiAgICAgICAgICAgIGlmIChhY3Rpb25OYW1lID09PSAncmVzaXplJyB8fCBhY3Rpb25OYW1lID09PSAncmVzaXpleXgnKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uTmFtZSA9ICdyZXNpemV4eSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVycyA9IHt9LFxuICAgICAgICBpbnRlcmFjdGlvbkxpc3RlbmVycyA9IFtcbiAgICAgICAgICAgICdkcmFnU3RhcnQnLCAnZHJhZ01vdmUnLCAncmVzaXplU3RhcnQnLCAncmVzaXplTW92ZScsICdnZXN0dXJlU3RhcnQnLCAnZ2VzdHVyZU1vdmUnLFxuICAgICAgICAgICAgJ3BvaW50ZXJPdmVyJywgJ3BvaW50ZXJPdXQnLCAncG9pbnRlckhvdmVyJywgJ3NlbGVjdG9yRG93bicsXG4gICAgICAgICAgICAncG9pbnRlckRvd24nLCAncG9pbnRlck1vdmUnLCAncG9pbnRlclVwJywgJ3BvaW50ZXJDYW5jZWwnLCAncG9pbnRlckVuZCcsXG4gICAgICAgICAgICAnYWRkUG9pbnRlcicsICdyZW1vdmVQb2ludGVyJywgJ3JlY29yZFBvaW50ZXInLCAnYXV0b1Njcm9sbE1vdmUnXG4gICAgICAgIF07XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaW50ZXJhY3Rpb25MaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBpbnRlcmFjdGlvbkxpc3RlbmVyc1tpXTtcblxuICAgICAgICBsaXN0ZW5lcnNbbmFtZV0gPSBkb09uSW50ZXJhY3Rpb25zKG5hbWUpO1xuICAgIH1cblxuICAgIC8vIGJvdW5kIHRvIHRoZSBpbnRlcmFjdGFibGUgY29udGV4dCB3aGVuIGEgRE9NIGV2ZW50XG4gICAgLy8gbGlzdGVuZXIgaXMgYWRkZWQgdG8gYSBzZWxlY3RvciBpbnRlcmFjdGFibGVcbiAgICBmdW5jdGlvbiBkZWxlZ2F0ZUxpc3RlbmVyIChldmVudCwgdXNlQ2FwdHVyZSkge1xuICAgICAgICB2YXIgZmFrZUV2ZW50ID0ge30sXG4gICAgICAgICAgICBkZWxlZ2F0ZWQgPSBkZWxlZ2F0ZWRFdmVudHNbZXZlbnQudHlwZV0sXG4gICAgICAgICAgICBldmVudFRhcmdldCA9IGdldEFjdHVhbEVsZW1lbnQoZXZlbnQucGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZXZlbnQucGF0aFswXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZXZlbnQudGFyZ2V0KSxcbiAgICAgICAgICAgIGVsZW1lbnQgPSBldmVudFRhcmdldDtcblxuICAgICAgICB1c2VDYXB0dXJlID0gdXNlQ2FwdHVyZT8gdHJ1ZTogZmFsc2U7XG5cbiAgICAgICAgLy8gZHVwbGljYXRlIHRoZSBldmVudCBzbyB0aGF0IGN1cnJlbnRUYXJnZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBldmVudCkge1xuICAgICAgICAgICAgZmFrZUV2ZW50W3Byb3BdID0gZXZlbnRbcHJvcF07XG4gICAgICAgIH1cblxuICAgICAgICBmYWtlRXZlbnQub3JpZ2luYWxFdmVudCA9IGV2ZW50O1xuICAgICAgICBmYWtlRXZlbnQucHJldmVudERlZmF1bHQgPSBwcmV2ZW50T3JpZ2luYWxEZWZhdWx0O1xuXG4gICAgICAgIC8vIGNsaW1iIHVwIGRvY3VtZW50IHRyZWUgbG9va2luZyBmb3Igc2VsZWN0b3IgbWF0Y2hlc1xuICAgICAgICB3aGlsZSAoaXNFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbGVnYXRlZC5zZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBkZWxlZ2F0ZWQuc2VsZWN0b3JzW2ldLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gZGVsZWdhdGVkLmNvbnRleHRzW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNTZWxlY3RvcihlbGVtZW50LCBzZWxlY3RvcilcbiAgICAgICAgICAgICAgICAgICAgJiYgbm9kZUNvbnRhaW5zKGNvbnRleHQsIGV2ZW50VGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICAmJiBub2RlQ29udGFpbnMoY29udGV4dCwgZWxlbWVudCkpIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gZGVsZWdhdGVkLmxpc3RlbmVyc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBmYWtlRXZlbnQuY3VycmVudFRhcmdldCA9IGVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaXN0ZW5lcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbal1bMV0gPT09IHVzZUNhcHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbal1bMF0oZmFrZUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxlbWVudCA9IHBhcmVudEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWxlZ2F0ZVVzZUNhcHR1cmUgKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBkZWxlZ2F0ZUxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQsIHRydWUpO1xuICAgIH1cblxuICAgIGludGVyYWN0YWJsZXMuaW5kZXhPZkVsZW1lbnQgPSBmdW5jdGlvbiBpbmRleE9mRWxlbWVudCAoZWxlbWVudCwgY29udGV4dCkge1xuICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpbnRlcmFjdGFibGUgPSB0aGlzW2ldO1xuXG4gICAgICAgICAgICBpZiAoKGludGVyYWN0YWJsZS5zZWxlY3RvciA9PT0gZWxlbWVudFxuICAgICAgICAgICAgICAgICYmIChpbnRlcmFjdGFibGUuX2NvbnRleHQgPT09IGNvbnRleHQpKVxuICAgICAgICAgICAgICAgIHx8ICghaW50ZXJhY3RhYmxlLnNlbGVjdG9yICYmIGludGVyYWN0YWJsZS5fZWxlbWVudCA9PT0gZWxlbWVudCkpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgaW50ZXJhY3RhYmxlcy5nZXQgPSBmdW5jdGlvbiBpbnRlcmFjdGFibGVHZXQgKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbdGhpcy5pbmRleE9mRWxlbWVudChlbGVtZW50LCBvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCldO1xuICAgIH07XG5cbiAgICBpbnRlcmFjdGFibGVzLmZvckVhY2hTZWxlY3RvciA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpbnRlcmFjdGFibGUgPSB0aGlzW2ldO1xuXG4gICAgICAgICAgICBpZiAoIWludGVyYWN0YWJsZS5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmV0ID0gY2FsbGJhY2soaW50ZXJhY3RhYmxlLCBpbnRlcmFjdGFibGUuc2VsZWN0b3IsIGludGVyYWN0YWJsZS5fY29udGV4dCwgaSwgdGhpcyk7XG5cbiAgICAgICAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcXFxuICAgICAqIGludGVyYWN0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKlxuICAgICAqIFRoZSBtZXRob2RzIG9mIHRoaXMgdmFyaWFibGUgY2FuIGJlIHVzZWQgdG8gc2V0IGVsZW1lbnRzIGFzXG4gICAgICogaW50ZXJhY3RhYmxlcyBhbmQgYWxzbyB0byBjaGFuZ2UgdmFyaW91cyBkZWZhdWx0IHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQ2FsbGluZyBpdCBhcyBhIGZ1bmN0aW9uIGFuZCBwYXNzaW5nIGFuIGVsZW1lbnQgb3IgYSB2YWxpZCBDU1Mgc2VsZWN0b3JcbiAgICAgKiBzdHJpbmcgcmV0dXJucyBhbiBJbnRlcmFjdGFibGUgb2JqZWN0IHdoaWNoIGhhcyB2YXJpb3VzIG1ldGhvZHMgdG9cbiAgICAgKiBjb25maWd1cmUgaXQuXG4gICAgICpcbiAgICAgLSBlbGVtZW50IChFbGVtZW50IHwgc3RyaW5nKSBUaGUgSFRNTCBvciBTVkcgRWxlbWVudCB0byBpbnRlcmFjdCB3aXRoIG9yIENTUyBzZWxlY3RvclxuICAgICA9IChvYmplY3QpIEFuIEBJbnRlcmFjdGFibGVcbiAgICAgKlxuICAgICA+IFVzYWdlXG4gICAgIHwgaW50ZXJhY3QoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RyYWdnYWJsZScpKS5kcmFnZ2FibGUodHJ1ZSk7XG4gICAgIHxcbiAgICAgfCB2YXIgcmVjdGFibGVzID0gaW50ZXJhY3QoJ3JlY3QnKTtcbiAgICAgfCByZWN0YWJsZXNcbiAgICAgfCAgICAgLmdlc3R1cmFibGUodHJ1ZSlcbiAgICAgfCAgICAgLm9uKCdnZXN0dXJlbW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICB8ICAgICAgICAgLy8gc29tZXRoaW5nIGNvb2wuLi5cbiAgICAgfCAgICAgfSlcbiAgICAgfCAgICAgLmF1dG9TY3JvbGwodHJ1ZSk7XG4gICAgXFwqL1xuICAgIGZ1bmN0aW9uIGludGVyYWN0IChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBpbnRlcmFjdGFibGVzLmdldChlbGVtZW50LCBvcHRpb25zKSB8fCBuZXcgSW50ZXJhY3RhYmxlKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qXFxcbiAgICAgKiBJbnRlcmFjdGFibGVcbiAgICAgWyBwcm9wZXJ0eSBdXG4gICAgICoqXG4gICAgICogT2JqZWN0IHR5cGUgcmV0dXJuZWQgYnkgQGludGVyYWN0XG4gICAgXFwqL1xuICAgIGZ1bmN0aW9uIEludGVyYWN0YWJsZSAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5faUV2ZW50cyA9IHRoaXMuX2lFdmVudHMgfHwge307XG5cbiAgICAgICAgdmFyIF93aW5kb3c7XG5cbiAgICAgICAgaWYgKHRyeVNlbGVjdG9yKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gZWxlbWVudDtcblxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dDtcblxuICAgICAgICAgICAgX3dpbmRvdyA9IGNvbnRleHQ/IGdldFdpbmRvdyhjb250ZXh0KSA6IHdpbmRvdztcblxuICAgICAgICAgICAgaWYgKGNvbnRleHQgJiYgKF93aW5kb3cuTm9kZVxuICAgICAgICAgICAgICAgICAgICA/IGNvbnRleHQgaW5zdGFuY2VvZiBfd2luZG93Lk5vZGVcbiAgICAgICAgICAgICAgICAgICAgOiAoaXNFbGVtZW50KGNvbnRleHQpIHx8IGNvbnRleHQgPT09IF93aW5kb3cuZG9jdW1lbnQpKSkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfd2luZG93ID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuXG4gICAgICAgICAgICBpZiAoaXNFbGVtZW50KGVsZW1lbnQsIF93aW5kb3cpKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoUG9pbnRlckV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cy5hZGQodGhpcy5fZWxlbWVudCwgcEV2ZW50VHlwZXMuZG93biwgbGlzdGVuZXJzLnBvaW50ZXJEb3duICk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cy5hZGQodGhpcy5fZWxlbWVudCwgcEV2ZW50VHlwZXMubW92ZSwgbGlzdGVuZXJzLnBvaW50ZXJIb3Zlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBldmVudHMuYWRkKHRoaXMuX2VsZW1lbnQsICdtb3VzZWRvd24nICwgbGlzdGVuZXJzLnBvaW50ZXJEb3duICk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cy5hZGQodGhpcy5fZWxlbWVudCwgJ21vdXNlbW92ZScgLCBsaXN0ZW5lcnMucG9pbnRlckhvdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzLmFkZCh0aGlzLl9lbGVtZW50LCAndG91Y2hzdGFydCcsIGxpc3RlbmVycy5wb2ludGVyRG93biApO1xuICAgICAgICAgICAgICAgICAgICBldmVudHMuYWRkKHRoaXMuX2VsZW1lbnQsICd0b3VjaG1vdmUnICwgbGlzdGVuZXJzLnBvaW50ZXJIb3Zlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZG9jID0gX3dpbmRvdy5kb2N1bWVudDtcblxuICAgICAgICBpZiAoIWNvbnRhaW5zKGRvY3VtZW50cywgdGhpcy5fZG9jKSkge1xuICAgICAgICAgICAgbGlzdGVuVG9Eb2N1bWVudCh0aGlzLl9kb2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW50ZXJhY3RhYmxlcy5wdXNoKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuc2V0KG9wdGlvbnMpO1xuICAgIH1cblxuICAgIEludGVyYWN0YWJsZS5wcm90b3R5cGUgPSB7XG4gICAgICAgIHNldE9uRXZlbnRzOiBmdW5jdGlvbiAoYWN0aW9uLCBwaGFzZXMpIHtcbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT09ICdkcm9wJykge1xuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHBoYXNlcy5vbmRyb3ApICAgICAgICAgICkgeyB0aGlzLm9uZHJvcCAgICAgICAgICAgPSBwaGFzZXMub25kcm9wICAgICAgICAgIDsgfVxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHBoYXNlcy5vbmRyb3BhY3RpdmF0ZSkgICkgeyB0aGlzLm9uZHJvcGFjdGl2YXRlICAgPSBwaGFzZXMub25kcm9wYWN0aXZhdGUgIDsgfVxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHBoYXNlcy5vbmRyb3BkZWFjdGl2YXRlKSkgeyB0aGlzLm9uZHJvcGRlYWN0aXZhdGUgPSBwaGFzZXMub25kcm9wZGVhY3RpdmF0ZTsgfVxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHBoYXNlcy5vbmRyYWdlbnRlcikgICAgICkgeyB0aGlzLm9uZHJhZ2VudGVyICAgICAgPSBwaGFzZXMub25kcmFnZW50ZXIgICAgIDsgfVxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHBoYXNlcy5vbmRyYWdsZWF2ZSkgICAgICkgeyB0aGlzLm9uZHJhZ2xlYXZlICAgICAgPSBwaGFzZXMub25kcmFnbGVhdmUgICAgIDsgfVxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHBoYXNlcy5vbmRyb3Btb3ZlKSAgICAgICkgeyB0aGlzLm9uZHJvcG1vdmUgICAgICAgPSBwaGFzZXMub25kcm9wbW92ZSAgICAgIDsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uID0gJ29uJyArIGFjdGlvbjtcblxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHBoYXNlcy5vbnN0YXJ0KSAgICAgICApIHsgdGhpc1thY3Rpb24gKyAnc3RhcnQnICAgICAgICAgXSA9IHBoYXNlcy5vbnN0YXJ0ICAgICAgICAgOyB9XG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocGhhc2VzLm9ubW92ZSkgICAgICAgICkgeyB0aGlzW2FjdGlvbiArICdtb3ZlJyAgICAgICAgICBdID0gcGhhc2VzLm9ubW92ZSAgICAgICAgICA7IH1cbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwaGFzZXMub25lbmQpICAgICAgICAgKSB7IHRoaXNbYWN0aW9uICsgJ2VuZCcgICAgICAgICAgIF0gPSBwaGFzZXMub25lbmQgICAgICAgICAgIDsgfVxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHBoYXNlcy5vbmluZXJ0aWFzdGFydCkpIHsgdGhpc1thY3Rpb24gKyAnaW5lcnRpYXN0YXJ0JyAgXSA9IHBoYXNlcy5vbmluZXJ0aWFzdGFydCAgOyB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qXFxcbiAgICAgICAgICogSW50ZXJhY3RhYmxlLmRyYWdnYWJsZVxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKlxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgd2hldGhlciBkcmFnIGFjdGlvbnMgY2FuIGJlIHBlcmZvcm1lZCBvbiB0aGVcbiAgICAgICAgICogSW50ZXJhY3RhYmxlXG4gICAgICAgICAqXG4gICAgICAgICA9IChib29sZWFuKSBJbmRpY2F0ZXMgaWYgdGhpcyBjYW4gYmUgdGhlIHRhcmdldCBvZiBkcmFnIGV2ZW50c1xuICAgICAgICAgfCB2YXIgaXNEcmFnZ2FibGUgPSBpbnRlcmFjdCgndWwgbGknKS5kcmFnZ2FibGUoKTtcbiAgICAgICAgICogb3JcbiAgICAgICAgIC0gb3B0aW9ucyAoYm9vbGVhbiB8IG9iamVjdCkgI29wdGlvbmFsIHRydWUvZmFsc2Ugb3IgQW4gb2JqZWN0IHdpdGggZXZlbnQgbGlzdGVuZXJzIHRvIGJlIGZpcmVkIG9uIGRyYWcgZXZlbnRzIChvYmplY3QgbWFrZXMgdGhlIEludGVyYWN0YWJsZSBkcmFnZ2FibGUpXG4gICAgICAgICA9IChvYmplY3QpIFRoaXMgSW50ZXJhY3RhYmxlXG4gICAgICAgICB8IGludGVyYWN0KGVsZW1lbnQpLmRyYWdnYWJsZSh7XG4gICAgICAgICB8ICAgICBvbnN0YXJ0OiBmdW5jdGlvbiAoZXZlbnQpIHt9LFxuICAgICAgICAgfCAgICAgb25tb3ZlIDogZnVuY3Rpb24gKGV2ZW50KSB7fSxcbiAgICAgICAgIHwgICAgIG9uZW5kICA6IGZ1bmN0aW9uIChldmVudCkge30sXG4gICAgICAgICB8XG4gICAgICAgICB8ICAgICAvLyB0aGUgYXhpcyBpbiB3aGljaCB0aGUgZmlyc3QgbW92ZW1lbnQgbXVzdCBiZVxuICAgICAgICAgfCAgICAgLy8gZm9yIHRoZSBkcmFnIHNlcXVlbmNlIHRvIHN0YXJ0XG4gICAgICAgICB8ICAgICAvLyAneHknIGJ5IGRlZmF1bHQgLSBhbnkgZGlyZWN0aW9uXG4gICAgICAgICB8ICAgICBheGlzOiAneCcgfHwgJ3knIHx8ICd4eScsXG4gICAgICAgICB8XG4gICAgICAgICB8ICAgICAvLyBtYXggbnVtYmVyIG9mIGRyYWdzIHRoYXQgY2FuIGhhcHBlbiBjb25jdXJyZW50bHlcbiAgICAgICAgIHwgICAgIC8vIHdpdGggZWxlbWVudHMgb2YgdGhpcyBJbnRlcmFjdGFibGUuIEluZmluaXR5IGJ5IGRlZmF1bHRcbiAgICAgICAgIHwgICAgIG1heDogSW5maW5pdHksXG4gICAgICAgICB8XG4gICAgICAgICB8ICAgICAvLyBtYXggbnVtYmVyIG9mIGRyYWdzIHRoYXQgY2FuIHRhcmdldCB0aGUgc2FtZSBlbGVtZW50K0ludGVyYWN0YWJsZVxuICAgICAgICAgfCAgICAgLy8gMSBieSBkZWZhdWx0XG4gICAgICAgICB8ICAgICBtYXhQZXJFbGVtZW50OiAyXG4gICAgICAgICB8IH0pO1xuICAgICAgICBcXCovXG4gICAgICAgIGRyYWdnYWJsZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kcmFnLmVuYWJsZWQgPSBvcHRpb25zLmVuYWJsZWQgPT09IGZhbHNlPyBmYWxzZTogdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBlckFjdGlvbignZHJhZycsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0T25FdmVudHMoJ2RyYWcnLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIGlmICgvXngkfF55JHxeeHkkLy50ZXN0KG9wdGlvbnMuYXhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRyYWcuYXhpcyA9IG9wdGlvbnMuYXhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5heGlzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMuZHJhZy5heGlzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNCb29sKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRyYWcuZW5hYmxlZCA9IG9wdGlvbnM7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5kcmFnO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldFBlckFjdGlvbjogZnVuY3Rpb24gKGFjdGlvbiwgb3B0aW9ucykge1xuICAgICAgICAgICAgLy8gZm9yIGFsbCB0aGUgZGVmYXVsdCBwZXItYWN0aW9uIG9wdGlvbnNcbiAgICAgICAgICAgIGZvciAodmFyIG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBvcHRpb24gZXhpc3RzIGZvciB0aGlzIGFjdGlvblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb24gaW4gZGVmYXVsdE9wdGlvbnNbYWN0aW9uXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgb3B0aW9uIGluIHRoZSBvcHRpb25zIGFyZyBpcyBhbiBvYmplY3QgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnNbb3B0aW9uXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGR1cGxpY2F0ZSB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbYWN0aW9uXVtvcHRpb25dID0gZXh0ZW5kKHRoaXMub3B0aW9uc1thY3Rpb25dW29wdGlvbl0gfHwge30sIG9wdGlvbnNbb3B0aW9uXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChkZWZhdWx0T3B0aW9ucy5wZXJBY3Rpb25bb3B0aW9uXSkgJiYgJ2VuYWJsZWQnIGluIGRlZmF1bHRPcHRpb25zLnBlckFjdGlvbltvcHRpb25dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW2FjdGlvbl1bb3B0aW9uXS5lbmFibGVkID0gb3B0aW9uc1tvcHRpb25dLmVuYWJsZWQgPT09IGZhbHNlPyBmYWxzZSA6IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNCb29sKG9wdGlvbnNbb3B0aW9uXSkgJiYgaXNPYmplY3QoZGVmYXVsdE9wdGlvbnMucGVyQWN0aW9uW29wdGlvbl0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbYWN0aW9uXVtvcHRpb25dLmVuYWJsZWQgPSBvcHRpb25zW29wdGlvbl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9uc1tvcHRpb25dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIGlmIGl0J3Mgbm90IHVuZGVmaW5lZCwgZG8gYSBwbGFpbiBhc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbYWN0aW9uXVtvcHRpb25dID0gb3B0aW9uc1tvcHRpb25dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qXFxcbiAgICAgICAgICogSW50ZXJhY3RhYmxlLmRyb3B6b25lXG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybnMgb3Igc2V0cyB3aGV0aGVyIGVsZW1lbnRzIGNhbiBiZSBkcm9wcGVkIG9udG8gdGhpc1xuICAgICAgICAgKiBJbnRlcmFjdGFibGUgdG8gdHJpZ2dlciBkcm9wIGV2ZW50c1xuICAgICAgICAgKlxuICAgICAgICAgKiBEcm9wem9uZXMgY2FuIHJlY2VpdmUgdGhlIGZvbGxvd2luZyBldmVudHM6XG4gICAgICAgICAqICAtIGBkcm9wYWN0aXZhdGVgIGFuZCBgZHJvcGRlYWN0aXZhdGVgIHdoZW4gYW4gYWNjZXB0YWJsZSBkcmFnIHN0YXJ0cyBhbmQgZW5kc1xuICAgICAgICAgKiAgLSBgZHJhZ2VudGVyYCBhbmQgYGRyYWdsZWF2ZWAgd2hlbiBhIGRyYWdnYWJsZSBlbnRlcnMgYW5kIGxlYXZlcyB0aGUgZHJvcHpvbmVcbiAgICAgICAgICogIC0gYGRyYWdtb3ZlYCB3aGVuIGEgZHJhZ2dhYmxlIHRoYXQgaGFzIGVudGVyZWQgdGhlIGRyb3B6b25lIGlzIG1vdmVkXG4gICAgICAgICAqICAtIGBkcm9wYCB3aGVuIGEgZHJhZ2dhYmxlIGlzIGRyb3BwZWQgaW50byB0aGlzIGRyb3B6b25lXG4gICAgICAgICAqXG4gICAgICAgICAqICBVc2UgdGhlIGBhY2NlcHRgIG9wdGlvbiB0byBhbGxvdyBvbmx5IGVsZW1lbnRzIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIENTUyBzZWxlY3RvciBvciBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiAgVXNlIHRoZSBgb3ZlcmxhcGAgb3B0aW9uIHRvIHNldCBob3cgZHJvcHMgYXJlIGNoZWNrZWQgZm9yLiBUaGUgYWxsb3dlZCB2YWx1ZXMgYXJlOlxuICAgICAgICAgKiAgIC0gYCdwb2ludGVyJ2AsIHRoZSBwb2ludGVyIG11c3QgYmUgb3ZlciB0aGUgZHJvcHpvbmUgKGRlZmF1bHQpXG4gICAgICAgICAqICAgLSBgJ2NlbnRlcidgLCB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQncyBjZW50ZXIgbXVzdCBiZSBvdmVyIHRoZSBkcm9wem9uZVxuICAgICAgICAgKiAgIC0gYSBudW1iZXIgZnJvbSAwLTEgd2hpY2ggaXMgdGhlIGAoaW50ZXJzZWN0aW9uIGFyZWEpIC8gKGRyYWdnYWJsZSBhcmVhKWAuXG4gICAgICAgICAqICAgICAgIGUuZy4gYDAuNWAgZm9yIGRyb3AgdG8gaGFwcGVuIHdoZW4gaGFsZiBvZiB0aGUgYXJlYSBvZiB0aGVcbiAgICAgICAgICogICAgICAgZHJhZ2dhYmxlIGlzIG92ZXIgdGhlIGRyb3B6b25lXG4gICAgICAgICAqXG4gICAgICAgICAtIG9wdGlvbnMgKGJvb2xlYW4gfCBvYmplY3QgfCBudWxsKSAjb3B0aW9uYWwgVGhlIG5ldyB2YWx1ZSB0byBiZSBzZXQuXG4gICAgICAgICB8IGludGVyYWN0KCcuZHJvcCcpLmRyb3B6b25lKHtcbiAgICAgICAgIHwgICBhY2NlcHQ6ICcuY2FuLWRyb3AnIHx8IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaW5nbGUtZHJvcCcpLFxuICAgICAgICAgfCAgIG92ZXJsYXA6ICdwb2ludGVyJyB8fCAnY2VudGVyJyB8fCB6ZXJvVG9PbmVcbiAgICAgICAgIHwgfVxuICAgICAgICAgPSAoYm9vbGVhbiB8IG9iamVjdCkgVGhlIGN1cnJlbnQgc2V0dGluZyBvciB0aGlzIEludGVyYWN0YWJsZVxuICAgICAgICBcXCovXG4gICAgICAgIGRyb3B6b25lOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRyb3AuZW5hYmxlZCA9IG9wdGlvbnMuZW5hYmxlZCA9PT0gZmFsc2U/IGZhbHNlOiB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0T25FdmVudHMoJ2Ryb3AnLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIGlmICgvXihwb2ludGVyfGNlbnRlcikkLy50ZXN0KG9wdGlvbnMub3ZlcmxhcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRyb3Aub3ZlcmxhcCA9IG9wdGlvbnMub3ZlcmxhcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNOdW1iZXIob3B0aW9ucy5vdmVybGFwKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZHJvcC5vdmVybGFwID0gTWF0aC5tYXgoTWF0aC5taW4oMSwgb3B0aW9ucy5vdmVybGFwKSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgnYWNjZXB0JyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZHJvcC5hY2NlcHQgPSBvcHRpb25zLmFjY2VwdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCdjaGVja2VyJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZHJvcC5jaGVja2VyID0gb3B0aW9ucy5jaGVja2VyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNCb29sKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRyb3AuZW5hYmxlZCA9IG9wdGlvbnM7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5kcm9wO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRyb3BDaGVjazogZnVuY3Rpb24gKGRyYWdFdmVudCwgZXZlbnQsIGRyYWdnYWJsZSwgZHJhZ2dhYmxlRWxlbWVudCwgZHJvcEVsZW1lbnQsIHJlY3QpIHtcbiAgICAgICAgICAgIHZhciBkcm9wcGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBkcm9wem9uZSBoYXMgbm8gcmVjdCAoZWcuIGRpc3BsYXk6IG5vbmUpXG4gICAgICAgICAgICAvLyBjYWxsIHRoZSBjdXN0b20gZHJvcENoZWNrZXIgb3IganVzdCByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIGlmICghKHJlY3QgPSByZWN0IHx8IHRoaXMuZ2V0UmVjdChkcm9wRWxlbWVudCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLm9wdGlvbnMuZHJvcC5jaGVja2VyXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5vcHRpb25zLmRyb3AuY2hlY2tlcihkcmFnRXZlbnQsIGV2ZW50LCBkcm9wcGVkLCB0aGlzLCBkcm9wRWxlbWVudCwgZHJhZ2dhYmxlLCBkcmFnZ2FibGVFbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICA6IGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRyb3BPdmVybGFwID0gdGhpcy5vcHRpb25zLmRyb3Aub3ZlcmxhcDtcblxuICAgICAgICAgICAgaWYgKGRyb3BPdmVybGFwID09PSAncG9pbnRlcicpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFnZSA9IGdldFBhZ2VYWShkcmFnRXZlbnQpLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW4gPSBnZXRPcmlnaW5YWShkcmFnZ2FibGUsIGRyYWdnYWJsZUVsZW1lbnQpLFxuICAgICAgICAgICAgICAgICAgICBob3Jpem9udGFsLFxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbDtcblxuICAgICAgICAgICAgICAgIHBhZ2UueCArPSBvcmlnaW4ueDtcbiAgICAgICAgICAgICAgICBwYWdlLnkgKz0gb3JpZ2luLnk7XG5cbiAgICAgICAgICAgICAgICBob3Jpem9udGFsID0gKHBhZ2UueCA+IHJlY3QubGVmdCkgJiYgKHBhZ2UueCA8IHJlY3QucmlnaHQpO1xuICAgICAgICAgICAgICAgIHZlcnRpY2FsICAgPSAocGFnZS55ID4gcmVjdC50b3AgKSAmJiAocGFnZS55IDwgcmVjdC5ib3R0b20pO1xuXG4gICAgICAgICAgICAgICAgZHJvcHBlZCA9IGhvcml6b250YWwgJiYgdmVydGljYWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkcmFnUmVjdCA9IGRyYWdnYWJsZS5nZXRSZWN0KGRyYWdnYWJsZUVsZW1lbnQpO1xuXG4gICAgICAgICAgICBpZiAoZHJvcE92ZXJsYXAgPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN4ID0gZHJhZ1JlY3QubGVmdCArIGRyYWdSZWN0LndpZHRoICAvIDIsXG4gICAgICAgICAgICAgICAgICAgIGN5ID0gZHJhZ1JlY3QudG9wICArIGRyYWdSZWN0LmhlaWdodCAvIDI7XG5cbiAgICAgICAgICAgICAgICBkcm9wcGVkID0gY3ggPj0gcmVjdC5sZWZ0ICYmIGN4IDw9IHJlY3QucmlnaHQgJiYgY3kgPj0gcmVjdC50b3AgJiYgY3kgPD0gcmVjdC5ib3R0b207XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc051bWJlcihkcm9wT3ZlcmxhcCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3ZlcmxhcEFyZWEgID0gKE1hdGgubWF4KDAsIE1hdGgubWluKHJlY3QucmlnaHQgLCBkcmFnUmVjdC5yaWdodCApIC0gTWF0aC5tYXgocmVjdC5sZWZ0LCBkcmFnUmVjdC5sZWZ0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIE1hdGgubWF4KDAsIE1hdGgubWluKHJlY3QuYm90dG9tLCBkcmFnUmVjdC5ib3R0b20pIC0gTWF0aC5tYXgocmVjdC50b3AgLCBkcmFnUmVjdC50b3AgKSkpLFxuICAgICAgICAgICAgICAgICAgICBvdmVybGFwUmF0aW8gPSBvdmVybGFwQXJlYSAvIChkcmFnUmVjdC53aWR0aCAqIGRyYWdSZWN0LmhlaWdodCk7XG5cbiAgICAgICAgICAgICAgICBkcm9wcGVkID0gb3ZlcmxhcFJhdGlvID49IGRyb3BPdmVybGFwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRyb3AuY2hlY2tlcikge1xuICAgICAgICAgICAgICAgIGRyb3BwZWQgPSB0aGlzLm9wdGlvbnMuZHJvcC5jaGVja2VyKGRyYWdFdmVudCwgZXZlbnQsIGRyb3BwZWQsIHRoaXMsIGRyb3BFbGVtZW50LCBkcmFnZ2FibGUsIGRyYWdnYWJsZUVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZHJvcHBlZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKlxcXG4gICAgICAgICAqIEludGVyYWN0YWJsZS5kcm9wQ2hlY2tlclxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKlxuICAgICAgICAgKiBERVBSRUNBVEVELiBVc2UgaW50ZXJhY3RhYmxlLmRyb3B6b25lKHsgY2hlY2tlcjogZnVuY3Rpb24uLi4gfSkgaW5zdGVhZC5cbiAgICAgICAgICpcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBmdW5jdGlvbiB1c2VkIHRvIGNoZWNrIGlmIGEgZHJhZ2dlZCBlbGVtZW50IGlzXG4gICAgICAgICAqIG92ZXIgdGhpcyBJbnRlcmFjdGFibGUuXG4gICAgICAgICAqXG4gICAgICAgICAtIGNoZWNrZXIgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiBjaGVja2luZyBmb3IgYSBkcm9wXG4gICAgICAgICA9IChGdW5jdGlvbiB8IEludGVyYWN0YWJsZSkgVGhlIGNoZWNrZXIgZnVuY3Rpb24gb3IgdGhpcyBJbnRlcmFjdGFibGVcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGNoZWNrZXIgZnVuY3Rpb24gdGFrZXMgdGhlIGZvbGxvd2luZyBhcmd1bWVudHM6XG4gICAgICAgICAqXG4gICAgICAgICAtIGRyYWdFdmVudCAoSW50ZXJhY3RFdmVudCkgVGhlIHJlbGF0ZWQgZHJhZ21vdmUgb3IgZHJhZ2VuZCBldmVudFxuICAgICAgICAgLSBldmVudCAoVG91Y2hFdmVudCB8IFBvaW50ZXJFdmVudCB8IE1vdXNlRXZlbnQpIFRoZSB1c2VyIG1vdmUvdXAvZW5kIEV2ZW50IHJlbGF0ZWQgdG8gdGhlIGRyYWdFdmVudFxuICAgICAgICAgLSBkcm9wcGVkIChib29sZWFuKSBUaGUgdmFsdWUgZnJvbSB0aGUgZGVmYXVsdCBkcm9wIGNoZWNrZXJcbiAgICAgICAgIC0gZHJvcHpvbmUgKEludGVyYWN0YWJsZSkgVGhlIGRyb3B6b25lIGludGVyYWN0YWJsZVxuICAgICAgICAgLSBkcm9wRWxlbWVudCAoRWxlbWVudCkgVGhlIGRyb3B6b25lIGVsZW1lbnRcbiAgICAgICAgIC0gZHJhZ2dhYmxlIChJbnRlcmFjdGFibGUpIFRoZSBJbnRlcmFjdGFibGUgYmVpbmcgZHJhZ2dlZFxuICAgICAgICAgLSBkcmFnZ2FibGVFbGVtZW50IChFbGVtZW50KSBUaGUgYWN0dWFsIGVsZW1lbnQgdGhhdCdzIGJlaW5nIGRyYWdnZWRcbiAgICAgICAgICpcbiAgICAgICAgID4gVXNhZ2U6XG4gICAgICAgICB8IGludGVyYWN0KHRhcmdldClcbiAgICAgICAgIHwgLmRyb3BDaGVja2VyKGZ1bmN0aW9uKGRyYWdFdmVudCwgICAgICAgICAvLyByZWxhdGVkIGRyYWdtb3ZlIG9yIGRyYWdlbmQgZXZlbnRcbiAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LCAgICAgICAgICAgICAvLyBUb3VjaEV2ZW50L1BvaW50ZXJFdmVudC9Nb3VzZUV2ZW50XG4gICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICBkcm9wcGVkLCAgICAgICAgICAgLy8gYm9vbCByZXN1bHQgb2YgdGhlIGRlZmF1bHQgY2hlY2tlclxuICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgZHJvcHpvbmUsICAgICAgICAgIC8vIGRyb3B6b25lIEludGVyYWN0YWJsZVxuICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgZHJvcEVsZW1lbnQsICAgICAgIC8vIGRyb3B6b25lIGVsZW1udFxuICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgZHJhZ2dhYmxlLCAgICAgICAgIC8vIGRyYWdnYWJsZSBJbnRlcmFjdGFibGVcbiAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnYWJsZUVsZW1lbnQpIHsvLyBkcmFnZ2FibGUgZWxlbWVudFxuICAgICAgICAgfFxuICAgICAgICAgfCAgIHJldHVybiBkcm9wcGVkICYmIGV2ZW50LnRhcmdldC5oYXNBdHRyaWJ1dGUoJ2FsbG93LWRyb3AnKTtcbiAgICAgICAgIHwgfVxuICAgICAgICBcXCovXG4gICAgICAgIGRyb3BDaGVja2VyOiBmdW5jdGlvbiAoY2hlY2tlcikge1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oY2hlY2tlcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZHJvcC5jaGVja2VyID0gY2hlY2tlcjtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoZWNrZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5vcHRpb25zLmdldFJlY3Q7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5kcm9wLmNoZWNrZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcXFxuICAgICAgICAgKiBJbnRlcmFjdGFibGUuYWNjZXB0XG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqXG4gICAgICAgICAqIERlcHJlY2F0ZWQuIGFkZCBhbiBgYWNjZXB0YCBwcm9wZXJ0eSB0byB0aGUgb3B0aW9ucyBvYmplY3QgcGFzc2VkIHRvXG4gICAgICAgICAqIEBJbnRlcmFjdGFibGUuZHJvcHpvbmUgaW5zdGVhZC5cbiAgICAgICAgICpcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBFbGVtZW50IG9yIENTUyBzZWxlY3RvciBtYXRjaCB0aGF0IHRoaXNcbiAgICAgICAgICogSW50ZXJhY3RhYmxlIGFjY2VwdHMgaWYgaXQgaXMgYSBkcm9wem9uZS5cbiAgICAgICAgICpcbiAgICAgICAgIC0gbmV3VmFsdWUgKEVsZW1lbnQgfCBzdHJpbmcgfCBudWxsKSAjb3B0aW9uYWxcbiAgICAgICAgICogSWYgaXQgaXMgYW4gRWxlbWVudCwgdGhlbiBvbmx5IHRoYXQgZWxlbWVudCBjYW4gYmUgZHJvcHBlZCBpbnRvIHRoaXMgZHJvcHpvbmUuXG4gICAgICAgICAqIElmIGl0IGlzIGEgc3RyaW5nLCB0aGUgZWxlbWVudCBiZWluZyBkcmFnZ2VkIG11c3QgbWF0Y2ggaXQgYXMgYSBzZWxlY3Rvci5cbiAgICAgICAgICogSWYgaXQgaXMgbnVsbCwgdGhlIGFjY2VwdCBvcHRpb25zIGlzIGNsZWFyZWQgLSBpdCBhY2NlcHRzIGFueSBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgPSAoc3RyaW5nIHwgRWxlbWVudCB8IG51bGwgfCBJbnRlcmFjdGFibGUpIFRoZSBjdXJyZW50IGFjY2VwdCBvcHRpb24gaWYgZ2l2ZW4gYHVuZGVmaW5lZGAgb3IgdGhpcyBJbnRlcmFjdGFibGVcbiAgICAgICAgXFwqL1xuICAgICAgICBhY2NlcHQ6IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKGlzRWxlbWVudChuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZHJvcC5hY2NlcHQgPSBuZXdWYWx1ZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0ZXN0IGlmIGl0IGlzIGEgdmFsaWQgQ1NTIHNlbGVjdG9yXG4gICAgICAgICAgICBpZiAodHJ5U2VsZWN0b3IobmV3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRyb3AuYWNjZXB0ID0gbmV3VmFsdWU7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMub3B0aW9ucy5kcm9wLmFjY2VwdDtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmRyb3AuYWNjZXB0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qXFxcbiAgICAgICAgICogSW50ZXJhY3RhYmxlLnJlc2l6YWJsZVxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKlxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgd2hldGhlciByZXNpemUgYWN0aW9ucyBjYW4gYmUgcGVyZm9ybWVkIG9uIHRoZVxuICAgICAgICAgKiBJbnRlcmFjdGFibGVcbiAgICAgICAgICpcbiAgICAgICAgID0gKGJvb2xlYW4pIEluZGljYXRlcyBpZiB0aGlzIGNhbiBiZSB0aGUgdGFyZ2V0IG9mIHJlc2l6ZSBlbGVtZW50c1xuICAgICAgICAgfCB2YXIgaXNSZXNpemVhYmxlID0gaW50ZXJhY3QoJ2lucHV0W3R5cGU9dGV4dF0nKS5yZXNpemFibGUoKTtcbiAgICAgICAgICogb3JcbiAgICAgICAgIC0gb3B0aW9ucyAoYm9vbGVhbiB8IG9iamVjdCkgI29wdGlvbmFsIHRydWUvZmFsc2Ugb3IgQW4gb2JqZWN0IHdpdGggZXZlbnQgbGlzdGVuZXJzIHRvIGJlIGZpcmVkIG9uIHJlc2l6ZSBldmVudHMgKG9iamVjdCBtYWtlcyB0aGUgSW50ZXJhY3RhYmxlIHJlc2l6YWJsZSlcbiAgICAgICAgID0gKG9iamVjdCkgVGhpcyBJbnRlcmFjdGFibGVcbiAgICAgICAgIHwgaW50ZXJhY3QoZWxlbWVudCkucmVzaXphYmxlKHtcbiAgICAgICAgIHwgICAgIG9uc3RhcnQ6IGZ1bmN0aW9uIChldmVudCkge30sXG4gICAgICAgICB8ICAgICBvbm1vdmUgOiBmdW5jdGlvbiAoZXZlbnQpIHt9LFxuICAgICAgICAgfCAgICAgb25lbmQgIDogZnVuY3Rpb24gKGV2ZW50KSB7fSxcbiAgICAgICAgIHxcbiAgICAgICAgIHwgICAgIGVkZ2VzOiB7XG4gICAgICAgICB8ICAgICAgIHRvcCAgIDogdHJ1ZSwgICAgICAgLy8gVXNlIHBvaW50ZXIgY29vcmRzIHRvIGNoZWNrIGZvciByZXNpemUuXG4gICAgICAgICB8ICAgICAgIGxlZnQgIDogZmFsc2UsICAgICAgLy8gRGlzYWJsZSByZXNpemluZyBmcm9tIGxlZnQgZWRnZS5cbiAgICAgICAgIHwgICAgICAgYm90dG9tOiAnLnJlc2l6ZS1zJywvLyBSZXNpemUgaWYgcG9pbnRlciB0YXJnZXQgbWF0Y2hlcyBzZWxlY3RvclxuICAgICAgICAgfCAgICAgICByaWdodCA6IGhhbmRsZUVsICAgIC8vIFJlc2l6ZSBpZiBwb2ludGVyIHRhcmdldCBpcyB0aGUgZ2l2ZW4gRWxlbWVudFxuICAgICAgICAgfCAgICAgfSxcbiAgICAgICAgIHxcbiAgICAgICAgIHwgICAgIC8vIFdpZHRoIGFuZCBoZWlnaHQgY2FuIGJlIGFkanVzdGVkIGluZGVwZW5kZW50bHkuIFdoZW4gYHRydWVgLCB3aWR0aCBhbmRcbiAgICAgICAgIHwgICAgIC8vIGhlaWdodCBhcmUgYWRqdXN0ZWQgYXQgYSAxOjEgcmF0aW8uXG4gICAgICAgICB8ICAgICBzcXVhcmU6IGZhbHNlLFxuICAgICAgICAgfFxuICAgICAgICAgfCAgICAgLy8gV2lkdGggYW5kIGhlaWdodCBjYW4gYmUgYWRqdXN0ZWQgaW5kZXBlbmRlbnRseS4gV2hlbiBgdHJ1ZWAsIHdpZHRoIGFuZFxuICAgICAgICAgfCAgICAgLy8gaGVpZ2h0IG1haW50YWluIHRoZSBhc3BlY3QgcmF0aW8gdGhleSBoYWQgd2hlbiByZXNpemluZyBzdGFydGVkLlxuICAgICAgICAgfCAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogZmFsc2UsXG4gICAgICAgICB8XG4gICAgICAgICB8ICAgICAvLyBhIHZhbHVlIG9mICdub25lJyB3aWxsIGxpbWl0IHRoZSByZXNpemUgcmVjdCB0byBhIG1pbmltdW0gb2YgMHgwXG4gICAgICAgICB8ICAgICAvLyAnbmVnYXRlJyB3aWxsIGFsbG93IHRoZSByZWN0IHRvIGhhdmUgbmVnYXRpdmUgd2lkdGgvaGVpZ2h0XG4gICAgICAgICB8ICAgICAvLyAncmVwb3NpdGlvbicgd2lsbCBrZWVwIHRoZSB3aWR0aC9oZWlnaHQgcG9zaXRpdmUgYnkgc3dhcHBpbmdcbiAgICAgICAgIHwgICAgIC8vIHRoZSB0b3AgYW5kIGJvdHRvbSBlZGdlcyBhbmQvb3Igc3dhcHBpbmcgdGhlIGxlZnQgYW5kIHJpZ2h0IGVkZ2VzXG4gICAgICAgICB8ICAgICBpbnZlcnQ6ICdub25lJyB8fCAnbmVnYXRlJyB8fCAncmVwb3NpdGlvbidcbiAgICAgICAgIHxcbiAgICAgICAgIHwgICAgIC8vIGxpbWl0IG11bHRpcGxlIHJlc2l6ZXMuXG4gICAgICAgICB8ICAgICAvLyBTZWUgdGhlIGV4cGxhbmF0aW9uIGluIHRoZSBASW50ZXJhY3RhYmxlLmRyYWdnYWJsZSBleGFtcGxlXG4gICAgICAgICB8ICAgICBtYXg6IEluZmluaXR5LFxuICAgICAgICAgfCAgICAgbWF4UGVyRWxlbWVudDogMSxcbiAgICAgICAgIHwgfSk7XG4gICAgICAgIFxcKi9cbiAgICAgICAgcmVzaXphYmxlOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnJlc2l6ZS5lbmFibGVkID0gb3B0aW9ucy5lbmFibGVkID09PSBmYWxzZT8gZmFsc2U6IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQZXJBY3Rpb24oJ3Jlc2l6ZScsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0T25FdmVudHMoJ3Jlc2l6ZScsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKC9eeCR8XnkkfF54eSQvLnRlc3Qob3B0aW9ucy5heGlzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucmVzaXplLmF4aXMgPSBvcHRpb25zLmF4aXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuYXhpcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucmVzaXplLmF4aXMgPSBkZWZhdWx0T3B0aW9ucy5yZXNpemUuYXhpcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNCb29sKG9wdGlvbnMucHJlc2VydmVBc3BlY3RSYXRpbykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnJlc2l6ZS5wcmVzZXJ2ZUFzcGVjdFJhdGlvID0gb3B0aW9ucy5wcmVzZXJ2ZUFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0Jvb2wob3B0aW9ucy5zcXVhcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5yZXNpemUuc3F1YXJlID0gb3B0aW9ucy5zcXVhcmU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNCb29sKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnJlc2l6ZS5lbmFibGVkID0gb3B0aW9ucztcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yZXNpemU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcXFxuICAgICAgICAgKiBJbnRlcmFjdGFibGUuc3F1YXJlUmVzaXplXG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqXG4gICAgICAgICAqIERlcHJlY2F0ZWQuIEFkZCBhIGBzcXVhcmU6IHRydWUgfHwgZmFsc2VgIHByb3BlcnR5IHRvIEBJbnRlcmFjdGFibGUucmVzaXphYmxlIGluc3RlYWRcbiAgICAgICAgICpcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHdoZXRoZXIgcmVzaXppbmcgaXMgZm9yY2VkIDE6MSBhc3BlY3RcbiAgICAgICAgICpcbiAgICAgICAgID0gKGJvb2xlYW4pIEN1cnJlbnQgc2V0dGluZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBvclxuICAgICAgICAgKlxuICAgICAgICAgLSBuZXdWYWx1ZSAoYm9vbGVhbikgI29wdGlvbmFsXG4gICAgICAgICA9IChvYmplY3QpIHRoaXMgSW50ZXJhY3RhYmxlXG4gICAgICAgIFxcKi9cbiAgICAgICAgc3F1YXJlUmVzaXplOiBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpc0Jvb2wobmV3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnJlc2l6ZS5zcXVhcmUgPSBuZXdWYWx1ZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5vcHRpb25zLnJlc2l6ZS5zcXVhcmU7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yZXNpemUuc3F1YXJlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qXFxcbiAgICAgICAgICogSW50ZXJhY3RhYmxlLmdlc3R1cmFibGVcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICpcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHdoZXRoZXIgbXVsdGl0b3VjaCBnZXN0dXJlcyBjYW4gYmUgcGVyZm9ybWVkIG9uIHRoZVxuICAgICAgICAgKiBJbnRlcmFjdGFibGUncyBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICA9IChib29sZWFuKSBJbmRpY2F0ZXMgaWYgdGhpcyBjYW4gYmUgdGhlIHRhcmdldCBvZiBnZXN0dXJlIGV2ZW50c1xuICAgICAgICAgfCB2YXIgaXNHZXN0dXJlYWJsZSA9IGludGVyYWN0KGVsZW1lbnQpLmdlc3R1cmFibGUoKTtcbiAgICAgICAgICogb3JcbiAgICAgICAgIC0gb3B0aW9ucyAoYm9vbGVhbiB8IG9iamVjdCkgI29wdGlvbmFsIHRydWUvZmFsc2Ugb3IgQW4gb2JqZWN0IHdpdGggZXZlbnQgbGlzdGVuZXJzIHRvIGJlIGZpcmVkIG9uIGdlc3R1cmUgZXZlbnRzIChtYWtlcyB0aGUgSW50ZXJhY3RhYmxlIGdlc3R1cmFibGUpXG4gICAgICAgICA9IChvYmplY3QpIHRoaXMgSW50ZXJhY3RhYmxlXG4gICAgICAgICB8IGludGVyYWN0KGVsZW1lbnQpLmdlc3R1cmFibGUoe1xuICAgICAgICAgfCAgICAgb25zdGFydDogZnVuY3Rpb24gKGV2ZW50KSB7fSxcbiAgICAgICAgIHwgICAgIG9ubW92ZSA6IGZ1bmN0aW9uIChldmVudCkge30sXG4gICAgICAgICB8ICAgICBvbmVuZCAgOiBmdW5jdGlvbiAoZXZlbnQpIHt9LFxuICAgICAgICAgfFxuICAgICAgICAgfCAgICAgLy8gbGltaXQgbXVsdGlwbGUgZ2VzdHVyZXMuXG4gICAgICAgICB8ICAgICAvLyBTZWUgdGhlIGV4cGxhbmF0aW9uIGluIEBJbnRlcmFjdGFibGUuZHJhZ2dhYmxlIGV4YW1wbGVcbiAgICAgICAgIHwgICAgIG1heDogSW5maW5pdHksXG4gICAgICAgICB8ICAgICBtYXhQZXJFbGVtZW50OiAxLFxuICAgICAgICAgfCB9KTtcbiAgICAgICAgXFwqL1xuICAgICAgICBnZXN0dXJhYmxlOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmdlc3R1cmUuZW5hYmxlZCA9IG9wdGlvbnMuZW5hYmxlZCA9PT0gZmFsc2U/IGZhbHNlOiB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UGVyQWN0aW9uKCdnZXN0dXJlJywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPbkV2ZW50cygnZ2VzdHVyZScsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0Jvb2wob3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZ2VzdHVyZS5lbmFibGVkID0gb3B0aW9ucztcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmdlc3R1cmU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcXFxuICAgICAgICAgKiBJbnRlcmFjdGFibGUuYXV0b1Njcm9sbFxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogRGVwcmVjYXRlZC4gQWRkIGFuIGBhdXRvc2Nyb2xsYCBwcm9wZXJ0eSB0byB0aGUgb3B0aW9ucyBvYmplY3RcbiAgICAgICAgICogcGFzc2VkIHRvIEBJbnRlcmFjdGFibGUuZHJhZ2dhYmxlIG9yIEBJbnRlcmFjdGFibGUucmVzaXphYmxlIGluc3RlYWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybnMgb3Igc2V0cyB3aGV0aGVyIGRyYWdnaW5nIGFuZCByZXNpemluZyBuZWFyIHRoZSBlZGdlcyBvZiB0aGVcbiAgICAgICAgICogd2luZG93L2NvbnRhaW5lciB0cmlnZ2VyIGF1dG9TY3JvbGwgZm9yIHRoaXMgSW50ZXJhY3RhYmxlXG4gICAgICAgICAqXG4gICAgICAgICA9IChvYmplY3QpIE9iamVjdCB3aXRoIGF1dG9TY3JvbGwgcHJvcGVydGllc1xuICAgICAgICAgKlxuICAgICAgICAgKiBvclxuICAgICAgICAgKlxuICAgICAgICAgLSBvcHRpb25zIChvYmplY3QgfCBib29sZWFuKSAjb3B0aW9uYWxcbiAgICAgICAgICogb3B0aW9ucyBjYW4gYmU6XG4gICAgICAgICAqIC0gYW4gb2JqZWN0IHdpdGggbWFyZ2luLCBkaXN0YW5jZSBhbmQgaW50ZXJ2YWwgcHJvcGVydGllcyxcbiAgICAgICAgICogLSB0cnVlIG9yIGZhbHNlIHRvIGVuYWJsZSBvciBkaXNhYmxlIGF1dG9TY3JvbGwgb3JcbiAgICAgICAgID0gKEludGVyYWN0YWJsZSkgdGhpcyBJbnRlcmFjdGFibGVcbiAgICAgICAgXFwqL1xuICAgICAgICBhdXRvU2Nyb2xsOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGV4dGVuZCh7IGFjdGlvbnM6IFsnZHJhZycsICdyZXNpemUnXX0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNCb29sKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHsgYWN0aW9uczogWydkcmFnJywgJ3Jlc2l6ZSddLCBlbmFibGVkOiBvcHRpb25zIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE9wdGlvbnMoJ2F1dG9TY3JvbGwnLCBvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKlxcXG4gICAgICAgICAqIEludGVyYWN0YWJsZS5zbmFwXG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBEZXByZWNhdGVkLiBBZGQgYSBgc25hcGAgcHJvcGVydHkgdG8gdGhlIG9wdGlvbnMgb2JqZWN0IHBhc3NlZFxuICAgICAgICAgKiB0byBASW50ZXJhY3RhYmxlLmRyYWdnYWJsZSBvciBASW50ZXJhY3RhYmxlLnJlc2l6YWJsZSBpbnN0ZWFkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBSZXR1cm5zIG9yIHNldHMgaWYgYW5kIGhvdyBhY3Rpb24gY29vcmRpbmF0ZXMgYXJlIHNuYXBwZWQuIEJ5XG4gICAgICAgICAqIGRlZmF1bHQsIHNuYXBwaW5nIGlzIHJlbGF0aXZlIHRvIHRoZSBwb2ludGVyIGNvb3JkaW5hdGVzLiBZb3UgY2FuXG4gICAgICAgICAqIGNoYW5nZSB0aGlzIGJ5IHNldHRpbmcgdGhlXG4gICAgICAgICAqIFtgZWxlbWVudE9yaWdpbmBdKGh0dHBzOi8vZ2l0aHViLmNvbS90YXllL2ludGVyYWN0LmpzL3B1bGwvNzIpLlxuICAgICAgICAgKipcbiAgICAgICAgID0gKGJvb2xlYW4gfCBvYmplY3QpIGBmYWxzZWAgaWYgc25hcCBpcyBkaXNhYmxlZDsgb2JqZWN0IHdpdGggc25hcCBwcm9wZXJ0aWVzIGlmIHNuYXAgaXMgZW5hYmxlZFxuICAgICAgICAgKipcbiAgICAgICAgICogb3JcbiAgICAgICAgICoqXG4gICAgICAgICAtIG9wdGlvbnMgKG9iamVjdCB8IGJvb2xlYW4gfCBudWxsKSAjb3B0aW9uYWxcbiAgICAgICAgID0gKEludGVyYWN0YWJsZSkgdGhpcyBJbnRlcmFjdGFibGVcbiAgICAgICAgID4gVXNhZ2VcbiAgICAgICAgIHwgaW50ZXJhY3QoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3RoaW5nJykpLnNuYXAoe1xuICAgICAgICAgfCAgICAgdGFyZ2V0czogW1xuICAgICAgICAgfCAgICAgICAgIC8vIHNuYXAgdG8gdGhpcyBzcGVjaWZpYyBwb2ludFxuICAgICAgICAgfCAgICAgICAgIHtcbiAgICAgICAgIHwgICAgICAgICAgICAgeDogMTAwLFxuICAgICAgICAgfCAgICAgICAgICAgICB5OiAxMDAsXG4gICAgICAgICB8ICAgICAgICAgICAgIHJhbmdlOiAyNVxuICAgICAgICAgfCAgICAgICAgIH0sXG4gICAgICAgICB8ICAgICAgICAgLy8gZ2l2ZSB0aGlzIGZ1bmN0aW9uIHRoZSB4IGFuZCB5IHBhZ2UgY29vcmRzIGFuZCBzbmFwIHRvIHRoZSBvYmplY3QgcmV0dXJuZWRcbiAgICAgICAgIHwgICAgICAgICBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgfCAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgfCAgICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgIHwgICAgICAgICAgICAgICAgIHk6ICg3NSArIDUwICogTWF0aC5zaW4oeCAqIDAuMDQpKSxcbiAgICAgICAgIHwgICAgICAgICAgICAgICAgIHJhbmdlOiA0MFxuICAgICAgICAgfCAgICAgICAgICAgICB9O1xuICAgICAgICAgfCAgICAgICAgIH0sXG4gICAgICAgICB8ICAgICAgICAgLy8gY3JlYXRlIGEgZnVuY3Rpb24gdGhhdCBzbmFwcyB0byBhIGdyaWRcbiAgICAgICAgIHwgICAgICAgICBpbnRlcmFjdC5jcmVhdGVTbmFwR3JpZCh7XG4gICAgICAgICB8ICAgICAgICAgICAgIHg6IDUwLFxuICAgICAgICAgfCAgICAgICAgICAgICB5OiA1MCxcbiAgICAgICAgIHwgICAgICAgICAgICAgcmFuZ2U6IDEwLCAgICAgICAgICAgICAgLy8gb3B0aW9uYWxcbiAgICAgICAgIHwgICAgICAgICAgICAgb2Zmc2V0OiB7IHg6IDUsIHk6IDEwIH0gLy8gb3B0aW9uYWxcbiAgICAgICAgIHwgICAgICAgICB9KVxuICAgICAgICAgfCAgICAgXSxcbiAgICAgICAgIHwgICAgIC8vIGRvIG5vdCBzbmFwIGR1cmluZyBub3JtYWwgbW92ZW1lbnQuXG4gICAgICAgICB8ICAgICAvLyBJbnN0ZWFkLCB0cmlnZ2VyIG9ubHkgb25lIHNuYXBwZWQgbW92ZSBldmVudFxuICAgICAgICAgfCAgICAgLy8gaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBlbmQgZXZlbnQuXG4gICAgICAgICB8ICAgICBlbmRPbmx5OiB0cnVlLFxuICAgICAgICAgfFxuICAgICAgICAgfCAgICAgcmVsYXRpdmVQb2ludHM6IFtcbiAgICAgICAgIHwgICAgICAgICB7IHg6IDAsIHk6IDAgfSwgIC8vIHNuYXAgcmVsYXRpdmUgdG8gdGhlIHRvcCBsZWZ0IG9mIHRoZSBlbGVtZW50XG4gICAgICAgICB8ICAgICAgICAgeyB4OiAxLCB5OiAxIH0sICAvLyBhbmQgYWxzbyB0byB0aGUgYm90dG9tIHJpZ2h0XG4gICAgICAgICB8ICAgICBdLCAgXG4gICAgICAgICB8XG4gICAgICAgICB8ICAgICAvLyBvZmZzZXQgdGhlIHNuYXAgdGFyZ2V0IGNvb3JkaW5hdGVzXG4gICAgICAgICB8ICAgICAvLyBjYW4gYmUgYW4gb2JqZWN0IHdpdGggeC95IG9yICdzdGFydENvb3JkcydcbiAgICAgICAgIHwgICAgIG9mZnNldDogeyB4OiA1MCwgeTogNTAgfVxuICAgICAgICAgfCAgIH1cbiAgICAgICAgIHwgfSk7XG4gICAgICAgIFxcKi9cbiAgICAgICAgc25hcDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSB0aGlzLnNldE9wdGlvbnMoJ3NuYXAnLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgaWYgKHJldCA9PT0gdGhpcykgeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmV0LmRyYWc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24gKG9wdGlvbiwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGFjdGlvbnMgPSBvcHRpb25zICYmIGlzQXJyYXkob3B0aW9ucy5hY3Rpb25zKVxuICAgICAgICAgICAgICAgICAgICA/IG9wdGlvbnMuYWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICA6IFsnZHJhZyddO1xuXG4gICAgICAgICAgICB2YXIgaTtcblxuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpIHx8IGlzQm9vbChvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3Rpb24gPSAvcmVzaXplLy50ZXN0KGFjdGlvbnNbaV0pPyAncmVzaXplJyA6IGFjdGlvbnNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc09iamVjdCh0aGlzLm9wdGlvbnNbYWN0aW9uXSkpIHsgY29udGludWU7IH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGhpc09wdGlvbiA9IHRoaXMub3B0aW9uc1thY3Rpb25dW29wdGlvbl07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbmQodGhpc09wdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzT3B0aW9uLmVuYWJsZWQgPSBvcHRpb25zLmVuYWJsZWQgPT09IGZhbHNlPyBmYWxzZTogdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbiA9PT0gJ3NuYXAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNPcHRpb24ubW9kZSA9PT0gJ2dyaWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNPcHRpb24udGFyZ2V0cyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0LmNyZWF0ZVNuYXBHcmlkKGV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzT3B0aW9uLmdyaWRPZmZzZXQgfHwgeyB4OiAwLCB5OiAwIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXNPcHRpb24uZ3JpZCB8fCB7fSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXNPcHRpb24ubW9kZSA9PT0gJ2FuY2hvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc09wdGlvbi50YXJnZXRzID0gdGhpc09wdGlvbi5hbmNob3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzT3B0aW9uLm1vZGUgPT09ICdwYXRoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzT3B0aW9uLnRhcmdldHMgPSB0aGlzT3B0aW9uLnBhdGhzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnZWxlbWVudE9yaWdpbicgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzT3B0aW9uLnJlbGF0aXZlUG9pbnRzID0gW29wdGlvbnMuZWxlbWVudE9yaWdpbl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQm9vbChvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc09wdGlvbi5lbmFibGVkID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmV0ID0ge30sXG4gICAgICAgICAgICAgICAgYWxsQWN0aW9ucyA9IFsnZHJhZycsICdyZXNpemUnLCAnZ2VzdHVyZSddO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYWxsQWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb24gaW4gZGVmYXVsdE9wdGlvbnNbYWxsQWN0aW9uc1tpXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0W2FsbEFjdGlvbnNbaV1dID0gdGhpcy5vcHRpb25zW2FsbEFjdGlvbnNbaV1dW29wdGlvbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLypcXFxuICAgICAgICAgKiBJbnRlcmFjdGFibGUuaW5lcnRpYVxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogRGVwcmVjYXRlZC4gQWRkIGFuIGBpbmVydGlhYCBwcm9wZXJ0eSB0byB0aGUgb3B0aW9ucyBvYmplY3QgcGFzc2VkXG4gICAgICAgICAqIHRvIEBJbnRlcmFjdGFibGUuZHJhZ2dhYmxlIG9yIEBJbnRlcmFjdGFibGUucmVzaXphYmxlIGluc3RlYWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybnMgb3Igc2V0cyBpZiBhbmQgaG93IGV2ZW50cyBjb250aW51ZSB0byBydW4gYWZ0ZXIgdGhlIHBvaW50ZXIgaXMgcmVsZWFzZWRcbiAgICAgICAgICoqXG4gICAgICAgICA9IChib29sZWFuIHwgb2JqZWN0KSBgZmFsc2VgIGlmIGluZXJ0aWEgaXMgZGlzYWJsZWQ7IGBvYmplY3RgIHdpdGggaW5lcnRpYSBwcm9wZXJ0aWVzIGlmIGluZXJ0aWEgaXMgZW5hYmxlZFxuICAgICAgICAgKipcbiAgICAgICAgICogb3JcbiAgICAgICAgICoqXG4gICAgICAgICAtIG9wdGlvbnMgKG9iamVjdCB8IGJvb2xlYW4gfCBudWxsKSAjb3B0aW9uYWxcbiAgICAgICAgID0gKEludGVyYWN0YWJsZSkgdGhpcyBJbnRlcmFjdGFibGVcbiAgICAgICAgID4gVXNhZ2VcbiAgICAgICAgIHwgLy8gZW5hYmxlIGFuZCB1c2UgZGVmYXVsdCBzZXR0aW5nc1xuICAgICAgICAgfCBpbnRlcmFjdChlbGVtZW50KS5pbmVydGlhKHRydWUpO1xuICAgICAgICAgfFxuICAgICAgICAgfCAvLyBlbmFibGUgYW5kIHVzZSBjdXN0b20gc2V0dGluZ3NcbiAgICAgICAgIHwgaW50ZXJhY3QoZWxlbWVudCkuaW5lcnRpYSh7XG4gICAgICAgICB8ICAgICAvLyB2YWx1ZSBncmVhdGVyIHRoYW4gMFxuICAgICAgICAgfCAgICAgLy8gaGlnaCB2YWx1ZXMgc2xvdyB0aGUgb2JqZWN0IGRvd24gbW9yZSBxdWlja2x5XG4gICAgICAgICB8ICAgICByZXNpc3RhbmNlICAgICA6IDE2LFxuICAgICAgICAgfFxuICAgICAgICAgfCAgICAgLy8gdGhlIG1pbmltdW0gbGF1bmNoIHNwZWVkIChwaXhlbHMgcGVyIHNlY29uZCkgdGhhdCByZXN1bHRzIGluIGluZXJ0aWEgc3RhcnRcbiAgICAgICAgIHwgICAgIG1pblNwZWVkICAgICAgIDogMjAwLFxuICAgICAgICAgfFxuICAgICAgICAgfCAgICAgLy8gaW5lcnRpYSB3aWxsIHN0b3Agd2hlbiB0aGUgb2JqZWN0IHNsb3dzIGRvd24gdG8gdGhpcyBzcGVlZFxuICAgICAgICAgfCAgICAgZW5kU3BlZWQgICAgICAgOiAyMCxcbiAgICAgICAgIHxcbiAgICAgICAgIHwgICAgIC8vIGJvb2xlYW47IHNob3VsZCBhY3Rpb25zIGJlIHJlc3VtZWQgd2hlbiB0aGUgcG9pbnRlciBnb2VzIGRvd24gZHVyaW5nIGluZXJ0aWFcbiAgICAgICAgIHwgICAgIGFsbG93UmVzdW1lICAgIDogdHJ1ZSxcbiAgICAgICAgIHxcbiAgICAgICAgIHwgICAgIC8vIGJvb2xlYW47IHNob3VsZCB0aGUganVtcCB3aGVuIHJlc3VtaW5nIGZyb20gaW5lcnRpYSBiZSBpZ25vcmVkIGluIGV2ZW50LmR4L2R5XG4gICAgICAgICB8ICAgICB6ZXJvUmVzdW1lRGVsdGE6IGZhbHNlLFxuICAgICAgICAgfFxuICAgICAgICAgfCAgICAgLy8gaWYgc25hcC9yZXN0cmljdCBhcmUgc2V0IHRvIGJlIGVuZE9ubHkgYW5kIGluZXJ0aWEgaXMgZW5hYmxlZCwgcmVsZWFzaW5nXG4gICAgICAgICB8ICAgICAvLyB0aGUgcG9pbnRlciB3aXRob3V0IHRyaWdnZXJpbmcgaW5lcnRpYSB3aWxsIGFuaW1hdGUgZnJvbSB0aGUgcmVsZWFzZVxuICAgICAgICAgfCAgICAgLy8gcG9pbnQgdG8gdGhlIHNuYXBlZC9yZXN0cmljdGVkIHBvaW50IGluIHRoZSBnaXZlbiBhbW91bnQgb2YgdGltZSAobXMpXG4gICAgICAgICB8ICAgICBzbW9vdGhFbmREdXJhdGlvbjogMzAwLFxuICAgICAgICAgfFxuICAgICAgICAgfCAgICAgLy8gYW4gYXJyYXkgb2YgYWN0aW9uIHR5cGVzIHRoYXQgY2FuIGhhdmUgaW5lcnRpYSAobm8gZ2VzdHVyZSlcbiAgICAgICAgIHwgICAgIGFjdGlvbnMgICAgICAgIDogWydkcmFnJywgJ3Jlc2l6ZSddXG4gICAgICAgICB8IH0pO1xuICAgICAgICAgfFxuICAgICAgICAgfCAvLyByZXNldCBjdXN0b20gc2V0dGluZ3MgYW5kIHVzZSBhbGwgZGVmYXVsdHNcbiAgICAgICAgIHwgaW50ZXJhY3QoZWxlbWVudCkuaW5lcnRpYShudWxsKTtcbiAgICAgICAgXFwqL1xuICAgICAgICBpbmVydGlhOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHJldCA9IHRoaXMuc2V0T3B0aW9ucygnaW5lcnRpYScsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICBpZiAocmV0ID09PSB0aGlzKSB7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQuZHJhZztcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRBY3Rpb246IGZ1bmN0aW9uIChwb2ludGVyLCBldmVudCwgaW50ZXJhY3Rpb24sIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSB0aGlzLmRlZmF1bHRBY3Rpb25DaGVja2VyKHBvaW50ZXIsIGludGVyYWN0aW9uLCBlbGVtZW50KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hY3Rpb25DaGVja2VyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hY3Rpb25DaGVja2VyKHBvaW50ZXIsIGV2ZW50LCBhY3Rpb24sIHRoaXMsIGVsZW1lbnQsIGludGVyYWN0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWZhdWx0QWN0aW9uQ2hlY2tlcjogZGVmYXVsdEFjdGlvbkNoZWNrZXIsXG5cbiAgICAgICAgLypcXFxuICAgICAgICAgKiBJbnRlcmFjdGFibGUuYWN0aW9uQ2hlY2tlclxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKlxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGZ1bmN0aW9uIHVzZWQgdG8gY2hlY2sgYWN0aW9uIHRvIGJlIHBlcmZvcm1lZCBvblxuICAgICAgICAgKiBwb2ludGVyRG93blxuICAgICAgICAgKlxuICAgICAgICAgLSBjaGVja2VyIChmdW5jdGlvbiB8IG51bGwpICNvcHRpb25hbCBBIGZ1bmN0aW9uIHdoaWNoIHRha2VzIGEgcG9pbnRlciBldmVudCwgZGVmYXVsdEFjdGlvbiBzdHJpbmcsIGludGVyYWN0YWJsZSwgZWxlbWVudCBhbmQgaW50ZXJhY3Rpb24gYXMgcGFyYW1ldGVycyBhbmQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBuYW1lIHByb3BlcnR5ICdkcmFnJyAncmVzaXplJyBvciAnZ2VzdHVyZScgYW5kIG9wdGlvbmFsbHkgYW4gYGVkZ2VzYCBvYmplY3Qgd2l0aCBib29sZWFuICd0b3AnLCAnbGVmdCcsICdib3R0b20nIGFuZCByaWdodCBwcm9wcy5cbiAgICAgICAgID0gKEZ1bmN0aW9uIHwgSW50ZXJhY3RhYmxlKSBUaGUgY2hlY2tlciBmdW5jdGlvbiBvciB0aGlzIEludGVyYWN0YWJsZVxuICAgICAgICAgKlxuICAgICAgICAgfCBpbnRlcmFjdCgnLnJlc2l6ZS1kcmFnJylcbiAgICAgICAgIHwgICAucmVzaXphYmxlKHRydWUpXG4gICAgICAgICB8ICAgLmRyYWdnYWJsZSh0cnVlKVxuICAgICAgICAgfCAgIC5hY3Rpb25DaGVja2VyKGZ1bmN0aW9uIChwb2ludGVyLCBldmVudCwgYWN0aW9uLCBpbnRlcmFjdGFibGUsIGVsZW1lbnQsIGludGVyYWN0aW9uKSB7XG4gICAgICAgICB8XG4gICAgICAgICB8ICAgaWYgKGludGVyYWN0Lm1hdGNoZXNTZWxlY3RvcihldmVudC50YXJnZXQsICcuZHJhZy1oYW5kbGUnKSB7XG4gICAgICAgICB8ICAgICAvLyBmb3JjZSBkcmFnIHdpdGggaGFuZGxlIHRhcmdldFxuICAgICAgICAgfCAgICAgYWN0aW9uLm5hbWUgPSBkcmFnO1xuICAgICAgICAgfCAgIH1cbiAgICAgICAgIHwgICBlbHNlIHtcbiAgICAgICAgIHwgICAgIC8vIHJlc2l6ZSBmcm9tIHRoZSB0b3AgYW5kIHJpZ2h0IGVkZ2VzXG4gICAgICAgICB8ICAgICBhY3Rpb24ubmFtZSAgPSAncmVzaXplJztcbiAgICAgICAgIHwgICAgIGFjdGlvbi5lZGdlcyA9IHsgdG9wOiB0cnVlLCByaWdodDogdHJ1ZSB9O1xuICAgICAgICAgfCAgIH1cbiAgICAgICAgIHxcbiAgICAgICAgIHwgICByZXR1cm4gYWN0aW9uO1xuICAgICAgICAgfCB9KTtcbiAgICAgICAgXFwqL1xuICAgICAgICBhY3Rpb25DaGVja2VyOiBmdW5jdGlvbiAoY2hlY2tlcikge1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oY2hlY2tlcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuYWN0aW9uQ2hlY2tlciA9IGNoZWNrZXI7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoZWNrZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5vcHRpb25zLmFjdGlvbkNoZWNrZXI7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hY3Rpb25DaGVja2VyO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qXFxcbiAgICAgICAgICogSW50ZXJhY3RhYmxlLmdldFJlY3RcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gZ2V0IGFuIEludGVyYWN0YWJsZXMgYm91bmRpbmcgcmVjdC4gQ2FuIGJlXG4gICAgICAgICAqIG92ZXJyaWRkZW4gdXNpbmcgQEludGVyYWN0YWJsZS5yZWN0Q2hlY2tlci5cbiAgICAgICAgICpcbiAgICAgICAgIC0gZWxlbWVudCAoRWxlbWVudCkgI29wdGlvbmFsIFRoZSBlbGVtZW50IHRvIG1lYXN1cmUuXG4gICAgICAgICA9IChvYmplY3QpIFRoZSBvYmplY3QncyBib3VuZGluZyByZWN0YW5nbGUuXG4gICAgICAgICBvIHtcbiAgICAgICAgIG8gICAgIHRvcCAgIDogMCxcbiAgICAgICAgIG8gICAgIGxlZnQgIDogMCxcbiAgICAgICAgIG8gICAgIGJvdHRvbTogMCxcbiAgICAgICAgIG8gICAgIHJpZ2h0IDogMCxcbiAgICAgICAgIG8gICAgIHdpZHRoIDogMCxcbiAgICAgICAgIG8gICAgIGhlaWdodDogMFxuICAgICAgICAgbyB9XG4gICAgICAgIFxcKi9cbiAgICAgICAgZ2V0UmVjdDogZnVuY3Rpb24gcmVjdENoZWNrIChlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudCB8fCB0aGlzLl9lbGVtZW50O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RvciAmJiAhKGlzRWxlbWVudChlbGVtZW50KSkpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gdGhpcy5fY29udGV4dC5xdWVyeVNlbGVjdG9yKHRoaXMuc2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZ2V0RWxlbWVudFJlY3QoZWxlbWVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcXFxuICAgICAgICAgKiBJbnRlcmFjdGFibGUucmVjdENoZWNrZXJcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICpcbiAgICAgICAgICogUmV0dXJucyBvciBzZXRzIHRoZSBmdW5jdGlvbiB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgaW50ZXJhY3RhYmxlJ3NcbiAgICAgICAgICogZWxlbWVudCdzIHJlY3RhbmdsZVxuICAgICAgICAgKlxuICAgICAgICAgLSBjaGVja2VyIChmdW5jdGlvbikgI29wdGlvbmFsIEEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGlzIEludGVyYWN0YWJsZSdzIGJvdW5kaW5nIHJlY3RhbmdsZS4gU2VlIEBJbnRlcmFjdGFibGUuZ2V0UmVjdFxuICAgICAgICAgPSAoZnVuY3Rpb24gfCBvYmplY3QpIFRoZSBjaGVja2VyIGZ1bmN0aW9uIG9yIHRoaXMgSW50ZXJhY3RhYmxlXG4gICAgICAgIFxcKi9cbiAgICAgICAgcmVjdENoZWNrZXI6IGZ1bmN0aW9uIChjaGVja2VyKSB7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihjaGVja2VyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0UmVjdCA9IGNoZWNrZXI7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoZWNrZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5vcHRpb25zLmdldFJlY3Q7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVjdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKlxcXG4gICAgICAgICAqIEludGVyYWN0YWJsZS5zdHlsZUN1cnNvclxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKlxuICAgICAgICAgKiBSZXR1cm5zIG9yIHNldHMgd2hldGhlciB0aGUgYWN0aW9uIHRoYXQgd291bGQgYmUgcGVyZm9ybWVkIHdoZW4gdGhlXG4gICAgICAgICAqIG1vdXNlIG9uIHRoZSBlbGVtZW50IGFyZSBjaGVja2VkIG9uIGBtb3VzZW1vdmVgIHNvIHRoYXQgdGhlIGN1cnNvclxuICAgICAgICAgKiBtYXkgYmUgc3R5bGVkIGFwcHJvcHJpYXRlbHlcbiAgICAgICAgICpcbiAgICAgICAgIC0gbmV3VmFsdWUgKGJvb2xlYW4pICNvcHRpb25hbFxuICAgICAgICAgPSAoYm9vbGVhbiB8IEludGVyYWN0YWJsZSkgVGhlIGN1cnJlbnQgc2V0dGluZyBvciB0aGlzIEludGVyYWN0YWJsZVxuICAgICAgICBcXCovXG4gICAgICAgIHN0eWxlQ3Vyc29yOiBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpc0Jvb2wobmV3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnN0eWxlQ3Vyc29yID0gbmV3VmFsdWU7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMub3B0aW9ucy5zdHlsZUN1cnNvcjtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnN0eWxlQ3Vyc29yO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qXFxcbiAgICAgICAgICogSW50ZXJhY3RhYmxlLnByZXZlbnREZWZhdWx0XG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybnMgb3Igc2V0cyB3aGV0aGVyIHRvIHByZXZlbnQgdGhlIGJyb3dzZXIncyBkZWZhdWx0IGJlaGF2aW91clxuICAgICAgICAgKiBpbiByZXNwb25zZSB0byBwb2ludGVyIGV2ZW50cy4gQ2FuIGJlIHNldCB0bzpcbiAgICAgICAgICogIC0gYCdhbHdheXMnYCB0byBhbHdheXMgcHJldmVudFxuICAgICAgICAgKiAgLSBgJ25ldmVyJ2AgdG8gbmV2ZXIgcHJldmVudFxuICAgICAgICAgKiAgLSBgJ2F1dG8nYCB0byBsZXQgaW50ZXJhY3QuanMgdHJ5IHRvIGRldGVybWluZSB3aGF0IHdvdWxkIGJlIGJlc3RcbiAgICAgICAgICpcbiAgICAgICAgIC0gbmV3VmFsdWUgKHN0cmluZykgI29wdGlvbmFsIGB0cnVlYCwgYGZhbHNlYCBvciBgJ2F1dG8nYFxuICAgICAgICAgPSAoc3RyaW5nIHwgSW50ZXJhY3RhYmxlKSBUaGUgY3VycmVudCBzZXR0aW5nIG9yIHRoaXMgSW50ZXJhY3RhYmxlXG4gICAgICAgIFxcKi9cbiAgICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKC9eKGFsd2F5c3xuZXZlcnxhdXRvKSQvLnRlc3QobmV3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0ID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0Jvb2wobmV3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0ID0gbmV3VmFsdWU/ICdhbHdheXMnIDogJ25ldmVyJztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKlxcXG4gICAgICAgICAqIEludGVyYWN0YWJsZS5vcmlnaW5cbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICpcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBvcmlnaW4gb2YgdGhlIEludGVyYWN0YWJsZSdzIGVsZW1lbnQuICBUaGUgeCBhbmQgeVxuICAgICAgICAgKiBvZiB0aGUgb3JpZ2luIHdpbGwgYmUgc3VidHJhY3RlZCBmcm9tIGFjdGlvbiBldmVudCBjb29yZGluYXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgIC0gb3JpZ2luIChvYmplY3QgfCBzdHJpbmcpICNvcHRpb25hbCBBbiBvYmplY3QgZWcuIHsgeDogMCwgeTogMCB9IG9yIHN0cmluZyAncGFyZW50JywgJ3NlbGYnIG9yIGFueSBDU1Mgc2VsZWN0b3JcbiAgICAgICAgICogT1JcbiAgICAgICAgIC0gb3JpZ2luIChFbGVtZW50KSAjb3B0aW9uYWwgQW4gSFRNTCBvciBTVkcgRWxlbWVudCB3aG9zZSByZWN0IHdpbGwgYmUgdXNlZFxuICAgICAgICAgKipcbiAgICAgICAgID0gKG9iamVjdCkgVGhlIGN1cnJlbnQgb3JpZ2luIG9yIHRoaXMgSW50ZXJhY3RhYmxlXG4gICAgICAgIFxcKi9cbiAgICAgICAgb3JpZ2luOiBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0cnlTZWxlY3RvcihuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub3JpZ2luID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc09iamVjdChuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub3JpZ2luID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMub3JpZ2luO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qXFxcbiAgICAgICAgICogSW50ZXJhY3RhYmxlLmRlbHRhU291cmNlXG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybnMgb3Igc2V0cyB0aGUgbW91c2UgY29vcmRpbmF0ZSB0eXBlcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGVcbiAgICAgICAgICogbW92ZW1lbnQgb2YgdGhlIHBvaW50ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAtIG5ld1ZhbHVlIChzdHJpbmcpICNvcHRpb25hbCBVc2UgJ2NsaWVudCcgaWYgeW91IHdpbGwgYmUgc2Nyb2xsaW5nIHdoaWxlIGludGVyYWN0aW5nOyBVc2UgJ3BhZ2UnIGlmIHlvdSB3YW50IGF1dG9TY3JvbGwgdG8gd29ya1xuICAgICAgICAgPSAoc3RyaW5nIHwgb2JqZWN0KSBUaGUgY3VycmVudCBkZWx0YVNvdXJjZSBvciB0aGlzIEludGVyYWN0YWJsZVxuICAgICAgICBcXCovXG4gICAgICAgIGRlbHRhU291cmNlOiBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gJ3BhZ2UnIHx8IG5ld1ZhbHVlID09PSAnY2xpZW50Jykge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kZWx0YVNvdXJjZSA9IG5ld1ZhbHVlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZGVsdGFTb3VyY2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcXFxuICAgICAgICAgKiBJbnRlcmFjdGFibGUucmVzdHJpY3RcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIERlcHJlY2F0ZWQuIEFkZCBhIGByZXN0cmljdGAgcHJvcGVydHkgdG8gdGhlIG9wdGlvbnMgb2JqZWN0IHBhc3NlZCB0b1xuICAgICAgICAgKiBASW50ZXJhY3RhYmxlLmRyYWdnYWJsZSwgQEludGVyYWN0YWJsZS5yZXNpemFibGUgb3IgQEludGVyYWN0YWJsZS5nZXN0dXJhYmxlIGluc3RlYWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybnMgb3Igc2V0cyB0aGUgcmVjdGFuZ2xlcyB3aXRoaW4gd2hpY2ggYWN0aW9ucyBvbiB0aGlzXG4gICAgICAgICAqIGludGVyYWN0YWJsZSAoYWZ0ZXIgc25hcCBjYWxjdWxhdGlvbnMpIGFyZSByZXN0cmljdGVkLiBCeSBkZWZhdWx0LFxuICAgICAgICAgKiByZXN0cmljdGluZyBpcyByZWxhdGl2ZSB0byB0aGUgcG9pbnRlciBjb29yZGluYXRlcy4gWW91IGNhbiBjaGFuZ2VcbiAgICAgICAgICogdGhpcyBieSBzZXR0aW5nIHRoZVxuICAgICAgICAgKiBbYGVsZW1lbnRSZWN0YF0oaHR0cHM6Ly9naXRodWIuY29tL3RheWUvaW50ZXJhY3QuanMvcHVsbC83MikuXG4gICAgICAgICAqKlxuICAgICAgICAgLSBvcHRpb25zIChvYmplY3QpICNvcHRpb25hbCBhbiBvYmplY3Qgd2l0aCBrZXlzIGRyYWcsIHJlc2l6ZSwgYW5kL29yIGdlc3R1cmUgd2hvc2UgdmFsdWVzIGFyZSByZWN0cywgRWxlbWVudHMsIENTUyBzZWxlY3RvcnMsIG9yICdwYXJlbnQnIG9yICdzZWxmJ1xuICAgICAgICAgPSAob2JqZWN0KSBUaGUgY3VycmVudCByZXN0cmljdGlvbnMgb2JqZWN0IG9yIHRoaXMgSW50ZXJhY3RhYmxlXG4gICAgICAgICAqKlxuICAgICAgICAgfCBpbnRlcmFjdChlbGVtZW50KS5yZXN0cmljdCh7XG4gICAgICAgICB8ICAgICAvLyB0aGUgcmVjdCB3aWxsIGJlIGBpbnRlcmFjdC5nZXRFbGVtZW50UmVjdChlbGVtZW50LnBhcmVudE5vZGUpYFxuICAgICAgICAgfCAgICAgZHJhZzogZWxlbWVudC5wYXJlbnROb2RlLFxuICAgICAgICAgfFxuICAgICAgICAgfCAgICAgLy8geCBhbmQgeSBhcmUgcmVsYXRpdmUgdG8gdGhlIHRoZSBpbnRlcmFjdGFibGUncyBvcmlnaW5cbiAgICAgICAgIHwgICAgIHJlc2l6ZTogeyB4OiAxMDAsIHk6IDEwMCwgd2lkdGg6IDIwMCwgaGVpZ2h0OiAyMDAgfVxuICAgICAgICAgfCB9KVxuICAgICAgICAgfFxuICAgICAgICAgfCBpbnRlcmFjdCgnLmRyYWdnYWJsZScpLnJlc3RyaWN0KHtcbiAgICAgICAgIHwgICAgIC8vIHRoZSByZWN0IHdpbGwgYmUgdGhlIHNlbGVjdGVkIGVsZW1lbnQncyBwYXJlbnRcbiAgICAgICAgIHwgICAgIGRyYWc6ICdwYXJlbnQnLFxuICAgICAgICAgfFxuICAgICAgICAgfCAgICAgLy8gZG8gbm90IHJlc3RyaWN0IGR1cmluZyBub3JtYWwgbW92ZW1lbnQuXG4gICAgICAgICB8ICAgICAvLyBJbnN0ZWFkLCB0cmlnZ2VyIG9ubHkgb25lIHJlc3RyaWN0ZWQgbW92ZSBldmVudFxuICAgICAgICAgfCAgICAgLy8gaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBlbmQgZXZlbnQuXG4gICAgICAgICB8ICAgICBlbmRPbmx5OiB0cnVlLFxuICAgICAgICAgfFxuICAgICAgICAgfCAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RheWUvaW50ZXJhY3QuanMvcHVsbC83MiNpc3N1ZS00MTgxMzQ5M1xuICAgICAgICAgfCAgICAgZWxlbWVudFJlY3Q6IHsgdG9wOiAwLCBsZWZ0OiAwLCBib3R0b206IDEsIHJpZ2h0OiAxIH1cbiAgICAgICAgIHwgfSk7XG4gICAgICAgIFxcKi9cbiAgICAgICAgcmVzdHJpY3Q6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIWlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0T3B0aW9ucygncmVzdHJpY3QnLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFjdGlvbnMgPSBbJ2RyYWcnLCAncmVzaXplJywgJ2dlc3R1cmUnXSxcbiAgICAgICAgICAgICAgICByZXQ7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBhY3Rpb24gPSBhY3Rpb25zW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwZXJBY3Rpb24gPSBleHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IFthY3Rpb25dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RyaWN0aW9uOiBvcHRpb25zW2FjdGlvbl1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IHRoaXMuc2V0T3B0aW9ucygncmVzdHJpY3QnLCBwZXJBY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKlxcXG4gICAgICAgICAqIEludGVyYWN0YWJsZS5jb250ZXh0XG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqXG4gICAgICAgICAqIEdldHMgdGhlIHNlbGVjdG9yIGNvbnRleHQgTm9kZSBvZiB0aGUgSW50ZXJhY3RhYmxlLiBUaGUgZGVmYXVsdCBpcyBgd2luZG93LmRvY3VtZW50YC5cbiAgICAgICAgICpcbiAgICAgICAgID0gKE5vZGUpIFRoZSBjb250ZXh0IE5vZGUgb2YgdGhpcyBJbnRlcmFjdGFibGVcbiAgICAgICAgICoqXG4gICAgICAgIFxcKi9cbiAgICAgICAgY29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NvbnRleHQ6IGRvY3VtZW50LFxuXG4gICAgICAgIC8qXFxcbiAgICAgICAgICogSW50ZXJhY3RhYmxlLmlnbm9yZUZyb21cbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlIHRhcmdldCBvZiB0aGUgYG1vdXNlZG93bmAsIGBwb2ludGVyZG93bmAgb3IgYHRvdWNoc3RhcnRgXG4gICAgICAgICAqIGV2ZW50IG9yIGFueSBvZiBpdCdzIHBhcmVudHMgbWF0Y2ggdGhlIGdpdmVuIENTUyBzZWxlY3RvciBvclxuICAgICAgICAgKiBFbGVtZW50LCBubyBkcmFnL3Jlc2l6ZS9nZXN0dXJlIGlzIHN0YXJ0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAtIG5ld1ZhbHVlIChzdHJpbmcgfCBFbGVtZW50IHwgbnVsbCkgI29wdGlvbmFsIGEgQ1NTIHNlbGVjdG9yIHN0cmluZywgYW4gRWxlbWVudCBvciBgbnVsbGAgdG8gbm90IGlnbm9yZSBhbnkgZWxlbWVudHNcbiAgICAgICAgID0gKHN0cmluZyB8IEVsZW1lbnQgfCBvYmplY3QpIFRoZSBjdXJyZW50IGlnbm9yZUZyb20gdmFsdWUgb3IgdGhpcyBJbnRlcmFjdGFibGVcbiAgICAgICAgICoqXG4gICAgICAgICB8IGludGVyYWN0KGVsZW1lbnQsIHsgaWdub3JlRnJvbTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25vLWFjdGlvbicpIH0pO1xuICAgICAgICAgfCAvLyBvclxuICAgICAgICAgfCBpbnRlcmFjdChlbGVtZW50KS5pZ25vcmVGcm9tKCdpbnB1dCwgdGV4dGFyZWEsIGEnKTtcbiAgICAgICAgXFwqL1xuICAgICAgICBpZ25vcmVGcm9tOiBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0cnlTZWxlY3RvcihuZXdWYWx1ZSkpIHsgICAgICAgICAgICAvLyBDU1Mgc2VsZWN0b3IgdG8gbWF0Y2ggZXZlbnQudGFyZ2V0XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmlnbm9yZUZyb20gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzRWxlbWVudChuZXdWYWx1ZSkpIHsgICAgICAgICAgICAgIC8vIHNwZWNpZmljIGVsZW1lbnRcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuaWdub3JlRnJvbSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmlnbm9yZUZyb207XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcXFxuICAgICAgICAgKiBJbnRlcmFjdGFibGUuYWxsb3dGcm9tXG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqXG4gICAgICAgICAqIEEgZHJhZy9yZXNpemUvZ2VzdHVyZSBpcyBzdGFydGVkIG9ubHkgSWYgdGhlIHRhcmdldCBvZiB0aGVcbiAgICAgICAgICogYG1vdXNlZG93bmAsIGBwb2ludGVyZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50IG9yIGFueSBvZiBpdCdzXG4gICAgICAgICAqIHBhcmVudHMgbWF0Y2ggdGhlIGdpdmVuIENTUyBzZWxlY3RvciBvciBFbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgLSBuZXdWYWx1ZSAoc3RyaW5nIHwgRWxlbWVudCB8IG51bGwpICNvcHRpb25hbCBhIENTUyBzZWxlY3RvciBzdHJpbmcsIGFuIEVsZW1lbnQgb3IgYG51bGxgIHRvIGFsbG93IGZyb20gYW55IGVsZW1lbnRcbiAgICAgICAgID0gKHN0cmluZyB8IEVsZW1lbnQgfCBvYmplY3QpIFRoZSBjdXJyZW50IGFsbG93RnJvbSB2YWx1ZSBvciB0aGlzIEludGVyYWN0YWJsZVxuICAgICAgICAgKipcbiAgICAgICAgIHwgaW50ZXJhY3QoZWxlbWVudCwgeyBhbGxvd0Zyb206IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkcmFnLWhhbmRsZScpIH0pO1xuICAgICAgICAgfCAvLyBvclxuICAgICAgICAgfCBpbnRlcmFjdChlbGVtZW50KS5hbGxvd0Zyb20oJy5oYW5kbGUnKTtcbiAgICAgICAgXFwqL1xuICAgICAgICBhbGxvd0Zyb206IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRyeVNlbGVjdG9yKG5ld1ZhbHVlKSkgeyAgICAgICAgICAgIC8vIENTUyBzZWxlY3RvciB0byBtYXRjaCBldmVudC50YXJnZXRcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuYWxsb3dGcm9tID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0VsZW1lbnQobmV3VmFsdWUpKSB7ICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBlbGVtZW50XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmFsbG93RnJvbSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmFsbG93RnJvbTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKlxcXG4gICAgICAgICAqIEludGVyYWN0YWJsZS5lbGVtZW50XG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoaXMgaXMgbm90IGEgc2VsZWN0b3IgSW50ZXJhY3RhYmxlLCBpdCByZXR1cm5zIHRoZSBlbGVtZW50IHRoaXNcbiAgICAgICAgICogaW50ZXJhY3RhYmxlIHJlcHJlc2VudHNcbiAgICAgICAgICpcbiAgICAgICAgID0gKEVsZW1lbnQpIEhUTUwgLyBTVkcgRWxlbWVudFxuICAgICAgICBcXCovXG4gICAgICAgIGVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qXFxcbiAgICAgICAgICogSW50ZXJhY3RhYmxlLmZpcmVcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICpcbiAgICAgICAgICogQ2FsbHMgbGlzdGVuZXJzIGZvciB0aGUgZ2l2ZW4gSW50ZXJhY3RFdmVudCB0eXBlIGJvdW5kIGdsb2JhbGx5XG4gICAgICAgICAqIGFuZCBkaXJlY3RseSB0byB0aGlzIEludGVyYWN0YWJsZVxuICAgICAgICAgKlxuICAgICAgICAgLSBpRXZlbnQgKEludGVyYWN0RXZlbnQpIFRoZSBJbnRlcmFjdEV2ZW50IG9iamVjdCB0byBiZSBmaXJlZCBvbiB0aGlzIEludGVyYWN0YWJsZVxuICAgICAgICAgPSAoSW50ZXJhY3RhYmxlKSB0aGlzIEludGVyYWN0YWJsZVxuICAgICAgICBcXCovXG4gICAgICAgIGZpcmU6IGZ1bmN0aW9uIChpRXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghKGlFdmVudCAmJiBpRXZlbnQudHlwZSkgfHwgIWNvbnRhaW5zKGV2ZW50VHlwZXMsIGlFdmVudC50eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgbGVuLFxuICAgICAgICAgICAgICAgIG9uRXZlbnQgPSAnb24nICsgaUV2ZW50LnR5cGUsXG4gICAgICAgICAgICAgICAgZnVuY05hbWUgPSAnJztcblxuICAgICAgICAgICAgLy8gSW50ZXJhY3RhYmxlI29uKCkgbGlzdGVuZXJzXG4gICAgICAgICAgICBpZiAoaUV2ZW50LnR5cGUgaW4gdGhpcy5faUV2ZW50cykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IHRoaXMuX2lFdmVudHNbaUV2ZW50LnR5cGVdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbiAmJiAhaUV2ZW50LmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lID0gbGlzdGVuZXJzW2ldLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpXShpRXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW50ZXJhY3RhYmxlLm9uZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbb25FdmVudF0pKSB7XG4gICAgICAgICAgICAgICAgZnVuY05hbWUgPSB0aGlzW29uRXZlbnRdLm5hbWU7XG4gICAgICAgICAgICAgICAgdGhpc1tvbkV2ZW50XShpRXZlbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbnRlcmFjdC5vbigpIGxpc3RlbmVyc1xuICAgICAgICAgICAgaWYgKGlFdmVudC50eXBlIGluIGdsb2JhbEV2ZW50cyAmJiAobGlzdGVuZXJzID0gZ2xvYmFsRXZlbnRzW2lFdmVudC50eXBlXSkpICB7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuICYmICFpRXZlbnQuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWUgPSBsaXN0ZW5lcnNbaV0ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldKGlFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKlxcXG4gICAgICAgICAqIEludGVyYWN0YWJsZS5vblxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKlxuICAgICAgICAgKiBCaW5kcyBhIGxpc3RlbmVyIGZvciBhbiBJbnRlcmFjdEV2ZW50IG9yIERPTSBldmVudC5cbiAgICAgICAgICpcbiAgICAgICAgIC0gZXZlbnRUeXBlICAoc3RyaW5nIHwgYXJyYXkgfCBvYmplY3QpIFRoZSB0eXBlcyBvZiBldmVudHMgdG8gbGlzdGVuIGZvclxuICAgICAgICAgLSBsaXN0ZW5lciAgIChmdW5jdGlvbikgVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiB0aGUgZ2l2ZW4gZXZlbnQocylcbiAgICAgICAgIC0gdXNlQ2FwdHVyZSAoYm9vbGVhbikgI29wdGlvbmFsIHVzZUNhcHR1cmUgZmxhZyBmb3IgYWRkRXZlbnRMaXN0ZW5lclxuICAgICAgICAgPSAob2JqZWN0KSBUaGlzIEludGVyYWN0YWJsZVxuICAgICAgICBcXCovXG4gICAgICAgIG9uOiBmdW5jdGlvbiAoZXZlbnRUeXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICAgICAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhldmVudFR5cGUpICYmIGV2ZW50VHlwZS5zZWFyY2goJyAnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBldmVudFR5cGUgPSBldmVudFR5cGUudHJpbSgpLnNwbGl0KC8gKy8pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNBcnJheShldmVudFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50VHlwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uKGV2ZW50VHlwZVtpXSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNPYmplY3QoZXZlbnRUeXBlKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub24ocHJvcCwgZXZlbnRUeXBlW3Byb3BdLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChldmVudFR5cGUgPT09ICd3aGVlbCcpIHtcbiAgICAgICAgICAgICAgICBldmVudFR5cGUgPSB3aGVlbEV2ZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjb252ZXJ0IHRvIGJvb2xlYW5cbiAgICAgICAgICAgIHVzZUNhcHR1cmUgPSB1c2VDYXB0dXJlPyB0cnVlOiBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKGV2ZW50VHlwZXMsIGV2ZW50VHlwZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIHR5cGUgb2YgZXZlbnQgd2FzIG5ldmVyIGJvdW5kIHRvIHRoaXMgSW50ZXJhY3RhYmxlXG4gICAgICAgICAgICAgICAgaWYgKCEoZXZlbnRUeXBlIGluIHRoaXMuX2lFdmVudHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lFdmVudHNbZXZlbnRUeXBlXSA9IFtsaXN0ZW5lcl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pRXZlbnRzW2V2ZW50VHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGVsZWdhdGVkIGV2ZW50IGZvciBzZWxlY3RvclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIGlmICghZGVsZWdhdGVkRXZlbnRzW2V2ZW50VHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGVkRXZlbnRzW2V2ZW50VHlwZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dHMgOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyczogW11cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgZGVsZWdhdGUgbGlzdGVuZXIgZnVuY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkb2N1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5hZGQoZG9jdW1lbnRzW2ldLCBldmVudFR5cGUsIGRlbGVnYXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLmFkZChkb2N1bWVudHNbaV0sIGV2ZW50VHlwZSwgZGVsZWdhdGVVc2VDYXB0dXJlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBkZWxlZ2F0ZWQgPSBkZWxlZ2F0ZWRFdmVudHNbZXZlbnRUeXBlXSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gZGVsZWdhdGVkLnNlbGVjdG9ycy5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWxlZ2F0ZWQuc2VsZWN0b3JzW2luZGV4XSA9PT0gdGhpcy5zZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgZGVsZWdhdGVkLmNvbnRleHRzW2luZGV4XSA9PT0gdGhpcy5fY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gZGVsZWdhdGVkLnNlbGVjdG9ycy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGVkLnNlbGVjdG9ycy5wdXNoKHRoaXMuc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZWQuY29udGV4dHMgLnB1c2godGhpcy5fY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlZC5saXN0ZW5lcnMucHVzaChbXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8ga2VlcCBsaXN0ZW5lciBhbmQgdXNlQ2FwdHVyZSBmbGFnXG4gICAgICAgICAgICAgICAgZGVsZWdhdGVkLmxpc3RlbmVyc1tpbmRleF0ucHVzaChbbGlzdGVuZXIsIHVzZUNhcHR1cmVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2ZW50cy5hZGQodGhpcy5fZWxlbWVudCwgZXZlbnRUeXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qXFxcbiAgICAgICAgICogSW50ZXJhY3RhYmxlLm9mZlxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKlxuICAgICAgICAgKiBSZW1vdmVzIGFuIEludGVyYWN0RXZlbnQgb3IgRE9NIGV2ZW50IGxpc3RlbmVyXG4gICAgICAgICAqXG4gICAgICAgICAtIGV2ZW50VHlwZSAgKHN0cmluZyB8IGFycmF5IHwgb2JqZWN0KSBUaGUgdHlwZXMgb2YgZXZlbnRzIHRoYXQgd2VyZSBsaXN0ZW5lZCBmb3JcbiAgICAgICAgIC0gbGlzdGVuZXIgICAoZnVuY3Rpb24pIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byBiZSByZW1vdmVkXG4gICAgICAgICAtIHVzZUNhcHR1cmUgKGJvb2xlYW4pICNvcHRpb25hbCB1c2VDYXB0dXJlIGZsYWcgZm9yIHJlbW92ZUV2ZW50TGlzdGVuZXJcbiAgICAgICAgID0gKG9iamVjdCkgVGhpcyBJbnRlcmFjdGFibGVcbiAgICAgICAgXFwqL1xuICAgICAgICBvZmY6IGZ1bmN0aW9uIChldmVudFR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gICAgICAgICAgICB2YXIgaTtcblxuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGV2ZW50VHlwZSkgJiYgZXZlbnRUeXBlLnNlYXJjaCgnICcpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZS50cmltKCkuc3BsaXQoLyArLyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0FycmF5KGV2ZW50VHlwZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRUeXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2ZmKGV2ZW50VHlwZVtpXSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNPYmplY3QoZXZlbnRUeXBlKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2ZmKHByb3AsIGV2ZW50VHlwZVtwcm9wXSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZXZlbnRMaXN0LFxuICAgICAgICAgICAgICAgIGluZGV4ID0gLTE7XG5cbiAgICAgICAgICAgIC8vIGNvbnZlcnQgdG8gYm9vbGVhblxuICAgICAgICAgICAgdXNlQ2FwdHVyZSA9IHVzZUNhcHR1cmU/IHRydWU6IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoZXZlbnRUeXBlID09PSAnd2hlZWwnKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRUeXBlID0gd2hlZWxFdmVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgaXQgaXMgYW4gYWN0aW9uIGV2ZW50IHR5cGVcbiAgICAgICAgICAgIGlmIChjb250YWlucyhldmVudFR5cGVzLCBldmVudFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRMaXN0ID0gdGhpcy5faUV2ZW50c1tldmVudFR5cGVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50TGlzdCAmJiAoaW5kZXggPSBpbmRleE9mKGV2ZW50TGlzdCwgbGlzdGVuZXIpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faUV2ZW50c1tldmVudFR5cGVdLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGVsZWdhdGVkIGV2ZW50XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlbGVnYXRlZCA9IGRlbGVnYXRlZEV2ZW50c1tldmVudFR5cGVdLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaEZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWRlbGVnYXRlZCkgeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICAgICAgICAgICAgLy8gY291bnQgZnJvbSBsYXN0IGluZGV4IG9mIGRlbGVnYXRlZCB0byAwXG4gICAgICAgICAgICAgICAgZm9yIChpbmRleCA9IGRlbGVnYXRlZC5zZWxlY3RvcnMubGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBsb29rIGZvciBtYXRjaGluZyBzZWxlY3RvciBhbmQgY29udGV4dCBOb2RlXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWxlZ2F0ZWQuc2VsZWN0b3JzW2luZGV4XSA9PT0gdGhpcy5zZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgZGVsZWdhdGVkLmNvbnRleHRzW2luZGV4XSA9PT0gdGhpcy5fY29udGV4dCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gZGVsZWdhdGVkLmxpc3RlbmVyc1tpbmRleF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVhY2ggaXRlbSBvZiB0aGUgbGlzdGVuZXJzIGFycmF5IGlzIGFuIGFycmF5OiBbZnVuY3Rpb24sIHVzZUNhcHR1cmVGbGFnXVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gbGlzdGVuZXJzW2ldWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VDYXAgPSBsaXN0ZW5lcnNbaV1bMV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgbGlzdGVuZXIgZnVuY3Rpb25zIGFuZCB1c2VDYXB0dXJlIGZsYWdzIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZuID09PSBsaXN0ZW5lciAmJiB1c2VDYXAgPT09IHVzZUNhcHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBmcm9tIHRoZSBhcnJheSBvZiBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBhbGwgbGlzdGVuZXJzIGZvciB0aGlzIGludGVyYWN0YWJsZSBoYXZlIGJlZW4gcmVtb3ZlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGludGVyYWN0YWJsZSBmcm9tIHRoZSBkZWxlZ2F0ZWQgYXJyYXlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGVkLnNlbGVjdG9ycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGVkLmNvbnRleHRzIC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGVkLmxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgZGVsZWdhdGUgZnVuY3Rpb24gZnJvbSBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHMucmVtb3ZlKHRoaXMuX2NvbnRleHQsIGV2ZW50VHlwZSwgZGVsZWdhdGVMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHMucmVtb3ZlKHRoaXMuX2NvbnRleHQsIGV2ZW50VHlwZSwgZGVsZWdhdGVVc2VDYXB0dXJlLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBhcnJheXMgaWYgdGhleSBhcmUgZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGVsZWdhdGVkLnNlbGVjdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZWRFdmVudHNbZXZlbnRUeXBlXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHJlbW92ZSBvbmUgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoRm91bmQpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlbW92ZSBsaXN0ZW5lciBmcm9tIHRoaXMgSW50ZXJhdGFibGUncyBlbGVtZW50XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBldmVudHMucmVtb3ZlKHRoaXMuX2VsZW1lbnQsIGV2ZW50VHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKlxcXG4gICAgICAgICAqIEludGVyYWN0YWJsZS5zZXRcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICpcbiAgICAgICAgICogUmVzZXQgdGhlIG9wdGlvbnMgb2YgdGhpcyBJbnRlcmFjdGFibGVcbiAgICAgICAgIC0gb3B0aW9ucyAob2JqZWN0KSBUaGUgbmV3IHNldHRpbmdzIHRvIGFwcGx5XG4gICAgICAgICA9IChvYmplY3QpIFRoaXMgSW50ZXJhY3RhYmxlXG4gICAgICAgIFxcKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0T3B0aW9ucy5iYXNlKTtcblxuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgYWN0aW9ucyA9IFsnZHJhZycsICdkcm9wJywgJ3Jlc2l6ZScsICdnZXN0dXJlJ10sXG4gICAgICAgICAgICAgICAgbWV0aG9kcyA9IFsnZHJhZ2dhYmxlJywgJ2Ryb3B6b25lJywgJ3Jlc2l6YWJsZScsICdnZXN0dXJhYmxlJ10sXG4gICAgICAgICAgICAgICAgcGVyQWN0aW9ucyA9IGV4dGVuZChleHRlbmQoe30sIGRlZmF1bHRPcHRpb25zLnBlckFjdGlvbiksIG9wdGlvbnNbYWN0aW9uXSB8fCB7fSk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFjdGlvbiA9IGFjdGlvbnNbaV07XG5cbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbYWN0aW9uXSA9IGV4dGVuZCh7fSwgZGVmYXVsdE9wdGlvbnNbYWN0aW9uXSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNldFBlckFjdGlvbihhY3Rpb24sIHBlckFjdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2RzW2ldXShvcHRpb25zW2FjdGlvbl0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSBbXG4gICAgICAgICAgICAgICAgICAgICdhY2NlcHQnLCAnYWN0aW9uQ2hlY2tlcicsICdhbGxvd0Zyb20nLCAnZGVsdGFTb3VyY2UnLFxuICAgICAgICAgICAgICAgICAgICAnZHJvcENoZWNrZXInLCAnaWdub3JlRnJvbScsICdvcmlnaW4nLCAncHJldmVudERlZmF1bHQnLFxuICAgICAgICAgICAgICAgICAgICAncmVjdENoZWNrZXInLCAnc3R5bGVDdXJzb3InXG4gICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc2V0dGluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2V0dGluZyA9IHNldHRpbmdzW2ldO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW3NldHRpbmddID0gZGVmYXVsdE9wdGlvbnMuYmFzZVtzZXR0aW5nXTtcblxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tzZXR0aW5nXShvcHRpb25zW3NldHRpbmddKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qXFxcbiAgICAgICAgICogSW50ZXJhY3RhYmxlLnVuc2V0XG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqXG4gICAgICAgICAqIFJlbW92ZSB0aGlzIGludGVyYWN0YWJsZSBmcm9tIHRoZSBsaXN0IG9mIGludGVyYWN0YWJsZXMgYW5kIHJlbW92ZVxuICAgICAgICAgKiBpdCdzIGRyYWcsIGRyb3AsIHJlc2l6ZSBhbmQgZ2VzdHVyZSBjYXBhYmlsaXRpZXNcbiAgICAgICAgICpcbiAgICAgICAgID0gKG9iamVjdCkgQGludGVyYWN0XG4gICAgICAgIFxcKi9cbiAgICAgICAgdW5zZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGV2ZW50cy5yZW1vdmUodGhpcy5fZWxlbWVudCwgJ2FsbCcpO1xuXG4gICAgICAgICAgICBpZiAoIWlzU3RyaW5nKHRoaXMuc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRzLnJlbW92ZSh0aGlzLCAnYWxsJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHlsZUN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmN1cnNvciA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBkZWxlZ2F0ZWQgZXZlbnRzXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdHlwZSBpbiBkZWxlZ2F0ZWRFdmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGVnYXRlZCA9IGRlbGVnYXRlZEV2ZW50c1t0eXBlXTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbGVnYXRlZC5zZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxlZ2F0ZWQuc2VsZWN0b3JzW2ldID09PSB0aGlzLnNlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgZGVsZWdhdGVkLmNvbnRleHRzW2ldID09PSB0aGlzLl9jb250ZXh0KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZWQuc2VsZWN0b3JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZWQuY29udGV4dHMgLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZWQubGlzdGVuZXJzLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgYXJyYXlzIGlmIHRoZXkgYXJlIGVtcHR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWxlZ2F0ZWQuc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZWRFdmVudHNbdHlwZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLnJlbW92ZSh0aGlzLl9jb250ZXh0LCB0eXBlLCBkZWxlZ2F0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5yZW1vdmUodGhpcy5fY29udGV4dCwgdHlwZSwgZGVsZWdhdGVVc2VDYXB0dXJlLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZHJvcHpvbmUoZmFsc2UpO1xuXG4gICAgICAgICAgICBpbnRlcmFjdGFibGVzLnNwbGljZShpbmRleE9mKGludGVyYWN0YWJsZXMsIHRoaXMpLCAxKTtcblxuICAgICAgICAgICAgcmV0dXJuIGludGVyYWN0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHdhcm5PbmNlIChtZXRob2QsIG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIEludGVyYWN0YWJsZS5wcm90b3R5cGUuc25hcCA9IHdhcm5PbmNlKEludGVyYWN0YWJsZS5wcm90b3R5cGUuc25hcCxcbiAgICAgICAgICdJbnRlcmFjdGFibGUjc25hcCBpcyBkZXByZWNhdGVkLiBTZWUgdGhlIG5ldyBkb2N1bWVudGF0aW9uIGZvciBzbmFwcGluZyBhdCBodHRwOi8vaW50ZXJhY3Rqcy5pby9kb2NzL3NuYXBwaW5nJyk7XG4gICAgSW50ZXJhY3RhYmxlLnByb3RvdHlwZS5yZXN0cmljdCA9IHdhcm5PbmNlKEludGVyYWN0YWJsZS5wcm90b3R5cGUucmVzdHJpY3QsXG4gICAgICAgICAnSW50ZXJhY3RhYmxlI3Jlc3RyaWN0IGlzIGRlcHJlY2F0ZWQuIFNlZSB0aGUgbmV3IGRvY3VtZW50YXRpb24gZm9yIHJlc3RpY3RpbmcgYXQgaHR0cDovL2ludGVyYWN0anMuaW8vZG9jcy9yZXN0cmljdGlvbicpO1xuICAgIEludGVyYWN0YWJsZS5wcm90b3R5cGUuaW5lcnRpYSA9IHdhcm5PbmNlKEludGVyYWN0YWJsZS5wcm90b3R5cGUuaW5lcnRpYSxcbiAgICAgICAgICdJbnRlcmFjdGFibGUjaW5lcnRpYSBpcyBkZXByZWNhdGVkLiBTZWUgdGhlIG5ldyBkb2N1bWVudGF0aW9uIGZvciBpbmVydGlhIGF0IGh0dHA6Ly9pbnRlcmFjdGpzLmlvL2RvY3MvaW5lcnRpYScpO1xuICAgIEludGVyYWN0YWJsZS5wcm90b3R5cGUuYXV0b1Njcm9sbCA9IHdhcm5PbmNlKEludGVyYWN0YWJsZS5wcm90b3R5cGUuYXV0b1Njcm9sbCxcbiAgICAgICAgICdJbnRlcmFjdGFibGUjYXV0b1Njcm9sbCBpcyBkZXByZWNhdGVkLiBTZWUgdGhlIG5ldyBkb2N1bWVudGF0aW9uIGZvciBhdXRvU2Nyb2xsIGF0IGh0dHA6Ly9pbnRlcmFjdGpzLmlvL2RvY3MvI2F1dG9zY3JvbGwnKTtcbiAgICBJbnRlcmFjdGFibGUucHJvdG90eXBlLnNxdWFyZVJlc2l6ZSA9IHdhcm5PbmNlKEludGVyYWN0YWJsZS5wcm90b3R5cGUuc3F1YXJlUmVzaXplLFxuICAgICAgICAgJ0ludGVyYWN0YWJsZSNzcXVhcmVSZXNpemUgaXMgZGVwcmVjYXRlZC4gU2VlIGh0dHA6Ly9pbnRlcmFjdGpzLmlvL2RvY3MvI3Jlc2l6ZS1zcXVhcmUnKTtcblxuICAgIEludGVyYWN0YWJsZS5wcm90b3R5cGUuYWNjZXB0ID0gd2Fybk9uY2UoSW50ZXJhY3RhYmxlLnByb3RvdHlwZS5hY2NlcHQsXG4gICAgICAgICAnSW50ZXJhY3RhYmxlI2FjY2VwdCBpcyBkZXByZWNhdGVkLiB1c2UgSW50ZXJhY3RhYmxlI2Ryb3B6b25lKHsgYWNjZXB0OiB0YXJnZXQgfSkgaW5zdGVhZCcpO1xuICAgIEludGVyYWN0YWJsZS5wcm90b3R5cGUuZHJvcENoZWNrZXIgPSB3YXJuT25jZShJbnRlcmFjdGFibGUucHJvdG90eXBlLmRyb3BDaGVja2VyLFxuICAgICAgICAgJ0ludGVyYWN0YWJsZSNkcm9wQ2hlY2tlciBpcyBkZXByZWNhdGVkLiB1c2UgSW50ZXJhY3RhYmxlI2Ryb3B6b25lKHsgZHJvcENoZWNrZXI6IGNoZWNrZXJGdW5jdGlvbiB9KSBpbnN0ZWFkJyk7XG4gICAgSW50ZXJhY3RhYmxlLnByb3RvdHlwZS5jb250ZXh0ID0gd2Fybk9uY2UoSW50ZXJhY3RhYmxlLnByb3RvdHlwZS5jb250ZXh0LFxuICAgICAgICAgJ0ludGVyYWN0YWJsZSNjb250ZXh0IGFzIGEgbWV0aG9kIGlzIGRlcHJlY2F0ZWQuIEl0IHdpbGwgc29vbiBiZSBhIERPTSBOb2RlIGluc3RlYWQnKTtcblxuICAgIC8qXFxcbiAgICAgKiBpbnRlcmFjdC5pc1NldFxuICAgICBbIG1ldGhvZCBdXG4gICAgICpcbiAgICAgKiBDaGVjayBpZiBhbiBlbGVtZW50IGhhcyBiZWVuIHNldFxuICAgICAtIGVsZW1lbnQgKEVsZW1lbnQpIFRoZSBFbGVtZW50IGJlaW5nIHNlYXJjaGVkIGZvclxuICAgICA9IChib29sZWFuKSBJbmRpY2F0ZXMgaWYgdGhlIGVsZW1lbnQgb3IgQ1NTIHNlbGVjdG9yIHdhcyBwcmV2aW91c2x5IHBhc3NlZCB0byBpbnRlcmFjdFxuICAgIFxcKi9cbiAgICBpbnRlcmFjdC5pc1NldCA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGludGVyYWN0YWJsZXMuaW5kZXhPZkVsZW1lbnQoZWxlbWVudCwgb3B0aW9ucyAmJiBvcHRpb25zLmNvbnRleHQpICE9PSAtMTtcbiAgICB9O1xuXG4gICAgLypcXFxuICAgICAqIGludGVyYWN0Lm9uXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKlxuICAgICAqIEFkZHMgYSBnbG9iYWwgbGlzdGVuZXIgZm9yIGFuIEludGVyYWN0RXZlbnQgb3IgYWRkcyBhIERPTSBldmVudCB0b1xuICAgICAqIGBkb2N1bWVudGBcbiAgICAgKlxuICAgICAtIHR5cGUgICAgICAgKHN0cmluZyB8IGFycmF5IHwgb2JqZWN0KSBUaGUgdHlwZXMgb2YgZXZlbnRzIHRvIGxpc3RlbiBmb3JcbiAgICAgLSBsaXN0ZW5lciAgIChmdW5jdGlvbikgVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiB0aGUgZ2l2ZW4gZXZlbnQocylcbiAgICAgLSB1c2VDYXB0dXJlIChib29sZWFuKSAjb3B0aW9uYWwgdXNlQ2FwdHVyZSBmbGFnIGZvciBhZGRFdmVudExpc3RlbmVyXG4gICAgID0gKG9iamVjdCkgaW50ZXJhY3RcbiAgICBcXCovXG4gICAgaW50ZXJhY3Qub24gPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcbiAgICAgICAgaWYgKGlzU3RyaW5nKHR5cGUpICYmIHR5cGUuc2VhcmNoKCcgJykgIT09IC0xKSB7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS50cmltKCkuc3BsaXQoLyArLyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNBcnJheSh0eXBlKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJhY3Qub24odHlwZVtpXSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJhY3Q7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNPYmplY3QodHlwZSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gdHlwZSkge1xuICAgICAgICAgICAgICAgIGludGVyYWN0Lm9uKHByb3AsIHR5cGVbcHJvcF0sIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGludGVyYWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgaXQgaXMgYW4gSW50ZXJhY3RFdmVudCB0eXBlLCBhZGQgbGlzdGVuZXIgdG8gZ2xvYmFsRXZlbnRzXG4gICAgICAgIGlmIChjb250YWlucyhldmVudFR5cGVzLCB0eXBlKSkge1xuICAgICAgICAgICAgLy8gaWYgdGhpcyB0eXBlIG9mIGV2ZW50IHdhcyBuZXZlciBib3VuZFxuICAgICAgICAgICAgaWYgKCFnbG9iYWxFdmVudHNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICBnbG9iYWxFdmVudHNbdHlwZV0gPSBbbGlzdGVuZXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsRXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vbiBJbnRlcmFjdEV2ZW50IHR5cGUsIGFkZEV2ZW50TGlzdGVuZXIgdG8gZG9jdW1lbnRcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBldmVudHMuYWRkKGRvY3VtZW50LCB0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW50ZXJhY3Q7XG4gICAgfTtcblxuICAgIC8qXFxcbiAgICAgKiBpbnRlcmFjdC5vZmZcbiAgICAgWyBtZXRob2QgXVxuICAgICAqXG4gICAgICogUmVtb3ZlcyBhIGdsb2JhbCBJbnRlcmFjdEV2ZW50IGxpc3RlbmVyIG9yIERPTSBldmVudCBmcm9tIGBkb2N1bWVudGBcbiAgICAgKlxuICAgICAtIHR5cGUgICAgICAgKHN0cmluZyB8IGFycmF5IHwgb2JqZWN0KSBUaGUgdHlwZXMgb2YgZXZlbnRzIHRoYXQgd2VyZSBsaXN0ZW5lZCBmb3JcbiAgICAgLSBsaXN0ZW5lciAgIChmdW5jdGlvbikgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIHJlbW92ZWRcbiAgICAgLSB1c2VDYXB0dXJlIChib29sZWFuKSAjb3B0aW9uYWwgdXNlQ2FwdHVyZSBmbGFnIGZvciByZW1vdmVFdmVudExpc3RlbmVyXG4gICAgID0gKG9iamVjdCkgaW50ZXJhY3RcbiAgICAgXFwqL1xuICAgIGludGVyYWN0Lm9mZiA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICAgICAgICBpZiAoaXNTdHJpbmcodHlwZSkgJiYgdHlwZS5zZWFyY2goJyAnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLnRyaW0oKS5zcGxpdCgvICsvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpbnRlcmFjdC5vZmYodHlwZVtpXSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJhY3Q7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNPYmplY3QodHlwZSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gdHlwZSkge1xuICAgICAgICAgICAgICAgIGludGVyYWN0Lm9mZihwcm9wLCB0eXBlW3Byb3BdLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbnRlcmFjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY29udGFpbnMoZXZlbnRUeXBlcywgdHlwZSkpIHtcbiAgICAgICAgICAgIGV2ZW50cy5yZW1vdmUoZG9jdW1lbnQsIHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbmRleDtcblxuICAgICAgICAgICAgaWYgKHR5cGUgaW4gZ2xvYmFsRXZlbnRzXG4gICAgICAgICAgICAgICAgJiYgKGluZGV4ID0gaW5kZXhPZihnbG9iYWxFdmVudHNbdHlwZV0sIGxpc3RlbmVyKSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsRXZlbnRzW3R5cGVdLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW50ZXJhY3Q7XG4gICAgfTtcblxuICAgIC8qXFxcbiAgICAgKiBpbnRlcmFjdC5lbmFibGVEcmFnZ2luZ1xuICAgICBbIG1ldGhvZCBdXG4gICAgICpcbiAgICAgKiBEZXByZWNhdGVkLlxuICAgICAqXG4gICAgICogUmV0dXJucyBvciBzZXRzIHdoZXRoZXIgZHJhZ2dpbmcgaXMgZW5hYmxlZCBmb3IgYW55IEludGVyYWN0YWJsZXNcbiAgICAgKlxuICAgICAtIG5ld1ZhbHVlIChib29sZWFuKSAjb3B0aW9uYWwgYHRydWVgIHRvIGFsbG93IHRoZSBhY3Rpb247IGBmYWxzZWAgdG8gZGlzYWJsZSBhY3Rpb24gZm9yIGFsbCBJbnRlcmFjdGFibGVzXG4gICAgID0gKGJvb2xlYW4gfCBvYmplY3QpIFRoZSBjdXJyZW50IHNldHRpbmcgb3IgaW50ZXJhY3RcbiAgICBcXCovXG4gICAgaW50ZXJhY3QuZW5hYmxlRHJhZ2dpbmcgPSB3YXJuT25jZShmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBudWxsICYmIG5ld1ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFjdGlvbklzRW5hYmxlZC5kcmFnID0gbmV3VmFsdWU7XG5cbiAgICAgICAgICAgIHJldHVybiBpbnRlcmFjdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aW9uSXNFbmFibGVkLmRyYWc7XG4gICAgfSwgJ2ludGVyYWN0LmVuYWJsZURyYWdnaW5nIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgc29vbiBiZSByZW1vdmVkLicpO1xuXG4gICAgLypcXFxuICAgICAqIGludGVyYWN0LmVuYWJsZVJlc2l6aW5nXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKlxuICAgICAqIERlcHJlY2F0ZWQuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIG9yIHNldHMgd2hldGhlciByZXNpemluZyBpcyBlbmFibGVkIGZvciBhbnkgSW50ZXJhY3RhYmxlc1xuICAgICAqXG4gICAgIC0gbmV3VmFsdWUgKGJvb2xlYW4pICNvcHRpb25hbCBgdHJ1ZWAgdG8gYWxsb3cgdGhlIGFjdGlvbjsgYGZhbHNlYCB0byBkaXNhYmxlIGFjdGlvbiBmb3IgYWxsIEludGVyYWN0YWJsZXNcbiAgICAgPSAoYm9vbGVhbiB8IG9iamVjdCkgVGhlIGN1cnJlbnQgc2V0dGluZyBvciBpbnRlcmFjdFxuICAgIFxcKi9cbiAgICBpbnRlcmFjdC5lbmFibGVSZXNpemluZyA9IHdhcm5PbmNlKGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICBpZiAobmV3VmFsdWUgIT09IG51bGwgJiYgbmV3VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYWN0aW9uSXNFbmFibGVkLnJlc2l6ZSA9IG5ld1ZhbHVlO1xuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJhY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjdGlvbklzRW5hYmxlZC5yZXNpemU7XG4gICAgfSwgJ2ludGVyYWN0LmVuYWJsZVJlc2l6aW5nIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgc29vbiBiZSByZW1vdmVkLicpO1xuXG4gICAgLypcXFxuICAgICAqIGludGVyYWN0LmVuYWJsZUdlc3R1cmluZ1xuICAgICBbIG1ldGhvZCBdXG4gICAgICpcbiAgICAgKiBEZXByZWNhdGVkLlxuICAgICAqXG4gICAgICogUmV0dXJucyBvciBzZXRzIHdoZXRoZXIgZ2VzdHVyaW5nIGlzIGVuYWJsZWQgZm9yIGFueSBJbnRlcmFjdGFibGVzXG4gICAgICpcbiAgICAgLSBuZXdWYWx1ZSAoYm9vbGVhbikgI29wdGlvbmFsIGB0cnVlYCB0byBhbGxvdyB0aGUgYWN0aW9uOyBgZmFsc2VgIHRvIGRpc2FibGUgYWN0aW9uIGZvciBhbGwgSW50ZXJhY3RhYmxlc1xuICAgICA9IChib29sZWFuIHwgb2JqZWN0KSBUaGUgY3VycmVudCBzZXR0aW5nIG9yIGludGVyYWN0XG4gICAgXFwqL1xuICAgIGludGVyYWN0LmVuYWJsZUdlc3R1cmluZyA9IHdhcm5PbmNlKGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICBpZiAobmV3VmFsdWUgIT09IG51bGwgJiYgbmV3VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYWN0aW9uSXNFbmFibGVkLmdlc3R1cmUgPSBuZXdWYWx1ZTtcblxuICAgICAgICAgICAgcmV0dXJuIGludGVyYWN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3Rpb25Jc0VuYWJsZWQuZ2VzdHVyZTtcbiAgICB9LCAnaW50ZXJhY3QuZW5hYmxlR2VzdHVyaW5nIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgc29vbiBiZSByZW1vdmVkLicpO1xuXG4gICAgaW50ZXJhY3QuZXZlbnRUeXBlcyA9IGV2ZW50VHlwZXM7XG5cbiAgICAvKlxcXG4gICAgICogaW50ZXJhY3QuZGVidWdcbiAgICAgWyBtZXRob2QgXVxuICAgICAqXG4gICAgICogUmV0dXJucyBkZWJ1Z2dpbmcgZGF0YVxuICAgICA9IChvYmplY3QpIEFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgdGhhdCBvdXRsaW5lIHRoZSBjdXJyZW50IHN0YXRlIGFuZCBleHBvc2UgaW50ZXJuYWwgZnVuY3Rpb25zIGFuZCB2YXJpYWJsZXNcbiAgICBcXCovXG4gICAgaW50ZXJhY3QuZGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnRlcmFjdGlvbiA9IGludGVyYWN0aW9uc1swXSB8fCBuZXcgSW50ZXJhY3Rpb24oKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW50ZXJhY3Rpb25zICAgICAgICAgIDogaW50ZXJhY3Rpb25zLFxuICAgICAgICAgICAgdGFyZ2V0ICAgICAgICAgICAgICAgIDogaW50ZXJhY3Rpb24udGFyZ2V0LFxuICAgICAgICAgICAgZHJhZ2dpbmcgICAgICAgICAgICAgIDogaW50ZXJhY3Rpb24uZHJhZ2dpbmcsXG4gICAgICAgICAgICByZXNpemluZyAgICAgICAgICAgICAgOiBpbnRlcmFjdGlvbi5yZXNpemluZyxcbiAgICAgICAgICAgIGdlc3R1cmluZyAgICAgICAgICAgICA6IGludGVyYWN0aW9uLmdlc3R1cmluZyxcbiAgICAgICAgICAgIHByZXBhcmVkICAgICAgICAgICAgICA6IGludGVyYWN0aW9uLnByZXBhcmVkLFxuICAgICAgICAgICAgbWF0Y2hlcyAgICAgICAgICAgICAgIDogaW50ZXJhY3Rpb24ubWF0Y2hlcyxcbiAgICAgICAgICAgIG1hdGNoRWxlbWVudHMgICAgICAgICA6IGludGVyYWN0aW9uLm1hdGNoRWxlbWVudHMsXG5cbiAgICAgICAgICAgIHByZXZDb29yZHMgICAgICAgICAgICA6IGludGVyYWN0aW9uLnByZXZDb29yZHMsXG4gICAgICAgICAgICBzdGFydENvb3JkcyAgICAgICAgICAgOiBpbnRlcmFjdGlvbi5zdGFydENvb3JkcyxcblxuICAgICAgICAgICAgcG9pbnRlcklkcyAgICAgICAgICAgIDogaW50ZXJhY3Rpb24ucG9pbnRlcklkcyxcbiAgICAgICAgICAgIHBvaW50ZXJzICAgICAgICAgICAgICA6IGludGVyYWN0aW9uLnBvaW50ZXJzLFxuICAgICAgICAgICAgYWRkUG9pbnRlciAgICAgICAgICAgIDogbGlzdGVuZXJzLmFkZFBvaW50ZXIsXG4gICAgICAgICAgICByZW1vdmVQb2ludGVyICAgICAgICAgOiBsaXN0ZW5lcnMucmVtb3ZlUG9pbnRlcixcbiAgICAgICAgICAgIHJlY29yZFBvaW50ZXIgICAgICAgIDogbGlzdGVuZXJzLnJlY29yZFBvaW50ZXIsXG5cbiAgICAgICAgICAgIHNuYXAgICAgICAgICAgICAgICAgICA6IGludGVyYWN0aW9uLnNuYXBTdGF0dXMsXG4gICAgICAgICAgICByZXN0cmljdCAgICAgICAgICAgICAgOiBpbnRlcmFjdGlvbi5yZXN0cmljdFN0YXR1cyxcbiAgICAgICAgICAgIGluZXJ0aWEgICAgICAgICAgICAgICA6IGludGVyYWN0aW9uLmluZXJ0aWFTdGF0dXMsXG5cbiAgICAgICAgICAgIGRvd25UaW1lICAgICAgICAgICAgICA6IGludGVyYWN0aW9uLmRvd25UaW1lc1swXSxcbiAgICAgICAgICAgIGRvd25FdmVudCAgICAgICAgICAgICA6IGludGVyYWN0aW9uLmRvd25FdmVudCxcbiAgICAgICAgICAgIGRvd25Qb2ludGVyICAgICAgICAgICA6IGludGVyYWN0aW9uLmRvd25Qb2ludGVyLFxuICAgICAgICAgICAgcHJldkV2ZW50ICAgICAgICAgICAgIDogaW50ZXJhY3Rpb24ucHJldkV2ZW50LFxuXG4gICAgICAgICAgICBJbnRlcmFjdGFibGUgICAgICAgICAgOiBJbnRlcmFjdGFibGUsXG4gICAgICAgICAgICBpbnRlcmFjdGFibGVzICAgICAgICAgOiBpbnRlcmFjdGFibGVzLFxuICAgICAgICAgICAgcG9pbnRlcklzRG93biAgICAgICAgIDogaW50ZXJhY3Rpb24ucG9pbnRlcklzRG93bixcbiAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zICAgICAgICA6IGRlZmF1bHRPcHRpb25zLFxuICAgICAgICAgICAgZGVmYXVsdEFjdGlvbkNoZWNrZXIgIDogZGVmYXVsdEFjdGlvbkNoZWNrZXIsXG5cbiAgICAgICAgICAgIGFjdGlvbkN1cnNvcnMgICAgICAgICA6IGFjdGlvbkN1cnNvcnMsXG4gICAgICAgICAgICBkcmFnTW92ZSAgICAgICAgICAgICAgOiBsaXN0ZW5lcnMuZHJhZ01vdmUsXG4gICAgICAgICAgICByZXNpemVNb3ZlICAgICAgICAgICAgOiBsaXN0ZW5lcnMucmVzaXplTW92ZSxcbiAgICAgICAgICAgIGdlc3R1cmVNb3ZlICAgICAgICAgICA6IGxpc3RlbmVycy5nZXN0dXJlTW92ZSxcbiAgICAgICAgICAgIHBvaW50ZXJVcCAgICAgICAgICAgICA6IGxpc3RlbmVycy5wb2ludGVyVXAsXG4gICAgICAgICAgICBwb2ludGVyRG93biAgICAgICAgICAgOiBsaXN0ZW5lcnMucG9pbnRlckRvd24sXG4gICAgICAgICAgICBwb2ludGVyTW92ZSAgICAgICAgICAgOiBsaXN0ZW5lcnMucG9pbnRlck1vdmUsXG4gICAgICAgICAgICBwb2ludGVySG92ZXIgICAgICAgICAgOiBsaXN0ZW5lcnMucG9pbnRlckhvdmVyLFxuXG4gICAgICAgICAgICBldmVudFR5cGVzICAgICAgICAgICAgOiBldmVudFR5cGVzLFxuXG4gICAgICAgICAgICBldmVudHMgICAgICAgICAgICAgICAgOiBldmVudHMsXG4gICAgICAgICAgICBnbG9iYWxFdmVudHMgICAgICAgICAgOiBnbG9iYWxFdmVudHMsXG4gICAgICAgICAgICBkZWxlZ2F0ZWRFdmVudHMgICAgICAgOiBkZWxlZ2F0ZWRFdmVudHMsXG5cbiAgICAgICAgICAgIHByZWZpeGVkUHJvcFJFcyAgICAgICA6IHByZWZpeGVkUHJvcFJFc1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBleHBvc2UgdGhlIGZ1bmN0aW9ucyB1c2VkIHRvIGNhbGN1bGF0ZSBtdWx0aS10b3VjaCBwcm9wZXJ0aWVzXG4gICAgaW50ZXJhY3QuZ2V0UG9pbnRlckF2ZXJhZ2UgPSBwb2ludGVyQXZlcmFnZTtcbiAgICBpbnRlcmFjdC5nZXRUb3VjaEJCb3ggICAgID0gdG91Y2hCQm94O1xuICAgIGludGVyYWN0LmdldFRvdWNoRGlzdGFuY2UgPSB0b3VjaERpc3RhbmNlO1xuICAgIGludGVyYWN0LmdldFRvdWNoQW5nbGUgICAgPSB0b3VjaEFuZ2xlO1xuXG4gICAgaW50ZXJhY3QuZ2V0RWxlbWVudFJlY3QgICAgICAgICA9IGdldEVsZW1lbnRSZWN0O1xuICAgIGludGVyYWN0LmdldEVsZW1lbnRDbGllbnRSZWN0ICAgPSBnZXRFbGVtZW50Q2xpZW50UmVjdDtcbiAgICBpbnRlcmFjdC5tYXRjaGVzU2VsZWN0b3IgICAgICAgID0gbWF0Y2hlc1NlbGVjdG9yO1xuICAgIGludGVyYWN0LmNsb3Nlc3QgICAgICAgICAgICAgICAgPSBjbG9zZXN0O1xuXG4gICAgLypcXFxuICAgICAqIGludGVyYWN0Lm1hcmdpblxuICAgICBbIG1ldGhvZCBdXG4gICAgICpcbiAgICAgKiBEZXByZWNhdGVkLiBVc2UgYGludGVyYWN0KHRhcmdldCkucmVzaXphYmxlKHsgbWFyZ2luOiBudW1iZXIgfSk7YCBpbnN0ZWFkLlxuICAgICAqIFJldHVybnMgb3Igc2V0cyB0aGUgbWFyZ2luIGZvciBhdXRvY2hlY2sgcmVzaXppbmcgdXNlZCBpblxuICAgICAqIEBJbnRlcmFjdGFibGUuZ2V0QWN0aW9uLiBUaGF0IGlzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBib3R0b20gYW5kIHJpZ2h0XG4gICAgICogZWRnZXMgb2YgYW4gZWxlbWVudCBjbGlja2luZyBpbiB3aGljaCB3aWxsIHN0YXJ0IHJlc2l6aW5nXG4gICAgICpcbiAgICAgLSBuZXdWYWx1ZSAobnVtYmVyKSAjb3B0aW9uYWxcbiAgICAgPSAobnVtYmVyIHwgaW50ZXJhY3QpIFRoZSBjdXJyZW50IG1hcmdpbiB2YWx1ZSBvciBpbnRlcmFjdFxuICAgIFxcKi9cbiAgICBpbnRlcmFjdC5tYXJnaW4gPSB3YXJuT25jZShmdW5jdGlvbiAobmV3dmFsdWUpIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKG5ld3ZhbHVlKSkge1xuICAgICAgICAgICAgbWFyZ2luID0gbmV3dmFsdWU7XG5cbiAgICAgICAgICAgIHJldHVybiBpbnRlcmFjdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFyZ2luO1xuICAgIH0sXG4gICAgJ2ludGVyYWN0Lm1hcmdpbiBpcyBkZXByZWNhdGVkLiBVc2UgaW50ZXJhY3QodGFyZ2V0KS5yZXNpemFibGUoeyBtYXJnaW46IG51bWJlciB9KTsgaW5zdGVhZC4nKSA7XG5cbiAgICAvKlxcXG4gICAgICogaW50ZXJhY3Quc3VwcG9ydHNUb3VjaFxuICAgICBbIG1ldGhvZCBdXG4gICAgICpcbiAgICAgPSAoYm9vbGVhbikgV2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdG91Y2ggaW5wdXRcbiAgICBcXCovXG4gICAgaW50ZXJhY3Quc3VwcG9ydHNUb3VjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHN1cHBvcnRzVG91Y2g7XG4gICAgfTtcblxuICAgIC8qXFxcbiAgICAgKiBpbnRlcmFjdC5zdXBwb3J0c1BvaW50ZXJFdmVudFxuICAgICBbIG1ldGhvZCBdXG4gICAgICpcbiAgICAgPSAoYm9vbGVhbikgV2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgc3VwcG9ydHMgUG9pbnRlckV2ZW50c1xuICAgIFxcKi9cbiAgICBpbnRlcmFjdC5zdXBwb3J0c1BvaW50ZXJFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHN1cHBvcnRzUG9pbnRlckV2ZW50O1xuICAgIH07XG5cbiAgICAvKlxcXG4gICAgICogaW50ZXJhY3Quc3RvcFxuICAgICBbIG1ldGhvZCBdXG4gICAgICpcbiAgICAgKiBDYW5jZWxzIGFsbCBpbnRlcmFjdGlvbnMgKGVuZCBldmVudHMgYXJlIG5vdCBmaXJlZClcbiAgICAgKlxuICAgICAtIGV2ZW50IChFdmVudCkgQW4gZXZlbnQgb24gd2hpY2ggdG8gY2FsbCBwcmV2ZW50RGVmYXVsdCgpXG4gICAgID0gKG9iamVjdCkgaW50ZXJhY3RcbiAgICBcXCovXG4gICAgaW50ZXJhY3Quc3RvcCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBmb3IgKHZhciBpID0gaW50ZXJhY3Rpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpbnRlcmFjdGlvbnNbaV0uc3RvcChldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW50ZXJhY3Q7XG4gICAgfTtcblxuICAgIC8qXFxcbiAgICAgKiBpbnRlcmFjdC5keW5hbWljRHJvcFxuICAgICBbIG1ldGhvZCBdXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIG9yIHNldHMgd2hldGhlciB0aGUgZGltZW5zaW9ucyBvZiBkcm9wem9uZSBlbGVtZW50cyBhcmVcbiAgICAgKiBjYWxjdWxhdGVkIG9uIGV2ZXJ5IGRyYWdtb3ZlIG9yIG9ubHkgb24gZHJhZ3N0YXJ0IGZvciB0aGUgZGVmYXVsdFxuICAgICAqIGRyb3BDaGVja2VyXG4gICAgICpcbiAgICAgLSBuZXdWYWx1ZSAoYm9vbGVhbikgI29wdGlvbmFsIFRydWUgdG8gY2hlY2sgb24gZWFjaCBtb3ZlLiBGYWxzZSB0byBjaGVjayBvbmx5IGJlZm9yZSBzdGFydFxuICAgICA9IChib29sZWFuIHwgaW50ZXJhY3QpIFRoZSBjdXJyZW50IHNldHRpbmcgb3IgaW50ZXJhY3RcbiAgICBcXCovXG4gICAgaW50ZXJhY3QuZHluYW1pY0Ryb3AgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQm9vbChuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgIC8vaWYgKGRyYWdnaW5nICYmIGR5bmFtaWNEcm9wICE9PSBuZXdWYWx1ZSAmJiAhbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvL2NhbGNSZWN0cyhkcm9wem9uZXMpO1xuICAgICAgICAgICAgLy99XG5cbiAgICAgICAgICAgIGR5bmFtaWNEcm9wID0gbmV3VmFsdWU7XG5cbiAgICAgICAgICAgIHJldHVybiBpbnRlcmFjdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHluYW1pY0Ryb3A7XG4gICAgfTtcblxuICAgIC8qXFxcbiAgICAgKiBpbnRlcmFjdC5wb2ludGVyTW92ZVRvbGVyYW5jZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICogUmV0dXJucyBvciBzZXRzIHRoZSBkaXN0YW5jZSB0aGUgcG9pbnRlciBtdXN0IGJlIG1vdmVkIGJlZm9yZSBhbiBhY3Rpb25cbiAgICAgKiBzZXF1ZW5jZSBvY2N1cnMuIFRoaXMgYWxzbyBhZmZlY3RzIHRvbGVyYW5jZSBmb3IgdGFwIGV2ZW50cy5cbiAgICAgKlxuICAgICAtIG5ld1ZhbHVlIChudW1iZXIpICNvcHRpb25hbCBUaGUgbW92ZW1lbnQgZnJvbSB0aGUgc3RhcnQgcG9zaXRpb24gbXVzdCBiZSBncmVhdGVyIHRoYW4gdGhpcyB2YWx1ZVxuICAgICA9IChudW1iZXIgfCBJbnRlcmFjdGFibGUpIFRoZSBjdXJyZW50IHNldHRpbmcgb3IgaW50ZXJhY3RcbiAgICBcXCovXG4gICAgaW50ZXJhY3QucG9pbnRlck1vdmVUb2xlcmFuY2UgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgcG9pbnRlck1vdmVUb2xlcmFuY2UgPSBuZXdWYWx1ZTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9pbnRlck1vdmVUb2xlcmFuY2U7XG4gICAgfTtcblxuICAgIC8qXFxcbiAgICAgKiBpbnRlcmFjdC5tYXhJbnRlcmFjdGlvbnNcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgb3Igc2V0cyB0aGUgbWF4aW11bSBudW1iZXIgb2YgY29uY3VycmVudCBpbnRlcmFjdGlvbnMgYWxsb3dlZC5cbiAgICAgKiBCeSBkZWZhdWx0IG9ubHkgMSBpbnRlcmFjdGlvbiBpcyBhbGxvd2VkIGF0IGEgdGltZSAoZm9yIGJhY2t3YXJkc1xuICAgICAqIGNvbXBhdGliaWxpdHkpLiBUbyBhbGxvdyBtdWx0aXBsZSBpbnRlcmFjdGlvbnMgb24gdGhlIHNhbWUgSW50ZXJhY3RhYmxlc1xuICAgICAqIGFuZCBlbGVtZW50cywgeW91IG5lZWQgdG8gZW5hYmxlIGl0IGluIHRoZSBkcmFnZ2FibGUsIHJlc2l6YWJsZSBhbmRcbiAgICAgKiBnZXN0dXJhYmxlIGAnbWF4J2AgYW5kIGAnbWF4UGVyRWxlbWVudCdgIG9wdGlvbnMuXG4gICAgICoqXG4gICAgIC0gbmV3VmFsdWUgKG51bWJlcikgI29wdGlvbmFsIEFueSBudW1iZXIuIG5ld1ZhbHVlIDw9IDAgbWVhbnMgbm8gaW50ZXJhY3Rpb25zLlxuICAgIFxcKi9cbiAgICBpbnRlcmFjdC5tYXhJbnRlcmFjdGlvbnMgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgbWF4SW50ZXJhY3Rpb25zID0gbmV3VmFsdWU7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1heEludGVyYWN0aW9ucztcbiAgICB9O1xuXG4gICAgaW50ZXJhY3QuY3JlYXRlU25hcEdyaWQgPSBmdW5jdGlvbiAoZ3JpZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXRYID0gMCxcbiAgICAgICAgICAgICAgICBvZmZzZXRZID0gMDtcblxuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGdyaWQub2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIG9mZnNldFggPSBncmlkLm9mZnNldC54O1xuICAgICAgICAgICAgICAgIG9mZnNldFkgPSBncmlkLm9mZnNldC55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZ3JpZHggPSBNYXRoLnJvdW5kKCh4IC0gb2Zmc2V0WCkgLyBncmlkLngpLFxuICAgICAgICAgICAgICAgIGdyaWR5ID0gTWF0aC5yb3VuZCgoeSAtIG9mZnNldFkpIC8gZ3JpZC55KSxcblxuICAgICAgICAgICAgICAgIG5ld1ggPSBncmlkeCAqIGdyaWQueCArIG9mZnNldFgsXG4gICAgICAgICAgICAgICAgbmV3WSA9IGdyaWR5ICogZ3JpZC55ICsgb2Zmc2V0WTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBuZXdYLFxuICAgICAgICAgICAgICAgIHk6IG5ld1ksXG4gICAgICAgICAgICAgICAgcmFuZ2U6IGdyaWQucmFuZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGVuZEFsbEludGVyYWN0aW9ucyAoZXZlbnQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnRlcmFjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGludGVyYWN0aW9uc1tpXS5wb2ludGVyRW5kKGV2ZW50LCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0ZW5Ub0RvY3VtZW50IChkb2MpIHtcbiAgICAgICAgaWYgKGNvbnRhaW5zKGRvY3VtZW50cywgZG9jKSkgeyByZXR1cm47IH1cblxuICAgICAgICB2YXIgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG5cbiAgICAgICAgLy8gYWRkIGRlbGVnYXRlIGV2ZW50IGxpc3RlbmVyXG4gICAgICAgIGZvciAodmFyIGV2ZW50VHlwZSBpbiBkZWxlZ2F0ZWRFdmVudHMpIHtcbiAgICAgICAgICAgIGV2ZW50cy5hZGQoZG9jLCBldmVudFR5cGUsIGRlbGVnYXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgZXZlbnRzLmFkZChkb2MsIGV2ZW50VHlwZSwgZGVsZWdhdGVVc2VDYXB0dXJlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChQb2ludGVyRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChQb2ludGVyRXZlbnQgPT09IHdpbi5NU1BvaW50ZXJFdmVudCkge1xuICAgICAgICAgICAgICAgIHBFdmVudFR5cGVzID0ge1xuICAgICAgICAgICAgICAgICAgICB1cDogJ01TUG9pbnRlclVwJywgZG93bjogJ01TUG9pbnRlckRvd24nLCBvdmVyOiAnbW91c2VvdmVyJyxcbiAgICAgICAgICAgICAgICAgICAgb3V0OiAnbW91c2VvdXQnLCBtb3ZlOiAnTVNQb2ludGVyTW92ZScsIGNhbmNlbDogJ01TUG9pbnRlckNhbmNlbCcgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBFdmVudFR5cGVzID0ge1xuICAgICAgICAgICAgICAgICAgICB1cDogJ3BvaW50ZXJ1cCcsIGRvd246ICdwb2ludGVyZG93bicsIG92ZXI6ICdwb2ludGVyb3ZlcicsXG4gICAgICAgICAgICAgICAgICAgIG91dDogJ3BvaW50ZXJvdXQnLCBtb3ZlOiAncG9pbnRlcm1vdmUnLCBjYW5jZWw6ICdwb2ludGVyY2FuY2VsJyB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBldmVudHMuYWRkKGRvYywgcEV2ZW50VHlwZXMuZG93biAgLCBsaXN0ZW5lcnMuc2VsZWN0b3JEb3duICk7XG4gICAgICAgICAgICBldmVudHMuYWRkKGRvYywgcEV2ZW50VHlwZXMubW92ZSAgLCBsaXN0ZW5lcnMucG9pbnRlck1vdmUgICk7XG4gICAgICAgICAgICBldmVudHMuYWRkKGRvYywgcEV2ZW50VHlwZXMub3ZlciAgLCBsaXN0ZW5lcnMucG9pbnRlck92ZXIgICk7XG4gICAgICAgICAgICBldmVudHMuYWRkKGRvYywgcEV2ZW50VHlwZXMub3V0ICAgLCBsaXN0ZW5lcnMucG9pbnRlck91dCAgICk7XG4gICAgICAgICAgICBldmVudHMuYWRkKGRvYywgcEV2ZW50VHlwZXMudXAgICAgLCBsaXN0ZW5lcnMucG9pbnRlclVwICAgICk7XG4gICAgICAgICAgICBldmVudHMuYWRkKGRvYywgcEV2ZW50VHlwZXMuY2FuY2VsLCBsaXN0ZW5lcnMucG9pbnRlckNhbmNlbCk7XG5cbiAgICAgICAgICAgIC8vIGF1dG9zY3JvbGxcbiAgICAgICAgICAgIGV2ZW50cy5hZGQoZG9jLCBwRXZlbnRUeXBlcy5tb3ZlLCBsaXN0ZW5lcnMuYXV0b1Njcm9sbE1vdmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXZlbnRzLmFkZChkb2MsICdtb3VzZWRvd24nLCBsaXN0ZW5lcnMuc2VsZWN0b3JEb3duKTtcbiAgICAgICAgICAgIGV2ZW50cy5hZGQoZG9jLCAnbW91c2Vtb3ZlJywgbGlzdGVuZXJzLnBvaW50ZXJNb3ZlICk7XG4gICAgICAgICAgICBldmVudHMuYWRkKGRvYywgJ21vdXNldXAnICAsIGxpc3RlbmVycy5wb2ludGVyVXAgICApO1xuICAgICAgICAgICAgZXZlbnRzLmFkZChkb2MsICdtb3VzZW92ZXInLCBsaXN0ZW5lcnMucG9pbnRlck92ZXIgKTtcbiAgICAgICAgICAgIGV2ZW50cy5hZGQoZG9jLCAnbW91c2VvdXQnICwgbGlzdGVuZXJzLnBvaW50ZXJPdXQgICk7XG5cbiAgICAgICAgICAgIGV2ZW50cy5hZGQoZG9jLCAndG91Y2hzdGFydCcgLCBsaXN0ZW5lcnMuc2VsZWN0b3JEb3duICk7XG4gICAgICAgICAgICBldmVudHMuYWRkKGRvYywgJ3RvdWNobW92ZScgICwgbGlzdGVuZXJzLnBvaW50ZXJNb3ZlICApO1xuICAgICAgICAgICAgZXZlbnRzLmFkZChkb2MsICd0b3VjaGVuZCcgICAsIGxpc3RlbmVycy5wb2ludGVyVXAgICAgKTtcbiAgICAgICAgICAgIGV2ZW50cy5hZGQoZG9jLCAndG91Y2hjYW5jZWwnLCBsaXN0ZW5lcnMucG9pbnRlckNhbmNlbCk7XG5cbiAgICAgICAgICAgIC8vIGF1dG9zY3JvbGxcbiAgICAgICAgICAgIGV2ZW50cy5hZGQoZG9jLCAnbW91c2Vtb3ZlJywgbGlzdGVuZXJzLmF1dG9TY3JvbGxNb3ZlKTtcbiAgICAgICAgICAgIGV2ZW50cy5hZGQoZG9jLCAndG91Y2htb3ZlJywgbGlzdGVuZXJzLmF1dG9TY3JvbGxNb3ZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50cy5hZGQod2luLCAnYmx1cicsIGVuZEFsbEludGVyYWN0aW9ucyk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh3aW4uZnJhbWVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudERvYyA9IHdpbi5mcmFtZUVsZW1lbnQub3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50V2luZG93ID0gcGFyZW50RG9jLmRlZmF1bHRWaWV3O1xuXG4gICAgICAgICAgICAgICAgZXZlbnRzLmFkZChwYXJlbnREb2MgICAsICdtb3VzZXVwJyAgICAgICwgbGlzdGVuZXJzLnBvaW50ZXJFbmQpO1xuICAgICAgICAgICAgICAgIGV2ZW50cy5hZGQocGFyZW50RG9jICAgLCAndG91Y2hlbmQnICAgICAsIGxpc3RlbmVycy5wb2ludGVyRW5kKTtcbiAgICAgICAgICAgICAgICBldmVudHMuYWRkKHBhcmVudERvYyAgICwgJ3RvdWNoY2FuY2VsJyAgLCBsaXN0ZW5lcnMucG9pbnRlckVuZCk7XG4gICAgICAgICAgICAgICAgZXZlbnRzLmFkZChwYXJlbnREb2MgICAsICdwb2ludGVydXAnICAgICwgbGlzdGVuZXJzLnBvaW50ZXJFbmQpO1xuICAgICAgICAgICAgICAgIGV2ZW50cy5hZGQocGFyZW50RG9jICAgLCAnTVNQb2ludGVyVXAnICAsIGxpc3RlbmVycy5wb2ludGVyRW5kKTtcbiAgICAgICAgICAgICAgICBldmVudHMuYWRkKHBhcmVudFdpbmRvdywgJ2JsdXInICAgICAgICAgLCBlbmRBbGxJbnRlcmFjdGlvbnMgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGludGVyYWN0LndpbmRvd1BhcmVudEVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcmV2ZW50IG5hdGl2ZSBIVE1MNSBkcmFnIG9uIGludGVyYWN0LmpzIHRhcmdldCBlbGVtZW50c1xuICAgICAgICBldmVudHMuYWRkKGRvYywgJ2RyYWdzdGFydCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnRlcmFjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJhY3Rpb24gPSBpbnRlcmFjdGlvbnNbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJhY3Rpb24uZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAmJiAoaW50ZXJhY3Rpb24uZWxlbWVudCA9PT0gZXZlbnQudGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBub2RlQ29udGFpbnMoaW50ZXJhY3Rpb24uZWxlbWVudCwgZXZlbnQudGFyZ2V0KSkpIHtcblxuICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5jaGVja0FuZFByZXZlbnREZWZhdWx0KGV2ZW50LCBpbnRlcmFjdGlvbi50YXJnZXQsIGludGVyYWN0aW9uLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZXZlbnRzLnVzZUF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICAvLyBGb3IgSUUncyBsYWNrIG9mIEV2ZW50I3ByZXZlbnREZWZhdWx0XG4gICAgICAgICAgICBldmVudHMuYWRkKGRvYywgJ3NlbGVjdHN0YXJ0JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGludGVyYWN0aW9uID0gaW50ZXJhY3Rpb25zWzBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVyYWN0aW9uLmN1cnJlbnRBY3Rpb24oKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5jaGVja0FuZFByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gRm9yIElFJ3MgYmFkIGRibGNsaWNrIGV2ZW50IHNlcXVlbmNlXG4gICAgICAgICAgICBldmVudHMuYWRkKGRvYywgJ2RibGNsaWNrJywgZG9PbkludGVyYWN0aW9ucygnaWU4RGJsY2xpY2snKSk7XG4gICAgICAgIH1cblxuICAgICAgICBkb2N1bWVudHMucHVzaChkb2MpO1xuICAgIH1cblxuICAgIGxpc3RlblRvRG9jdW1lbnQoZG9jdW1lbnQpO1xuXG4gICAgZnVuY3Rpb24gaW5kZXhPZiAoYXJyYXksIHRhcmdldCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJheVtpXSA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udGFpbnMgKGFycmF5LCB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4T2YoYXJyYXksIHRhcmdldCkgIT09IC0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoZXNTZWxlY3RvciAoZWxlbWVudCwgc2VsZWN0b3IsIG5vZGVMaXN0KSB7XG4gICAgICAgIGlmIChpZThNYXRjaGVzU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBpZThNYXRjaGVzU2VsZWN0b3IoZWxlbWVudCwgc2VsZWN0b3IsIG5vZGVMaXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSAvZGVlcC8gZnJvbSBzZWxlY3RvcnMgaWYgc2hhZG93RE9NIHBvbHlmaWxsIGlzIHVzZWRcbiAgICAgICAgaWYgKHdpbmRvdyAhPT0gcmVhbFdpbmRvdykge1xuICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKC9cXC9kZWVwXFwvL2csICcgJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlbWVudFtwcmVmaXhlZE1hdGNoZXNTZWxlY3Rvcl0oc2VsZWN0b3IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoZXNVcFRvIChlbGVtZW50LCBzZWxlY3RvciwgbGltaXQpIHtcbiAgICAgICAgd2hpbGUgKGlzRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoZXNTZWxlY3RvcihlbGVtZW50LCBzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxlbWVudCA9IHBhcmVudEVsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzU2VsZWN0b3IoZWxlbWVudCwgc2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEZvciBJRTgncyBsYWNrIG9mIGFuIEVsZW1lbnQjbWF0Y2hlc1NlbGVjdG9yXG4gICAgLy8gdGFrZW4gZnJvbSBodHRwOi8vdGFuYWxpbi5jb20vZW4vYmxvZy8yMDEyLzEyL21hdGNoZXMtc2VsZWN0b3ItaWU4LyBhbmQgbW9kaWZpZWRcbiAgICBpZiAoIShwcmVmaXhlZE1hdGNoZXNTZWxlY3RvciBpbiBFbGVtZW50LnByb3RvdHlwZSkgfHwgIWlzRnVuY3Rpb24oRWxlbWVudC5wcm90b3R5cGVbcHJlZml4ZWRNYXRjaGVzU2VsZWN0b3JdKSkge1xuICAgICAgICBpZThNYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiAoZWxlbWVudCwgc2VsZWN0b3IsIGVsZW1zKSB7XG4gICAgICAgICAgICBlbGVtcyA9IGVsZW1zIHx8IGVsZW1lbnQucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVsZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1zW2ldID09PSBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSBwb2x5ZmlsbFxuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxhc3RUaW1lID0gMCxcbiAgICAgICAgICAgIHZlbmRvcnMgPSBbJ21zJywgJ21veicsICd3ZWJraXQnLCAnbyddO1xuXG4gICAgICAgIGZvcih2YXIgeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhcmVhbFdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsreCkge1xuICAgICAgICAgICAgcmVxRnJhbWUgPSByZWFsV2luZG93W3ZlbmRvcnNbeF0rJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgICAgICAgICAgY2FuY2VsRnJhbWUgPSByZWFsV2luZG93W3ZlbmRvcnNbeF0rJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ10gfHwgcmVhbFdpbmRvd1t2ZW5kb3JzW3hdKydDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVxRnJhbWUpIHtcbiAgICAgICAgICAgIHJlcUZyYW1lID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKSxcbiAgICAgICAgICAgICAgICAgICAgaWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpOyB9LFxuICAgICAgICAgICAgICAgICAgdGltZVRvQ2FsbCk7XG4gICAgICAgICAgICAgICAgbGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2FuY2VsRnJhbWUpIHtcbiAgICAgICAgICAgIGNhbmNlbEZyYW1lID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0oKSk7XG5cbiAgICAvKiBnbG9iYWwgZXhwb3J0czogdHJ1ZSwgbW9kdWxlLCBkZWZpbmUgKi9cblxuICAgIC8vIGh0dHA6Ly9kb2N1bWVudGNsb3VkLmdpdGh1Yi5pby91bmRlcnNjb3JlL2RvY3MvdW5kZXJzY29yZS5odG1sI3NlY3Rpb24tMTFcbiAgICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gaW50ZXJhY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0cy5pbnRlcmFjdCA9IGludGVyYWN0O1xuICAgIH1cbiAgICAvLyBBTURcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKCdpbnRlcmFjdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVyYWN0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlYWxXaW5kb3cuaW50ZXJhY3QgPSBpbnRlcmFjdDtcbiAgICB9XG5cbn0gKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnPyB1bmRlZmluZWQgOiB3aW5kb3cpKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGpRdWVyeSBleHRlbnNpb25zXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHBhcmFtc1xuICAgIC8vIHRvZ2dsZUNsYXNzIC0gcmVxdWlyZWRcbiAgICAvLyB0cmlnZ2VyU2VsZWN0b3IgLSBvcHRpb25hbC4gdGhlIHNlbGVjdG9yIGZvciB0aGUgZWxlbWVudCB0aGF0IHRyaWdnZXJzIHRoZSBldmVudCBoYW5kbGVyLiBkZWZhdWx0cyB0byB0aGUgY2hpbGQgZWxlbWVudHMgb2YgdGhlIGxpc3QuXG4gICAgLy8gZXZlbnROYW1lIC0gb3B0aW9uYWwuIGRlZmF1bHRzIHRvICdjbGljaydcbiAgICAkLmZuLnRvZ2dsZWRMaXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLnRvZ2dsZUNsYXNzKSB7IHJldHVybiB0aGlzOyB9XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGxpc3Qub24ob3B0aW9ucy5ldmVudE5hbWUgfHwgJ2NsaWNrJywgb3B0aW9ucy50cmlnZ2VyU2VsZWN0b3IgfHwgbGlzdC5jaGlsZHJlbigpLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdmFyIGNsYXNzVGFyZ2V0ID0gb3B0aW9ucy50cmlnZ2VyU2VsZWN0b3IgPyAkKHRoaXMpLnBhcmVudCgpIDogJCh0aGlzKTtcbiAgICAgICAgICAgIGNsYXNzVGFyZ2V0LnRvZ2dsZUNsYXNzKG9wdGlvbnMudG9nZ2xlQ2xhc3MpO1xuICAgICAgICAgICAgLy8gZXhlY3V0ZSBjYWxsYmFjayBpZiBleGlzdHNcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrKSB7b3B0aW9ucy5jYWxsYmFjaygpO31cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgICQuZm4uc3luY0hlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyciA9ICQubWFrZUFycmF5KHRoaXMpO1xuICAgICAgICBhcnIuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuICQoYSkuaGVpZ2h0KCkgLSAkKGIpLmhlaWdodCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0KCQoYXJyW2Fyci5sZW5ndGggLSAxXSkuaGVpZ2h0KCkpO1xuICAgIH07XG5cbiAgICAkLmZuLmNlbnRlciA9IGZ1bmN0aW9uKGxvYWRlZCwgZXZlbnROYW1lU3BhY2UpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcztcbiAgICAgICAgdmFyIGJvZHlfd2lkdGggPSBwYXJzZUludCgkKHdpbmRvdykud2lkdGgoKSk7XG4gICAgICAgIHZhciBib2R5X2hlaWdodCA9IHBhcnNlSW50KCQod2luZG93KS5oZWlnaHQoKSk7XG5cbiAgICAgICAgZWxlbWVudHMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciAkZWwgPSAkKHRoaXMpO1xuICAgICAgICAgICAgdmFyIGJsb2NrX3dpZHRoID0gcGFyc2VJbnQoJGVsLndpZHRoKCkpO1xuICAgICAgICAgICAgdmFyIGJsb2NrX2hlaWdodCA9IHBhcnNlSW50KCRlbC5oZWlnaHQoKSk7XG4gICAgICAgICAgICB2YXIgc3RvcENlbnRlcmluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgbGVmdF9wb3NpdGlvbiA9IHBhcnNlSW50KChib2R5X3dpZHRoIC8gMikgLSAoYmxvY2tfd2lkdGggLyAyKSAgKyAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpKTtcbiAgICAgICAgICAgIGlmIChib2R5X3dpZHRoIDwgYmxvY2tfd2lkdGgpIHtcbiAgICAgICAgICAgICAgICBsZWZ0X3Bvc2l0aW9uID0gMFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRvcF9wb3NpdGlvbiA9IHBhcnNlSW50KChib2R5X2hlaWdodCAvIDIpIC0gKGJsb2NrX2hlaWdodCAvIDIpICsgJCh3aW5kb3cpLnNjcm9sbFRvcCgpKTtcbiAgICAgICAgICAgIGlmIChib2R5X2hlaWdodCA8IGJsb2NrX2hlaWdodCkge1xuICAgICAgICAgICAgICAgIHN0b3BDZW50ZXJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZighbG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgJGVsLmNzcyh7ICdwb3NpdGlvbic6ICdhYnNvbHV0ZScgfSk7XG4gICAgICAgICAgICAgICAgJGVsLmNzcyh7ICdsZWZ0JzogbGVmdF9wb3NpdGlvbiwgJ3RvcCc6IHRvcF9wb3NpdGlvbiB9KTtcbiAgICAgICAgICAgICAgICAkZWwuY2VudGVyKHRydWUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlc2l6ZUV2ZW50ID0gZXZlbnROYW1lU3BhY2UgPyAncmVzaXplLicgKyBldmVudE5hbWVTcGFjZSA6ICdyZXNpemUnO1xuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxFdmVudCA9IGV2ZW50TmFtZVNwYWNlID8gJ3Njcm9sbC4nICsgZXZlbnROYW1lU3BhY2UgOiAnc2Nyb2xsJztcblxuICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWVTcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAkKHdpbmRvdykub2ZmKHJlc2l6ZUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgJCh3aW5kb3cpLm9mZihzY3JvbGxFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgJCh3aW5kb3cpLm9uKHJlc2l6ZUV2ZW50LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJGVsLmNlbnRlcih0cnVlKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICQod2luZG93KS5vbihzY3JvbGxFdmVudCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRlbC5jZW50ZXIodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdG9wQ2VudGVyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICRlbC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICRlbC5jc3Moeydwb3NpdGlvbic6ICdhYnNvbHV0ZSd9KTtcbiAgICAgICAgICAgICAgICAgICAgJGVsLmFuaW1hdGUoeydsZWZ0JzogbGVmdF9wb3NpdGlvbiwgJ3RvcCc6IHRvcF9wb3NpdGlvbn0sIDIwMCwgJ2xpbmVhcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRpYWxvZyA9IHJlcXVpcmUoJy4vZGlhbG9nJyksXG4gICAgcGFnZSA9IHJlcXVpcmUoJy4vcGFnZScpLFxuICAgIHZhbGlkYXRvciA9IHJlcXVpcmUoJy4vdmFsaWRhdG9yJyksXG4gICAgZmxvYXRMYWJlbCA9IHJlcXVpcmUoJy4vZmxvYXQtbGFiZWxzJyk7XG5cbnZhciBsb2dpbiA9IHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBpbml0IGV2ZW50cyBmb3IgdGhlIGxvZ2luUGFnZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy9vLWF1dGggYmluZGluZyBmb3Igd2hpY2ggaWNvbiBpcyBjbGlja2VkXG4gICAgICAgICQoJy5vQXV0aEljb24nKS5vZmYoJ2NsaWNrJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICQoJy5PQXV0aFByb3ZpZGVyJykudmFsKHRoaXMuaWQpO1xuICAgICAgICB9KTtcbiAgICBcblxuICAgICAgICAvL3RvZ2dsZSB0aGUgdmFsdWUgb2YgdGhlIHJlbWVtYmVybWUgY2hlY2tib3hcbiAgICAgICAgJCgnI2R3ZnJtX2xvZ2luX3JlbWVtYmVybWUnKS5iaW5kKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoJCgnI2R3ZnJtX2xvZ2luX3JlbWVtYmVybWUnKS5hdHRyKCdjaGVja2VkJykpIHtcbiAgICAgICAgICAgICAgICAkKCcjcmVtZW1iZXJtZScpLnZhbCgndHJ1ZScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKCcjcmVtZW1iZXJtZScpLnZhbCgnZmFsc2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAkKCcjcGFzc3dvcmQtcmVzZXQnKS5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBkaWFsb2cub3Blbih7XG4gICAgICAgICAgICAgICAgdXJsOiAkKGUudGFyZ2V0KS5hdHRyKCdocmVmJyksXG4gICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICBvcGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3IuaW5pdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyICRyZXF1ZXN0UGFzc3dvcmRGb3JtID0gJCgnW25hbWUkPVwiX3JlcXVlc3RwYXNzd29yZFwiXScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyICRzdWJtaXQgPSAkcmVxdWVzdFBhc3N3b3JkRm9ybS5maW5kKCdbbmFtZSQ9XCJfcmVxdWVzdHBhc3N3b3JkX3NlbmRcIl0nKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgJCgkc3VibWl0KS5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghJHJlcXVlc3RQYXNzd29yZEZvcm0udmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9ICRyZXF1ZXN0UGFzc3dvcmRGb3JtLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBmb3JtIGFjdGlvbiB0byBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSArPSAnJicgKyAkc3VibWl0LmF0dHIoJ25hbWUnKSArICc9JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIHNlcnZlciBrbm93cyB0aGlzIGlzIGFuIGFqYXggcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmluZGV4T2YoJ2FqYXgnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSArPSAnJmZvcm1hdD1hamF4JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICRyZXF1ZXN0UGFzc3dvcmRGb3JtLmF0dHIoJ2FjdGlvbicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFyZXNwb25zZS5zdWNjZXNzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmVycm9yID09PSAnQ1NSRiBUb2tlbiBNaXNtYXRjaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlLnJlZGlyZWN0KFVybHMuY3NyZmZhaWxlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWFsb2cuJGNvbnRhaW5lci5odG1sKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCcuY2xvc2UtYnV0dG9uJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlhbG9nLiRjb250YWluZXIuaHRtbCgnPGgxPicgKyBSZXNvdXJjZXMuU0VSVkVSX0VSUk9SICsgJzwvaDE+Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdmFyICR0d2l0dGVyRXJyb3IgPSAkKCcudHdpdHRlci1vYXV0aC1lcnJvcicpLmRldGFjaCgpO1xuICAgICAgICAkKCcuc29jaWFsLWxvZ2luJykuYWZ0ZXIoJHR3aXR0ZXJFcnJvcik7XG4gICAgICAgICR0d2l0dGVyRXJyb3Iuc2hvdygpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbG9naW47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gICAgYm9udXNQcm9kdWN0c1ZpZXcgPSByZXF1aXJlKCcuL2JvbnVzLXByb2R1Y3RzLXZpZXcnKTtcblxudmFyIG1pbmlDYXJ0RGVsYXkgPSA1MDAwO1xuXG52YXIgdGltZXIgPSB7XG4gICAgaWQ6IG51bGwsXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaWQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5pZCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5pZDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIChkdXJhdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5pZCA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIGR1cmF0aW9uKTtcbiAgICB9XG59O1xuXG52YXIgbWluaWNhcnQgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRlbCA9ICQoJyNtaW5pLWNhcnQnKTtcbiAgICAgICAgdGhpcy4kY29udGVudCA9IHRoaXMuJGVsLmZpbmQoJy5taW5pLWNhcnQtY29udGVudCcpO1xuICAgICAgICB0aGlzLiRjYXJ0TGluayA9IHRoaXMuJGVsLmZpbmQoJy5taW5pLWNhcnQtbGluaycpO1xuICAgICAgICB0aGlzLiR2aWV3QmFnTGluayA9IHRoaXMuJGVsLmZpbmQoJy5taW5pLWNhcnQtbGluay1jYXJ0Jyk7XG5cbiAgICAgICAgdGhpcy53aGlsZVNjcm9sbGluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGltZXIuY2xlYXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2Nyb2xsQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRpbWVyLmNsZWFyKCk7XG4gICAgICAgICAgICB0aW1lci5zdGFydChtaW5pQ2FydERlbGF5LCB0aGlzLmNsb3NlLmJpbmQodGhpcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgJCgnLm1pbmktY2FydC1wcm9kdWN0cycpLm1DdXN0b21TY3JvbGxiYXIoe1xuICAgICAgICAgICAgY2FsbGJhY2tzOntcbiAgICAgICAgICAgICAgICB3aGlsZVNjcm9sbGluZzp0aGlzLndoaWxlU2Nyb2xsaW5nLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgb25TY3JvbGw6dGhpcy5zY3JvbGxDb21wbGV0ZS5iaW5kKHRoaXMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgICQoJy5taW5pLWNhcnQtcHJvZHVjdCcpLmVxKDApLmZpbmQoJy5taW5pLWNhcnQtdG9nZ2xlJykuYWRkQ2xhc3MoJ2ZhLWNhcmV0LWRvd24nKTtcbiAgICAgICAgJCgnLm1pbmktY2FydC1wcm9kdWN0Jykubm90KCc6Zmlyc3QnKS5hZGRDbGFzcygnY29sbGFwc2VkJylcbiAgICAgICAgICAgIC5maW5kKCcubWluaS1jYXJ0LXRvZ2dsZScpLmFkZENsYXNzKCdmYS1jYXJldC1yaWdodCcpO1xuXG4gICAgICAgICQoJy5taW5pLWNhcnQtdG9nZ2xlJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJCh0aGlzKS50b2dnbGVDbGFzcygnZmEtY2FyZXQtZG93biBmYS1jYXJldC1yaWdodCcpO1xuICAgICAgICAgICAgJCh0aGlzKS5jbG9zZXN0KCcubWluaS1jYXJ0LXByb2R1Y3QnKS50b2dnbGVDbGFzcygnY29sbGFwc2VkJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuJGNhcnRMaW5rLm9uKCdtb3VzZWVudGVyIHRvdWNoc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kY29udGVudC5ub3QoJzp2aXNpYmxlJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNsaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgdGhpcy4kY2FydExpbmsub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKCQodGhpcykuaGFzQ2xhc3MoJ21pbmktY2FydC1lbXB0eScpKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uLmhyZWYgPSAkKHRoaXMpLmF0dHIoJ3JlbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLiR2aWV3QmFnTGluay5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFwcC50cmlnZ2VyVUlTQ2FydENoZWNrKCdjYXJ0Jyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuJGNvbnRlbnQuZmluZCgnLm1pbmktY2FydC1jbG9zZScpLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLiRjb250ZW50Lm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aW1lci5jbGVhcigpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgIHRoaXMuJGNvbnRlbnQub24oJ21vdXNlbGVhdmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRpbWVyLmNsZWFyKCk7XG4gICAgICAgICAgICB0aW1lci5zdGFydChtaW5pQ2FydERlbGF5LCB0aGlzLmNsb3NlLmJpbmQodGhpcykpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIFNob3dzIHRoZSBnaXZlbiBjb250ZW50IGluIHRoZSBtaW5pIGNhcnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gQSBIVE1MIHN0cmluZyB3aXRoIHRoZSBjb250ZW50IHdoaWNoIHdpbGwgYmUgc2hvd25cbiAgICAgKi9cbiAgICBzaG93OiBmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICB0aGlzLiRlbC5odG1sKGh0bWwpO1xuICAgICAgICB1dGlsLnNjcm9sbEJyb3dzZXIoMCk7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB0aGlzLnNsaWRlKCk7XG4gICAgICAgIGJvbnVzUHJvZHVjdHNWaWV3LmxvYWRCb251c09wdGlvbigpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIFNsaWRlcyBkb3duIGFuZCBzaG93IHRoZSBjb250ZW50cyBvZiB0aGUgbWluaSBjYXJ0XG4gICAgICovXG4gICAgc2xpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGltZXIuY2xlYXIoKTtcbiAgICAgICAgLy8gc2hvdyB0aGUgaXRlbVxuICAgICAgICB0aGlzLiRjb250ZW50LnNsaWRlRG93bignc2xvdycpO1xuICAgICAgICAvLyBhZnRlciBhIHRpbWUgb3V0IGF1dG9tYXRpY2FsbHkgY2xvc2UgaXRcbiAgICAgICAgdGltZXIuc3RhcnQobWluaUNhcnREZWxheSwgdGhpcy5jbG9zZS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBDbG9zZXMgdGhlIG1pbmkgY2FydCB3aXRoIGdpdmVuIGRlbGF5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5IFRoZSBkZWxheSBpbiBtaWxsaXNlY29uZHNcbiAgICAgKi9cbiAgICBjbG9zZTogZnVuY3Rpb24gKGRlbGF5KSB7XG4gICAgICAgIHRpbWVyLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuJGNvbnRlbnQuc2xpZGVVcChkZWxheSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtaW5pY2FydDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIHBhZ2UgPSB7XG4gICAgdGl0bGU6ICcnLFxuICAgIHR5cGU6ICcnLFxuICAgIHBhcmFtczogdXRpbC5nZXRRdWVyeVN0cmluZ1BhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cigxKSksXG4gICAgcmVkaXJlY3Q6IGZ1bmN0aW9uIChuZXdVUkwpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IG5ld1VSTDtcbiAgICAgICAgfSwgMCk7XG4gICAgfSxcbiAgICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYWdlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2lmdGNlcnQgPSByZXF1aXJlKCcuLi9naWZ0Y2VydCcpLFxuICAgIHRvb2x0aXAgPSByZXF1aXJlKCcuLi90b29sdGlwJyksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgICBkaWFsb2cgPSByZXF1aXJlKCcuLi9kaWFsb2cnKSxcbiAgICBwYWdlID0gcmVxdWlyZSgnLi4vcGFnZScpLFxuICAgIGxvZ2luID0gcmVxdWlyZSgnLi4vbG9naW4nKSxcbiAgICB2YWxpZGF0b3IgPSByZXF1aXJlKCcuLi92YWxpZGF0b3InKSxcbiAgICBmbG9hdGxhYmVscyA9IHJlcXVpcmUoJy4uL2Zsb2F0LWxhYmVscycpLFxuICAgIFRQcm9taXNlID0gcmVxdWlyZSgncHJvbWlzZScpLFxuICAgIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvbiBJbml0aWFsaXplcyB0aGUgZXZlbnRzIG9uIHRoZSBhZGRyZXNzIGZvcm0gKGFwcGx5LCBjYW5jZWwsIGRlbGV0ZSlcbiAqIEBwYXJhbSB7RWxlbWVudH0gZm9ybSBUaGUgZm9ybSB3aGljaCB3aWxsIGJlIGluaXRpYWxpemVkXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVBZGRyZXNzRm9ybSh2YWxpZGF0ZSkge1xuICAgIHZhciAkZm9ybSA9ICQoJyNlZGl0LWFkZHJlc3MtZm9ybScpO1xuICAgIHZhciB2YWxpZGF0ZSA9ICh0eXBlb2YgdmFsaWRhdGUgPT09ICdib29sZWFuJykgPyB2YWxpZGF0ZSA6IGZhbHNlO1xuXG4gICAgJGZvcm0uZmluZCgnaW5wdXRbbmFtZT1cImZvcm1hdFwiXScpLnJlbW92ZSgpO1xuICAgIHRvb2x0aXAuaW5pdCgpO1xuXG4gICAgdmFyICRpbWcgPSAkKCcudG9vbHRpcC1pbWFnZS1ub3JtYWwnKTtcblx0dmFyICRob3ZlckltZyA9ICQoJy50b29sdGlwLWltYWdlLWhvdmVyJyk7XG4gICAgJGZvcm0uZmluZCgnLmZvcm0tZmllbGQtdG9vbHRpcCcpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgIFx0dmFyICR0b29sdGlwID0gJCh0aGlzKS5maW5kKCcudG9vbHRpcCcpO1xuICAgIFx0aWYoISR0b29sdGlwLmZpbmQoJy50b29sdGlwLWltYWdlJykubGVuZ3RoKXtcblx0ICAgIFx0dmFyICRjaGlsZHJlbiA9ICR0b29sdGlwLmNoaWxkcmVuKCkuZGV0YWNoKCk7XG5cdCAgICBcdCR0b29sdGlwLmVtcHR5KCk7XG5cdCAgICBcdCR0b29sdGlwLmFwcGVuZCgkaW1nKTtcblx0ICAgIFx0JHRvb2x0aXAuYXBwZW5kKCRob3ZlckltZyk7XG5cdCAgICBcdCR0b29sdGlwLmFwcGVuZCgkY2hpbGRyZW4pO1xuICAgIFx0fVxuICAgIFx0JHRvb2x0aXAub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgXHRlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8kKFwiPGlucHV0Lz5cIikuYXR0cih7dHlwZTpcImhpZGRlblwiLCBuYW1lOlwiZm9ybWF0XCIsIHZhbHVlOlwiYWpheFwifSkuYXBwZW5kVG8oZm9ybSk7XG5cbiAgICAkZm9ybS5vbignY2xpY2snLCAnLmFwcGx5LWJ1dHRvbicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKCEkZm9ybS52YWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVybCA9IHV0aWwuYXBwZW5kUGFyYW1Ub1VSTCgkZm9ybS5hdHRyKCdhY3Rpb24nKSwgJ2Zvcm1hdCcsICdhamF4Jyk7XG4gICAgICAgIHZhciBhcHBseU5hbWUgPSAkZm9ybS5maW5kKCcuYXBwbHktYnV0dG9uJykuYXR0cignbmFtZScpO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgZGF0YTogJGZvcm0uc2VyaWFsaXplKCkgKyAnJicgKyAkKHRoaXMpLmF0dHIoJ25hbWUnKSArICc9eCcsXG4gICAgICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgICAgICBkYXRlVHlwZTogXCJodG1sXCJcbiAgICAgICAgfTtcblxuICAgICAgICAkLmFqYXgob3B0aW9ucykuZG9uZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgaWYgKGRhdGEgPT0gXCJzdWNjZXNzXCIpIHtcbiAgICAgICAgICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBwYWdlLnJlZnJlc2goKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBcdCQoJyNkaWFsb2ctY29udGFpbmVyJykuaHRtbChkYXRhKTtcbiAgICAgICAgICAgIFx0aW5pdGlhbGl6ZUFkZHJlc3NGb3JtKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIH0pXG4gICAgLm9uKCdjbGljaycsICcuY2FuY2VsLWJ1dHRvbiwgLmNsb3NlLWJ1dHRvbicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGlhbG9nLmNsb3NlKCk7XG4gICAgfSlcbiAgICAub24oJ2NsaWNrJywgJy5kZWxldGUtYnV0dG9uJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAod2luZG93LmNvbmZpcm0oU3RyaW5nLmZvcm1hdChSZXNvdXJjZXMuQ09ORklSTV9ERUxFVEUsIFJlc291cmNlcy5USVRMRV9BRERSRVNTKSkpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSB1dGlsLmFwcGVuZFBhcmFtc1RvVXJsKFVybHMuZGVsZXRlQWRkcmVzcywge1xuICAgICAgICAgICAgICAgIEFkZHJlc3NJRDogJGZvcm0uZmluZCgnI2FkZHJlc3NpZCcpLnZhbCgpLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogJ2FqYXgnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJ1xuICAgICAgICAgICAgfSkuZG9uZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLnN0YXR1cy50b0xvd2VyQ2FzZSgpID09PSAnb2snKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBwYWdlLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hbGVydChkYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2UucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSlcbiAgICAub24oJ2NoYW5nZScsICcuaW5wdXQtdGV4dC5waG9uZScsIHZhbGlkYXRvci5mb3JtYXR0ZXIucGhvbmUpO1xuICAgICQoJy5pbnB1dC10ZXh0LnBob25lJykudHJpZ2dlcignY2hhbmdlJyk7XG5cbiAgICB2YXIgJHN0YXRlRW1wdHlPcHRpb25FbCA9ICRmb3JtLmZpbmQoJy5zdGF0ZS1maWVsZC1jb250YWluZXIgc2VsZWN0IG9wdGlvbjpmaXJzdC1jaGlsZCcpO1xuICAgIHZhciBzdGF0ZUVtcHR5T3B0aW9uSHRtbCA9ICQoJzxkaXY+JykuYXBwZW5kKCRzdGF0ZUVtcHR5T3B0aW9uRWwuY2xvbmUoKSlcbiAgICAgICAgLmh0bWwoKTtcbiAgICAkZm9ybS5vbignY2hhbmdlJywgJ3NlbGVjdC5jb3VudHJ5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHV0aWwuY2hhbmdlU3RhdGVGaWVsZCgkKHRoaXMpLnZhbCgpLCAkZm9ybSwgc3RhdGVFbXB0eU9wdGlvbkh0bWwpO1xuICAgIH0pO1xuICAgICRmb3JtLmZpbmQoJ3NlbGVjdC5jb3VudHJ5JykudHJpZ2dlcignY2hhbmdlJyk7XG5cbiAgICB2YWxpZGF0b3IuaW5pdCgpO1xuICAgIGZsb2F0bGFiZWxzLmluaXQoKTtcbiAgICB1dGlsLmluaXRaaXBTZXJ2aWNlKCRmb3JtKTtcblxuICAgICQoJy51aS1kaWFsb2ctdGl0bGViYXItY2xvc2UnKS5ibHVyKCk7XG5cbiAgICBpZiAodmFsaWRhdGUpIHtcbiAgICBcdCRmb3JtLnZhbGlkKCk7XG4gICAgfVxufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKiBAZGVzY3JpcHRpb24gVG9nZ2xlcyB0aGUgbGlzdCBvZiBPcmRlcnNcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlRnVsbE9yZGVyICgpIHtcbiAgICAkKCcub3JkZXItaXRlbXMnKVxuICAgICAgICAuZmluZCgnbGkuaGlkZGVuOmZpcnN0JylcbiAgICAgICAgLnByZXYoJ2xpJylcbiAgICAgICAgLmFwcGVuZCgnPGEgY2xhc3M9XCJ0b2dnbGVcIj5WaWV3IEFsbDwvYT4nKVxuICAgICAgICAuY2hpbGRyZW4oJy50b2dnbGUnKVxuICAgICAgICAuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5zaWJsaW5ncygnbGkuaGlkZGVuJykuc2hvdygpO1xuICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvbiBCaW5kcyB0aGUgZXZlbnRzIG9uIHRoZSBhZGRyZXNzIGZvcm0gKGVkaXQsIGNyZWF0ZSwgZGVsZXRlKVxuICovXG5mdW5jdGlvbiBpbml0QWRkcmVzc0V2ZW50cygpIHtcbiAgICB2YXIgYWRkcmVzc2VzID0gJCgnI2FkZHJlc3NlcycpO1xuICAgIGlmIChhZGRyZXNzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgXHRyZXR1cm47XG4gICAgfVxuXG4gICAgYWRkcmVzc2VzLm9uKCdjbGljaycsICcuYWRkcmVzcy1lZGl0LCAuYWRkcmVzcy1jcmVhdGUnLCBmdW5jdGlvbiAoZSkge1xuICAgIFx0dmFyICRmb3JtID0gJCgnI2VkaXQtYWRkcmVzcy1mb3JtJyk7XG4gICAgXHQkZm9ybS5maW5kKFwiaW5wdXQsIHRleHRhcmVhLCBzZWxlY3RcIikudmFsKFwiXCIpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciB3aWR0aCA9ICh3aW5kb3cuaW5uZXJXaWR0aCA8IDcwOCkgPyAod2luZG93LmlubmVyV2lkdGggLSA0MCkudG9TdHJpbmcoKSA6ICc2NjgnO1xuICAgICAgICBkaWFsb2cub3Blbih7XG4gICAgICAgICAgICB1cmw6IHRoaXMuZ2V0QXR0cmlidXRlKCdwb3B1cC1ocmVmJyksXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBcdCd3aWR0aCc6IHdpZHRoLFxuICAgICAgICAgICAgICAgIG9wZW46IGluaXRpYWxpemVBZGRyZXNzRm9ybSxcbiAgICAgICAgICAgICAgICBkaWFsb2dDbGFzczogXCJhZGRyZXNzYm9vay1tb2RhbFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgfSkub24oJ2NsaWNrJywgJy5kZWxldGUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmICh3aW5kb3cuY29uZmlybShTdHJpbmcuZm9ybWF0KFJlc291cmNlcy5DT05GSVJNX0RFTEVURSwgUmVzb3VyY2VzLlRJVExFX0FERFJFU1MpKSkge1xuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICB1cmw6IHV0aWwuYXBwZW5kUGFyYW1Ub1VSTCgkKHRoaXMpLmF0dHIoJ2hyZWYnKSwgJ2Zvcm1hdCcsICdhamF4JyksXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJ1xuICAgICAgICAgICAgfSkuZG9uZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLnN0YXR1cy50b0xvd2VyQ2FzZSgpID09PSAnb2snKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2UucmVkaXJlY3QoVXJscy5hZGRyZXNzZXNMaXN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hbGVydChkYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2UucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvbiBCaW5kcyB0aGUgZXZlbnRzIG9mIHRoZSBwYXltZW50IG1ldGhvZHMgbGlzdCAoZGVsZXRlIGNhcmQpXG4gKi9cbmZ1bmN0aW9uIGluaXRQYXltZW50RXZlbnRzKCkge1xuICAgICQoJy5hZGQtY2FyZCcpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIHdpZHRoID0gNjY4O1xuICAgICAgICBpZih3aW5kb3cuaW5uZXJXaWR0aCA8IDc2OCl7XG4gICAgICAgIFx0d2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCAtIDU3O1xuICAgICAgICB9XG4gICAgICAgIGRpYWxvZy5vcGVuKHtcbiAgICAgICAgICAgIHVybDogJChlLnRhcmdldCkuYXR0cignaHJlZicpLFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIG9wZW46IGluaXRpYWxpemVQYXltZW50Rm9ybSxcbiAgICAgICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBcdCQoJyNjdXJyZW50LWNhcmQtdHlwZS1pbWcnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBcdCQoJyNDcmVkaXRDYXJkRm9ybScpLmZpbmQoJyNkd2ZybV9wYXltZW50aW5zdHJ1bWVudHNfY3JlZGl0Y2FyZHNfbmV3Y3JlZGl0Y2FyZF9leHBpcmF0aW9uZGF0ZScpLnBhcmVudCgpLmZpbmQoJ2Rpdi5lcnJvcicpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGlhbG9nQ2xhc3M6IFwicGF5bWVudGluc3RydW1lbnRzLW1vZGFsXCIsXG4gICAgICAgICAgICAgICAgJ3dpZHRoJzogd2lkdGhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgcGF5bWVudExpc3QgPSAkKCcucGF5bWVudC1saXN0Jyk7XG4gICAgaWYgKHBheW1lbnRMaXN0Lmxlbmd0aCA9PT0gMCkgeyByZXR1cm47IH1cblxuICAgIHV0aWwuc2V0RGVsZXRlQ29uZmlybWF0aW9uKHBheW1lbnRMaXN0LCBTdHJpbmcuZm9ybWF0KFJlc291cmNlcy5DT05GSVJNX0RFTEVURSwgUmVzb3VyY2VzLlRJVExFX0NSRURJVENBUkQpKTtcblxuICAgICQoJ2Zvcm1bbmFtZT1cInBheW1lbnQtcmVtb3ZlXCJdJykub24oJ3N1Ym1pdCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gb3ZlcnJpZGUgZm9ybSBzdWJtaXNzaW9uIGluIG9yZGVyIHRvIHByZXZlbnQgcmVmcmVzaCBpc3N1ZXNcbiAgICAgICAgdmFyIGJ1dHRvbiA9ICQodGhpcykuZmluZCgnLmRlbGV0ZScpO1xuICAgICAgICAkKCc8aW5wdXQvPicpLmF0dHIoe1xuICAgICAgICAgICAgdHlwZTogJ2hpZGRlbicsXG4gICAgICAgICAgICBuYW1lOiBidXR0b24uYXR0cignbmFtZScpLFxuICAgICAgICAgICAgdmFsdWU6IGJ1dHRvbi5hdHRyKCd2YWx1ZScpIHx8ICdkZWxldGUgY2FyZCdcbiAgICAgICAgfSkuYXBwZW5kVG8oJCh0aGlzKSk7XG4gICAgICAgIHZhciBkYXRhID0gJCh0aGlzKS5zZXJpYWxpemUoKTtcbiAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICAgIHVybDogJCh0aGlzKS5hdHRyKCdhY3Rpb24nKSxcbiAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgfSlcbiAgICAgICAgLmRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcGFnZS5yZWRpcmVjdChVcmxzLnBheW1lbnRzTGlzdCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLy9mdW5jdGlvbiBSZW1vdmVQYXltZW50SW1nKCkge31cbmZ1bmN0aW9uIGluaXRpYWxpemVQYXltZW50Rm9ybSgpIHtcblx0dmFyICRmb3JtID0gJCgnI0NyZWRpdENhcmRGb3JtJyk7XG5cdHZhciAkZXhwZGF0ZSA9ICQoJyNkd2ZybV9wYXltZW50aW5zdHJ1bWVudHNfY3JlZGl0Y2FyZHNfbmV3Y3JlZGl0Y2FyZF9leHBpcmF0aW9uZGF0ZScpO1xuXHR2YXIgJGhpZGRlbm1vbnRoID0gJCgnI2R3ZnJtX3BheW1lbnRpbnN0cnVtZW50c19jcmVkaXRjYXJkc19uZXdjcmVkaXRjYXJkX21vbnRoJyk7XG5cdHZhciAkaGlkZGVueWVhciA9ICQoJyNkd2ZybV9wYXltZW50aW5zdHJ1bWVudHNfY3JlZGl0Y2FyZHNfbmV3Y3JlZGl0Y2FyZF95ZWFyJyk7XG5cdCRmb3JtLm9uKCdjbGljaycsICcjYXBwbHlCdG4nLCBmdW5jdGlvbiAoZSkge1xuICAgIFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIFx0aWYgKCEkZm9ybS52YWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNjSW5wdXQgPSAkZm9ybS5maW5kKCcuZm9ybS1yb3c6bnRoLWNoaWxkKDMpIGlucHV0Jyk7XG4gICAgXHRjY0lucHV0LnZhbChjY0lucHV0LnZhbCgpLnJlcGxhY2UoL1xccy9nLCAnJykpO1xuICAgICAgICB2YXIgdXJsID0gdXRpbC5hcHBlbmRQYXJhbVRvVVJMKCRmb3JtLmF0dHIoJ2FjdGlvbicpLCAnZm9ybWF0JywgJ2FqYXgnKTtcbiAgICAgICAgdmFyIGFwcGx5TmFtZSA9ICRmb3JtLmZpbmQoJyNhcHBseUJ0bicpLmF0dHIoJ25hbWUnKTtcblxuICAgICAgICAvLyB0YWtlIGRhdGEgZnJvbSBzaW5nbGUgZXhwaXJhdGlvbiBmaWVsZCBhbmQgcG9wdWxhdGUgaGlkZGVuIGZpZWxkcyBmb3IgdmFsaWRhdGlvbiBhbmQgcGF5bWVudCBpbnN0cnVtZW50IGNyZWF0aW9uXG4gICAgICAgICRoaWRkZW5tb250aC52YWwoJGV4cGRhdGUudmFsKCkuc3BsaXQoJyAvICcpWzBdLnJlcGxhY2UoJzAnLCAnJykpO1xuICAgICAgICAkaGlkZGVueWVhci52YWwoJzIwJyArICRleHBkYXRlLnZhbCgpLnNwbGl0KCcgLyAnKVsxXSk7XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgIGRhdGE6ICRmb3JtLnNlcmlhbGl6ZSgpICsgJyYnICsgJCh0aGlzKS5hdHRyKCduYW1lJykgKyAnPXgnLFxuICAgICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgICAgZGF0ZVR5cGU6IFwiaHRtbFwiXG4gICAgICAgIH07XG5cbiAgICAgICAgJC5hamF4KG9wdGlvbnMpLmRvbmUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChkYXRhID09IFwic3VjY2Vzc1wiKSB7XG4gICAgICAgICAgICAgICAgZGlhbG9nLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcGFnZS5yZWZyZXNoKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXHQvL3BhZ2UucmVkaXJlY3QoVXJscy5jc3JmZmFpbGVkKTtcbiAgICAgICAgICAgIFx0aWYgKGRhdGEuZXJyb3IgPT0gXCJDUkVESVRDQVJEX0lOVkFMSURfRVhQSVJBVElPTl9EQVRFXCIpIHtcbiAgICAgICAgICAgIFx0XHRzaG93Rm9ybUVycm9yKCQoJy5mb3JtLXJvdzpudGgtY2hpbGQoNiknKSk7XG4gICAgICAgICAgICBcdFx0c2hvd0Zvcm1FcnJvcigkKCcuZm9ybS1yb3c6bnRoLWNoaWxkKDcpJykpO1xuICAgICAgICAgICAgXHR9XG4gICAgICAgICAgICBcdGlmIChkYXRhLmVycm9yID09IFwiQ1JFRElUQ0FSRF9JTlZBTElEX0NBUkRfTlVNQkVSXCIpIHtcbiAgICAgICAgICAgIFx0XHRzaG93Rm9ybUVycm9yKCQoJy5mb3JtLXJvdzpudGgtY2hpbGQoMyknKSk7XG4gICAgICAgICAgICBcdH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSkub24oJ2NsaWNrJywgJy5jYW5jZWwtYnV0dG9uJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAgICB9KTtcblxuXG5cdCQoJy5mb3JtLXJvdyBpbnB1dCcpLmJsdXIoZnVuY3Rpb24oKXtcblx0XHQkKHRoaXMpLnZhbGlkKCk7XG5cdH0pO1xuXG4gICAgZnVuY3Rpb24gc2VsZWN0SGlkZGVuQ3JlZGl0Q2FyZFllYXIoJHNlbGVjdEZpZWxkWWVhciwgeWVhcikge1xuICAgIFx0aWYoeWVhciA+IDIwMjYpIHtcbiAgICBcdFx0JHNlbGVjdEZpZWxkWWVhci52YWwoMjAxNCk7XG4gICAgXHR9XG4gICAgXHRlbHNlIHtcbiAgICBcdFx0JHNlbGVjdEZpZWxkWWVhci52YWwoeWVhcik7XG4gICAgXHR9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VsZWN0SGlkZGVuQ3JlZGl0Q2FyZE1vbnRoKCRzZWxlY3RGaWVsZE1vbnRoLCBtb250aCkge1xuICAgIFx0aWYobW9udGggPiAxMikge1xuICAgIFx0XHQkc2VsZWN0RmllbGRNb250aC52YWwoMSk7XG4gICAgXHR9XG4gICAgXHRlbHNlIHtcbiAgICBcdFx0JHNlbGVjdEZpZWxkTW9udGgudmFsKG1vbnRoKTtcbiAgICBcdH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRNb250aCgkdGV4dEJveEV4cGlyYXRpb25EYXRlKSB7XG4gICAgXHR2YXIgbW9udGggPSAxO1xuXG4gICAgXHRpZigkdGV4dEJveEV4cGlyYXRpb25EYXRlICYmICR0ZXh0Qm94RXhwaXJhdGlvbkRhdGUudmFsKCkubGVuZ3RoID4gMSkge1xuICAgIFx0XHRtb250aCA9IHBhcnNlSW50KCR0ZXh0Qm94RXhwaXJhdGlvbkRhdGUudmFsKCkuc3Vic3RyaW5nKDAsIDIpKTtcbiAgICBcdH1cblxuICAgIFx0cmV0dXJuIG1vbnRoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFllYXIoJHRleHRCb3hFeHBpcmF0aW9uRGF0ZSkge1xuICAgIFx0dmFyIHllYXIgPSAyMDE0O1xuXG4gICAgXHRpZigkdGV4dEJveEV4cGlyYXRpb25EYXRlICYmICR0ZXh0Qm94RXhwaXJhdGlvbkRhdGUudmFsKCkubGVuZ3RoID09IDcpXG4gICAgXHRcdHllYXIgPSBwYXJzZUludChcIjIwXCIgKyAkdGV4dEJveEV4cGlyYXRpb25EYXRlLnZhbCgpLnN1YnN0cmluZyg1LCA3KSk7XG5cbiAgICBcdHJldHVybiB5ZWFyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlbGVjdEhpZGRlbkNyZWRpdENhcmRPcHRpb24gKCRzZWxlY3RGaWVsZCwgY3JlZGl0Q2FyZFR5cGUpIHtcbiAgICBcdCRzZWxlY3RGaWVsZC52YWwoY3JlZGl0Q2FyZFR5cGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENyZWRpdENhcmRUeXBlKGNyZWRpdENhcmROdW1iZXIpIHtcbiAgICBcdC8vIERlZmF1bHQgY3JlZGl0IGNhcmQgdHlwZSB0byBWaXNhLlxuICAgIFx0dmFyIGNyZWRpdENhcmRUeXBlID0gXCJcIjtcblxuICAgIFx0Ly8gRW5zdXJlIGNyZWRpdCBjYXJkIG51bWJlciBoYXMgYSBtaW5pbXVtIG9mIHRocmVlIGRpZ2l0cy5cbiAgICBcdC8vIERlZmF1bHQgdG8gVmlzYSBhZ2FpbiBqdXN0IGluIGNhc2UgaXQgd2FzIG5ldmVyIHNldC5cbiAgICBcdGlmKGNyZWRpdENhcmROdW1iZXIubGVuZ3RoID4gMykge1xuXG4gICAgXHRcdGlmICgvXig1WzEtNV18MlsyLTddWzAtOV0pLy50ZXN0KGNyZWRpdENhcmROdW1iZXIpKVxuICAgIFx0XHRcdGNyZWRpdENhcmRUeXBlID0gXCJNYXN0ZXJcIjtcbiAgICBcdFx0ZWxzZSBpZiAoL140Ly50ZXN0KGNyZWRpdENhcmROdW1iZXIpKVxuICAgIFx0XHRcdGNyZWRpdENhcmRUeXBlID0gXCJWaXNhXCI7XG4gICAgXHRcdGVsc2UgaWYgKC9eM1s0N10vLnRlc3QoY3JlZGl0Q2FyZE51bWJlcikpXG4gICAgXHRcdFx0Y3JlZGl0Q2FyZFR5cGUgPSBcIkFtZXhcIjtcbiAgICBcdFx0ZWxzZSBpZiAoL14oNjAxMXw2MjIoMTJbNi05XXwxWzMtOV1bMC05XXxbMi04XVswLTldezJ9fDlbMC0xXVswLTldfDkyWzAtNV18NjRbNC05XSl8NjUpLy50ZXN0KGNyZWRpdENhcmROdW1iZXIpKVxuICAgIFx0XHRcdGNyZWRpdENhcmRUeXBlID0gXCJEaXNjb3ZlclwiO1xuICAgIFx0XHRlbHNlXG4gICAgXHRcdFx0Y3JlZGl0Q2FyZFR5cGUgPSBcIlZpc2FcIlxuICAgIFx0fSBlbHNlIHtcbiAgICBcdFx0Y3JlZGl0Q2FyZFR5cGUgPSBcIlwiO1xuICAgIFx0fVxuXG4gICAgXHQvLyBSZXR1cm4gdGhlIGNyZWRpdCBjYXJkIHR5cGUuXG4gICAgXHRyZXR1cm4gY3JlZGl0Q2FyZFR5cGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q3JlZGl0Q2FyZE51bWJlcigkdGV4dEJveCkge1xuICAgIFx0cmV0dXJuICR0ZXh0Qm94LnZhbCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFsbG93T25seUludGVnZXJzT24oJHRleHRCb3gpIHtcbiAgICBcdCR0ZXh0Qm94LmtleWRvd24oZnVuY3Rpb24gKGUpIHtcbiAgICBcdFx0Ly8gUmV0dXJuIHRydWUgaWYga2V5IHN0cm9rZSBpcyBhIG51bWJlci5cbiAgICBcdFx0Ly8gT3RoZXJ3aXNlLCByZXR1cm4gZmFsc2UuXG4gICAgICAgICAgICB2YXIgaXNOdW1iZXIgPSAoZS5zaGlmdEtleSB8fCAoZS5rZXlDb2RlID49IDQ4ICYmIGUua2V5Q29kZSA8PTU3KSB8fCAoZS5rZXlDb2RlID49IDk2ICYmIGUua2V5Q29kZSA8PTEwNSkpO1xuXG4gICAgXHRcdC8vIFJldHVybiB0cnVlIGlmIGtleSBzdHJva2UgaXMgYSBiYWNrc3BhY2UsIGRlbGV0ZSwgdGFiLCBlc2NhcGUsIGFuZC9vciBlbnRlclxuICAgIFx0XHQvLyBPdGhlcndpc2UsIHJldHVybiBmYWxzZS5cbiAgICBcdFx0dmFyIGFsbG93ZWRLZXkxID0gJC5pbkFycmF5KGUua2V5Q29kZSwgWzQ2LCA4LCA5LCAyNywgMTMsIDExMCwgMTkwXSkgIT09IC0xO1xuXG4gICAgXHRcdC8vIFJldHVybiB0cnVlIGlmIGtleSBzdHJva2UgaXMgQ3RybCtBIG9yIENvbW1hbmQrQVxuICAgIFx0XHQvLyBPdGhlcndpc2UsIHJldHVybiBmYWxzZS5cbiAgICBcdFx0dmFyIGFsbG93ZWRLZXkyID0gKGUua2V5Q29kZSA9PT0gNjUgJiYgKGUuY3RybEtleSA9PT0gdHJ1ZSB8fCBlLm1ldGFLZXkgPT09IHRydWUpKTtcblxuICAgIFx0XHQvLyBSZXR1cm4gdHJ1ZSBpZiBrZXkgc3Ryb2tlIGlzIGhvbWUsIGVuZCwgbGVmdCwgcmlnaHQsIGRvd24sIG9yIHVwLlxuICAgIFx0XHQvLyBPdGhlcndpc2UsIHJldHVybiBmYWxzZS5cbiAgICBcdFx0dmFyIGFsbG93ZWRLZXkzID0gKGUua2V5Q29kZSA+PSAzNSAmJiBlLmtleUNvZGUgPD0gNDApO1xuXG4gICAgICAgICAgICAvLyBEbyBub3QgZG8gYW55dGhpbmcgaWYgdGhlIGN1cnJlbnQga2V5IHN0cm9rZSBpcyBvbmUgb2YgdGhlXG4gICAgXHRcdC8vIGFsbG93ZWQga2V5cy5cbiAgICAgICAgICAgIGlmIChhbGxvd2VkS2V5MSB8fCBhbGxvd2VkS2V5MiB8fCBhbGxvd2VkS2V5MylcbiAgICBcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0Ly8gRG8gbm90IGFsbG93IGtleSBwcmVzcyBpZiB0aGUgdXNlciBpbnB1dCBpcyBub3QgYSBudW1iZXIuXG4gICAgICAgICAgICBpZiAoIWlzTnVtYmVyKVxuICAgIFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gY3JlZGl0IGNhcmQgZm9ybSB0eXBlIGF1dG8tZGV0ZWN0IGFuZCBleHBpcmF0aW9uIGRhdGUgZm9ybWF0XG4gICAgdmFyIGNyZWRpdENhcmROdW1iZXIgPSBcIlwiO1xuXHR2YXIgJHRleHRCb3ggPSAkKFwiLmZvcm0tcm93Om50aC1jaGlsZCgzKSAuaW5wdXQtdGV4dFwiKTtcblx0dmFyICRzZWxlY3RGaWVsZCA9ICQoJyNkd2ZybV9wYXltZW50aW5zdHJ1bWVudHNfY3JlZGl0Y2FyZHNfbmV3Y3JlZGl0Y2FyZF90eXBlJyk7XG5cdHZhciAkdGV4dEJveEV4cGlyYXRpb25EYXRlID0gJChcIiNkd2ZybV9wYXltZW50aW5zdHJ1bWVudHNfY3JlZGl0Y2FyZHNfbmV3Y3JlZGl0Y2FyZF9leHBpcmF0aW9uZGF0ZVwiKTtcblx0dmFyICRzZWxlY3RGaWVsZE1vbnRoID0gJChcIiNkd2ZybV9wYXltZW50aW5zdHJ1bWVudHNfY3JlZGl0Y2FyZHNfbmV3Y3JlZGl0Y2FyZF9tb250aFwiKTtcblx0dmFyICRzZWxlY3RGaWVsZFllYXIgPSAkKFwiI2R3ZnJtX3BheW1lbnRpbnN0cnVtZW50c19jcmVkaXRjYXJkc19uZXdjcmVkaXRjYXJkX3llYXJcIik7XG5cblx0Ly8gT25seSBhbGxvdyBpbnRlZ2VycyBvbiB0aGUgY3JlZGl0IGNhcmQgbnVtYmVyXG5cdC8vIHRleHQgYm94IGZpZWxkLlxuXHRhbGxvd09ubHlJbnRlZ2Vyc09uKCR0ZXh0Qm94KTtcblxuXHR2YXIgJGN1cnJlbnRDYXJkVHlwZSA9ICQoJyNjdXJyZW50LWNhcmQtdHlwZScpLmRldGFjaCgpO1xuXHQkKCcuZm9ybS1yb3c6bnRoLWNoaWxkKDMpJykuYXBwZW5kKCRjdXJyZW50Q2FyZFR5cGUpO1xuXHQkY3VycmVudENhcmRUeXBlLmFwcGVuZChcIjxpbWcgaWQ9J2N1cnJlbnQtY2FyZC10eXBlLWltZycvPlwiKTtcblx0dmFyICRjYXJkSW1nID0gJCgnI2N1cnJlbnQtY2FyZC10eXBlLWltZycpO1xuXG5cdC8vIEtleSBVcCBFdmVudCBmb3IgdGhlIENyZWRpdCBDYXJkIE51bWJlciBUZXh0IEJveCBGaWVsZFxuXHQkdGV4dEJveC5vbigna2V5dXAgYmx1cicsIGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGNyZWRpdENhcmROdW1iZXIgPSBnZXRDcmVkaXRDYXJkTnVtYmVyKCR0ZXh0Qm94KTtcblx0XHR2YXIgY3JlZGl0Q2FyZFR5cGUgPSBnZXRDcmVkaXRDYXJkVHlwZShjcmVkaXRDYXJkTnVtYmVyKTtcblx0XHRzZWxlY3RIaWRkZW5DcmVkaXRDYXJkT3B0aW9uKCRzZWxlY3RGaWVsZCwgY3JlZGl0Q2FyZFR5cGUpO1xuXG5cdFx0dmFyIHNlbGVjdGVkVHlwZVVSTCA9ICRjYXJkSW1nLmF0dHIoXCJzcmNcIik7XG5cdFx0dmFyIHNlbGVjdGVkVHlwZUFsdCA9ICRjYXJkSW1nLmF0dHIoXCJhbHRcIik7XG5cblx0XHRpZihjcmVkaXRDYXJkVHlwZSA9PSBcIlZpc2FcIil7XG5cdFx0XHRzZWxlY3RlZFR5cGVVUkwgPSB2aXNhVVJMO1xuXHRcdFx0c2VsZWN0ZWRUeXBlQWx0ID0gY3JlZGl0Q2FyZFR5cGU7XG5cdFx0fWVsc2UgaWYoY3JlZGl0Q2FyZFR5cGUgPT0gXCJNYXN0ZXJcIil7XG5cdFx0XHRzZWxlY3RlZFR5cGVVUkwgPSBtYXN0ZXJjYXJkVVJMO1xuXHRcdFx0c2VsZWN0ZWRUeXBlQWx0ID0gXCJNYXN0ZXJDYXJkXCI7XG5cdFx0fWVsc2UgaWYoY3JlZGl0Q2FyZFR5cGUgPT0gXCJBbWV4XCIpe1xuXHRcdFx0c2VsZWN0ZWRUeXBlVVJMID0gYW1lcmljYW5leHByZXNzVVJMO1xuXHRcdFx0c2VsZWN0ZWRUeXBlQWx0ID0gXCJBbWVyaWNhbiBFeHByZXNzXCI7XG5cdFx0fWVsc2UgaWYoY3JlZGl0Q2FyZFR5cGUgPT0gXCJEaXNjb3ZlclwiKXtcblx0XHRcdHNlbGVjdGVkVHlwZVVSTCA9IGRpc2NvdmVyVVJMO1xuXHRcdFx0c2VsZWN0ZWRUeXBlQWx0ID0gXCJEaXNjb3ZlclwiO1xuXHRcdH1cblx0XHRpZigkKHRoaXMpLnZhbCgpICYmIGNyZWRpdENhcmRUeXBlICE9ICcnKSB7XG5cdFx0XHQkY2FyZEltZy5hdHRyKFwic3JjXCIsIHNlbGVjdGVkVHlwZVVSTCwgXCJhbHRcIiwgc2VsZWN0ZWRUeXBlQWx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0JGNhcmRJbWcuYXR0cihcInNyY1wiLCAnJywgXCJhbHRcIiwgJycpO1xuXHRcdH1cblx0fSk7XG5cblx0JHRleHRCb3gubWFzayhcIjAwMDAgIDAwMDAgIDAwMDAgIDAwMDBcIiwgeyB3YXRjaElucHV0czogdHJ1ZSB9KTtcblxuXG5cdC8vIE9ubHkgYWxsb3cgaW50ZWdlcnMgb24gdGhlIGNyZWRpdCBjYXJkIG51bWJlclxuXHQvLyB0ZXh0IGJveCBmaWVsZC5cblx0YWxsb3dPbmx5SW50ZWdlcnNPbigkdGV4dEJveEV4cGlyYXRpb25EYXRlKTtcblxuXG5cdC8vIEtleSBVcCBFdmVudCBmb3IgdGhlIENyZWRpdCBDYXJkJ3MgRXhwaXJhdGlvbiBEYXRlXG5cdCR0ZXh0Qm94RXhwaXJhdGlvbkRhdGUub24oJ2tleXVwIGJsdXInLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy8gR2V0IHllYXIgZnJvbSBpbnB1dCBmaWVsZFxuICAgICAgICB2YXIgeWVhckRhdGEgPSAgJHRleHRCb3hFeHBpcmF0aW9uRGF0ZS52YWwoKS5zdWJzdHIoNCwgMyk7XG4gICAgICAgICAgICAvLyBHZXQgTW9udGggZnJvbSBpbnB1dCBmaWVsZFxuICAgICAgICB2YXIgbW9udGhEYXRhID0gJHRleHRCb3hFeHBpcmF0aW9uRGF0ZS52YWwoKS5zdWJzdHIoMCwgMik7XG4gICAgICAgICAgICAvLyBHZXQgY3VycmVudCB5ZWFyXG4gICAgICAgIHZhciBjdXJyZW50WWVhciA9ICBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAvLyBHZXQgY3VycmVudCBtb250aFxuICAgICAgICB2YXIgY3VycmVudE1vbnRoID0gbmV3IERhdGUoKS5nZXRNb250aCgpO1xuICAgICAgICAgICAgLy8gR2V0IGFsbG93ZWQgeWVhciByYW5nZVxuICAgICAgICB2YXIgYWxsb3dZZWFyID0gY3VycmVudFllYXIgKyA5O1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHllYXJcbiAgICAgICAgeWVhckRhdGEgPSAnMjAnK3BhcnNlSW50KHllYXJEYXRhKTtcbiAgICAgICAgICAgIC8vIEFzc2lnbiBzZWxlY3RlZCBtb250aCBhbmQgeWVhciB0byBoaWRkZW4gbW9udGgveWVhciBmaWVsZHNcbiAgICAgICAgc2VsZWN0SGlkZGVuQ3JlZGl0Q2FyZE1vbnRoKCRzZWxlY3RGaWVsZE1vbnRoLCBtb250aERhdGEpO1xuICAgICAgICBzZWxlY3RIaWRkZW5DcmVkaXRDYXJkWWVhcigkc2VsZWN0RmllbGRZZWFyLCB5ZWFyRGF0YSk7XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB1c2VyIGhhcyBlbnRlcmVkIGluIGRhdGVcbiAgICAgICAgaWYgKHllYXJEYXRhLmxlbmd0aCA9PSA0ICYmIHBhcnNlSW50KG1vbnRoRGF0YSkgPiAwICYmIHBhcnNlSW50KG1vbnRoRGF0YSkgPCAxMykge1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBjcmVkaXQgY2FyZCBkYXRlIGlzbid0IGV4cGlyZWRcblxuICAgICAgICBcdGlmICggKHllYXJEYXRhID09IGN1cnJlbnRZZWFyICYmIG1vbnRoRGF0YSA+PSBjdXJyZW50TW9udGgpIHx8ICh5ZWFyRGF0YSA8PSBhbGxvd1llYXIgJiYgeWVhckRhdGEgPiBjdXJyZW50WWVhcikgKSB7XG4gICAgICAgICAgICAgICAgJHRleHRCb3hFeHBpcmF0aW9uRGF0ZS5hZGRDbGFzcygndmFsaWQnKS5uZXh0KCcuZXJyb3InKS50ZXh0KCcnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHRleHRCb3hFeHBpcmF0aW9uRGF0ZS5yZW1vdmVDbGFzcygndmFsaWQnKS5uZXh0KCcuZXJyb3InKS5yZW1vdmVDbGFzcygndmFsaWQnKS50ZXh0KFJlc291cmNlcy5JTlZBTElEX0VYUElSQVRJT04pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHRleHRCb3hFeHBpcmF0aW9uRGF0ZS5yZW1vdmVDbGFzcygndmFsaWQnKS5uZXh0KCcuZXJyb3InKS5yZW1vdmVDbGFzcygndmFsaWQnKS50ZXh0KFJlc291cmNlcy5NSVNTSU5HX0VYUElSQVRJT04pO1xuICAgICAgICB9XG5cblx0fSk7XG5cblx0Ly8gTWFzayB0aGUgQ3JlZGl0IENhcmQncyBFeHBpcmF0aW9uIERhdGVcblx0JHRleHRCb3hFeHBpcmF0aW9uRGF0ZS5tYXNrKFwiMDAgLyAwMFwiLCB7IHdhdGNoSW5wdXRzOiB0cnVlIH0pO1xuXG5cdCQoJy5mb3JtLXJvdzpoYXMoc2VsZWN0KScpLmhpZGUoKTtcblxuXHRmbG9hdGxhYmVscy5pbml0KCk7XG5cdHZhbGlkYXRvci5pbml0KCk7XG59XG5cbmZ1bmN0aW9uIHByZWZlcnJlZFN0b3JlVGVtcGxhdGUoc3RvcmUpIHtcbiAgICB2YXIgbmV3TGluZSA9ICdcXG4nO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgJzxsaT4nLFxuICAgICAgICAnICAgIDxkaXYgY2xhc3M9XCJzdG9yZVwiPicsXG4gICAgICAgICcgICAgICAgIDxkaXYgY2xhc3M9XCJzdG9yZS1pbmZvcm1hdGlvblwiPicsXG4gICAgICAgICcgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3RvcmUtbmFtZVwiPicgKyBzdG9yZS5uYW1lICsgJzwvZGl2PicsXG4gICAgICAgICcgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3RvcmUtYWRkcmVzc1wiPicsXG4gICAgICAgICcgICAgICAgICAgICAgICAgPGRpdj4nICsgc3RvcmUuYWRkcmVzczEgKyAnPC9kaXY+JyxcbiAgICAgICAgJyAgICAgICAgICAgICAgICA8ZGl2PicgKyBzdG9yZS5jaXR5ICsgKChzdG9yZS5zdGF0ZUNvZGUpID8gJywgJyArIHN0b3JlLnN0YXRlQ29kZSA6ICcnKSxcbiAgICAgICAgJyAgICAgICAgICAgICAgICAgICAgICcgKyBzdG9yZS5wb3N0YWxDb2RlLFxuICAgICAgICAnICAgICAgICAgICAgICAgIDwvZGl2PicsXG4gICAgICAgICcgICAgICAgICAgICAgICAgPGRpdj4nICsgc3RvcmUuY291bnRyeUNvZGUgKyAnPC9kaXY+JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAoKHN0b3JlLnBob25lKSA/ICc8ZGl2IGNsYXNzPVwic3RvcmUtcGhvbmVcIj4nICsgc3RvcmUucGhvbmUgKyAnPC9kaXY+JyA6ICcnKSxcbiAgICAgICAgJyAgICAgICAgICAgIDwvZGl2PicsXG4gICAgICAgICcgICAgICAgIDwvZGl2PicsXG4gICAgICAgICcgICAgPC9kaXY+JyxcbiAgICAgICAgJzwvbGk+J1xuICAgIF0uam9pbihuZXdMaW5lKTtcbn1cblxuZnVuY3Rpb24gc3RvcmVUZW1wbGF0ZShzdG9yZSwgcHJlZmVycmVkU3RvcmVJRCkge1xuICAgIHZhciBuZXdMaW5lID0gJ1xcbic7XG5cbiAgICAvLyBSZW1vdmUgYWxsIEhUTUwgYWZ0ZXIgdHdvIDxicj4gZWxlbWVudHMgZnJvbSBzdG9yZSBob3Vyc1xuICAgIHZhciBzdG9yZUhvdXJzT25seSA9IHN0b3JlLnN0b3JlSG91cnMuc3BsaXQoLzxiclxccypcXC8qPlxccyo8YnJcXHMqXFwvKj4vKVswXTtcblxuICAgIHZhciBzdG9yZUhvdXJzUGFydHMgPSBzdG9yZUhvdXJzT25seS5zcGxpdCgvPGJyXFxzKlxcLyo+Lyk7XG4gICAgdmFyIHN0b3JlSG91cnNTdGFja2VkID0gc3RvcmVIb3Vyc1BhcnRzLmpvaW4oJzxici8+Jyk7XG4gICAgdmFyIHN0b3JlSG91cnNMb25nID0gc3RvcmVIb3Vyc1BhcnRzLmpvaW4oJywgXFx1MDBBMCcpO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgJzxsaSBjbGFzcz1cInN0b3JlLXRpbGUgc3RvcmUtdGlsZS1pZC0nICsgc3RvcmUuc3RvcmVJZCArIChzdG9yZS5zdG9yZUlkID09PSBwcmVmZXJyZWRTdG9yZUlEID8gJyBzZWxlY3RlZCcgOiAnJykgKyAnXCInICtcbiAgICAgICAgICAgICcgZGF0YS1zdG9yZS1pZD1cIicgKyBzdG9yZS5zdG9yZUlkICsgJ1wiPicsXG4gICAgICAgICAgICAoKHN0b3JlLnN0b3JlSWQgPT09IHByZWZlcnJlZFN0b3JlSUQpID8gJzxzcGFuIGNsYXNzPVwicHJlZmVycmVkLXNob3AtbXNnXCI+JyArICd5b3VyIHByZWZlcnJlZCBzaG9wJyArICc8L3NwYW4+JyA6ICcnKSxcbiAgICAgICAgJyAgICA8YnV0dG9uIGNsYXNzPVwic2VsZWN0LXN0b3JlLXJhZGlvXCIgZGF0YS1zdG9yZS1pZD1cIicgKyBzdG9yZS5zdG9yZUlkICsgJ1wiJyArJz4nLFxuICAgICAgICAnICAgIDwvYnV0dG9uPicsXG4gICAgICAgICcgICAgPGRpdiBjbGFzcz1cInN0b3JlLXByaW1hcnktaW5mb1wiPicsXG4gICAgICAgICcgICAgICAgIDxwIGNsYXNzPVwic3RvcmUtbmFtZVwiPicsXG4gICAgICAgICcgICAgICAgICAgICAnICsgc3RvcmUubmFtZSArICc8YnIvPicsXG4gICAgICAgICcgICAgICAgIDwvcD4nLFxuICAgICAgICAnICAgICAgICA8cCBjbGFzcz1cInN0b3JlLWFkZHJlc3NcIj4nLFxuICAgICAgICAnICAgICAgICAgICAgJyArIHN0b3JlLmFkZHJlc3MxICsgJzxici8+JyxcbiAgICAgICAgJyAgICAgICAgICAgICcgKyBzdG9yZS5jaXR5ICsgJywgJyArIHN0b3JlLnN0YXRlQ29kZSArICcgJyArIHN0b3JlLnBvc3RhbENvZGUsXG4gICAgICAgICcgICAgICAgIDwvcD4nLFxuICAgICAgICAnICAgIDwvZGl2PicsXG4gICAgICAgICcgICAgPGRpdiBjbGFzcz1cInN0b3JlLXNlY29uZGFyeS1pbmZvXCI+JyxcbiAgICAgICAgJyAgICAgICAgPHAgY2xhc3M9XCJzdG9yZS1ob3Vycy1zdGFja2VkXCI+JyArIHN0b3JlSG91cnNTdGFja2VkICsgJzwvcD4nLFxuICAgICAgICAnICAgICAgICA8cCBjbGFzcz1cInN0b3JlLWhvdXJzLWxvbmdcIj4nICsgc3RvcmVIb3Vyc0xvbmcgKyAnPC9wPicsXG4gICAgICAgICcgICAgPC9kaXY+JyxcbiAgICAgICAgJyAgICA8YSBjbGFzcz1cInN0b3JlLW1hcC10b2dnbGVcIj4nICsgJ01BUCcgKyAnPC9hPicsXG4gICAgICAgICcgICAgPGRpdiBjbGFzcz1cInN0b3JlLW1hcC1jb250YWluZXJcIj4nLFxuICAgICAgICAnICAgICAgIDxkaXYgY2xhc3M9XCJzdG9yZS1tYXBcIj48L2Rpdj4nLFxuICAgICAgICAnICAgIDwvZGl2PicsXG4gICAgICAgICc8L2xpPidcbiAgICBdLmpvaW4obmV3TGluZSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlWmlwQ29kZSh6aXBDb2RlKSB7XG4gICAgdmFyIHJlZ2V4ZXMgPSB7XG4gICAgICAgICAgICBjYW5hZGE6IC9eW0FCQ0VHSEpLTE1OUFJTVFZYWV1cXGRbQUJDRUdISktMTU5QUlNUVldYWVpdKCApP1xcZFtBQkNFR0hKS0xNTlBSU1RWV1hZWl1cXGQkL2ksXG4gICAgICAgICAgICB1c2E6IC9eXFxkezV9KC1cXGR7NH0pPyQvXG4gICAgICAgIH07XG4gICAgdmFyIHZhbGlkID0gZmFsc2U7XG4gICAgaWYgKCF6aXBDb2RlKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgXy5lYWNoKHJlZ2V4ZXMsIGZ1bmN0aW9uKHJlKSB7XG4gICAgICAgIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKHJlKTtcbiAgICAgICAgdmFsaWQgPSByZWdleHAudGVzdCh6aXBDb2RlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB2YWxpZDtcbn1cblxudmFyIG5lYXJlc3RTdG9yZSA9IHtcbiAgICBESVNQTEFZX1NUT1JFU19DT1VOVDogMyxcbiAgICAkY2FjaGU6IHt9LFxuXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciAkY29udGFpbmVyID0gJCgnI3NlYXJjaC1zdG9yZXMtY29udGFpbmVyJyk7XG4gICAgICAgIHRoaXMuJGNhY2hlID0ge1xuICAgICAgICAgICAgY29udGFpbmVyOiAkY29udGFpbmVyLFxuICAgICAgICAgICAgc3RvcmVMaXN0OiAkY29udGFpbmVyLmZpbmQoJy5zdG9yZS1saXN0JyksXG4gICAgICAgICAgICBzdG9yZUNvdW50ZXI6ICRjb250YWluZXIuZmluZCgnLnN0b3JlLWNvdW50ZXInKSxcbiAgICAgICAgICAgIHppcElucHV0OiAkY29udGFpbmVyLmZpbmQoJy56aXAtaW5wdXQnKSxcbiAgICAgICAgICAgIGRpc3RhbmNlSW5wdXQ6ICRjb250YWluZXIuZmluZCgnLmRpc3RhbmNlLWlucHV0JyksXG4gICAgICAgICAgICBkaXN0YW5jZUxhYmVsOiAkY29udGFpbmVyLmZpbmQoJy5kaXN0YW5jZS1pbnB1dC1sYWJlbCcpLFxuICAgICAgICAgICAgcHJlZmVycmVkU3RvcmVzOiAkKCcuanMtcHJlZmVycmVkLXN0b3JlLWxpc3QnKVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuaW5pdEV2ZW50cygpO1xuICAgICAgICB0aGlzLnVwZGF0ZURpc3RhbmNlTGFiZWwoKTtcbiAgICB9LFxuXG4gICAgb3BlbkRpYWxvZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBUUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICB1cmw6IFVybHMuYWNjb3VudFNlYXJjaFN0b3JlcyxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZSA6ICdqc29uJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBzZWxmLnVwZGF0ZURpYWxvZyhyZXNwb25zZSk7XG4gICAgICAgICAgICB2YXIgZGlhbG9nV2lkdGggPSAod2luZG93LmlubmVyV2lkdGggPCA3MDgpID8gKHdpbmRvdy5pbm5lcldpZHRoKS50b1N0cmluZygpIDogJzY2OCc7XG5cbiAgICAgICAgICAgIGRpYWxvZy5vcGVuKHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6ICQoJyNzZWFyY2gtc3RvcmVzLWNvbnRhaW5lcicpLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IFJlc291cmNlcy5VUERBVEVfTVlfU1RPUkUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0U3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZ0NsYXNzOiAnYWNjb3VudC1zZWFyY2gtc3RvcmVzLWRpYWxvZycsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBkaWFsb2dXaWR0aFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgdXBkYXRlRGlhbG9nOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgLy8gVXBkYXRlIHN0b3JlIGxpc3RcbiAgICAgICAgdmFyIHN0b3JlcyA9IGRhdGEua2F0ZVN0b3Jlcy5zbGljZSgwLCB0aGlzLkRJU1BMQVlfU1RPUkVTX0NPVU5UKTtcbiAgICAgICAgdmFyIHN0b3JlTGlzdEhUTUwgPSBfLm1hcChzdG9yZXMsIGZ1bmN0aW9uKHN0b3JlKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmVUZW1wbGF0ZShzdG9yZSwgZGF0YS5wcmVmZXJyZWRTdG9yZUlEKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuJGNhY2hlLnN0b3JlTGlzdC5lbXB0eSgpXG4gICAgICAgICAgICAuaHRtbChzdG9yZUxpc3RIVE1MKTtcblxuICAgICAgICAvLyBCaW5kIGZ1bGwgc3RvcmVzIGRhdGEgdG8gRE9NIGVsZW1lbnRzXG4gICAgICAgIF8uZWFjaChzdG9yZXMsIGZ1bmN0aW9uKHN0b3JlKSB7XG4gICAgICAgICAgICBzZWxmLiRjYWNoZS5zdG9yZUxpc3QuZmluZCgnLnN0b3JlLXRpbGUtaWQtJyArIHN0b3JlLnN0b3JlSWQpXG4gICAgICAgICAgICAgICAgLmRhdGEoJ3NvdXJjZU9iaicsIHN0b3JlKTtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICAvLyBVcGRhdGUgc3RvcmVzIGNvdW50ZXJcbiAgICAgICAgdmFyIHN0b3JlQ291bnQgPSBzdG9yZXMubGVuZ3RoO1xuICAgICAgICB0aGlzLiRjYWNoZS5zdG9yZUNvdW50ZXIudGV4dChzdG9yZUNvdW50KTtcblxuICAgICAgICAvLyBVcGRhdGUgemlwIGNvZGUgdmFsdWUgaWYgbmVlZGVkXG4gICAgICAgIGlmIChkYXRhLmRlZmF1bHRaaXApIHtcbiAgICAgICAgICAgIHRoaXMuJGNhY2hlLnppcElucHV0LnZhbChkYXRhLmRlZmF1bHRaaXApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGluaXRFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciAkY29udGFpbmVyID0gdGhpcy4kY2FjaGUuY29udGFpbmVyO1xuXG4gICAgICAgICQoJy5qcy1hY2NvdW50LXNldHVwLXByZWZlcnJlZC1zdG9yZScpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5vcGVuRGlhbG9nKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRjb250YWluZXIub24oJ2NsaWNrJywgJy5zZWxlY3Qtc3RvcmUtcmFkaW8nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIHZhciAkc3RvcmVUaWxlID0gJCh0aGlzKS5jbG9zZXN0KCcuc3RvcmUtdGlsZScpO1xuICAgICAgICAgICAgaWYgKCEkc3RvcmVUaWxlLmhhc0NsYXNzKCdzZWxlY3RlZCcpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi4kY2FjaGUuc3RvcmVMaXN0LmZpbmQoJy5zdG9yZS10aWxlLnNlbGVjdGVkJykucmVtb3ZlQ2xhc3MoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgJHN0b3JlVGlsZS5hZGRDbGFzcygnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgJGNvbnRhaW5lci5vbignY2xpY2snLCAnLnN0b3JlLW1hcC10b2dnbGUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAgICAgICB2YXIgJHN0b3JlVGlsZSA9ICR0aGlzLmNsb3Nlc3QoJy5zdG9yZS10aWxlJyk7XG4gICAgICAgICAgICB2YXIgJG1hcENvbnRhaW5lciA9ICRzdG9yZVRpbGUuZmluZCgnLnN0b3JlLW1hcCcpO1xuXG4gICAgICAgICAgICAkbWFwQ29udGFpbmVyLnRvZ2dsZSgpO1xuICAgICAgICAgICAgJHRoaXMudG9nZ2xlQ2xhc3MoJ3Zpc2libGUnKTtcbiAgICAgICAgICAgICRzdG9yZVRpbGUuZmluZCgnLnN0b3JlLW1hcC1jb250YWluZXInKVxuICAgICAgICAgICAgICAgIC50b2dnbGVDbGFzcygndmlzaWJsZScpO1xuXG4gICAgICAgICAgICBpZiAoJG1hcENvbnRhaW5lci5jaGlsZHJlbigpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXAgPSBuZXcgZ29vZ2xlLm1hcHMuTWFwKCRtYXBDb250YWluZXJbMF0sIHtcbiAgICAgICAgICAgICAgICAgICAgem9vbTogOFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIGdlb2NvZGVyID0gbmV3IGdvb2dsZS5tYXBzLkdlb2NvZGVyKCk7XG4gICAgICAgICAgICAgICAgdmFyIGFkZHJlc3MgPSAkc3RvcmVUaWxlLmZpbmQoJy5zdG9yZS1hZGRyZXNzJylbMF0uaW5uZXJUZXh0O1xuICAgICAgICAgICAgICAgIGdlb2NvZGVyLmdlb2NvZGUoeydhZGRyZXNzJzogYWRkcmVzc30sIGZ1bmN0aW9uKHJlc3VsdHMsIHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnT0snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuc2V0Q2VudGVyKHJlc3VsdHNbMF0uZ2VvbWV0cnkubG9jYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmtlciA9IG5ldyBnb29nbGUubWFwcy5NYXJrZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcDogbWFwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiByZXN1bHRzWzBdLmdlb21ldHJ5LmxvY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0dlb2NvZGUgd2FzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZm9sbG93aW5nIHJlYXNvbjogJyArIHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgJGNvbnRhaW5lci5vbignc3VibWl0JywgJyNzaG93U3RvcmVzRm9ybScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHNlbGYudXBkYXRlU3RvcmVzKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuJGNhY2hlLmRpc3RhbmNlSW5wdXQub24oJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi51cGRhdGVEaXN0YW5jZUxhYmVsKCk7XG4gICAgICAgICAgICBzZWxmLnVwZGF0ZVN0b3JlcygpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgdXBkYXRlU3RvcmVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHZhciB6aXBDb2RlID0gdGhpcy4kY2FjaGUuemlwSW5wdXQudmFsKCk7XG4gICAgICAgIHZhciBtYXhEaXN0YW5jZSA9IHRoaXMuJGNhY2hlLmRpc3RhbmNlSW5wdXQudmFsKCk7XG4gICAgICAgIGlmICghdmFsaWRhdGVaaXBDb2RlKHppcENvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXJsID0gdXRpbC5hcHBlbmRQYXJhbXNUb1VybChVcmxzLmFjY291bnRTZWFyY2hTdG9yZXMsIHtcbiAgICAgICAgICAgIHppcDogemlwQ29kZSxcbiAgICAgICAgICAgIGRpc3RhbmNlOiBtYXhEaXN0YW5jZVxuICAgICAgICB9KTtcblxuICAgICAgICBUUHJvbWlzZS5yZXNvbHZlKCQuYWpheCh7XG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgfSkpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHNlbGYudXBkYXRlRGlhbG9nKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHVwZGF0ZURpc3RhbmNlTGFiZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLiRjYWNoZS5kaXN0YW5jZUlucHV0LmZpbmQoJ29wdGlvbjpzZWxlY3RlZCcpLmF0dHIoJ3ZhbHVlJyk7XG4gICAgICAgIHRoaXMuJGNhY2hlLmRpc3RhbmNlTGFiZWwudGV4dCgnUmFkaXVzOiAnICsgdmFsdWUgKyAnIG1pbGVzJyk7XG4gICAgfSxcblxuICAgIHNldFN0b3JlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHZhciAkc2VsZWN0ZWRTdG9yZSA9IHRoaXMuJGNhY2hlLnN0b3JlTGlzdC5maW5kKCcuc3RvcmUtdGlsZS5zZWxlY3RlZCcpO1xuICAgICAgICBpZiAoJHNlbGVjdGVkU3RvcmUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgc3RvcmVJZCA9ICRzZWxlY3RlZFN0b3JlLmRhdGEoJ3N0b3JlLWlkJyk7XG4gICAgICAgICAgICB2YXIgdXJsID0gdXRpbC5hcHBlbmRQYXJhbXNUb1VybChVcmxzLnNldE5lYXJlc3RTdG9yZSwge1xuICAgICAgICAgICAgICAgIHN0b3JlSWQ6IHN0b3JlSWRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBUUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZSA6ICdqc29uJ1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZVByZWZlcnJlZFN0b3JlKCRzZWxlY3RlZFN0b3JlLmRhdGEoJ3NvdXJjZU9iaicpKTtcbiAgICAgICAgICAgICAgICAgICAgJCgnLnVuc2VsZWN0ZWQtbmVhcmVzdC1zdG9yZS1oZWFkZXInKS5odG1sKFJlc291cmNlcy5ORUFSRVNUX1NUT1JFX1NFTEVDVEVEX0hFQURFUikucmVtb3ZlQ2xhc3MoJ3Vuc2VsZWN0ZWQtbmVhcmVzdC1zdG9yZS1oZWFkZXInKTtcbiAgICAgICAgICAgICAgICAgICAgJCgnLnVuc2VsZWN0ZWQtbmVhcmVzdC1zdG9yZS1idXR0b24nKS5odG1sKFJlc291cmNlcy5ORUFSRVNUX1NUT1JFX0VESVQpLnJlbW92ZUNsYXNzKCd1bnNlbGVjdGVkLW5lYXJlc3Qtc3RvcmUtYnV0dG9uJyk7XG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdXBkYXRlUHJlZmVycmVkU3RvcmU6IGZ1bmN0aW9uKHN0b3JlKSB7XG4gICAgICAgIHZhciBzdG9yZUh0bWwgPSBwcmVmZXJyZWRTdG9yZVRlbXBsYXRlKHN0b3JlKTtcbiAgICAgICAgdGhpcy4kY2FjaGUucHJlZmVycmVkU3RvcmVzLmh0bWwoc3RvcmVIdG1sKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBpbml0UGVyc29uYWxFdmVudHMoKSB7XG5cdCQoJyNhY2NvdW50LXBlcnNvbmFsZGF0YSAuZWRpdC1saW5rJykub24oXCJjbGlja1wiLCBmdW5jdGlvbihlKXtcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0ZGlhbG9nLm9wZW4oe1xuXHRcdFx0dXJsOiB0aGlzLmdldEF0dHJpYnV0ZSgncG9wdXAtaHJlZicpLFxuXHRcdFx0Y2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpbml0aWFsaXplSW5mb0Zvcm0oKTtcblx0XHRcdFx0aW5pdGlhbGl6ZVBhc3N3b3JkRm9ybSgpO1xuXHRcdFx0fSxcblx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0J3dpZHRoJyA6IHdpbmRvdy5pbm5lcldpZHRoIDwgNzY4ID8gd2luZG93LmlubmVyV2lkdGggLSA0MCA6IDY2OCxcblx0XHRcdFx0J2hlaWdodCcgOiAnYXV0bycsXG5cdFx0XHRcdCdkaWFsb2dDbGFzcyc6IFwicGVyc29uYWxkYXRhLW1vZGFsXCJcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8vZnVuY3Rpb25zIGZvciBvcmRlciBoaXN0b3J5XG5mdW5jdGlvbiBpbml0T3JkZXJIaXN0b3J5KCl7XG5cdCQoJy5vcmRlci1kZXRhaWxzLWxpbmtiYWNrJykuY2xpY2soZnVuY3Rpb24oZSl7XG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdHdpbmRvdy5oaXN0b3J5LmdvKC0xKTtcblx0fSk7XG59XG5cbi8vQUNDT1VOVCBFRElUIElORk8gLSBQRVJTT05BTCBJTkZPIEZPUk0gTE9BREVEIFZJQSBBSkFYXG5mdW5jdGlvbiBpbml0aWFsaXplSW5mb0Zvcm0oKSB7XG5cdHZhciBmb3JtID0gJChcIiNwZXJzb25hbEVkaXRJbmZvXCIpO1xuXHR2YXIgZGF0ZUZpZWxkcyA9IFtcIiNkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2JpcnRoTW9udGhcIiwgXCIjZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aERheVwiLCBcIiNkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2JpcnRoWWVhclwiXTtcblxuXHQvLyBDbGVhciBmb3JtIG9mIGVycm9ycyBhbmQgZm9jdXNcblx0YXBwLnV0aWwuZm9ybUJsdXIoZm9ybSk7XG5cdCQoJyNkd2ZybV9wcm9maWxlX2N1c3RvbWVyX25ld2VtYWlsJykuYXR0cigndmFsdWUnLCBjdXN0b21lckVtYWlsQWRkcmVzcyk7XG5cdCQoJyNkd2ZybV9wcm9maWxlX2N1c3RvbWVyX25ld2VtYWlsY29uZmlybScpLmF0dHIoJ3ZhbHVlJywgY3VzdG9tZXJFbWFpbEFkZHJlc3MpO1xuXHRmbG9hdGxhYmVscy5pbml0KCk7XG5cblx0Zm9ybS52YWxpZGF0ZSh7XG5cdFx0Z3JvdXBzOiB7XG5cdFx0XHRkYXRlOiBcImR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfYmlydGhNb250aCBkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2JpcnRoRGF5IGR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfYmlydGhZZWFyXCJcblx0XHR9LFxuXHRcdHJ1bGVzOiB7XG5cdFx0XHRcImR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfYmlydGhNb250aFwiOiB7XG5cdFx0XHRcdG11bHRpZGF0ZTogZGF0ZUZpZWxkc1xuXHRcdFx0fSxcblx0XHRcdFwiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aERheVwiOiB7XG5cdFx0XHRcdG11bHRpZGF0ZTogZGF0ZUZpZWxkc1xuXHRcdFx0fSxcblx0XHRcdFwiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aFllYXJcIjoge1xuXHRcdFx0XHRtdWx0aWRhdGU6IGRhdGVGaWVsZHNcblx0XHRcdH1cblx0XHR9LFxuXHRcdG1lc3NhZ2VzOiB7XG5cdFx0XHRcImR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfZmlyc3RuYW1lXCI6IHtcblx0XHRcdFx0cmVxdWlyZWQ6IGFwcC5yZXNvdXJjZXMuTUlTU0lOR19GSVJTVF9OQU1FXG5cdFx0XHR9LFxuXHRcdFx0XCJkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2xhc3RuYW1lXCI6IHtcblx0XHRcdFx0cmVxdWlyZWQ6IGFwcC5yZXNvdXJjZXMuTUlTU0lOR19MQVNUX05BTUVcblx0XHRcdH0sXG5cdFx0XHRcImR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfZW1haWxcIjoge1xuXHRcdFx0XHRyZXF1aXJlZDogYXBwLnJlc291cmNlcy5NSVNTSU5HX0VNQUlMXG5cdFx0XHR9LFxuXHRcdFx0XCJkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2VtYWlsY29uZmlybVwiOiB7XG5cdFx0XHRcdHJlcXVpcmVkOiBhcHAucmVzb3VyY2VzLk1JU1NJTkdfRU1BSUxDT05GSVJNXG5cdFx0XHR9LFxuXHRcdFx0XCJkd2ZybV9wcm9maWxlX2xvZ2luX3Bhc3N3b3JkXCI6IHtcblx0XHRcdFx0cmVxdWlyZWQ6IGFwcC5yZXNvdXJjZXMuTUlTU0lOR19QQVNTV09SRFxuXHRcdFx0fSxcblx0XHRcdFwiZHdmcm1fcHJvZmlsZV9sb2dpbl9wYXNzd29yZGNvbmZpcm1cIjoge1xuXHRcdFx0XHRyZXF1aXJlZDogYXBwLnJlc291cmNlcy5NSVNTSU5HX1BBU1NXT1JEQ09ORklSTVxuXHRcdFx0fSxcblx0XHRcdFwiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl96aXBcIjoge1xuXHRcdFx0XHRyZXF1aXJlZDogYXBwLnJlc291cmNlcy5NSVNTSU5HX1BPU1RBTFxuXHRcdFx0fSxcblx0XHRcdFwiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aE1vbnRoXCI6IHtcblx0XHRcdFx0bXVsdGlkYXRlOiBhcHAucmVzb3VyY2VzLkJJUlRIREFURV9JTlZBTElEXG5cdFx0XHR9LFxuXHRcdFx0XCJkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2JpcnRoRGF5XCI6IHtcblx0XHRcdFx0bXVsdGlkYXRlOiBhcHAucmVzb3VyY2VzLkJJUlRIREFURV9JTlZBTElEXG5cdFx0XHR9LFxuXHRcdFx0XCJkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2JpcnRoWWVhclwiOiB7XG5cdFx0XHRcdG11bHRpZGF0ZTogYXBwLnJlc291cmNlcy5CSVJUSERBVEVfSU5WQUxJRFxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXJyb3JDbGFzcyA6ICdlcnJvcicsXG5cdFx0ZXJyb3JFbGVtZW50IDogJ3NwYW4nLFxuXHRcdGlnbm9yZTogXCI6aGlkZGVuOm5vdCgucmVwbGFjZWQpXCIsXG5cdFx0b25rZXl1cCA6IGZhbHNlLFxuXHRcdG9uZm9jdXNvdXQgOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuXHRcdFx0aWYoIXRoaXMuY2hlY2thYmxlKGVsZW1lbnQpKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudChlbGVtZW50KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGhpZ2hsaWdodCA6IGZ1bmN0aW9uKGVsZW1lbnQsIGVycm9yQ2xhc3MsIHZhbGlkQ2xhc3MpIHtcblx0XHRcdGlmIChlbGVtZW50LnR5cGUgPT09ICdyYWRpbycpIHtcblx0XHRcdFx0dGhpcy5maW5kQnlOYW1lKGVsZW1lbnQubmFtZSkuYWRkQ2xhc3MoZXJyb3JDbGFzcykucmVtb3ZlQ2xhc3ModmFsaWRDbGFzcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQkKGVsZW1lbnQpLmFkZENsYXNzKGVycm9yQ2xhc3MpLnJlbW92ZUNsYXNzKHZhbGlkQ2xhc3MpO1xuXHRcdFx0XHRpZihlbGVtZW50LnR5cGUgPT09ICdzZWxlY3Qtb25lJyl7XG5cdFx0XHRcdFx0dmFyICRlbGVtZW50ID0gJChlbGVtZW50KTtcblx0XHRcdFx0XHRpZigkZWxlbWVudC5hdHRyKCdpZCcpICYmICRlbGVtZW50Lmhhc0NsYXNzKCdyZXBsYWNlZCcpKXtcblx0XHRcdFx0XHRcdHZhciBzZWxlY3RCb3ggPSAkKCcjJyArICRlbGVtZW50LmF0dHIoJ2lkJykgKyAnU2VsZWN0Qm94SXRDb250YWluZXInKTtcblx0XHRcdFx0XHRcdGlmKHNlbGVjdEJveCl7XG5cdFx0XHRcdFx0XHRcdHNlbGVjdEJveC5hZGRDbGFzcyhlcnJvckNsYXNzKS5yZW1vdmVDbGFzcyh2YWxpZENsYXNzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICgkKGVsZW1lbnQpLmF0dHIoJ2lkJykgPT09IFwiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aE1vbnRoXCJcblx0XHRcdFx0XHR8fCAkKGVsZW1lbnQpLmF0dHIoJ2lkJykgPT09IFwiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aERheVwiXG5cdFx0XHRcdFx0fHwgJChlbGVtZW50KS5hdHRyKCdpZCcpID09PSBcImR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfYmlydGhZZWFyXCIpIHtcblx0XHRcdFx0JChkYXRlRmllbGRzWzBdKS5yZW1vdmVDbGFzcyhlcnJvckNsYXNzKTtcblx0XHRcdFx0JChkYXRlRmllbGRzWzFdKS5yZW1vdmVDbGFzcyhlcnJvckNsYXNzKTtcblx0XHRcdFx0JChkYXRlRmllbGRzWzJdKS5yZW1vdmVDbGFzcyhlcnJvckNsYXNzKTtcblx0XHRcdFx0JChcIiNlcnJvcnNcIikuZW1wdHkoKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHVuaGlnaGxpZ2h0IDogZnVuY3Rpb24oZWxlbWVudCwgZXJyb3JDbGFzcywgdmFsaWRDbGFzcykge1xuXHRcdFx0aWYgKGVsZW1lbnQudHlwZSA9PT0gJ3JhZGlvJykge1xuXHRcdFx0XHR0aGlzLmZpbmRCeU5hbWUoZWxlbWVudC5uYW1lKS5yZW1vdmVDbGFzcyhlcnJvckNsYXNzKS5hZGRDbGFzcyh2YWxpZENsYXNzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCQoZWxlbWVudCkucmVtb3ZlQ2xhc3MoZXJyb3JDbGFzcykuYWRkQ2xhc3ModmFsaWRDbGFzcyk7XG5cdFx0XHRcdGlmKGVsZW1lbnQudHlwZSA9PT0gJ3NlbGVjdC1vbmUnKXtcblx0XHRcdFx0XHR2YXIgJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuXHRcdFx0XHRcdGlmKCRlbGVtZW50LmF0dHIoJ2lkJykgJiYgJGVsZW1lbnQuaGFzQ2xhc3MoJ3JlcGxhY2VkJykpe1xuXHRcdFx0XHRcdFx0dmFyIHNlbGVjdEJveCA9ICQoJyMnICsgJGVsZW1lbnQuYXR0cignaWQnKSArICdTZWxlY3RCb3hJdENvbnRhaW5lcicpO1xuXHRcdFx0XHRcdFx0aWYoc2VsZWN0Qm94KXtcblx0XHRcdFx0XHRcdFx0c2VsZWN0Qm94LnJlbW92ZUNsYXNzKGVycm9yQ2xhc3MpLmFkZENsYXNzKHZhbGlkQ2xhc3MpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCQoZWxlbWVudCkuYXR0cignaWQnKSA9PT0gXCJkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2JpcnRoTW9udGhcIlxuXHRcdFx0XHRcdHx8ICQoZWxlbWVudCkuYXR0cignaWQnKSA9PT0gXCJkd2ZybV9wcm9maWxlX2N1c3RvbWVyX2JpcnRoRGF5XCJcblx0XHRcdFx0XHR8fCAkKGVsZW1lbnQpLmF0dHIoJ2lkJykgPT09IFwiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aFllYXJcIikge1xuXHRcdFx0XHQkKGRhdGVGaWVsZHNbMF0pLnJlbW92ZUNsYXNzKGVycm9yQ2xhc3MpO1xuXHRcdFx0XHQkKGRhdGVGaWVsZHNbMV0pLnJlbW92ZUNsYXNzKGVycm9yQ2xhc3MpO1xuXHRcdFx0XHQkKGRhdGVGaWVsZHNbMl0pLnJlbW92ZUNsYXNzKGVycm9yQ2xhc3MpO1xuXHRcdFx0XHQkKFwiI2Vycm9yc1wiKS5lbXB0eSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hvd0Vycm9yczogZnVuY3Rpb24gKGVycm9yTWFwLCBlcnJvckxpc3QpIHtcblx0XHRcdHRoaXMuZGVmYXVsdFNob3dFcnJvcnMoKTtcblxuXHRcdFx0dmFyIGJpcnRoZGF0ZUVycm9yID0gXCJcIjtcblx0XHRcdGlmIChlcnJvck1hcC5oYXNPd25Qcm9wZXJ0eShcImR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfYmlydGhNb250aFwiKSkge1xuXHRcdFx0XHRiaXJ0aGRhdGVFcnJvciA9IGVycm9yTWFwW1wiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aE1vbnRoXCJdO1xuXHRcdFx0fSBlbHNlIGlmIChlcnJvck1hcC5oYXNPd25Qcm9wZXJ0eShcImR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfYmlydGhEYXlcIikpIHtcblx0XHRcdFx0YmlydGhkYXRlRXJyb3IgPSBlcnJvck1hcFtcImR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfYmlydGhEYXlcIl07XG5cdFx0XHR9IGVsc2UgaWYgKGVycm9yTWFwLmhhc093blByb3BlcnR5KFwiZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9iaXJ0aFllYXJcIikpIHtcblx0XHRcdFx0YmlydGhkYXRlRXJyb3IgPSBlcnJvck1hcFtcImR3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfYmlydGhZZWFyXCJdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYmlydGhkYXRlRXJyb3IgIT0gXCJcIikge1xuXHRcdFx0XHQkKFwiI2Vycm9yc1wiKS5odG1sKCc8c3BhbiBjbGFzcz1cImVycm9yXCIgZ2VuZXJhdGVkPVwidHJ1ZVwiIGZvcj1cImRhdGVcIj4nICsgYmlydGhkYXRlRXJyb3IgKyAnPC9zcGFuPicpO1xuXHRcdFx0XHQkKGRhdGVGaWVsZHNbMF0pLmFkZENsYXNzKFwiZXJyb3JcIik7XG5cdFx0XHRcdCQoZGF0ZUZpZWxkc1sxXSkuYWRkQ2xhc3MoXCJlcnJvclwiKTtcblx0XHRcdFx0JChkYXRlRmllbGRzWzJdKS5hZGRDbGFzcyhcImVycm9yXCIpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0dmFsaWRhdG9yLmluaXRGb3JtKGZvcm0pO1xuXG5cdGZvcm0ub24oXCJjbGlja1wiLCBcIi5hcHBseS1idXR0b25cIiwgZnVuY3Rpb24oZSkge1xuXHRcdC8vIFN0b3AgdGhlIGZvcm0gZnJvbSBzdWJtaXR0aW5nICh3aGljaCBjYXVzZXMgdGhlIHBpcGVsaW5lIHRvIHJlZGlyZWN0IGVsc2V3aGVyZSlcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRpZigkKCcjZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9uZXdlbWFpbCcpLnZhbCgpICE9IFwiXCIgJiYgJCgnI2R3ZnJtX3Byb2ZpbGVfY3VzdG9tZXJfbmV3ZW1haWxjb25maXJtJykudmFsKCkgPT0gXCJcIil7XG5cdFx0XHQkKCcjZHdmcm1fcHJvZmlsZV9jdXN0b21lcl9uZXdlbWFpbGNvbmZpcm0nKS52YWwoY3VzdG9tZXJFbWFpbEFkZHJlc3MpO1xuXHRcdFx0JCgnI2R3ZnJtX3Byb2ZpbGVfbG9naW5fY3VycmVudHBhc3N3b3JkX19uZXdlbWFpbCcpLnZhbCgkKCcjZHdmcm1fcHJvZmlsZV9sb2dpbl9jdXJyZW50cGFzc3dvcmRfX25ld3Bhc3N3b3JkJykudmFsKCkpO1xuXHRcdH1cblxuXHRcdGlmICghKCgkKGRhdGVGaWVsZHNbMF0pLnZhbCgpID09IFwiXCIgJiYgJChkYXRlRmllbGRzWzFdKS52YWwoKSA9PSBcIlwiICYmICQoZGF0ZUZpZWxkc1syXSkudmFsKCkgPT0gXCJcIikgfHxcblx0XHRcdFx0KCQoZGF0ZUZpZWxkc1swXSkudmFsKCkgIT0gXCJcIiAmJiAkKGRhdGVGaWVsZHNbMV0pLnZhbCgpICE9IFwiXCIgJiYgJChkYXRlRmllbGRzWzJdKS52YWwoKSAhPSBcIlwiKSkpIHtcblx0XHRcdC8vIFVzZXIgaGFzIHB1dCBpbiBvbmx5IGEgcGFydGlhbCBiaXJ0aGRhdGUgYW5kIHdlIHNob3VsZCBlcnJvclxuXHRcdFx0JChcIiNlcnJvcnNcIikuaHRtbCgnPHNwYW4gY2xhc3M9XCJlcnJvclwiIGdlbmVyYXRlZD1cInRydWVcIiBmb3I9XCJkYXRlXCI+JyArIGFwcC5yZXNvdXJjZXMuQklSVEhEQVRFX0lOVkFMSUQgKyAnPC9zcGFuPicpO1xuXHRcdFx0JChkYXRlRmllbGRzWzBdKS5hZGRDbGFzcyhcImVycm9yXCIpO1xuXHRcdFx0JChkYXRlRmllbGRzWzFdKS5hZGRDbGFzcyhcImVycm9yXCIpO1xuXHRcdFx0JChkYXRlRmllbGRzWzJdKS5hZGRDbGFzcyhcImVycm9yXCIpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhbGlkYXRvci5pbml0Rm9ybShmb3JtKTtcblx0XHRpZiAoIWZvcm0udmFsaWQoKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRhcHAudXRpbC5mb3Jtc3VibWl0KGZvcm0sIGpRdWVyeSh0aGlzKSwgXCJodG1sXCIsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG5cdFx0XHQvLyBzdWNjZXNzXG5cdFx0XHRpZigkLnRyaW0ocmVzcG9uc2UudG9TdHJpbmcoKSkgPT0gJ3N1Y2Nlc3MnKSBwYWdlLnJlZnJlc2goKTtcblx0XHRcdC8vIEZhaWx1cmVcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQkKCcjcGVyc29uYWxkYXRhLWVkaXQtaW5mbycpLmVtcHR5KCkuaHRtbChyZXNwb25zZSk7XG5cdFx0XHRcdGluaXRpYWxpemVJbmZvRm9ybSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn07XG5cbi8vQUNDT1VOVCBFRElUIElORk8gLSBQRVJTT05BTCBJTkZPIEZPUk0gTE9BREVEIFZJQSBBSkFYXG5mdW5jdGlvbiBpbml0aWFsaXplUGFzc3dvcmRGb3JtKCkge1xuXHR2YXIgZm9ybSA9ICQoXCIjcGVyc29uYWxFZGl0UGFzc3dvcmRcIik7XG5cdC8vIENsZWFyIGZvcm0gb2YgZXJyb3JzIGFuZCBmb2N1c1xuXHRhcHAudXRpbC5mb3JtQmx1cihmb3JtKTtcblx0ZmxvYXRsYWJlbHMuaW5pdCgpO1xuXG5cdHZhbGlkYXRvci5pbml0Rm9ybShcIiNwZXJzb25hbEVkaXRQYXNzd29yZFwiLCB7XG4gICAgICAgIHJ1bGVzOiB7XG4gICAgICAgICAgICBcImR3ZnJtX3Byb2ZpbGVfbG9naW5fbmV3cGFzc3dvcmRcIjoge1xuICAgICAgICAgICAgXHRyYW5nZWxlbmd0aDogWzcsIDIwXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZHdmcm1fcHJvZmlsZV9sb2dpbl9uZXdwYXNzd29yZGNvbmZpcm1cIjoge1xuICAgICAgICAgICAgXHRyYW5nZWxlbmd0aDogWzcsIDIwXSxcbiAgICAgICAgICAgIFx0ZXF1YWxUbzogXCIjZHdmcm1fcHJvZmlsZV9sb2dpbl9uZXdwYXNzd29yZFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICAgICBcImR3ZnJtX3Byb2ZpbGVfbG9naW5fbmV3cGFzc3dvcmRcIjoge1xuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBSZXNvdXJjZXMuTUlTU0lOR19QQVNTV09SRCxcbiAgICAgICAgICAgICAgICByYW5nZWxlbmd0aDogUmVzb3VyY2VzLlZBTElEQVRFX1JBTkdFTEVOR1RILFxuICAgICAgICAgICAgICAgIGVxdWFsVG86IFJlc291cmNlcy5WQUxJREFURV9JTlZBTElEX1BBU1NNQVRDSFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvckNsYXNzIDogJ2Vycm9yJyxcbiAgICAgICAgZXJyb3JFbGVtZW50IDogJ3NwYW4nLFxuICAgICAgICBpZ25vcmU6IFwiOmhpZGRlbjpub3QoLnJlcGxhY2VkKVwiLFxuICAgICAgICBvbmtleXVwIDogZmFsc2UsXG4gICAgICAgIG9uZm9jdXNvdXQgOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgaWYoIXRoaXMuY2hlY2thYmxlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cblx0Zm9ybS5vbihcImNsaWNrXCIsIFwiLmFwcGx5LWJ1dHRvblwiLCBmdW5jdGlvbihlKSB7XG5cdFx0Ly8gU3RvcCB0aGUgZm9ybSBmcm9tIHN1Ym1pdHRpbmcgKHdoaWNoIGNhdXNlcyB0aGUgcGlwZWxpbmUgdG8gcmVkaXJlY3QgZWxzZXdoZXJlKVxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR1dGlsLmZvcm1zdWJtaXQoZm9ybSwgalF1ZXJ5KHRoaXMpLCBcImh0bWxcIiwgZnVuY3Rpb24ocmVzcG9uc2UpIHtcblx0XHRcdC8vIHN1Y2Nlc3Ncblx0XHRcdGlmKCQudHJpbShyZXNwb25zZS50b1N0cmluZygpKSA9PSAnc3VjY2VzcycpIHBhZ2UucmVmcmVzaCgpO1xuXHRcdFx0Ly8gRmFpbHVyZVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdCQoJyNwZXJzb25hbGRhdGEtZWRpdC1wYXNzd29yZCcpLmVtcHR5KCkuaHRtbChyZXNwb25zZSk7XG5cdFx0XHRcdGluaXRpYWxpemVQYXNzd29yZEZvcm0oKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSlcblx0Lm9uKCdjbGljaycsICcuY2FuY2VsLWJ1dHRvbicsIGZ1bmN0aW9uKGUpe1xuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRkaWFsb2cuY2xvc2UoKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIHNob3dGb3JtRXJyb3IoJHJvdyl7XG5cdHZhciAkaW5wdXQgID0gJHJvdy5maW5kKCdpbnB1dCcpO1xuXHR2YXIgc3BhbiA9IFwiPHNwYW4gY2xhc3M9J2Vycm9yIGludmFsaWQtZm9ybS1pY29uJz48L3NwYW4+XCI7XG5cdCRpbnB1dC5hZGRDbGFzcygnZXJyb3InKTtcblx0JGlucHV0LmFmdGVyKHNwYW4pO1xuXHQkaW5wdXQuYmx1cihmdW5jdGlvbigpe1xuXHRcdCRyb3cuZmluZCgnLmludmFsaWQtZm9ybS1pY29uJykucmVtb3ZlKCk7XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvbiBCaW5kcyB0aGUgZXZlbnRzIG9mIHRoZSBvcmRlciwgYWRkcmVzcyBhbmQgcGF5bWVudCBwYWdlc1xuICovXG5mdW5jdGlvbiBpbml0aWFsaXplRXZlbnRzKCkge1xuICAgIHRvZ2dsZUZ1bGxPcmRlcigpO1xuICAgIGluaXRBZGRyZXNzRXZlbnRzKCk7XG4gICAgaW5pdFBheW1lbnRFdmVudHMoKTtcbiAgICBpbml0UGVyc29uYWxFdmVudHMoKTtcbiAgICBpbml0T3JkZXJIaXN0b3J5KCk7XG4gICAgbG9naW4uaW5pdCgpO1xufVxuXG52YXIgYWNjb3VudCA9IHtcbiAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluaXRpYWxpemVFdmVudHMoKTtcbiAgICAgICAgZ2lmdGNlcnQuaW5pdCgpO1xuICAgICAgICBuZWFyZXN0U3RvcmUuaW5pdCgpO1xuICAgIH0sXG4gICAgaW5pdENhcnRMb2dpbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dpbi5pbml0KCk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBhY2NvdW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWNjb3VudCA9IHJlcXVpcmUoJy4vYWNjb3VudCcpLFxuICAgIGJvbnVzUHJvZHVjdHNWaWV3ID0gcmVxdWlyZSgnLi4vYm9udXMtcHJvZHVjdHMtdmlldycpLFxuICAgIHF1aWNrdmlldyA9IHJlcXVpcmUoJy4uL3F1aWNrdmlldycpLFxuICAgIHNlbGVjdEJveEl0ID0gcmVxdWlyZSgnLi4vc2VsZWN0Ym94aXQnKSxcbiAgICBjYXJ0U3RvcmVJbnZlbnRvcnkgPSByZXF1aXJlKCcuLi9zdG9yZWludmVudG9yeS9jYXJ0JyksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgICAkY2FjaGUgPSB7fSxcbiAgICBTRkxfUEFHRV9TSVpFID0gNTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKiBAZGVzY3JpcHRpb24gQmluZHMgZXZlbnRzIHRvIHRoZSBjYXJ0IHBhZ2UgKGVkaXQgaXRlbSdzIGRldGFpbHMsIGJvbnVzIGl0ZW0ncyBhY3Rpb25zLCBjb3Vwb24gY29kZSBlbnRyeSlcbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZUV2ZW50cygpIHtcbiAgICAkKCcjY2FydC10YWJsZScpLm9uKCdjbGljaycsICcuaXRlbS1lZGl0LWRldGFpbHMgYScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIGlzR0MgPSAkKGUudGFyZ2V0KS5oYXNDbGFzcygnZ2lmdENhcmQnKSA/ICdnaWZ0Q2FyZCcgOiAnJztcbiAgICAgICAgLy9WZXJ5IHNwZWNpZmljIGNhc2UgZm9yIG1ha2luZyBpbnB1dHMgb3V0c2lkZSBvZiBkaWFsb2cgYXZhaWxhYmxlXG4gICAgICAgICQud2lkZ2V0KCBcInVpLmRpYWxvZ1wiLCAkLnVpLmRpYWxvZywge1xuICAgICAgICAgICAgX2FsbG93SW50ZXJhY3Rpb246IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISEkKCBldmVudC50YXJnZXQgKS5pcyggXCJpbnB1dFwiICkgfHwgdGhpcy5fc3VwZXIoIGV2ZW50ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBxdWlja3ZpZXcuc2hvdyh7XG4gICAgICAgICAgICB1cmw6IGUudGFyZ2V0LmhyZWYsXG4gICAgICAgICAgICBzb3VyY2U6ICdjYXJ0JyxcbiAgICAgICAgICAgIGN1c3RvbUNsYXNzOiAndWktZGlhbG9nX3VwZGF0ZS1pdGVtICcgKyBpc0dDLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJpY2UgPSAkKCcuZS1naWZ0LWNhcmQgLnByb2R1Y3QtcHJpY2UnKS50ZXh0KCkudHJpbSgpO1xuICAgICAgICAgICAgICAgICQoJy5lLWdpZnQtY2FyZCAuc3dhdGNoZXMgbGknKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFByaWNlID0gJCh0aGlzKS5maW5kKCdhJykuZGF0YSgnY29tYmluZWQnKTtcbiAgICAgICAgICAgICAgICAgICBpZihjdXJyZW50UHJpY2UgPT0gcHJpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgJCgnLmUtZ2lmdC1jYXJkIC5zd2F0Y2hlcyBsaScpLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAkKCcuZS1naWZ0LWNhcmQnKS5vbignY2xpY2snLCAnLnN3YXRjaGVzLkNvbG9yIGxpJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAkKCcucHJvZHVjdC1vcHRpb25zLWdpZnQtY2FyZCAjZ2NBbW91bnRzZWxlY3QgLnNlbGVjdGVkIGEnKS50cmlnZ2VyKCdjbGljaycpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAub24oJ2NsaWNrJywgJy5ib251cy1pdGVtLWFjdGlvbnMgYSwgLml0ZW0tZGV0YWlscyAuYm9udXNwcm9kdWN0cyBhJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBib251c1Byb2R1Y3RzVmlldy5zaG93KHRoaXMuaHJlZik7XG4gICAgfSk7XG5cbiAgICAvL3JlbmRlciBXaGl0ZSBHbG92ZSBCbG9ja1xuICAgIHZhciAkdGFyZ2V0QmxvY2sgPSAkKCcud2hpdGUtZ2xvdmUtYmxvY2sgLnRvb2x0aXAgPiAudG9vbHRpcC1jb250ZW50Jyk7XG4gICAgdmFyIHRhcmdldENvbnRlbnQgPSAkdGFyZ2V0QmxvY2suZmluZCgnLnRvb2x0aXAtY29udGVudCcpLmh0bWwoKTtcbiAgICAkdGFyZ2V0QmxvY2suZW1wdHkoKTtcbiAgICAkdGFyZ2V0QmxvY2suaHRtbCh0YXJnZXRDb250ZW50KTtcblxuICAgIC8vIG92ZXJyaWRlIGVudGVyIGtleSBmb3IgY291cG9uIGNvZGUgZW50cnlcbiAgICAkKCdmb3JtIGlucHV0W25hbWUkPVwiX2NvdXBvbkNvZGVcIl0nKS5vbigna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLndoaWNoID09PSAxMyAmJiAkKHRoaXMpLnZhbCgpLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB9KTtcblxuICAgIC8vdG8gcHJldmVudCBtdWx0aXBsZSBzdWJtaXNzaW9ucyBvZiB0aGUgZm9ybSB3aGVuIHJlbW92aW5nIGEgcHJvZHVjdCBmcm9tIHRoZSBjYXJ0XG4gICAgdmFyIHJlbW92ZUl0ZW1FdmVudCA9IGZhbHNlO1xuICAgICQoJ2J1dHRvbltuYW1lJD1cImRlbGV0ZVByb2R1Y3RcIl0nKS5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgIFx0dmFyIHByb2R1Y3RJRCA9ICQodGhpcykuZGF0YSgncGlkJyk7XG4gICAgXHRcbiAgICAgICAgaWYgKHJlbW92ZUl0ZW1FdmVudCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlSXRlbUV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YUxheWVyKSB7XG4gICAgICAgICAgICB2YXIgZWNvbW1lcmNlID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUxheWVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCdlY29tbWVyY2UnIGluIGRhdGFMYXllcltpXSkge1xuICAgICAgICAgICAgICAgICAgICBlY29tbWVyY2UgPSBkYXRhTGF5ZXJbaV0uZWNvbW1lcmNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWNvbW1lcmNlICE9IHVuZGVmaW5lZCAmJiAnY2hlY2tvdXQnIGluIGVjb21tZXJjZSAmJiAncHJvZHVjdHMnIGluIGVjb21tZXJjZS5jaGVja291dCkge1xuICAgICAgICAgICAgICAgIHZhciBwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWNvbW1lcmNlLmNoZWNrb3V0LnByb2R1Y3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBlY29tbWVyY2UuY2hlY2tvdXQucHJvZHVjdHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwLmlkID09IHByb2R1Y3RJRCl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFMYXllci5wdXNoKGFwcC5kYXRhbGF5ZXIuZ2V0RXZlbnQoXCJldmVudFwiLFwiZWNvbVJlbW92ZVwiLCBcImVjb21tZXJjZVwiLCBcIiBcIiwgXCJyZW1vdmVcIiwgW3BdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8qU2NyaXB0IGZvciB1bnVzaWFsIHBvc2l0aW9uIG9mIGNvbnRyb2wgYnV0dG9uIG9uIFNob3BwaW5nIENhcnQgcGFnZSovXG4gICAgaWYgKCQoJy5pdGVtLWVkaXQtZGV0YWlscycpLmxlbmd0aCAmJiAkKCcuaXRlbS11c2VyLWFjdGlvbnMnKS5sZW5ndGgpIHtcbiAgICAgICAgJCgnLmNhcnQtcm93JykuZWFjaCggZnVuY3Rpb24gKCl7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9ICQodGhpcykuZmluZCgnLml0ZW0tZWRpdC1kZXRhaWxzJyk7XG4gICAgICAgICAgICB2YXIgcGxhY2UgPSAkKHRoaXMpLmZpbmQoJy5pdGVtLXVzZXItYWN0aW9ucycpO1xuICAgICAgICAgICAgdmFyIGFjdGlvbmJveCA9ICQodGhpcykuZmluZCgnLmFjdGlvbi1ib3gnKTtcbiAgICAgICAgICAgIHZhciBtb2JpbGVoZWFkZXIgPSAkKHRoaXMpLmZpbmQoJy5tb2JpbGUtaGVhZGVyJyk7XG4gICAgICAgICAgICBjdXJyZW50LnByZXBlbmRUbyhwbGFjZSk7XG4gICAgICAgICAgICBwbGFjZS5jbG9uZSgpLnByZXBlbmRUbyhhY3Rpb25ib3gpO1xuICAgICAgICAgICAgJCh0aGlzKS5maW5kKCcuc2t1JykuY2xvbmUoKS5wcmVwZW5kVG8obW9iaWxlaGVhZGVyKTtcbiAgICAgICAgICAgICQodGhpcykuZmluZCgnLm5hbWUnKS5jbG9uZSgpLnByZXBlbmRUbyhtb2JpbGVoZWFkZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqL1xuICAgICQoJy5pdGVtLWRldGFpbHMgYnV0dG9uJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpe1xuICAgICAgICAgdmFyIHhPZmZzZXQgPSAyNDtcbiAgICAgICAgIHZhciB5T2Zmc2V0ID0gMjQ7XG4gICAgICAgICB2YXIgZWxlbW50ID0gJCh0aGlzKTtcbiAgICAgICAgICQodGhpcykuZmFkZU91dCgnZmFzdCcpO1xuICAgICAgICAgdmFyIGJnVG9wID0gMDtcbiAgICAgICAgIHZhciBmcmFtZXMgPSA1O1xuICAgICAgICAgdmFyIGZyYW1lU2l6ZSA9IDMyO1xuICAgICAgICAgdmFyIGZyYW1lUmF0ZSA9IDEwMDtcbiAgICAgICAgIGZvcihpPTE7aTxmcmFtZXM7aSsrKSB7XG4gICAgICAgICAgICAgYmdUb3AgLT0gZnJhbWVTaXplO1xuICAgICAgICAgICAgIHZhciBmID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvb2YuY3NzKCdiYWNrZ3JvdW5kLXBvc2l0aW9uJywnMCAtJyArIGkqZnJhbWVTaXplICsgJ3B4Jyk7XG4gICAgICAgICAgICAgICAgfSwgaSpmcmFtZVJhdGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmKGkpO1xuICAgICAgICAgfVxuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZWxlbW50LmNsb3Nlc3QoJy5jYXJ0LXJvdycpLmhpZGUoKTtcbiAgICAgICAgICAgIGVsZW1udC5jbG9zZXN0KCcuY2FydC1yb3cnKS5uZXh0KCcuZmluYWwtc2FsZS1yb3cnKS5oaWRlKCk7XG4gICAgICAgIH0sIGZyYW1lcyAqIGZyYW1lUmF0ZSk7XG4gICAgfSk7XG5cbiAgICAvLyBTYXZlIGZvciBsYXRlciBsYXp5IGxvYWRpbmdcbiAgICAkY2FjaGUuc2ZsID0ge1xuICAgICAgICBmb290ZXJFbDogJCgnI2Zvb3Rlci13cmFwcGVyICNmb290ZXInKVswXSxcbiAgICAgICAgdGFibGVFbDogJCgnLmpzLXNmbC10YWJsZScpLFxuICAgICAgICBsb2FkZXJFbDogJCgnLnNhdmVkZm9ybGF0ZXItd3JhcHBlciAuc2ZsLWxvYWRlcicpLFxuICAgICAgICByZXNwb25zZUNvbnRhaW5lcjogJCgnPGRpdj4nKSxcbiAgICAgICAgaXNSZXF1ZXN0UGVuZGluZzogZmFsc2VcbiAgICB9O1xuICAgIFxuXG4gICAgZnVuY3Rpb24gbG9hZEFsbFNmbEl0ZW1zKCkge1xuICAgICAgICB2YXIgdG90YWxRdHkgPSBOdW1iZXIoJGNhY2hlLnNmbC50YWJsZUVsLmF0dHIoJ2RhdGEtc2ZsLXRvdGFsLXF0eScpKSxcbiAgICAgICAgICAgIHNob3dJdGVtc1F0eSA9IE51bWJlcigkY2FjaGUuc2ZsLnRhYmxlRWwuYXR0cignZGF0YS1zZmwtc2hvdy1pdGVtcy1xdHknKSksXG4gICAgICAgICAgICByZXF1ZXN0VXJsID0gJGNhY2hlLnNmbC50YWJsZUVsLmF0dHIoJ2RhdGEtc2ZsLWxvYWQtdXJsJyk7XG5cbiAgICAgICAgaWYgKHRvdGFsUXR5ID4gc2hvd0l0ZW1zUXR5KSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRJZHggPSBzaG93SXRlbXNRdHk7XG4gICAgICAgICAgICB2YXIgZW5kSWR4ID0gc3RhcnRJZHggKyBTRkxfUEFHRV9TSVpFIC0gMTtcbiAgICAgICAgICAgIGlmIChlbmRJZHggPj0gdG90YWxRdHkgfHwgJCgnYm9keScpLndpZHRoKCkgPCA3NjgpIHtcbiAgICAgICAgICAgICAgICBlbmRJZHggPSB0b3RhbFF0eSAtIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICRjYWNoZS5zZmwuaXNSZXF1ZXN0UGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgICAkY2FjaGUuc2ZsLmxvYWRlckVsLmFkZENsYXNzKCdzZmwtbG9hZGVyLXZpc2libGUnKTtcbiAgICAgICAgICAgIGxvYWRTZmxJdGVtcyh7XG4gICAgICAgICAgICAgICAgc3RhcnRJZHg6IHN0YXJ0SWR4LFxuICAgICAgICAgICAgICAgIGVuZElkeDogZW5kSWR4LFxuICAgICAgICAgICAgICAgIHJlcXVlc3RVcmw6IHJlcXVlc3RVcmwsXG4gICAgICAgICAgICAgICAgc2hvd0l0ZW1zUXR5OiBzaG93SXRlbXNRdHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJCgnI3NmbC1tb2JpbGUtbG9hZGVyJykuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICQod2luZG93KS5vbignc2Nyb2xsLnNmbExhenlMb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaXNGb290ZXJWaXNpYmxlID0gJGNhY2hlLnNmbC5mb290ZXJFbCAmJiB1dGlsLmVsZW1lbnRJblZpZXdwb3J0KCRjYWNoZS5zZmwuZm9vdGVyRWwpO1xuXG4gICAgICAgICAgICBpZiAoaXNGb290ZXJWaXNpYmxlICYmICEkY2FjaGUuc2ZsLmlzUmVxdWVzdFBlbmRpbmcgJiYgJGNhY2hlLnNmbC50YWJsZUVsLmxlbmd0aCA+IDAgJiYgJCgnYm9keScpLndpZHRoKCkgPiA3NjcpIHtcbiAgICAgICAgICAgICAgICBsb2FkQWxsU2ZsSXRlbXMoKTtcbiAgICAgICAgICAgIH1cbiAgICB9KTtcbiAgICAkKCdib2R5Jykub24oJ2NsaWNrJywgJyNzZmwtbW9iaWxlLWxvYWRlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9hZEFsbFNmbEl0ZW1zKCk7XG4gICAgfSk7XG5cbiAgICAvLyBGaXhlZCBjYXJ0IHN1bW1hcnlcbiAgICAkY2FjaGUuZml4ZWRUb3RhbHMgPSB7XG4gICAgICAgIHRvdGFsc0VsOiAkKCcjY2FydC1pdGVtcy1mb3JtIC5jYXJ0LWZvb3RlcicpLFxuICAgICAgICBoZWFkZXI6ICQoJy5wdF9jYXJ0ID4gLnRvcC1iYW5uZXInKSxcbiAgICAgICAgcGxhY2Vob2xkZXI6ICQoJyNjYXJ0LWl0ZW1zLWZvcm0gLmNhcnQtZm9vdGVyLXBsYWNlaG9sZGVyJyksXG4gICAgICAgIGlzRml4ZWQ6IGZhbHNlLFxuICAgICAgICBpc0luaXRpYWxpemVkOiBmYWxzZVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpbml0Q2FydFRvdGFscygpIHtcbiAgICAgICAgaWYgKCRjYWNoZS5maXhlZFRvdGFscy50b3RhbHNFbC5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgICAgICB2YXIgd2luZG93V2lkdGggPSAkKHdpbmRvdykud2lkdGgoKTtcblxuICAgICAgICBpZiAod2luZG93V2lkdGggPiA5NjApIHtcbiAgICAgICAgICAgIG1ha2VUb3RhbHNTdGF0aWMoKTtcbiAgICAgICAgICAgIGNhbGNUb3RhbHNQb3NpdGlvbigpO1xuICAgICAgICAgICAgcmVtb3ZlVG90YWxzRXZlbkxpc3RlbmVycygpO1xuICAgICAgICAgICAgYWRkVG90YWxzRXZlbkxpc3RlbmVycygpO1xuICAgICAgICAgICAgJGNhY2hlLmZpeGVkVG90YWxzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCRjYWNoZS5maXhlZFRvdGFscy5pc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgbWFrZVRvdGFsc1N0YXRpYygpO1xuICAgICAgICAgICAgICAgIHJlbW92ZVRvdGFsc0V2ZW5MaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAkY2FjaGUuZml4ZWRUb3RhbHMuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZVRvdGFsc1N0YXRpYygpIHtcbiAgICAgICAgJGNhY2hlLmZpeGVkVG90YWxzLmlzRml4ZWQgPSBmYWxzZTtcbiAgICAgICAgJGNhY2hlLmZpeGVkVG90YWxzLnBsYWNlaG9sZGVyLnJlbW92ZUNsYXNzKCdjYXJ0LWZvb3Rlci1wbGFjZWhvbGRlci12aXNpYmxlJyk7XG4gICAgICAgICRjYWNoZS5maXhlZFRvdGFscy50b3RhbHNFbFxuICAgICAgICAgICAgLmNzcyh7XG4gICAgICAgICAgICAgICAgbGVmdDogJycsXG4gICAgICAgICAgICAgICAgdG9wOiAnJyxcbiAgICAgICAgICAgICAgICB3aWR0aDogJydcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ2NhcnQtdG90YWxzLWZpeGVkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZVRvdGFsc0ZpeGVkKCkge1xuICAgICAgICAkY2FjaGUuZml4ZWRUb3RhbHMuaXNGaXhlZCA9IHRydWU7XG4gICAgICAgICRjYWNoZS5maXhlZFRvdGFscy5wbGFjZWhvbGRlci5hZGRDbGFzcygnY2FydC1mb290ZXItcGxhY2Vob2xkZXItdmlzaWJsZScpO1xuICAgICAgICAkY2FjaGUuZml4ZWRUb3RhbHMudG90YWxzRWxcbiAgICAgICAgICAgIC5jc3Moe1xuICAgICAgICAgICAgICAgIHdpZHRoOiAkY2FjaGUuZml4ZWRUb3RhbHMud2lkdGgsXG4gICAgICAgICAgICAgICAgbGVmdDogJGNhY2hlLmZpeGVkVG90YWxzLm9mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiAkY2FjaGUuZml4ZWRUb3RhbHMuaGVhZGVyLmhlaWdodCgpICsgMjBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2NhcnQtdG90YWxzLWZpeGVkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY1RvdGFsc1Bvc2l0aW9uKCkge1xuICAgICAgICAkY2FjaGUuZml4ZWRUb3RhbHMud2lkdGggPSAgJGNhY2hlLmZpeGVkVG90YWxzLnRvdGFsc0VsLndpZHRoKCk7XG4gICAgICAgICRjYWNoZS5maXhlZFRvdGFscy5oZWlnaHQgPSAkY2FjaGUuZml4ZWRUb3RhbHMudG90YWxzRWwuaGVpZ2h0KCk7XG4gICAgICAgICRjYWNoZS5maXhlZFRvdGFscy5vZmZzZXRMZWZ0ID0gJGNhY2hlLmZpeGVkVG90YWxzLnRvdGFsc0VsLm9mZnNldCgpLmxlZnQ7XG4gICAgICAgICRjYWNoZS5maXhlZFRvdGFscy5zY3JvbGxUcmlnZ2VyID0gJGNhY2hlLmZpeGVkVG90YWxzLmhlaWdodCArICRjYWNoZS5maXhlZFRvdGFscy50b3RhbHNFbC5vZmZzZXQoKS50b3A7XG4gICAgICAgICRjYWNoZS5maXhlZFRvdGFscy5wbGFjZWhvbGRlci5oZWlnaHQoJGNhY2hlLmZpeGVkVG90YWxzLmhlaWdodClcbiAgICAgICAgICAgIC53aWR0aCgkY2FjaGUuZml4ZWRUb3RhbHMud2lkdGgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFRvdGFsc0V2ZW5MaXN0ZW5lcnMoKSB7XG4gICAgICAgICQod2luZG93KS5vbignc2Nyb2xsLmNhcnQuZml4ZWRUb3RhbHMnLCBoYW5kbGVGaXhlZFRvdGFscyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlVG90YWxzRXZlbkxpc3RlbmVycygpIHtcbiAgICAgICAgJCh3aW5kb3cpLm9mZignc2Nyb2xsLmNhcnQuZml4ZWRUb3RhbHMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVGaXhlZFRvdGFscygpIHtcbiAgICAgICAgaWYgKCQod2luZG93KS5zY3JvbGxUb3AoKSA+ICRjYWNoZS5maXhlZFRvdGFscy5zY3JvbGxUcmlnZ2VyKSB7XG4gICAgICAgICAgICBpZiAoISRjYWNoZS5maXhlZFRvdGFscy5pc0ZpeGVkKSB7XG4gICAgICAgICAgICAgICAgbWFrZVRvdGFsc0ZpeGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoJGNhY2hlLmZpeGVkVG90YWxzLmlzRml4ZWQpIHtcbiAgICAgICAgICAgIG1ha2VUb3RhbHNTdGF0aWMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdGlja3lCbG9jaygpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoID4gOTYwKSB7XG4gICAgICAgICAgICAkKCcuY2FydC1mb290ZXInKS5zdGlja19pbl9wYXJlbnQoKS5vbihcInN0aWNreV9raXQ6Ym90dG9tXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoJ2JvdHRvbScpO1xuICAgICAgICAgICAgfSkub24oXCJzdGlja3lfa2l0OnVuYm90dG9tXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoJ2JvdHRvbScpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cbiAgICAkKHdpbmRvdykubG9hZChmdW5jdGlvbigpe1xuICAgICAgICBzdGlja3lCbG9jaygpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbG9hZFNmbEl0ZW1zKG9wdGlvbnMpIHtcbiAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgIHR5cGUgOiAnR0VUJyxcbiAgICAgICAgICAgIHVybCA6IG9wdGlvbnMucmVxdWVzdFVybCxcbiAgICAgICAgICAgIGRhdGEgOiB7XG4gICAgICAgICAgICAgICAgc2ZsX3N0YXJ0OiBvcHRpb25zLnN0YXJ0SWR4LFxuICAgICAgICAgICAgICAgIHNmbF9lbmQ6IG9wdGlvbnMuZW5kSWR4XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YVR5cGUgOiAnaHRtbCcsXG4gICAgICAgICAgICBzdWNjZXNzIDogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAkY2FjaGUuc2ZsLnJlc3BvbnNlQ29udGFpbmVyLmh0bWwocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHZhciByZXNwb25zZVRhYmxlRWwgPSAkY2FjaGUuc2ZsLnJlc3BvbnNlQ29udGFpbmVyLmZpbmQoJy5qcy1zZmwtdGFibGUnKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VTaG93SXRlbXNRdHkgPSBOdW1iZXIocmVzcG9uc2VUYWJsZUVsLmF0dHIoJ2RhdGEtc2ZsLXNob3ctaXRlbXMtcXR5JykpO1xuXG4gICAgICAgICAgICAgICAgJGNhY2hlLnNmbC50YWJsZUVsLmF0dHIoJ2RhdGEtc2ZsLXNob3ctaXRlbXMtcXR5Jywgb3B0aW9ucy5zaG93SXRlbXNRdHkgKyByZXNwb25zZVNob3dJdGVtc1F0eSk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1NmbEl0ZW1zID0gcmVzcG9uc2VUYWJsZUVsLmNoaWxkcmVuKCd0Ym9keScpLmNoaWxkcmVuKCk7XG4gICAgICAgICAgICAgICAgbmV3U2ZsSXRlbXNcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzZmwtaXRlbS1oaWRkZW4nKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8oJGNhY2hlLnNmbC50YWJsZUVsLmNoaWxkcmVuKCd0Ym9keScpKTtcblxuICAgICAgICAgICAgICAgICRjYWNoZS5zZmwubG9hZGVyRWwucmVtb3ZlQ2xhc3MoJ3NmbC1sb2FkZXItdmlzaWJsZScpO1xuICAgICAgICAgICAgICAgICRjYWNoZS5zZmwuaXNSZXF1ZXN0UGVuZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NmbEl0ZW1zLnJlbW92ZUNsYXNzKCdzZmwtaXRlbS1oaWRkZW4nKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgJCgnLnRpcCcpLm9uKCdtb3VzZWVudGVyJywgZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcbiAgICAgICAgaWYoISRjYWNoZS50aXApIHtcbiAgICAgICAgICAgICRjYWNoZS50aXAgPSAkKCcjdG9vbHRpcCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjbnQgPSAkKCR0aGlzLmRhdGEoJ2NvbnRlbnQnKSk7XG4gICAgICAgIHZhciB3aWR0aCA9ICR0aGlzLmRhdGEoJ3dpZHRoJyk7XG4gICAgICAgIHZhciBjdG9wID0gJHRoaXMub2Zmc2V0KCkudG9wO1xuICAgICAgICB2YXIgY2xlZnQgPSAkdGhpcy5vZmZzZXQoKS5sZWZ0O1xuICAgICAgICB2YXIgYWxpZ24gPSAkdGhpcy5kYXRhKCdhbGlnbicpO1xuICAgICAgICBpZighYWxpZ24pe1xuICAgICAgICAgICAgYWxpZ24gPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBvcHVsYXRlIHRpcCB3aXRoIGNvbnRlbnRcbiAgICAgICAgJGNhY2hlLnRpcC5maW5kKCcuYm9keScpLmh0bWwoY250Lmh0bWwoKSlcbiAgICAgICAgLy8gQWRqdXN0IHdpZHRoXG4gICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgJGNhY2hlLnRpcC5jc3MoJ3dpZHRoJyx3aWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGp1c3QgcG9zaXRpb25cbiAgICAgICAgaWYgKGFsaWduLmluZGV4T2YoJ3JpZ2h0JykgPj0gMCkge1xuICAgICAgICAgICAgLy8gcmlnaHQgYWxpZ25cbiAgICAgICAgICAgIGlmIChhbGlnbi5pbmRleE9mKCdpbm5lcnJpZ2h0JykgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIHNpZGUgcmlnaHQsIGFkZCB3aWR0aCBvZiBlbGVtZW50IGFuZCA1IHBpeGVscyBmb3Igc3BhY2luZ1xuICAgICAgICAgICAgICAgIGNsZWZ0ID0gY2xlZnQgKyAkdGhpcy5vdXRlcldpZHRoKCkgKyA1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbGVmdCBhbGlnblxuICAgICAgICAgICAgLy8gc3VidHJhY3Qgd2lkdGggb2YgdGlwIGJveFxuICAgICAgICAgICAgY2xlZnQgPSBjbGVmdCAtICRjYWNoZS50aXAub3V0ZXJXaWR0aCgpO1xuICAgICAgICAgICAgaWYgKGFsaWduLmluZGV4T2YoJ2lubmVybGVmdCcpID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgaW5uZXIgbGVmdCwgc3VidHJhY3Qgd2lkdGggb2YgZWxlbWVudFxuICAgICAgICAgICAgICAgIGNsZWZ0ID0gY2xlZnQgKyAkdGhpcy5vdXRlcldpZHRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGxlZnQgb3V0ZXIgYWxpZ25cbiAgICAgICAgICAgICAgICAvLyBmb3Igb3V0ZXIgbGVmdCwgc3VidHJhY3QgZXh0cmEgNSBwaXhlbHMgZm9yIHNwYWNpbmdcbiAgICAgICAgICAgICAgICBjbGVmdCA9IGNsZWZ0IC0gNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxpZ24uaW5kZXhPZignYm90dG9tJykgPj0gMCkge1xuICAgICAgICAgICAgLy8gYm90dG9tIGFsaWduXG4gICAgICAgICAgICBpZiAoYWxpZ24uaW5kZXhPZignaW5uZXJib3R0b20nKSA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBmb3Igb3V0ZXIgYm90dG9tIChha2EgYm90dG9tKSwgYWRkIGVsZW1lbnQgaGVpZ2h0IGFuZCBleHRyYSA1IHBpeGVscyBmb3Igc3BhY2luZ1xuICAgICAgICAgICAgICAgIGN0b3AgPSBjdG9wICsgJHRoaXMub3V0ZXJIZWlnaHQoKSArNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJsaXR5LCBkZWZhdWx0IHRvIDIwIHBpeGVscyB1cCBmcm9tIHRvcCBvZiBlbGVtZW50XG4gICAgICAgICAgICBjdG9wID0gY3RvcCAtIDIwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUG9zaXRpb24gdGlwXG4gICAgICAgICRjYWNoZS50aXAuY3NzKHsnbGVmdCc6IGNsZWZ0LCAndG9wJzogY3RvcH0pXG4gICAgICAgICRjYWNoZS50aXAuc3RvcChjbGVhclF1ZXVlLCBqdW1wVG9FbmQpLnNob3coKTtcbiAgICAgICAgdmFyIG1vdXNlT25UcmlnZ2VyID0gdHJ1ZTtcblxuICAgIH0pLm9uKCdtb3VzZWxlYXZlJywgZnVuY3Rpb24oKXtcbiAgICAgICAgdG9vbHRpcENsb3NpbmcoKTtcbiAgICAgICAgdmFyIG1vdXNlT25UcmlnZ2VyID0gZmFsc2U7XG4gICAgfSk7XG4gICAgXG4gICAgaWYgKCQoJy5qcy1jYXJ0LWNvdXBvbi1jb2RlJykuZmluZCgnLmVycm9yJykubGVuZ3RoID4gMCkge1xuICAgICAgICAkKCcuanMtY2FydC1jb3Vwb24tY29kZScpLmFkZENsYXNzKCdleHBhbmRlZCcpO1xuXG4gICAgICAgICQoJy5qcy1jYXJ0LWNvdXBvbi1jb2RlIGlucHV0Jykub24oJ2ZvY3VzLmNhcnQuY291cG9uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhZGRDb3Vwb25GaWVsZEV2ZW50cygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAkKCdib2R5Jykub24oJ2NsaWNrJywgJy5qcy1jYXJ0LWNvdXBvbi10b2dnbGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgJCgnLmpzLWNhcnQtY291cG9uLWNvZGUnKS5hZGRDbGFzcygnZXhwYW5kZWQnKTtcbiAgICAgICAgYWRkQ291cG9uRmllbGRFdmVudHMoKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFkZENvdXBvbkZpZWxkRXZlbnRzKCkge1xuICAgICAgICAkKCdib2R5Jykub24oJ2NsaWNrLmNhcnQuY291cG9uJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyICR0YXJnZXQgPSAkKGUudGFyZ2V0KTtcbiAgICAgICAgICAgIHZhciBpc1RhcmdldEluQ291cG9uQ29udGFpbmVyID0gJHRhcmdldC5jbG9zZXN0KCcuanMtY2FydC1jb3Vwb24tY29kZScpLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICBpZiAoIWlzVGFyZ2V0SW5Db3Vwb25Db250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAkKCcuanMtY2FydC1jb3Vwb24tY29kZScpLnJlbW92ZUNsYXNzKCdleHBhbmRlZCcpO1xuICAgICAgICAgICAgICAgICQoJ2JvZHknKS5vZmYoJ2NsaWNrLmNhcnQuY291cG9uJyk7XG4gICAgICAgICAgICAgICAgJCgnLmpzLWNhcnQtY291cG9uLWNvZGUgaW5wdXQnKS5vZmYoJ2ZvY3VzLmNhcnQuY291cG9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaXN0ZW5lclxuICAgICAqIEBkZXNjcmlwdGlvbiBMaXN0ZW5zIHRvIHRoZSBzZWxlY3QgZXZlbnQgb24gdGhlIGNhcnQgcHJvZHVjdCBxdWFudGl0eSBmaWVsZCBhbmQgdXBkYXRlcyB0aGUgY2FydCB3aGVuIHRyaWdnZXJlZFxuICAgICAqL1xuICAgICQoJ3NlbGVjdFtuYW1lJD1cIl9xdWFudGl0eVwiXScpLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICQoJ2J1dHRvbltuYW1lJD1cInVwZGF0ZUNhcnRcIl0nKS50cmlnZ2VyKCdjbGljaycpO1xuICAgIH0pO1xufVxuXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaW5pdGlhbGl6ZUV2ZW50cygpO1xuICAgIHNlbGVjdEJveEl0LnNlbGVjdEJveEl0KCQoJy5jYXJ0LXF1YW50aXR5JykpO1xuICAgIGlmIChTaXRlUHJlZmVyZW5jZXMuU1RPUkVfUElDS1VQKSB7XG4gICAgICAgIGNhcnRTdG9yZUludmVudG9yeS5pbml0KCk7XG4gICAgfVxuICAgIGFjY291bnQuaW5pdENhcnRMb2dpbigpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyksXG4gICAgdmFsaWRhdG9yID0gcmVxdWlyZSgnLi4vLi4vdmFsaWRhdG9yJyksXG4gICAgc2hpcHBpbmcgPSByZXF1aXJlKCcuL3NoaXBwaW5nJyk7XG52YXIgaXNDaGVja2luZ1RJID0gMDtcblxuZnVuY3Rpb24gY2hlY2tJZlNhbWVBc1NhdmVkQWRkcmVzcygpXG57XG5cdGlmIChpc0NoZWNraW5nVEkpIHtcblx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KGlzQ2hlY2tpbmdUSSk7XG5cdH1cblx0XG5cdGlzQ2hlY2tpbmdUSSA9IHdpbmRvdy5zZXRUaW1lb3V0KGRvQ2hlY2tJZlNhbWVBc1NhdmVkQWRkcmVzcywgNTAwKTtcbn1cblxuZnVuY3Rpb24gZG9DaGVja0lmU2FtZUFzU2F2ZWRBZGRyZXNzKCkge1xuICAgIHZhciAkZm9ybSA9ICQoJy5zaGlwcGluZy1mb3JtIGZvcm0uYWRkcmVzcycpO1xuXHR2YXIgJGFkZHJlc3NMaXN0ID0gJCgnc2VsZWN0W25hbWUkPVwiX2FkZHJlc3NMaXN0XCJdJywgJGZvcm0pO1xuXHRcblx0aWYgKCRhZGRyZXNzTGlzdC5sZW5ndGggPT0gMCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRcblx0dmFyICRwbGFjZUhvbGRlckVsZW1lbnQgPSBudWxsO1xuXHR2YXIgaGFzSWRlbnRpY2FsQWRkcmVzcyA9IGZhbHNlO1xuXHRcblx0JCgnb3B0aW9uJywgJGFkZHJlc3NMaXN0KS5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgJG9wdGlvbiA9ICQodGhpcyk7XG5cdFx0dmFyIGFkZHJlc3MgPSAkb3B0aW9uLmRhdGEoJ2FkZHJlc3MnKTtcblx0XHRcblx0XHRpZiAoIWFkZHJlc3MpIHtcblx0XHRcdCRwbGFjZUhvbGRlckVsZW1lbnQgPSAkb3B0aW9uO1xuXHRcdH0gZWxzZSBpZiAoaXNJZGVudGljYWwoYWRkcmVzcywgJGZvcm0pKSB7XG5cdFx0XHRzZWxlY3RBZGRyZXNzKCRhZGRyZXNzTGlzdCwgJG9wdGlvbik7XG5cdFx0XHRoYXNJZGVudGljYWxBZGRyZXNzID0gdHJ1ZTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH0pO1xuXHRcblx0aWYgKCFoYXNJZGVudGljYWxBZGRyZXNzICYmICRwbGFjZUhvbGRlckVsZW1lbnQpIHtcblx0XHRzZWxlY3RBZGRyZXNzKCRhZGRyZXNzTGlzdCwgJHBsYWNlSG9sZGVyRWxlbWVudCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gc2VsZWN0QWRkcmVzcygkYWRkcmVzc0xpc3QsICRvcHRpb24pXG57XG5cdCRhZGRyZXNzTGlzdC5vbignY2hhbmdlJywgc3VwcmVzc0V2ZW50cyk7XG5cdCRvcHRpb24ucHJvcCgnc2VsZWN0ZWQnLCB0cnVlKTtcblx0JGFkZHJlc3NMaXN0LnZhbCgkb3B0aW9uLmF0dHIoJ3ZhbHVlJykpO1xuXHQkYWRkcmVzc0xpc3Qub2ZmKCdjaGFuZ2UnLCBzdXByZXNzRXZlbnRzKTtcbn1cblxuZnVuY3Rpb24gc3VwcmVzc0V2ZW50cyhldmVudClcbntcblx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSWRlbnRpY2FsKGFkZHJlc3MsICRmb3JtKSB7XG4gICAgdmFyIGlkZW50aWNhbCA9IHRydWU7XG4gICAgdmFyICRmaWVsZCA9IG51bGw7XG4gICAgZm9yICh2YXIgZmllbGQgaW4gYWRkcmVzcykge1xuICAgICAgICBpZiAoZmllbGQgPT09ICdJRCcgfHwgZmllbGQgPT09ICdVVUlEJyB8fCBmaWVsZCA9PT0gJ2tleScgfHwgZmllbGQgPT09ICd0eXBlJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZHJlc3NbZmllbGRdID09PSBudWxsKSB7XG4gICAgICAgIFx0YWRkcmVzc1tmaWVsZF0gPSAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgJGZpZWxkID0gJGZvcm0uZmluZCgnW25hbWUkPVwiJyArIGZpZWxkLnJlcGxhY2UoJ0NvZGUnLCAnJykgKyAnXCJdJyk7XG4gICAgICAgIGlmICgkZmllbGQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWRlbnRpY2FsID0gaWRlbnRpY2FsICYmICRmaWVsZC52YWwoKSA9PSBhZGRyZXNzW2ZpZWxkXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGQgPT09ICdwb3N0YWxDb2RlJykge1xuICAgICAgICBcdCRmaWVsZCA9ICRmb3JtLmZpbmQoJ2lucHV0LnBvc3RhbCcpO1xuICAgICAgICBcdGlmICgkZmllbGQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlkZW50aWNhbCA9IGlkZW50aWNhbCAmJiAoJGZpZWxkLnZhbCgpID09IGFkZHJlc3NbZmllbGRdIHx8ICRmaWVsZC52YWwoKSA9PSBhZGRyZXNzWyd6aXAnXSk7XG4gICAgICAgIFx0fVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZCA9PT0gJ2NvdW50cnlDb2RlJykge1xuICAgICAgICBcdCRmaWVsZCA9ICRmb3JtLmZpbmQoJ1tuYW1lJD1cImNvdW50cnlcIl0nKTtcbiAgICAgICAgXHRpZiAoJGZpZWxkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZGVudGljYWwgPSBpZGVudGljYWwgJiYgJGZpZWxkLnZhbCgpID09IGFkZHJlc3MuY291bnRyeUNvZGUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgXHR9XG4gICAgICAgICAgICAkZmllbGQgPSAkZm9ybS5maW5kKCdbbmFtZSQ9XCJzdGF0ZVwiXScpO1xuICAgICAgICBcdGlmICgkZmllbGQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlkZW50aWNhbCA9IGlkZW50aWNhbCAmJiAkZmllbGQudmFsKCkgPT0gYWRkcmVzcy5zdGF0ZUNvZGU7XG4gICAgICAgIFx0fVxuICAgICAgICAgICAgJGZpZWxkID0gJGZvcm0uZmluZCgnW25hbWUkPVwiemlwXCJdJyk7XG4gICAgICAgIFx0aWYgKCRmaWVsZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWRlbnRpY2FsID0gaWRlbnRpY2FsICYmICgkZmllbGQudmFsKCkgPT0gYWRkcmVzcy5wb3N0YWxDb2RlIHx8ICRmaWVsZC52YWwoKSA9PSBhZGRyZXNzLnppcCk7XG4gICAgICAgIFx0fVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZCA9PT0gJ3Bob25lJykge1xuICAgICAgICBcdCRmaWVsZCA9ICQoJy5pbnB1dC10ZXh0LnBob25lJyk7XG4gICAgICAgIFx0aWYgKCRmaWVsZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBcdGlkZW50aWNhbCA9IGlkZW50aWNhbCAmJiAkZmllbGQudmFsKCkgPT0gYWRkcmVzcy5waG9uZTtcbiAgICAgICAgXHR9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpZGVudGljYWwpIHtcbiAgICAgICAgXHRyZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGFkZEFkZHJlc3NMaXN0ZW5lcigpXG57XG5cdHZhciAkZm9ybSA9ICQoJy5zaGlwcGluZy1mb3JtIGZvcm0uYWRkcmVzcycpO1xuXHR2YXIgJGFkZHJlc3NMaXN0ID0gJCgnc2VsZWN0W25hbWUkPVwiX2FkZHJlc3NMaXN0XCJdJywgJGZvcm0pO1xuXHR2YXIgaW5wdXRzID0gW1xuXHRcdFx0JGZvcm0uZmluZCgnW25hbWUkPVwiY291bnRyeVwiXScpLFxuXHRcdFx0JGZvcm0uZmluZCgnW25hbWUkPVwic3RhdGVcIl0nKSxcblx0XHRcdCRmb3JtLmZpbmQoJ1tuYW1lJD1cInppcFwiXScpLFxuXHRcdFx0JGZvcm0uZmluZCgnaW5wdXQucG9zdGFsJyksXG5cdFx0XHQkZm9ybS5maW5kKCdbbmFtZSQ9XCJhZGRyZXNzMVwiXScpLFxuXHRcdFx0JGZvcm0uZmluZCgnW25hbWUkPVwiYWRkcmVzczJcIl0nKSxcblx0XHRcdCRmb3JtLmZpbmQoJ1tuYW1lJD1cImNpdHlcIl0nKSxcblx0XHRcdCRmb3JtLmZpbmQoJ1tuYW1lJD1cInNhbWVzaGlwcGluZ1wiXScpLFxuXHRcdFx0JGZvcm0uZmluZCgnW25hbWUkPVwiZmlyc3ROYW1lXCJdJyksXG5cdFx0XHQkZm9ybS5maW5kKCdbbmFtZSQ9XCJsYXN0TmFtZVwiXScpLFxuXHRcdFx0JCgnLmlucHV0LXRleHQucGhvbmUnKVxuXHRcdFx0XTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAoaW5wdXRzW2ldLmxlbmd0aCA+IDApIHtcblx0XHRcdGlucHV0c1tpXS5vbignY2hhbmdlJywgY2hlY2tJZlNhbWVBc1NhdmVkQWRkcmVzcyk7XG5cdFx0fVxuXHR9XG5cdCRmb3JtLmZpbmQoJ1tuYW1lJD1cInNhbWVzaGlwcGluZ1wiXScpLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCQodGhpcykucHJvcCgnY2hlY2tlZCcpKSB7XG5cdFx0XHQkYWRkcmVzc0xpc3QucHJvcCgnZGlzYWJsZWQnLCB0cnVlKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0JGFkZHJlc3NMaXN0LnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpLnJlbW92ZUNsYXNzKCdkaXNhYmxlZCcpO1xuXHRcdH1cblx0XHRcblx0fSk7XG5cdGlmICgkZm9ybS5maW5kKCdbbmFtZSQ9XCJzYW1lc2hpcHBpbmdcIl0nKS5wcm9wKCdjaGVja2VkJykpIHtcblx0XHQkYWRkcmVzc0xpc3QucHJvcCgnZGlzYWJsZWQnLCB0cnVlKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcblx0fSBlbHNlIHtcblx0XHQkYWRkcmVzc0xpc3QucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSkucmVtb3ZlQ2xhc3MoJ2Rpc2FibGVkJyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvbiBTZWxlY3RzIHRoZSBmaXJzdCBhZGRyZXNzIGZyb20gdGhlIGxpc3Qgb2YgYWRkcmVzc2VzXG4gKi9cbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJGZvcm0gPSAkKCcuYWRkcmVzcycpO1xuXG4gICAgLy8gU2VsZWN0IGFkZHJlc3MgZnJvbSBsaXN0XG4gICAgJCgnc2VsZWN0W25hbWUkPVwiX2FkZHJlc3NMaXN0XCJdJywgJGZvcm0pLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICRmb3JtLm9uKCdjaGFuZ2UnLCAnLmlucHV0LXRleHQucGhvbmUnLCB2YWxpZGF0b3IuZm9ybWF0dGVyLnBob25lKTtcblxuICAgICAgICB2YXIgc2VsZWN0ZWQgPSAkKHRoaXMpLmNoaWxkcmVuKCc6c2VsZWN0ZWQnKS5maXJzdCgpO1xuICAgICAgICB2YXIgc2VsZWN0ZWRBZGRyZXNzID0gJChzZWxlY3RlZCkuZGF0YSgnYWRkcmVzcycpO1xuICAgICAgICB2YXIgJGJpbGxpbmdBZGRyZXNzRmllbGRzID0gJCgnI2JpbGxpbmctYWRkcmVzcy1maWVsZHMnKTtcbiAgICAgICAgJCh0aGlzKS5hZGRDbGFzcygnc2VsZWN0ZWQnKTtcblxuICAgICAgICBpZiAoIXNlbGVjdGVkQWRkcmVzcykge1xuICAgICAgICBcdCRiaWxsaW5nQWRkcmVzc0ZpZWxkcy5zaG93KCk7XG4gICAgICAgIFx0cmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciAkc3RhdGVFbXB0eU9wdGlvbkVsID0gJGZvcm0uZmluZCgnLnN0YXRlLWZpZWxkLWNvbnRhaW5lciBzZWxlY3Qgb3B0aW9uOmZpcnN0LWNoaWxkJyk7XG4gICAgICAgIHZhciBzdGF0ZUVtcHR5T3B0aW9uSHRtbCA9ICQoJzxkaXY+JykuYXBwZW5kKCRzdGF0ZUVtcHR5T3B0aW9uRWwuY2xvbmUoKSlcbiAgICAgICAgICAgIC5odG1sKCk7XG4gICAgICAgIHV0aWwuY2hhbmdlU3RhdGVGaWVsZChzZWxlY3RlZEFkZHJlc3MuY291bnRyeUNvZGUsICRmb3JtLCBzdGF0ZUVtcHR5T3B0aW9uSHRtbCk7XG4gICAgICAgIHV0aWwuZmlsbEFkZHJlc3NGaWVsZHMoc2VsZWN0ZWRBZGRyZXNzLCAkZm9ybSk7XG4gICAgICAgIHNoaXBwaW5nLnVwZGF0ZVNoaXBwaW5nTWV0aG9kTGlzdCgpO1xuICAgICAgICB1dGlsLnNlbGVjdFVuZmxvYXQoKTtcbiAgICAgICAgaWYoJGZvcm0uZmluZChcInNlbGVjdFtpZCQ9J19zdGF0ZSddXCIpLnZhbCgpICYmICRmb3JtLmZpbmQoXCJzZWxlY3RbaWQkPSdfc3RhdGUnXVwiKS52YWwoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAkZm9ybS5maW5kKFwic2VsZWN0W2lkJD0nX3N0YXRlJ11cIikuY2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgJCgnW25hbWUkPVwic2hpcHBpbmdBZGRyZXNzX3NhdmVcIl0sIFtuYW1lJD1cImJpbGxpbmdfc2F2ZVwiXScpLnJlbW92ZUF0dHIoJ2Rpc2FibGVkJyk7XG4gICAgICAgICQoJy5pbnB1dC10ZXh0LnBob25lJykudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgfSk7XG4gICAgXG4gICAgY2hlY2tJZlNhbWVBc1NhdmVkQWRkcmVzcygpO1xuICAgIGFkZEFkZHJlc3NMaXN0ZW5lcigpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFqYXggPSByZXF1aXJlKCcuLi8uLi9hamF4JyksXG5cdGRpYWxvZyA9IHJlcXVpcmUoJy4uLy4uL2RpYWxvZycpLFxuICAgIGZvcm1QcmVwYXJlID0gcmVxdWlyZSgnLi9mb3JtUHJlcGFyZScpLFxuICAgIGdpZnRjYXJkID0gcmVxdWlyZSgnLi4vLi4vZ2lmdGNhcmQnKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpLFxuICAgIHByb2dyZXNzID0gcmVxdWlyZSgnLi4vLi4vcHJvZ3Jlc3MnKSxcblx0cGFnZSA9IHJlcXVpcmUoJy4uLy4uL3BhZ2UnKSxcbiAgICB2YWxpZGF0b3IgPSByZXF1aXJlKCcuLi8uLi92YWxpZGF0b3InKSxcblx0c2hpcHBpbmcgPSByZXF1aXJlKCcuL3NoaXBwaW5nJyk7XG5cbnZhciAkY2hlY2tvdXRGb3JtID0gJCgnLmNoZWNrb3V0LWJpbGxpbmcnKTtcbnZhciAkYXZzQ29udGFpbmVyID0gJChcIiNhdnNEaXZcIik7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLypcdFx0XHRcdFx0XHRcdFx0XHRcdFBPUFVMQVRFIFNUQVRFIFRFWFQgQk9YIElGIFNBTUUgQVMgU0hJUFBJTkdcdFx0XHRcdFx0XHRcdCAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmZ1bmN0aW9uIHBvcHVsYXRlU3RhdGVUZXh0Qm94KCkge1xuXHRpZigkKCcjZHdmcm1fYmlsbGluZ19zYW1lc2hpcHBpbmcnKS5pcygnOmNoZWNrZWQnKSkge1xuXHQgICAgcG9wdWxhdGVCaWxsaW5nV2l0aFNoaXBwaW5nKCk7IFxuXHR9XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLypcdFx0XHRcdFx0XHRcdFx0XHRcdE9OIFBBR0UgTE9BRCBFUlJPUiBIQU5ETElORyBGT1IgQ1JFRElUIENBUkRcdFx0XHRcdFx0XHRcdCAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmZ1bmN0aW9uIEhhbmRsZUNyZWRpdENhcmRWYWxpZGF0aW9uT25QYWdlTG9hZCgpIHtcblxuXHQvLyBDcmVkaXQgQ2FyZCBOdW1iZXIgRWxlbWVudHNcblx0dmFyICRjcmVkaXRDYXJkTnVtYmVyQ29udGFpbmVyID0gJCgnLmNyZWRpdC1jYXJkLW51bWJlcicpO1xuXHR2YXIgJGNyZWRpdENhcmRGaWVsZCA9ICRjcmVkaXRDYXJkTnVtYmVyQ29udGFpbmVyLmZpbmQoJ2lucHV0Jyk7XG5cblx0Ly8gQ1ZOIEVsZW1lbnRzXG5cdHZhciAkY3ZuQ29udGFpbmVyID0gJCgnLmN2bicpO1xuXHR2YXIgJGN2bkZpZWxkID0gJGN2bkNvbnRhaW5lci5maW5kKCdpbnB1dCcpO1xuXG5cdC8vIEV4cGlyYXRpb24gRGF0ZSBFbGVtZW50c1xuXHR2YXIgJGV4cGlyYXRpb25EYXRlRmllbGQgPSAkKFwiI2R3ZnJtX2JpbGxpbmdfcGF5bWVudE1ldGhvZHNfY3JlZGl0Q2FyZF9leHBpcmF0aW9uZGF0ZVwiKTtcblx0dmFyICRzZWxlY3RGaWVsZE1vbnRoID0gJChcIiNkd2ZybV9iaWxsaW5nX3BheW1lbnRNZXRob2RzX2NyZWRpdENhcmRfbW9udGhcIik7XG5cdHZhciAkc2VsZWN0RmllbGRZZWFyID0gJChcIiNkd2ZybV9iaWxsaW5nX3BheW1lbnRNZXRob2RzX2NyZWRpdENhcmRfeWVhclwiKTtcblx0dmFyIG1vbnRoID0gZ2V0TW9udGgoJGV4cGlyYXRpb25EYXRlRmllbGQpO1xuXHR2YXIgeWVhciA9IGdldFllYXIoJGV4cGlyYXRpb25EYXRlRmllbGQpO1xuXG5cdC8vIEhhbmRsZSBGaWVsZHM6IENyZWRpdCBDYXJkIGFuZCBDVk4gb24gUGFnZSBMb2FkXG5cdGhhbmRsZUZpZWxkVmFsaWRhdGlvbk9uUGFnZUxvYWQoJGNyZWRpdENhcmROdW1iZXJDb250YWluZXIsICRjcmVkaXRDYXJkRmllbGQpO1xuXHRoYW5kbGVGaWVsZFZhbGlkYXRpb25PblBhZ2VMb2FkKCRjdm5Db250YWluZXIsICRjdm5GaWVsZCk7XG5cblx0Ly8gU2V0IEV4cGlyYXRpb24gRGF0ZVxuXHRzZXRFeHBpcmF0aW9uRGF0ZU9uUGFnZUxvYWQoJHNlbGVjdEZpZWxkTW9udGgsIG1vbnRoLCAkc2VsZWN0RmllbGRZZWFyLCB5ZWFyKTtcblxuXHQvLyBDbGVhciBFeHBpcmF0aW9uIERhdGUgaWYgRXhwaXJlZFxuXHRjbGVhckV4cGlyYXRpb25EYXRlSWZFeHBpcmVkKCk7XG59IFxuXG5mdW5jdGlvbiBjbGVhckV4cGlyYXRpb25EYXRlSWZFeHBpcmVkKCkge1xuXHRpZigkKCcuc2d4LWV4cGlyYXRpb24tZGF0ZScpLmZpbmQoJy5tb250aCcpLmhhc0NsYXNzKCdlcnJvcicpIHx8ICQoJy5zZ3gtZXhwaXJhdGlvbi1kYXRlJykuZmluZCgnLnllYXInKS5oYXNDbGFzcygnZXJyb3InKSkge1xuXHRcdCQoJy5leHBpcmF0aW9uLWRhdGUnKS5maW5kKCdpbnB1dCcpLnZhbCgnJyk7XG5cdFx0JCgnLmV4cGlyYXRpb24tZGF0ZScpLmZpbmQoJ2lucHV0JykuYmx1cigpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHNldEV4cGlyYXRpb25EYXRlT25QYWdlTG9hZCgkc2VsZWN0RmllbGRNb250aCwgbW9udGgsICRzZWxlY3RGaWVsZFllYXIsIHllYXIpIHtcblx0c2VsZWN0SGlkZGVuQ3JlZGl0Q2FyZE1vbnRoKCRzZWxlY3RGaWVsZE1vbnRoLCBtb250aCk7XG5cdHNlbGVjdEhpZGRlbkNyZWRpdENhcmRZZWFyKCRzZWxlY3RGaWVsZFllYXIsIHllYXIpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVGaWVsZFZhbGlkYXRpb25PblBhZ2VMb2FkKCRjb250YWluZXIsICRmaWVsZCwgc3BhbkVycm9ySWQpIHtcblx0c2V0RmllbGRFdmVudE9uQmx1cigkZmllbGQsIHNwYW5FcnJvcklkKTtcblx0YWRkRXJyb3JzT25GaWVsZElmTm90VmFsaWQoJGNvbnRhaW5lciwgJGZpZWxkKTtcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JzT25GaWVsZElmTm90VmFsaWQoJGNvbnRhaW5lciwgJGZpZWxkKSB7XG5cdGlmKGNvbnRhaW5lckhhc0Vycm9yKCRjb250YWluZXIpKSB7XG5cdFx0YWRkRXJyb3JDbGFzc1RvRmllbGQoJGZpZWxkKTtcblx0XHRhZGRFcnJvclNwYW5BZnRlckZpZWxkKCRmaWVsZCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gc2V0RmllbGRFdmVudE9uQmx1cigkZmllbGQpIHtcblx0JGZpZWxkLmJsdXIoZnVuY3Rpb24oKSB7XG5cdFx0cmVtb3ZlU3BhbklmVmFsaWQoJGZpZWxkLm5leHQoJ3NwYW4nKSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTcGFuSWZWYWxpZCgkc3Bhbikge1xuXHRpZihzcGFuSXNWYWxpZCgkc3BhbikpIHtcblx0XHRyZW1vdmVTcGFuKCRzcGFuKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTcGFuKCRzcGFuKSB7XG5cdCRzcGFuLm5leHQoJ3NwYW4nKS5yZW1vdmUoKTtcbn1cblxuZnVuY3Rpb24gc3BhbklzVmFsaWQoJHNwYW4pIHtcblx0cmV0dXJuICRzcGFuLmhhc0NsYXNzKCd2YWxpZCcpO1xufVxuXG5mdW5jdGlvbiBjb250YWluZXJIYXNFcnJvcigkY29udGFpbmVyKSB7XG5cdHJldHVybiAkY29udGFpbmVyLmhhc0NsYXNzKCdlcnJvcicpO1xufVxuXG5mdW5jdGlvbiBhZGRFcnJvckNsYXNzVG9GaWVsZCgkZmllbGQpIHtcblx0JGZpZWxkLmFkZENsYXNzKCdlcnJvcicpO1xufVxuXG5mdW5jdGlvbiBhZGRFcnJvclNwYW5BZnRlckZpZWxkKCRmaWVsZCkge1xuXHQkKFwiPHNwYW4+PC9zcGFuPlwiKS5pbnNlcnRBZnRlcigkZmllbGQpLmFkZENsYXNzKCdlcnJvcicpO1xufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qXHRcdFx0XHRcdFx0XHRcdFx0XHRTQU1FIEFTIFNISVBQSU5HIENIRUNLQk9YIEZVTkNUSU9OQUxJVFlcdFx0XHRcdFx0XHRcdFx0XHQqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAZGVzY3JpcHRpb24gVGhpcyBpcyB0aGUgZXZlbnQgaGFuZGxlciB3aGVuIGEgdXNlciBjaGVja3Mgb3IgdW5jaGVja3MgdGhlIHNhbWUgYXMgc2hpcHBpbmcgY2hlY2tib3guIFxuICogICAgICAgICAgICAgIFdoZW4gYSB1c2VyIGNoZWNrcyAoZW5hYmxlcykgdGhpcyBjaGVjayBib3ggLSB0aGUgYmlsbGluZyBhZGRyZXNzIGZpZWxkcyB3aWxsIGJlIHBvcHVsYXRlZCBcbiAqICAgICAgICAgICAgICB3aXRoIHRoZSBzaGlwcGluZyBhZGRyZXNzIGRhdGEuIFxuICogICAgICAgICAgICAgIE90aGVyd2lzZSwgd2hlbiB0aGUgY2hlY2sgYm94IGlzIG5vdCBjaGVja2VkIChkaXNhYmxlZCkgdGhlIHByZXZpb3VzIGFkZHJlc3MgZGF0YSB3aWxsIGJlIHJlc3RvcmVkLiBcbiAqIEBwYXJhbSBUYWtlcyBubyBwYXJhbWV0ZXJzLiBcbiAqL1xuXG5pZiAoJCgnI2R3ZnJtX2JpbGxpbmdfc2FtZXNoaXBwaW5nOmNoZWNrZWQnKS5sZW5ndGgpIHtcbiAgICAkKCcjYmlsbGluZy1hZGRyZXNzLWZpZWxkcycpLmhpZGUoKTtcbn1cblxuJCgnI2R3ZnJtX2JpbGxpbmdfc2FtZXNoaXBwaW5nJykuY2hhbmdlKGZ1bmN0aW9uKCkge1xuICAgIC8vIFBvcHVsYXRlIHRoZSBiaWxsaW5nIGFkZHJlc3MgZm9ybSB3aXRoIGRhdGEgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGVcbiAgICAvLyBvZiB0aGUgc2FtZSBhcyBzaGlwcGluZyBjaGVjayBib3guXG4gICAgaWYodGhpcy5jaGVja2VkKSB7XG5cbiAgICAgICAgLy8gU3RvcmUgYW55IGlucHV0IHRoYXQgd2FzIGVudGVyZWQgYnkgdGhlIHVzZXIgaW50byBoaWRkZW4gZmllbGRzLlxuICAgIFx0Ly8gVGhpcyBkYXRhIHdpbGwgYmUgdXNlZCB0byByZXBvcHVsYXRlIHRoZSBiaWxsaW5nIGFkZHJlc3MgZmllbGRzIGlmIGFcbiAgICBcdC8vIHVzZXIgdW5jaGVja3MgdGhlIHNhbWUgYXMgc2hpcHBpbmcgdGV4dCBib3guXG4gICAgICAgIHNhdmVDdXJyZW50QmlsbGluZ0FkZHJlc3MoKTtcblxuICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgYmlsbGluZyBhZGRyZXNzIGZvcm0gd2l0aCBzaGlwcGluZyBhZGRyZXNzIGRhdGEuXG5cdCAgICBwb3B1bGF0ZUJpbGxpbmdXaXRoU2hpcHBpbmcoKTtcblx0ICAgICQoJyNiaWxsaW5nLWFkZHJlc3MtZmllbGRzJykuaGlkZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICBcdHBvcHVsYXRlQmlsbGluZ1dpdGhQcmV2aW91c0RhdGEoKTtcbiAgICBcdCQoJyNiaWxsaW5nLWFkZHJlc3MtZmllbGRzJykuc2hvdygpO1xuICAgIH1cblxuICAgIC8vIEFsd2F5cyB2YWxpZGF0ZSB0aGUgZm9ybSBhZnRlciB0aGUgc2FtZSBhcyBzaGlwcGluZyBjaGVjayBib3ggaGFzIGJlZW4gY2hlY2tlZC5cbiAgICBmb3JtUHJlcGFyZS52YWxpZGF0ZUZvcm0oKTtcbiAgICBpZiAoJCgnI215LWJhZy10b2dnbGUtYnV0dG9uJykuaGFzQ2xhc3MoJ2ZhLW1pbnVzJykpIHtcbiAgICAgICAgJCgnI215LWJhZy10b2dnbGUtYnV0dG9uJykudHJpZ2dlcignY2xpY2snKTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvbiBHcmFicyB0aGUgaGlkZGVuIGZpZWxkcyB3aGljaCBjb250YWluIHRoZSBwcmV2aW91c2x5IGVudGVyZWQgc2hpcHBpbmcgYWRkcmVzcyBkYXRhIGZyb20gdGhlIFxuICogICAgICAgICAgICAgIHNoaXBwaW5nIHBhZ2UuIFRoaXMgaXMgdGhlbiB1c2VkIHRvIHBvcHVsYXRlIHRoZSBiaWxsaW5nIGFkZHJlc3MgZm9ybSBhZGRyZXNzIGZpZWxkcyBzaW5jZSBcbiAqICAgICAgICAgICAgICB0aGUgdXNlciBqdXN0IGNoZWNrZWQgdGhlIHNhbWUgYXMgc2hpcHBpbmcgY2hlY2sgYm94LlxuICogQHBhcmFtIFRha2VzIG5vIHBhcmFtZXRlcnMuXG4gKi9cbmZ1bmN0aW9uIHNhdmVDdXJyZW50QmlsbGluZ0FkZHJlc3MoKSB7XG5cdFxuXHQkKCcjYmlsbGluZy1maXJzdC1uYW1lJykudmFsKCQoJyNkd2ZybV9iaWxsaW5nX2JpbGxpbmdBZGRyZXNzX2FkZHJlc3NGaWVsZHNfZmlyc3ROYW1lJykudmFsKCkpO1xuXHQkKCcjYmlsbGluZy1sYXN0LW5hbWUnKS52YWwoJCgnI2R3ZnJtX2JpbGxpbmdfYmlsbGluZ0FkZHJlc3NfYWRkcmVzc0ZpZWxkc19sYXN0TmFtZScpLnZhbCgpKTtcblx0JCgnI2JpbGxpbmctYWRkcmVzczEnKS52YWwoJCgnI2R3ZnJtX2JpbGxpbmdfYmlsbGluZ0FkZHJlc3NfYWRkcmVzc0ZpZWxkc19hZGRyZXNzMScpLnZhbCgpKTtcblx0JCgnI2JpbGxpbmctYWRkcmVzczInKS52YWwoJCgnI2R3ZnJtX2JpbGxpbmdfYmlsbGluZ0FkZHJlc3NfYWRkcmVzc0ZpZWxkc19hZGRyZXNzMicpLnZhbCgpKTtcblx0JCgnI2JpbGxpbmctY2l0eScpLnZhbCgkKCcjZHdmcm1fYmlsbGluZ19iaWxsaW5nQWRkcmVzc19hZGRyZXNzRmllbGRzX2NpdHknKS52YWwoKSk7XG5cdCQoJyNiaWxsaW5nLXppcC1jb2RlJykudmFsKCQoJyNkd2ZybV9iaWxsaW5nX2JpbGxpbmdBZGRyZXNzX2FkZHJlc3NGaWVsZHNfemlwJykudmFsKCkpO1xuXHQkKCcjYmlsbGluZy1zdGF0ZScpLnZhbCgkKCcjZHdmcm1fYmlsbGluZ19iaWxsaW5nQWRkcmVzc19hZGRyZXNzRmllbGRzX3N0YXRlc19zdGF0ZScpLnZhbCgpLnRyaW0oKSk7XG5cdCQoJyNiaWxsaW5nLWNvdW50cnknKS52YWwoJCgnI2R3ZnJtX2JpbGxpbmdfYmlsbGluZ0FkZHJlc3NfYWRkcmVzc0ZpZWxkc19jb3VudHJ5JykudmFsKCkpO1xuXHQkKCcjYmlsbGluZy1waG9uZScpLnZhbCgkKCcjZHdmcm1fYmlsbGluZ19iaWxsaW5nQWRkcmVzc19hZGRyZXNzRmllbGRzX3Bob25lJykudmFsKCkpO1xuXHRcblx0c2V0SXNTYXZlZEJpbGxpbmdTdGF0ZSgpO1xufSBcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvbiBHcmFicyB0aGUgaGlkZGVuIGZpZWxkcyB3aGljaCBjb250YWluIHRoZSBwcmV2aW91c2x5IGVudGVyZWQgc2hpcHBpbmcgYWRkcmVzcyBkYXRhIGZyb20gdGhlIFxuICogICAgICAgICAgICAgIHNoaXBwaW5nIHBhZ2UuIFRoaXMgaXMgdGhlbiB1c2VkIHRvIHBvcHVsYXRlIHRoZSBiaWxsaW5nIGFkZHJlc3MgZm9ybSBhZGRyZXNzIGZpZWxkcyBzaW5jZSBcbiAqICAgICAgICAgICAgICB0aGUgdXNlciBqdXN0IGNoZWNrZWQgdGhlIHNhbWUgYXMgc2hpcHBpbmcgY2hlY2sgYm94LlxuICogQHBhcmFtIFRha2VzIG5vIHBhcmFtZXRlcnMuXG4gKi9cbmZ1bmN0aW9uIHBvcHVsYXRlQmlsbGluZ1dpdGhQcmV2aW91c0RhdGEoKSB7XG5cdGlmIChpc1NhdmVkQmlsbGluZ1N0YXRlKCkpIHtcblx0XHQkKCcjZHdmcm1fYmlsbGluZ19iaWxsaW5nQWRkcmVzc19hZGRyZXNzRmllbGRzX2ZpcnN0TmFtZScpLnZhbCgkKCcjYmlsbGluZy1maXJzdC1uYW1lJykudmFsKCkpO1xuXHRcdCQoJyNkd2ZybV9iaWxsaW5nX2JpbGxpbmdBZGRyZXNzX2FkZHJlc3NGaWVsZHNfbGFzdE5hbWUnKS52YWwoJCgnI2JpbGxpbmctbGFzdC1uYW1lJykudmFsKCkpO1xuXHRcdCQoJyNkd2ZybV9iaWxsaW5nX2JpbGxpbmdBZGRyZXNzX2FkZHJlc3NGaWVsZHNfYWRkcmVzczEnKS52YWwoJCgnI2JpbGxpbmctYWRkcmVzczEnKS52YWwoKSk7XG5cdFx0JCgnI2R3ZnJtX2JpbGxpbmdfYmlsbGluZ0FkZHJlc3NfYWRkcmVzc0ZpZWxkc19hZGRyZXNzMicpLnZhbCgkKCcjYmlsbGluZy1hZGRyZXNzMicpLnZhbCgpKTtcblx0XHQkKCcjZHdmcm1fYmlsbGluZ19iaWxsaW5nQWRkcmVzc19hZGRyZXNzRmllbGRzX2NpdHknKS52YWwoJCgnI2JpbGxpbmctY2l0eScpLnZhbCgpKTtcblx0XHQkKCcjZHdmcm1fYmlsbGluZ19iaWxsaW5nQWRkcmVzc19hZGRyZXNzRmllbGRzX3ppcCcpLnZhbCgkKCcjYmlsbGluZy16aXAtY29kZScpLnZhbCgpKTtcblx0XHQkKCcjZHdmcm1fYmlsbGluZ19iaWxsaW5nQWRkcmVzc19hZGRyZXNzRmllbGRzX3N0YXRlc19zdGF0ZScpLnZhbCgkKCcjYmlsbGluZy1zdGF0ZScpLnZhbCgpLnRyaW0oKS50b1VwcGVyQ2FzZSgpKTtcblx0XHQkKCcjZHdmcm1fYmlsbGluZ19iaWxsaW5nQWRkcmVzc19hZGRyZXNzRmllbGRzX2NvdW50cnknKS52YWwoJCgnI2JpbGxpbmctY291bnRyeScpLnZhbCgpLnRyaW0oKS50b1VwcGVyQ2FzZSgpKTtcblx0XHQkKCcjZHdmcm1fYmlsbGluZ19iaWxsaW5nQWRkcmVzc19hZGRyZXNzRmllbGRzX3Bob25lJykudmFsKCQoJyNiaWxsaW5nLXBob25lJykudmFsKCkpO1xuXHR9XG59IFxuXG4vKipcbiAqIEBmdW5jdGlvbiBcbiAqIEBkZXNjcmlwdGlvbiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGhpZGRlbiBiaWxsaW5nIGRhdGEgY2FjaGUgZmllbGRzIGhhdmUgYmVlbiB1cGRhdGVkIHdpdGggZGF0YVxuICogXHRcdFx0XHRiZXNpZGVzIGZvciBlbXB0eSBzdHJpbmdzLlxuICogQHBhcmFtIFRha2Ugbm8gcGFyYW1ldGVyc1xuICovXG5mdW5jdGlvbiBpc1NhdmVkQmlsbGluZ1N0YXRlKCkge1xuXHRyZXR1cm4gJCgnI2JpbGxpbmctaGFzLXNhdmVkLWRhdGEnKS52YWwoKS5sZW5ndGggPiAwO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvbiBcbiAqIEBkZXNjcmlwdGlvbiBTZXRzIHRoZSBiaWxsaW5nLWhhcy1zYXZlZC1kYXRhIGZpZWxkIHRvIGEgdHJ1dGh5IHZhbHVlIGlmIHRoZSBoaWRkZW4gYmlsbGluZyBkYXRhIGNhY2hlIFxuICogXHRcdFx0XHRmaWVsZHMgY29udGFpbiBpbmZvcm1hdGlvbiBvdGhlciB0aGFuIGFuIGVtcHR5IHN0cmluZy4gT3RoZXJ3aXNlIGl0IHNldHMgdGhlIGZpZWxkIHRvIGEgXG4gKiBcdFx0XHRcdGZhbHNleSB2YWx1ZS5cbiAqIEBwYXJhbSBUYWtlIG5vIHBhcmFtZXRlcnNcbiAqL1xuZnVuY3Rpb24gc2V0SXNTYXZlZEJpbGxpbmdTdGF0ZSgpIHtcblx0dmFyIGlzU2F2ZWRTdGF0ZSA9IGZhbHNlO1xuXHRpc1NhdmVkU3RhdGUgfD0gJCgnI2JpbGxpbmctZmlyc3QtbmFtZScpLnZhbCgpLmxlbmd0aCA+IDA7XG5cdGlzU2F2ZWRTdGF0ZSB8PSAkKCcjYmlsbGluZy1sYXN0LW5hbWUnKS52YWwoKS5sZW5ndGggPiAwO1xuXHRpc1NhdmVkU3RhdGUgfD0gJCgnI2JpbGxpbmctYWRkcmVzczEnKS52YWwoKS5sZW5ndGggPiAwO1xuXHRpc1NhdmVkU3RhdGUgfD0gJCgnI2JpbGxpbmctYWRkcmVzczInKS52YWwoKS5sZW5ndGggPiAwO1xuXHRpc1NhdmVkU3RhdGUgfD0gJCgnI2JpbGxpbmctY2l0eScpLnZhbCgpLmxlbmd0aCA+IDA7XG5cdGlzU2F2ZWRTdGF0ZSB8PSAkKCcjYmlsbGluZy16aXAtY29kZScpLnZhbCgpLmxlbmd0aCA+IDA7XG5cdGlzU2F2ZWRTdGF0ZSB8PSAkKCcjYmlsbGluZy1zdGF0ZScpLnZhbCgpLmxlbmd0aCA+IDA7XG5cdGlzU2F2ZWRTdGF0ZSB8PSAkKCcjYmlsbGluZy1jb3VudHJ5JykudmFsKCkubGVuZ3RoID4gMDtcblx0aXNTYXZlZFN0YXRlIHw9ICQoJyNiaWxsaW5nLXBob25lJykudmFsKCkubGVuZ3RoID4gMDtcblx0XG5cdGlmIChpc1NhdmVkU3RhdGUpIHtcblx0XHQkKCcjYmlsbGluZy1oYXMtc2F2ZWQtZGF0YScpLnZhbCgndHJ1ZScpO1xuXHR9IGVsc2Uge1xuXHRcdCQoJyNiaWxsaW5nLWhhcy1zYXZlZC1kYXRhJykudmFsKCcnKTtcblx0fVxufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uIEdyYWJzIHRoZSBoaWRkZW4gZmllbGRzIHdoaWNoIGNvbnRhaW4gdGhlIHByZXZpb3VzbHkgZW50ZXJlZCBzaGlwcGluZyBhZGRyZXNzIGRhdGEgZnJvbSB0aGUgXG4gKiAgICAgICAgICAgICAgc2hpcHBpbmcgcGFnZS4gVGhpcyBpcyB0aGVuIHVzZWQgdG8gcG9wdWxhdGUgdGhlIGJpbGxpbmcgYWRkcmVzcyBmb3JtIGFkZHJlc3MgZmllbGRzIHNpbmNlIFxuICogICAgICAgICAgICAgIHRoZSB1c2VyIGp1c3QgY2hlY2tlZCB0aGUgc2FtZSBhcyBzaGlwcGluZyBjaGVjayBib3guXG4gKiBAcGFyYW0gVGFrZXMgbm8gcGFyYW1ldGVycy5cbiAqL1xuZnVuY3Rpb24gcG9wdWxhdGVCaWxsaW5nV2l0aFNoaXBwaW5nKCkge1xuXHR2YXIgemlwQ29kZVZhbHVlID0gJCgnI3NoaXBwaW5nLXppcC1jb2RlJykudGV4dCgpO1xuXG5cdGlmKHppcENvZGVWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0JCgnI2R3ZnJtX2JpbGxpbmdfYmlsbGluZ0FkZHJlc3NfYWRkcmVzc0ZpZWxkc196aXAnKS52YWwoemlwQ29kZVZhbHVlLnRyaW0oKSkuYmx1cigpO1xuXHR9XG5cdCQoJyNkd2ZybV9iaWxsaW5nX2JpbGxpbmdBZGRyZXNzX2FkZHJlc3NGaWVsZHNfZmlyc3ROYW1lJykudmFsKCQoJyNzaGlwcGluZy1maXJzdC1uYW1lJykudGV4dCgpKS5ibHVyKCk7XG5cdCQoJyNkd2ZybV9iaWxsaW5nX2JpbGxpbmdBZGRyZXNzX2FkZHJlc3NGaWVsZHNfbGFzdE5hbWUnKS52YWwoJCgnI3NoaXBwaW5nLWxhc3QtbmFtZScpLnRleHQoKSkuYmx1cigpO1xuXHQkKCcjZHdmcm1fYmlsbGluZ19iaWxsaW5nQWRkcmVzc19hZGRyZXNzRmllbGRzX2FkZHJlc3MxJykudmFsKCQoJyNzaGlwcGluZy1hZGRyZXNzMScpLnRleHQoKSkuYmx1cigpO1xuXHQkKCcjZHdmcm1fYmlsbGluZ19iaWxsaW5nQWRkcmVzc19hZGRyZXNzRmllbGRzX2FkZHJlc3MyJykudmFsKCQoJyNzaGlwcGluZy1hZGRyZXNzMicpLnRleHQoKSkuYmx1cigpO1xuXHQkKCcjZHdmcm1fYmlsbGluZ19iaWxsaW5nQWRkcmVzc19hZGRyZXNzRmllbGRzX2NpdHknKS52YWwoJCgnI3NoaXBwaW5nLWNpdHknKS50ZXh0KCkpLmJsdXIoKTtcblx0JCgnI2R3ZnJtX2JpbGxpbmdfYmlsbGluZ0FkZHJlc3NfYWRkcmVzc0ZpZWxkc19zdGF0ZXNfc3RhdGUnKS52YWwoJCgnI3NoaXBwaW5nLXN0YXRlJykudGV4dCgpLnRyaW0oKS50b1VwcGVyQ2FzZSgpKS5ibHVyKCk7XG5cdCQoJyNkd2ZybV9iaWxsaW5nX2JpbGxpbmdBZGRyZXNzX2FkZHJlc3NGaWVsZHNfY291bnRyeScpLnZhbCgkKCcjc2hpcHBpbmctY291bnRyeScpLnRleHQoKS50cmltKCkudG9VcHBlckNhc2UoKSkuYmx1cigpO1xuXHQkKCcjZHdmcm1fYmlsbGluZ19iaWxsaW5nQWRkcmVzc19hZGRyZXNzRmllbGRzX3Bob25lJykudmFsKCQoJyNzaGlwcGluZy1waG9uZScpLnRleHQoKSkuYmx1cigpO1xuXHR2YXIgc2hpcHBpbmdFbWFpbCA9ICQoJyNzaGlwcGluZy1lbWFpbCcpLnRleHQoKTtcblx0aWYgKHNoaXBwaW5nRW1haWwudHJpbSgpKSB7XG5cdFx0JCgnI2R3ZnJtX2JpbGxpbmdfYmlsbGluZ0FkZHJlc3NfZW1haWxfZW1haWxBZGRyZXNzJykudmFsKHNoaXBwaW5nRW1haWwpLmJsdXIoKTtcblx0fVxufSBcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKlx0XHRcdFx0XHRcdFx0XHRcdFx0Q1JFRElUIENBUkQgTUVUSE9EU1x0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAZGVzY3JpcHRpb24gU2VsZWN0cyB0aGUgYXBwcm9wcmlhdGUgeWVhciBiYXNlZCBvbiB0aGUgdXNlciBpbnB1dCB3aXRoaW4gdGhlIGV4cGlyYXRpb24gZGF0ZSBmaWVsZFxuICogQHBhcmFtIGpRdWVyeSBTZWxlY3QgRmllbGQgT2JqZWN0IGZvciB0aGUgRXhwaXJhdGlvbiBZZWFyXG4gKi9cbmZ1bmN0aW9uIHNlbGVjdEhpZGRlbkNyZWRpdENhcmRZZWFyKCRzZWxlY3RGaWVsZFllYXIsIHllYXIpIHsgXG5cdGlmKHllYXIgPiAyMDI2KSB7XG5cdFx0JHNlbGVjdEZpZWxkWWVhci52YWwoMjAxNCk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0JHNlbGVjdEZpZWxkWWVhci52YWwoeWVhcik7XG5cdH1cbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvbiBTZWxlY3RzIHRoZSBhcHByb3ByaWF0ZSBtb250aCBiYXNlZCBvbiB0aGUgdXNlciBpbnB1dCB3aXRoaW4gdGhlIGV4cGlyYXRpb24gZGF0ZSBmaWVsZFxuICogQHBhcmFtIGpRdWVyeSBTZWxlY3QgRmllbGQgT2JqZWN0IGZvciB0aGUgRXhwaXJhdGlvbiBNb250aFxuICovXG5mdW5jdGlvbiBzZWxlY3RIaWRkZW5DcmVkaXRDYXJkTW9udGgoJHNlbGVjdEZpZWxkTW9udGgsIG1vbnRoKSB7IFxuXHRpZihtb250aCA+IDEyKSB7XG5cdFx0JHNlbGVjdEZpZWxkTW9udGgudmFsKDEpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdCRzZWxlY3RGaWVsZE1vbnRoLnZhbChtb250aCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvbiBHZXRzIHRoZSBtb250aCBmcm9tIHVzZXIgaW5wdXRcbiAqIEBwYXJhbSBqUXVlcnkgVGV4dCBCb3ggRXhwaXJhdGlvbiBEYXRlIE9iamVjdFxuICovXG5mdW5jdGlvbiBnZXRNb250aCgkdGV4dEJveEV4cGlyYXRpb25EYXRlKSB7XG5cdGlmICghJHRleHRCb3hFeHBpcmF0aW9uRGF0ZS5sZW5ndGgpIHsgcmV0dXJuOyB9XG5cblx0dmFyIG1vbnRoID0gMTtcblxuXHRpZigkdGV4dEJveEV4cGlyYXRpb25EYXRlICYmICR0ZXh0Qm94RXhwaXJhdGlvbkRhdGUudmFsKCkubGVuZ3RoID4gMSkge1xuXHRcdG1vbnRoID0gcGFyc2VJbnQoJHRleHRCb3hFeHBpcmF0aW9uRGF0ZS52YWwoKS5zdWJzdHJpbmcoMCwgMikpO1xuXHR9XG5cblx0cmV0dXJuIG1vbnRoO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uIEdldHMgdGhlIHllYXIgZnJvbSB1c2VyIGlucHV0XG4gKiBAcGFyYW0galF1ZXJ5IFRleHQgQm94IEV4cGlyYXRpb24gRGF0ZSBPYmplY3RcbiAqL1xuZnVuY3Rpb24gZ2V0WWVhcigkdGV4dEJveEV4cGlyYXRpb25EYXRlKSB7XG4gICAgaWYgKCEkdGV4dEJveEV4cGlyYXRpb25EYXRlLmxlbmd0aCkgeyByZXR1cm47IH1cblxuICAgIHZhciB5ZWFyID0gMjAxNDtcblxuXHRpZigkdGV4dEJveEV4cGlyYXRpb25EYXRlICYmICR0ZXh0Qm94RXhwaXJhdGlvbkRhdGUudmFsKCkubGVuZ3RoID09IDcpXG5cdFx0eWVhciA9IHBhcnNlSW50KFwiMjBcIiArICR0ZXh0Qm94RXhwaXJhdGlvbkRhdGUudmFsKCkuc3Vic3RyaW5nKDUsIDcpKTtcblxuXHRyZXR1cm4geWVhcjtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvbiBTZWxlY3RzIHRoZSBjcmVkaXQgY2FyZCB0eXBlIHdpdGggcmVzcGVjdCB0byB0aGUgY3JlZGl0IGNhcmQgcGFyYW1ldGVyIGJlaW5nIHBhc3NlZCBpblxuICogQHBhcmFtIGpRdWVyeSBTZWxlY3QgRmllbGQgT2JqZWN0IGFuZCB0aGUgQ3JlZGl0IENhcmQgVHlwZSAoVmlzYSwgTWFzdGVyY2FyZCwgQU1FWCwgYW5kL29yIERpc2NvdmVyKVxuICovXG5mdW5jdGlvbiBzZWxlY3RIaWRkZW5DcmVkaXRDYXJkT3B0aW9uICgkc2VsZWN0RmllbGQsIGNyZWRpdENhcmRUeXBlKSB7XG5cdCRzZWxlY3RGaWVsZC52YWwoY3JlZGl0Q2FyZFR5cGUpO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uIE9ubHkgYWxsb3cgaW50ZWdlcnMgaW4gdGhlIGNyZWRpdCBjYXJkIG51bWJlclxuICogQHBhcmFtIGpRdWVyeSBUZXh0IEJveCBPYmplY3QgXG4gKi9cbmZ1bmN0aW9uIGdldENyZWRpdENhcmRUeXBlKGNyZWRpdENhcmROdW1iZXIpIHtcbiAgICB2YXIgY3JlZGl0Q2FyZE51bWJlciA9IGNyZWRpdENhcmROdW1iZXIucmVwbGFjZSgvXFxzKy9nLCAnJyk7XG5cbiAgICAvLyBEZWZhdWx0IGNyZWRpdCBjYXJkIHR5cGUgdG8gVmlzYS5cbiAgICB2YXIgY3JlZGl0Q2FyZFR5cGUgPSAnJztcblxuICAgIC8vIEVuc3VyZSBjcmVkaXQgY2FyZCBudW1iZXIgaGFzIGEgbWluaW11bSBvZiB0aHJlZSBkaWdpdHMuXG4gICAgLy8gRGVmYXVsdCB0byBWaXNhIGFnYWluIGp1c3QgaW4gY2FzZSBpdCB3YXMgbmV2ZXIgc2V0LlxuICAgIGlmKGNyZWRpdENhcmROdW1iZXIubGVuZ3RoID4gMykge1xuICAgICAgICBpZiAoL141WzEtNV18XjIoPzoyKD86MlsxLTldfFszLTldXFxkKXxbMy02XVxcZFxcZHw3KD86WzAxXVxcZHwyMCkpXFxkezEyfSQvLnRlc3QoY3JlZGl0Q2FyZE51bWJlcikpXG4gICAgICAgICAgICBjcmVkaXRDYXJkVHlwZSA9IFwiTWFzdGVyXCI7XG4gICAgICAgIGVsc2UgaWYgKC9eNC8udGVzdChjcmVkaXRDYXJkTnVtYmVyKSlcbiAgICAgICAgICAgIGNyZWRpdENhcmRUeXBlID0gXCJWaXNhXCI7XG4gICAgICAgIGVsc2UgaWYgKC9eM1s0N10vLnRlc3QoY3JlZGl0Q2FyZE51bWJlcikpXG4gICAgICAgICAgICBjcmVkaXRDYXJkVHlwZSA9IFwiQW1leFwiO1xuICAgICAgICBlbHNlIGlmICgvXig2MDExfDYyMigxMls2LTldfDFbMy05XVswLTldfFsyLThdWzAtOV17Mn18OVswLTFdWzAtOV18OTJbMC01XXw2NFs0LTldKXw2NSkvLnRlc3QoY3JlZGl0Q2FyZE51bWJlcikpXG4gICAgICAgICAgICBjcmVkaXRDYXJkVHlwZSA9IFwiRGlzY292ZXJcIjtcbiAgICB9XG5cblx0Ly8gUmV0dXJuIHRoZSBjcmVkaXQgY2FyZCB0eXBlLlxuXHRyZXR1cm4gY3JlZGl0Q2FyZFR5cGU7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAZGVzY3JpcHRpb24gUmV0dXJucyB0aGUgY3JlZGl0IGNhcmQgbnVtYmVyIHRoZSB1c2VyIGhhcyBqdXN0IGVudGVyZWQgaW4gdGhlIGNyZWRpdCBjYXJkIGZpZWxkXG4gKiBAcGFyYW0galF1ZXJ5IFRleHQgQm94IE9iamVjdCBcbiAqL1xuZnVuY3Rpb24gZ2V0Q3JlZGl0Q2FyZE51bWJlcigkdGV4dEJveCkge1xuXHRyZXR1cm4gJHRleHRCb3gudmFsKCk7XG59XG5mdW5jdGlvbiBzZXRNYXNrQ3JlZGl0Q2FyZE51bWJlcigkdGV4dEJveCkge1xuICAgICR0ZXh0Qm94LnZhbChmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9cXFcvZ2ksICcnKS5yZXBsYWNlKC8oLns0fSkvZywgJyQxICcpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uIE9ubHkgYWxsb3dzIGludGVnZXJzIGZvciB0aGUgY3JlZGl0IGNhcmQgZmllbGRcbiAqIEBwYXJhbSBqUXVlcnkgVGV4dCBCb3ggT2JqZWN0IFxuICovXG5mdW5jdGlvbiBhbGxvd09ubHlJbnRlZ2Vyc09uKCR0ZXh0Qm94KSB7XG5cdCR0ZXh0Qm94LmtleWRvd24oZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBSZXR1cm4gdHJ1ZSBpZiBrZXkgc3Ryb2tlIGlzIGEgbnVtYmVyLlxuXHRcdC8vIE90aGVyd2lzZSwgcmV0dXJuIGZhbHNlLlxuXHRcdHZhciBpc051bWJlciA9IChlLnNoaWZ0S2V5IHx8IChlLmtleUNvZGUgPj0gNDggJiYgZS5rZXlDb2RlIDw9NTcpIHx8IChlLmtleUNvZGUgPj0gOTYgJiYgZS5rZXlDb2RlIDw9MTA1KSk7XG5cblx0XHQvLyBSZXR1cm4gdHJ1ZSBpZiBrZXkgc3Ryb2tlIGlzIGEgYmFja3NwYWNlLCBkZWxldGUsIHRhYiwgZXNjYXBlLCBhbmQvb3IgZW50ZXJcblx0XHQvLyBPdGhlcndpc2UsIHJldHVybiBmYWxzZS5cblx0XHR2YXIgYWxsb3dlZEtleTEgPSAkLmluQXJyYXkoZS5rZXlDb2RlLCBbNDYsIDgsIDksIDI3LCAxMywgMTEwLCAxOTBdKSAhPT0gLTE7XG5cblx0XHQvLyBSZXR1cm4gdHJ1ZSBpZiBrZXkgc3Ryb2tlIGlzIEN0cmwrQSBvciBDb21tYW5kK0Fcblx0XHQvLyBPdGhlcndpc2UsIHJldHVybiBmYWxzZS5cblx0XHR2YXIgYWxsb3dlZEtleTIgPSAoZS5rZXlDb2RlID09PSA2NSAmJiAoZS5jdHJsS2V5ID09PSB0cnVlIHx8IGUubWV0YUtleSA9PT0gdHJ1ZSkpO1xuXG5cdFx0Ly8gUmV0dXJuIHRydWUgaWYga2V5IHN0cm9rZSBpcyBob21lLCBlbmQsIGxlZnQsIHJpZ2h0LCBkb3duLCBvciB1cC5cblx0XHQvLyBPdGhlcndpc2UsIHJldHVybiBmYWxzZS5cblx0XHR2YXIgYWxsb3dlZEtleTMgPSAoZS5rZXlDb2RlID49IDM1ICYmIGUua2V5Q29kZSA8PSA0MCk7XG5cbiAgICAgICAgLy8gRG8gbm90IGRvIGFueXRoaW5nIGlmIHRoZSBjdXJyZW50IGtleSBzdHJva2UgaXMgb25lIG9mIHRoZVxuXHRcdC8vIGFsbG93ZWQga2V5cy5cbiAgICAgICAgaWYgKGFsbG93ZWRLZXkxIHx8IGFsbG93ZWRLZXkyIHx8IGFsbG93ZWRLZXkzKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0Ly8gRG8gbm90IGFsbG93IGtleSBwcmVzcyBpZiB0aGUgdXNlciBpbnB1dCBpcyBub3QgYSBudW1iZXIuXG4gICAgICAgIGlmICghaXNOdW1iZXIpXG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGFsbG93T25seUludGVnZXJzQ1ZOKCRjdm4pIHtcblx0JGN2bi5rZXlkb3duKGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGNoYXJDb2RlID0gKGUud2hpY2gpID8gZS53aGljaCA6IGV2ZW50LmtleUNvZGU7XG5cdFx0cmV0dXJuICEoY2hhckNvZGUgPiAzMSAmJiAoY2hhckNvZGUgPCA0OCB8fCBjaGFyQ29kZSA+IDU3KSk7XG5cdH0pO1xuXHQkY3ZuLm9uKCdpbnB1dCcsIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoJCh0aGlzKS52YWwoKS5sZW5ndGggPiA0KSB7XG5cdFx0XHQkKHRoaXMpLnZhbCgkKHRoaXMpLnZhbCgpLnNsaWNlKDAsNCkpO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uIEZpbGxzIHRoZSBDcmVkaXQgQ2FyZCBmb3JtIHdpdGggdGhlIHBhc3NlZCBkYXRhLXBhcmFtZXRlciBhbmQgY2xlYXJzIHRoZSBmb3JtZXIgY3ZuIGlucHV0XG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgQ3JlZGl0IENhcmQgZGF0YSAoaG9sZGVyLCB0eXBlLCBtYXNrZWQgbnVtYmVyLCBleHBpcmF0aW9uIG1vbnRoL3llYXIpXG4gKi9cbmZ1bmN0aW9uIHNldENDRmllbGRzKGRhdGEpIHtcbiAgICB2YXIgJGNyZWRpdENhcmQgPSAkKCdbZGF0YS1tZXRob2Q9XCJDUkVESVRfQ0FSRFwiXScpO1xuICAgIHZhciAkbW9udGggPSAkY3JlZGl0Q2FyZC5maW5kKCdbbmFtZSQ9XCJfbW9udGhcIl0nKTtcbiAgICB2YXIgJHllYXIgPSAkY3JlZGl0Q2FyZC5maW5kKCdbbmFtZSQ9XCJfeWVhclwiXScpO1xuXG4gICAgJGNyZWRpdENhcmQuZmluZCgnaW5wdXRbbmFtZSQ9XCJjcmVkaXRDYXJkX293bmVyXCJdJykudmFsKGRhdGEuaG9sZGVyKS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAkY3JlZGl0Q2FyZC5maW5kKCdzZWxlY3RbbmFtZSQ9XCJfdHlwZVwiXScpLnZhbChkYXRhLnR5cGUpLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgICQoJy5wYXltZW50LW1ldGhvZC1pbWFnZS1jcmVkaXQtY2FyZCcpLmZpbmQoJy5hY3RpdmUnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgJCgnLnBheW1lbnQtbWV0aG9kLWltYWdlLWNyZWRpdC1jYXJkJykuZmluZCgnZGl2JykuZWFjaChmdW5jdGlvbigpe1xuICAgIFx0aWYoJCh0aGlzKS5oYXNDbGFzcyhkYXRhLnR5cGUudG9Mb3dlckNhc2UoKSkpe1xuICAgIFx0XHQkKHRoaXMpLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICBcdH1cbiAgICB9KTtcbiAgICAkY3JlZGl0Q2FyZC5maW5kKCdpbnB1dFtuYW1lKj1cIl9jcmVkaXRDYXJkX251bWJlclwiXScpLnZhbChkYXRhLm1hc2tlZE51bWJlcik7XG4gICAgJChcIiNkd2ZybV9iaWxsaW5nX3BheW1lbnRNZXRob2RzX2NyZWRpdENhcmRfbnVtYmVyXCIpLmZvY3VzKCk7XG4gICAgJChcIiNkd2ZybV9iaWxsaW5nX3BheW1lbnRNZXRob2RzX2NyZWRpdENhcmRfbnVtYmVyXCIpLmJsdXIoKTtcbiAgICAkbW9udGgudmFsKGRhdGEuZXhwaXJhdGlvbk1vbnRoKS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAkeWVhci52YWwoZGF0YS5leHBpcmF0aW9uWWVhcikudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgJCgnaW5wdXRbbmFtZSo9XCJfY3ZuX1wiXSwgaW5wdXRbbmFtZSQ9XCJfY3ZuXCJdJywgJGNyZWRpdENhcmQpLmVhY2goZnVuY3Rpb24oaW5kLCBlbCkge1xuICAgIFx0JChlbCkudmFsKCcnKS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICB9KTtcblxuICAgIC8vIFNldCB0aGUgZXhwaXJhdGlvbiBjaGVja2JveCB0byB0aGUgdmFsdWUgb2YgdGhlIHNlbGVjdCBtZW51cyBmb3IgYm90aCB0aGVcbiAgICAvLyBtb250aCBhbmQgeWVhciBmaWVsZHMgd2hpY2ggYXJlIGhpZGRlbi5cbiAgICAvLyBUaGUgaGlkZGVuIHNlbGVjdCBmaWVsZHMgYXJlIHBhcnQgb2YgdGhlIG9yaWdpbmFsLCBTR1ggYXJjaGl0ZWN0dXJlLlxuICAgIC8vIFRoZXJlZm9yZSwgdGhpcyBpcyBiZWluZyBpbXBsaW1lbnRlZCBhcyBhIGN1c3RpbWl6YXRpb24gZm9yIHRoZSBleHBpcmF0aW9uIGRhdGUgdGV4dCBib3guXG4gICAgdmFyIG1vbnRoVmFsdWUgPSAkbW9udGgudmFsKCkubGVuZ3RoID4gMSA/ICRtb250aC52YWwoKSA6IFwiMFwiICsgJG1vbnRoLnZhbCgpO1xuICAgIHZhciB5ZWFyVmFsdWUgPSAkeWVhci52YWwoKS5zdWJzdHIoMiwgMik7XG5cbiAgICAvLyBTZXQgdGhlIGV4cGlyYXRpb24gdGV4dCBib3ggdG8gdGhlIG1vbnRoIGFuZCBleHBpcmF0aW9uIGRhdGUgc2V0IHdpdGhpblxuICAgIC8vIHRoZSBoaWRkZW4gU0dYIHNlbGVjdCBmaWVsZHMuXG4gICAgLy8gQmx1ciB0aGlzIGZpZWxkIHNvIGl0IGlzIHZhbGlkYXRlZCBhcyB3ZWxsLlxuICAgICQoJyNkd2ZybV9iaWxsaW5nX3BheW1lbnRNZXRob2RzX2NyZWRpdENhcmRfZXhwaXJhdGlvbmRhdGUnKS52YWwobW9udGhWYWx1ZSArIFwiIC8gXCIgKyB5ZWFyVmFsdWUpLmJsdXIoKTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvbiBVcGRhdGVzIHRoZSBjcmVkaXQgY2FyZCBmb3JtIHdpdGggdGhlIGF0dHJpYnV0ZXMgb2YgYSBnaXZlbiBjYXJkXG4gKiBAcGFyYW0ge1N0cmluZ30gY2FyZElEIHRoZSBjcmVkaXQgY2FyZCBJRCBvZiBhIGdpdmVuIGNhcmRcbiAqL1xuZnVuY3Rpb24gcG9wdWxhdGVDcmVkaXRDYXJkRm9ybShjYXJkSUQpIHtcbiAgICAvLyBsb2FkIGNhcmQgZGV0YWlsc1xuICAgIHZhciB1cmwgPSB1dGlsLmFwcGVuZFBhcmFtVG9VUkwoVXJscy5iaWxsaW5nU2VsZWN0Q0MsICdjcmVkaXRDYXJkVVVJRCcsIGNhcmRJRCk7XG4gICAgYWpheC5nZXRKc29uKHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmFsZXJ0KFJlc291cmNlcy5DQ19MT0FEX0VSUk9SKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRDQ0ZpZWxkcyhkYXRhKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uIENoYW5nZXMgdGhlIHBheW1lbnQgbWV0aG9kIGZvcm0gZGVwZW5kaW5nIG9uIHRoZSBwYXNzZWQgcGF5bWVudE1ldGhvZElEXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF5bWVudE1ldGhvZElEIHRoZSBJRCBvZiB0aGUgcGF5bWVudCBtZXRob2QsIHRvIHdoaWNoIHRoZSBwYXltZW50IG1ldGhvZCBmb3JtIHNob3VsZCBiZSBjaGFuZ2VkIHRvXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVBheW1lbnRNZXRob2QocGF5bWVudE1ldGhvZElEKSB7XG4gICAgdmFyICRwYXltZW50TWV0aG9kcyA9ICQoJy5wYXltZW50LW1ldGhvZCcpLFxuICAgICAgICAkcGF5UGFsID0gJCgnLnBheW1lbnQtbWV0aG9kLW9wdGlvbnMnKS5maW5kKCcuUFknKSxcbiAgICAgICAgJGNyZWRpdENhcmQgPSAkKCcucGF5bWVudC1tZXRob2Qtb3B0aW9ucycpLmZpbmQoJy5DUkVESVRfQ0FSRCcpLFxuICAgICAgICBjb250aW51ZUJ1dHRvblRleHQgPSAkKCcuY2hlY2tvdXRidXR0b24gc3BhbicpO1xuXG4gICAgJHBheW1lbnRNZXRob2RzLnJlbW92ZUNsYXNzKCdwYXltZW50LW1ldGhvZC1leHBhbmRlZCcpO1xuXG4gICAgdmFyICRzZWxlY3RlZFBheW1lbnRNZXRob2QgPSAkcGF5bWVudE1ldGhvZHMuZmlsdGVyKCdbZGF0YS1tZXRob2Q9XCInICsgcGF5bWVudE1ldGhvZElEICsgJ1wiXScpO1xuICAgIGlmICgkc2VsZWN0ZWRQYXltZW50TWV0aG9kLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAkc2VsZWN0ZWRQYXltZW50TWV0aG9kID0gJCgnW2RhdGEtbWV0aG9kPVwiQ3VzdG9tXCJdJyk7XG4gICAgfVxuICAgICRzZWxlY3RlZFBheW1lbnRNZXRob2QuYWRkQ2xhc3MoJ3BheW1lbnQtbWV0aG9kLWV4cGFuZGVkJyk7XG5cbiAgICAvLyBlbnN1cmUgY2hlY2tib3ggb2YgcGF5bWVudCBtZXRob2QgaXMgY2hlY2tlZFxuICAgICQoJ2lucHV0W25hbWUkPVwiX3NlbGVjdGVkUGF5bWVudE1ldGhvZElEXCJdJykucmVtb3ZlQXR0cignY2hlY2tlZCcpO1xuICAgICQoJ2lucHV0W3ZhbHVlPScgKyBwYXltZW50TWV0aG9kSUQgKyAnXScpLnByb3AoJ2NoZWNrZWQnLCAnY2hlY2tlZCcpO1xuXG4gICAgLy8gQWRkIGEgY2xhc3Mgb2YgYWN0aXZlIGFyb3VuZCB0aGUgcGF5bWVudCBtZXRob2Qgd2hpY2ggd2FzIGp1c3RcbiAgICAvLyBzZWxlY3RlZCBieSB0aGUgdXNlci5cbiAgICAvLyBSZW1vdmUgdGhlIGNsYXNzIG9mIGFjdGl2ZSBmcm9tIHRoZSBwYXltZW50IG1ldGhvZCB3aGljaCB3YXMgbm90XG4gICAgLy8gc2VsZWN0ZWQgYnkgdGhlIHVzZXIuXG4gICAgc3dpdGNoKHBheW1lbnRNZXRob2RJRCkge1xuICAgIFx0Y2FzZSBcIlBZXCI6XG4gICAgXHRcdCRwYXlQYWwuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgIFx0XHQkY3JlZGl0Q2FyZC5yZW1vdmVDbGFzcygnYWN0aXZlJyk7ICAgIFx0XHRcbiAgICBcdFx0Y29udGludWVCdXR0b25UZXh0LnRleHQoUmVzb3VyY2VzLkNPTlRJTlVFX1BBWVBBTCk7XG4gICAgXHRcdGJyZWFrO1xuICAgIFx0ZGVmYXVsdDpcbiAgICBcdFx0JGNyZWRpdENhcmQudG9nZ2xlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgIFx0XHQkcGF5UGFsLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICBcdFx0Y29udGludWVCdXR0b25UZXh0LnRleHQoUmVzb3VyY2VzLlJFVklFV19PUkRFUik7XG4gICAgXHRcdGJyZWFrO1xuICAgIH1cblxuICAgIGZvcm1QcmVwYXJlLnZhbGlkYXRlRm9ybSgpO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uIFRoaXMgbWV0aG9kJ3MgbWFpbiBwdXJwb3NlIGlzIHRvIHN0b3AgdGhlIGZvcm0gcG9zdCBpZiBhbiBpbnZhbGlkIGFkZHJlc3MgaGFzIGJlZW4gZW50ZXJlZCwgYW5kIHBvcCB1cCB0aGUgXG4gKiAgICAgICAgICAgICAgQVZTIE1vZGFsLiBUaGUgQVZTIE1vZGFsIHdpbGwgYWxsb3cgdGhlIHVzZXIgdG8gbW9kaWZ5IHRoZWlyIGFkZHJlc3MuIFxuICogQHBhcmFtIHtTdHJpbmd9IHBheW1lbnRNZXRob2RJRCB0aGUgSUQgb2YgdGhlIHBheW1lbnQgbWV0aG9kLCB0byB3aGljaCB0aGUgcGF5bWVudCBtZXRob2QgZm9ybSBzaG91bGQgYmUgY2hhbmdlZCB0b1xuICovXG5mdW5jdGlvbiBiaWxsaW5nTG9hZCgpIHtcblxuXHRmdW5jdGlvbiBjRXJyb3IoKXtcblx0XHR2YXIgY291bnRyeUVycm9yID0gJCgnc2VsZWN0I2R3ZnJtX2JpbGxpbmdfYmlsbGluZ0FkZHJlc3NfYWRkcmVzc0ZpZWxkc19jb3VudHJ5JykuaGFzQ2xhc3MoJ2Vycm9yJyk7XG5cdFx0cmV0dXJuIGNvdW50cnlFcnJvcjtcblx0fVxuXG5cdGZ1bmN0aW9uIHNFcnJvcigpe1xuXHRcdHZhciBzdGF0ZUVycm9yID0gJCgnc2VsZWN0I2R3ZnJtX2JpbGxpbmdfYmlsbGluZ0FkZHJlc3NfYWRkcmVzc0ZpZWxkc19zdGF0ZXNfc3RhdGUnKS5oYXNDbGFzcygnZXJyb3InKTtcblx0XHRyZXR1cm4gc3RhdGVFcnJvcjtcblx0fVxuXG5cdGZ1bmN0aW9uIHByZVZhbGlkYXRlKCl7XG5cdFx0dmFyIHB2ID0gJGNoZWNrb3V0Rm9ybS52YWxpZGF0ZSgpLmZvcm0oKTtcblxuXHRcdGlmKGNFcnJvcigpKXtcblx0XHRcdCQoJ2RpdiNkd2ZybV9iaWxsaW5nX2JpbGxpbmdBZGRyZXNzX2FkZHJlc3NGaWVsZHNfY291bnRyeVNlbGVjdEJveEl0Q29udGFpbmVyJykuYWRkQ2xhc3MoJ2Vycm9yJyk7XG5cdFx0XHQkKFwic3Bhbltmb3I9J2R3ZnJtX2JpbGxpbmdfYmlsbGluZ0FkZHJlc3NfYWRkcmVzc0ZpZWxkc19jb3VudHJ5J11cIikuaW5zZXJ0QWZ0ZXIoJyNkd2ZybV9iaWxsaW5nX2JpbGxpbmdBZGRyZXNzX2FkZHJlc3NGaWVsZHNfY291bnRyeVNlbGVjdEJveEl0Q29udGFpbmVyJyk7XG5cblx0XHR9XG5cblx0XHRpZihzRXJyb3IoKSl7XG5cdFx0XHQkKCdkaXYjZHdmcm1fYmlsbGluZ19zaGlwcGluZ0FkZHJlc3NfYWRkcmVzc0ZpZWxkc19zdGF0ZXNfc3RhdGVTZWxlY3RCb3hJdENvbnRhaW5lcicpLmFkZENsYXNzKCdlcnJvcicpO1xuXHRcdFx0JChcInNwYW5bZm9yPSdkd2ZybV9iaWxsaW5nX2JpbGxpbmdfYWRkcmVzc0ZpZWxkc19zdGF0ZXNfc3RhdGUnXVwiKS5yZW1vdmUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcHY7XG5cdH1cblxuXHRmdW5jdGlvbiBiaWxsaW5nVmFsaWRhdGUoKSB7XG5cblx0XHRpZihwcmVWYWxpZGF0ZSgpKXtcblx0XHRcdHZhciB1cmwgPSAgVXJscy52ZXJpZnlBZGRyZXNzO1xuXHRcdFx0dmFyIGRhdGEgPSAkY2hlY2tvdXRGb3JtLmZpbmQoJ2ZpZWxkc2V0Om50aC1vZi10eXBlKDIpJykuc2VyaWFsaXplKCk7XG5cblx0XHRcdCRhdnNDb250YWluZXIuYXBwZW5kKFwiPGRpdiBpZD1cXFwibmV3QXZzRGl2XFxcIj48L2Rpdj5cIik7XG5cblx0XHRcdHZhciBvcHRpb25zID0ge1xuXHRcdFx0XHR3aWR0aDogNjAwLFxuXHRcdFx0XHRoZWlnaHQ6ICdhdXRvJyxcblx0XHRcdFx0dGl0bGU6Jydcblx0XHRcdH07XG5cblx0XHRcdGFqYXgubG9hZCh7XG5cdFx0XHRcdHVybDogdXJsLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHR0eXBlOlwiUE9TVFwiLFxuXHRcdFx0XHRjYWxsYmFjazogZnVuY3Rpb24gKHJlc3ApIHtcblx0XHRcdFx0XHRhcHAucHJvZ3Jlc3MuaGlkZSgkKHRoaXMpKTtcblx0XHRcdFx0XHRpZigkLnRyaW0ocmVzcCkgIT0gXCJ7fVwiKSB7XG5cdFx0XHRcdFx0XHQkKFwiI2F2c0RpdlwiKS5odG1sKCQoXCIjbmV3QXZzRGl2XCIpLmh0bWwoKSk7XG5cdFx0XHRcdCAgICAgICAgZGlhbG9nLm9wZW4oe1xuXHRcdFx0XHQgICAgICAgICAgICB1cmw6IHVybCxcblx0XHRcdFx0ICAgICAgICAgICAgdGFyZ2V0OiAkKFwiI25ld0F2c0RpdlwiKSxcblx0XHRcdFx0ICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuXHRcdFx0XHQgICAgICAgIH0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQkKCcjdmVyaWZ5QnRuJykuY2xpY2soKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRlbHNle1xuXHRcdFx0YXBwLnByb2dyZXNzLmhpZGUoJCh0aGlzKSk7XG5cdFx0fVxuXG5cdH1cblxuXHQvLyBFeGVjdXRlIG9uIGZvcm0gc3VibWlzc2lvbi5cblx0JCgnI2R3ZnJtX2JpbGxpbmcnKS5vbihcInN1Ym1pdFwiLGZ1bmN0aW9uKGUpIHtcblx0XHQvL2UucHJldmVudERlZmF1bHQoKTtcblx0XHQvL2lmICghJCh0aGlzKS52YWxpZCgpKSB7XG5cdFx0XHQvL3JldHVybjtcblx0XHQvL31cblx0XHQvL2JpbGxpbmdWYWxpZGF0ZSgpO1xuICAgICAgICB2YXIgJGNjRmllbGQgPSAkKFwiI2R3ZnJtX2JpbGxpbmdfcGF5bWVudE1ldGhvZHNfY3JlZGl0Q2FyZF9udW1iZXJcIik7XG5cdFx0dmFyIGNyZWRpdENhcmROdW1iZXIgPSAkY2NGaWVsZC52YWwoKSxcblx0XHRcdGNyZWRpdENhcmRUeXBlO1xuXHRcdGlmKCgkKCcjY3JlZGl0Q2FyZExpc3QnKS5sZW5ndGggPT0gMCB8fCAoJCgnI2NyZWRpdENhcmRMaXN0JykubGVuZ3RoID4gMCAmJiAkKCcjY3JlZGl0Q2FyZExpc3QnKS52YWwoKSA9PSAnJykpICYmIGNyZWRpdENhcmROdW1iZXIuaW5kZXhPZignKioqKicpID09IC0xKXtcblx0XHQvL2lmKCgoJCgnI2NyZWRpdENhcmRMaXN0JykubGVuZ3RoID4gMCAmJiAkKCcjY3JlZGl0Q2FyZExpc3QnKS52YWwoKSA9PSAnJykpICYmIGNyZWRpdENhcmROdW1iZXIuaW5kZXhPZignKioqKicpID09IC0xKXtcblx0ICAgICAgICAvLyBSZXBsYWNlIGFsbCBzcGFjZXMgd2l0aCBhbiBlbXB0eSBzdHJpbmdcblx0ICAgICAgICB2YXIgcHJvY2Vzc2VkID0gY3JlZGl0Q2FyZE51bWJlci5yZXBsYWNlKC8gL2csICcnKTtcblx0ICAgICAgICB2YXIgY2NGaWVsZFZhbCA9IHBhcnNlSW50KHByb2Nlc3NlZCwgMTApO1xuXHQgICAgICAgICRjY0ZpZWxkLnZhbChjY0ZpZWxkVmFsKTtcblx0XHR9XG5cblx0XHQvL3NldCBoaWRkZW4gY2FyZCB0eXBlIHNlbGVjdCBmaWVsZCBpZiBpdCdzIG5vdCBhbHJlYWR5IHNldDtcblx0XHQvL2lmIHRoZSBjcmVkaXQgY2FyZCBpcyBhIHNhdmVkIGNhcmQsIHRoZW4gd2UgY2FuJ3QgdmVyaWZ5IHRoZSBjYXJkIHR5cGUgZnJvbSB0aGUgY2FyZCBudW1iZXJcblx0XHQvL3NvIHdlIG11c3QgY2FsbCBvdXQgdG8gZ2V0IHRoZSB0eXBlXG5cdFx0aWYoY3JlZGl0Q2FyZE51bWJlci5pbmRleE9mKCcqKioqJykgIT0gLTEpe1xuXHRcdFx0dmFyIGNyZWRpdENhcmRVVUlEID0gJCgnI2NyZWRpdENhcmRMaXN0IDpzZWxlY3RlZCcpLnZhbCgpO1xuXHRcdFx0aWYoY3JlZGl0Q2FyZFVVSUQpe1xuXHRcdFx0XHR2YXIgdXJsID0gdXRpbC5hcHBlbmRQYXJhbVRvVVJMKFVybHMuYmlsbGluZ1NlbGVjdENDLCAnY3JlZGl0Q2FyZFVVSUQnLCBjcmVkaXRDYXJkVVVJRCk7XG5cdFx0XHQgICAgJC5hamF4KHtcblx0XHRcdCAgICAgICAgdXJsOiB1cmwsXG5cdFx0XHQgICAgICAgIHR5cGU6ICdHRVQnLFxuXHRcdFx0ICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRcdCAgICAgICAgICAgIGlmICghZGF0YSkge1xuXHRcdFx0ICAgICAgICAgICAgICAgIHdpbmRvdy5hbGVydChSZXNvdXJjZXMuQ0NfTE9BRF9FUlJPUik7XG5cdFx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdFx0ICAgICAgICAgICAgfVxuXHRcdFx0ICAgICAgICAgICAgY3JlZGl0Q2FyZFR5cGUgPSBkYXRhO1xuXHRcdFx0ICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhkYXRhKTtcblx0XHRcdCAgICAgICAgICAgIHNlbGVjdEhpZGRlbkNyZWRpdENhcmRPcHRpb24oJCgnI2R3ZnJtX2JpbGxpbmdfcGF5bWVudE1ldGhvZHNfY3JlZGl0Q2FyZF90eXBlJyksIGRhdGEudHlwZSk7XG5cdFx0XHQgICAgICAgIH1cblx0XHRcdCAgICB9KTtcblx0XHRcdH1cblx0XHR9ZWxzZXtcblx0XHRcdGNyZWRpdENhcmRUeXBlID0gZ2V0Q3JlZGl0Q2FyZFR5cGUoY3JlZGl0Q2FyZE51bWJlcik7XG5cdFx0XHRzZWxlY3RIaWRkZW5DcmVkaXRDYXJkT3B0aW9uKCQoJyNkd2ZybV9iaWxsaW5nX3BheW1lbnRNZXRob2RzX2NyZWRpdENhcmRfdHlwZScpLCBjcmVkaXRDYXJkVHlwZSk7XG5cdFx0fVxuXHR9KVxuXHQub24oJ2NoYW5nZScsICcuaW5wdXQtdGV4dC5waG9uZScsICB2YWxpZGF0b3IuZm9ybWF0dGVyLnBob25lKTtcblx0JCgnLmlucHV0LXRleHQucGhvbmUnKS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAvLyBWYWxpZGF0ZSBwaG9uZSBudW1iZXJcbiAgICAkKCcuaW5wdXQtdGV4dC5waG9uZScpLm9uKCdmb2N1cyBjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICQodGhpcykucGFyZW50KCkuYWRkQ2xhc3MoJ2ZvY3VzZWQnKTtcbiAgICB9KS5vbignYmx1cicsIGZ1bmN0aW9uKCl7XG4gICAgICAgICQodGhpcykucGFyZW50KCkucmVtb3ZlQ2xhc3MoJ2ZvY3VzZWQnKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gaW5pdEdpZnRDYXJkcygpIHtcbiAgICB2YXIgJGJpbGxpbmdGb3JtID0gJCgnZm9ybSNkd2ZybV9iaWxsaW5nJyk7XG4gICAgdmFyICRnY0FwcGx5ID0gJCgnI2djLWFwcGx5Jyk7XG4gICAgdmFyICRnY0NoZWNrQmFsYW5jZSA9ICQoJyNnYy1jaGVja2JhbGFuY2UnKTtcbiAgICB2YXIgJGdjQ29kZSA9ICRiaWxsaW5nRm9ybS5maW5kKFwiaW5wdXRbbmFtZSQ9J19naWZ0Q2VydENvZGUnXVwiKTtcbiAgICB2YXIgJGdjUGluID0gJGJpbGxpbmdGb3JtLmZpbmQoXCJpbnB1dFtuYW1lJD0nX2dpZnRDYXJkUGluJ11cIik7XG4gICAgdmFyICRiYWxhbmNlID0gJGJpbGxpbmdGb3JtLmZpbmQoJ2Rpdi5iYWxhbmNlJyk7XG5cbiAgICAkZ2NBcHBseS5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBlcnJvciA9ICRiYWxhbmNlLmZpbmQoJ3NwYW4uZXJyb3InKTtcbiAgICAgICAgaWYgKCEkZ2NDb2RlLnZhbCgpKSB7ICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZXJyb3IubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAkKCc8c3Bhbj4nKS5hZGRDbGFzcygnZXJyb3InKS5hcHBlbmRUbygkYmFsYW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvci5odG1sKFJlc291cmNlcy5HSUZUX0NFUlRfTlVNQkVSX01JU1NJTkcpO1xuICAgICAgICB9IGVsc2UgaWYgKCEkZ2NQaW4udmFsKCkpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICQoJzxzcGFuPicpLmFkZENsYXNzKCdlcnJvcicpLmFwcGVuZFRvKCRiYWxhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yLmh0bWwoUmVzb3VyY2VzLkdJRlRfQ0VSVF9QSU5fTUlTU0lORyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkKCcuanMtcGF5bWVudC1tZXRob2RzLWNvbnRhaW5lciBpbnB1dCwgLmpzLXBheW1lbnQtbWV0aG9kcy1jb250YWluZXIgc2VsZWN0JykucmVtb3ZlQ2xhc3MoJ3JlcXVpcmVkIGVycm9yJyk7XG4gICAgICAgICAgICAkKCcuanMtYmlsbGluZy1hZGRyZXNzLWNvbnRhaW5lciBpbnB1dCwgLmpzLWJpbGxpbmctYWRkcmVzcy1jb250YWluZXIgc2VsZWN0JykucmVtb3ZlQ2xhc3MoJ3JlcXVpcmVkIGVycm9yJyk7XG4gICAgICAgICAgICB2YXIgYWN0aW9uTmFtZSA9ICQodGhpcykuYXR0cignbmFtZScpO1xuICAgICAgICAgICAgJCgnI2Zha2UtZ2MtYXBwbHknKS5hdHRyKCduYW1lJywgYWN0aW9uTmFtZSkudmFsKCQodGhpcykudmFsKCkpO1xuXG4gICAgICAgICAgICBwcm9ncmVzcy5zaG93KCk7XG4gICAgICAgICAgICBnaWZ0Y2FyZC5jaGVja0JhbGFuY2UoJGdjQ29kZS52YWwoKSwgJGdjUGluLnZhbCgpLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgb3ZlcmxheVxuICAgICAgICAgICAgICAgIHByb2dyZXNzLmhpZGUoKTtcblxuICAgICAgICAgICAgICAgIGlmKCFkYXRhIHx8ICFkYXRhLmdpZnRDZXJ0aWZpY2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlcnJvclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkYmFsYW5jZS5maW5kKCdzcGFuLmVycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gJCgnPHNwYW4+JykuYWRkQ2xhc3MoJ2Vycm9yJykuYXBwZW5kVG8oJGJhbGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmh0bWwoUmVzb3VyY2VzLkdJRlRfQ0VSVF9JTlZBTElEKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1lbHNle1xuXHQgICAgICAgICAgICAgICAgLy8gYXBwbHkgdmFsaWQgZ2lmdENlcnRpZmljYXRlXG5cdCAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGRpc2FibGUgYWxsIGlucHV0IGZpZWxkcyBleGNlcHQgZ2lmdCBudWJtZXIgYW5kIHBpbiBpbiBvcmRlciB0byBwYXNzIHZhbGlkYXRpb24gZHVyaW5nIGZvcm0gc3VibWl0aW9uXG5cdCAgICAgICAgICAgICAgICAkYmlsbGluZ0Zvcm0uZmluZCgnaW5wdXQ6bm90KFtuYW1lJD1cIl9naWZ0Q2VydENvZGVcIl0sIFtuYW1lJD1cIl9naWZ0Q2FyZFBpblwiXSknKS5yZW1vdmVBdHRyKCdyZXF1aXJlZCcpO1xuXHQgICAgICAgICAgICAgICAgLy8kYmlsbGluZ0Zvcm0uZmluZCgnaW5wdXQ6bm90KFtuYW1lJD1cIl9naWZ0Q2VydENvZGVcIl0sIFtuYW1lJD1cIl9naWZ0Q2FyZFBpblwiXSksIC5mb3JtLXJvdycpLnJlbW92ZUF0dHIoJ3JlcXVpcmVkJykucmVtb3ZlQ2xhc3MoJy5yZXF1aXJlZCcpO1xuXHQgICAgICAgICAgICAgICAgLy9XZSBuZWVkIHRvIGRpc2FibGVkIGFsbCBvdGhlciBmaWVsZHMgaW4gb3JkZXIgbm90IHRvIHN1Ym1pdCBhbmQgc2tpcCB2YWxpZGF0aW9uXG5cdCAgICAgICAgICAgICAgICAkYmlsbGluZ0Zvcm0uZmluZCgnaW5wdXQ6bm90KFtuYW1lJD1cIl9naWZ0Q2VydENvZGVcIl0sIFtuYW1lJD1cIl9naWZ0Q2FyZFBpblwiXSwgI2Zha2UtZ2MtYXBwbHkpLCBzZWxlY3QnKS5hdHRyKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuXHQgICAgICAgICAgICAgICAgJGJpbGxpbmdGb3JtLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkZ2NDaGVja0JhbGFuY2Uub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgJGJhbGFuY2UudGV4dCgnJyk7XG4gICAgICAgIGlmICgkZ2NDb2RlLnZhbCgpLmxlbmd0aCA9PT0gMCB8fCAkZ2NDb2RlLnZhbCgpID09PSAnR2lmdCBDYXJkIE51bWJlcicpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9ICRiYWxhbmNlLmZpbmQoJ3NwYW4uZXJyb3InKTtcbiAgICAgICAgICAgIGlmIChlcnJvci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICQoJzxzcGFuPicpLmFkZENsYXNzKCdlcnJvcicpLmFwcGVuZFRvKCRiYWxhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yLmh0bWwoUmVzb3VyY2VzLkdJRlRfQ0VSVF9OVU1CRVJfTUlTU0lORyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJGdjUGluLnZhbCgpLmxlbmd0aCA9PT0gMCB8fCAkZ2NQaW4udmFsKCkgPT09ICdQSU4nKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSAkYmFsYW5jZS5maW5kKCdzcGFuLmVycm9yJyk7XG4gICAgICAgICAgICBpZiAoZXJyb3IubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAkKCc8c3Bhbj4nKS5hZGRDbGFzcygnZXJyb3InKS5hcHBlbmRUbygkYmFsYW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvci5odG1sKFJlc291cmNlcy5HSUZUX0NFUlRfUElOX01JU1NJTkcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvZ3Jlc3Muc2hvdygpO1xuICAgICAgICBnaWZ0Y2FyZC5jaGVja0JhbGFuY2UoJGdjQ29kZS52YWwoKSwgJGdjUGluLnZhbCgpLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBwcm9ncmVzcyBvdmVybGF5XG4gICAgICAgICAgICBwcm9ncmVzcy5oaWRlKCk7XG5cbiAgICAgICAgICAgIGlmKCFkYXRhIHx8ICFkYXRhLmdpZnRDZXJ0aWZpY2F0ZSkge1xuICAgICAgICAgICAgICAgIC8vIGVycm9yXG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJGJhbGFuY2UuZmluZCgnc3Bhbi5lcnJvcicpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSAkKCc8c3Bhbj4nKS5hZGRDbGFzcygnZXJyb3InKS5hcHBlbmRUbygkYmFsYW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVycm9yLmh0bWwoUmVzb3VyY2VzLkdJRlRfQ0VSVF9JTlZBTElEKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkaXNwbGF5IGRldGFpbHMgaW4gVUlcbiAgICAgICAgICAgICRiYWxhbmNlLmZpbmQoJ3NwYW4uZXJyb3InKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIHZhciBiYWxhbmNlID0gZGF0YS5naWZ0Q2VydGlmaWNhdGUuYmFsYW5jZTtcbiAgICAgICAgICAgIHZhciBiYWxhbmNlTXNnID0gUmVzb3VyY2VzLkdJRlRfQ0VSVF9CQUxBTkNFICsgJyAnICsgYmFsYW5jZTtcbiAgICAgICAgICAgICRiYWxhbmNlLmh0bWwoYmFsYW5jZU1zZyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG5cbiAgICAkKCcuZ2NyZWRlbXB0aW9uJykub24oJ2NsaWNrJywgJ2EuZ2NyZW1vdmUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIGdjSWQgPSBhcHAudXRpbC50cmltUHJlZml4KCQodGhpcykuYXR0cignaWQnKSwgJ3JnYy0nKTtcbiAgICAgICAgcmVtb3ZlR2lmdENlcnRpZmljYXRlKGdjSWQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICAkKFskZ2NDb2RlWzBdLCAkZ2NQaW5bMF1dKS5vbigna2V5dXAgY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhbGlkYXRlR0NGaWVsZHMoKVxuICAgIH0pO1xuXG4gICAgdmFsaWRhdGVHQ0ZpZWxkcygpO1xuXG4gICAgZnVuY3Rpb24gcmVtb3ZlR2lmdENlcnRpZmljYXRlKGdpZnRDZXJ0aWZpY2F0ZUlkKSB7XG4gICAgICAgICRiYWxhbmNlLmVtcHR5KCk7XG4gICAgICAgIHNldEdpZnRDYXJkRXJyb3IobnVsbCk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGdpZnQgY2VydGlmaWNhdGVcbiAgICAgICAgdmFyIHVybCA9IFVybHMucmVtb3ZlR2lmdENlcnRpZmljYXRlO1xuICAgICAgICB1cmwgPSBhcHAudXRpbC5hcHBlbmRQYXJhbVRvVVJMKHVybCwgJ2dpZnRDZXJ0aWZpY2F0ZUlEJywgZ2lmdENlcnRpZmljYXRlSWQpO1xuICAgICAgICBhcHAuYWpheC5nZXRKc29uKHtcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZighZGF0YSB8fCAhZGF0YS5naWZ0Q2VydGlmaWNhdGUgfHwgIWRhdGEuZ2lmdENlcnRpZmljYXRlLnJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0R2lmdENlcnRFcnJvcihhcHAucmVzb3VyY2VzLkNBTlRSRU1PVkVHSUZUQ0FSRCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbmVlZHJlZGlyZWN0ID0gJCgnLmpzLWdpZnQtY2VydC11c2VkJykubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICBpZiAobmVlZHJlZGlyZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2UucmVkaXJlY3QoVXJscy5iaWxsaW5nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkKFwiI2djLVwiK2dpZnRDZXJ0aWZpY2F0ZUlkKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgc2hpcHBpbmcudXBkYXRlU3VtbWFyeSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0R2lmdENhcmRFcnJvcihtc2cpIHtcbiAgICAgICAgdmFyIGVycm9yID0gJGJhbGFuY2UuZmluZCgnc3Bhbi5lcnJvcicpO1xuICAgICAgICBpZiAoZXJyb3IubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBlcnJvciA9ICQoJzxzcGFuPicpLmFkZENsYXNzKCdlcnJvcicpLmFwcGVuZFRvKCRiYWxhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFtc2cpIHtcbiAgICAgICAgICAgIGVycm9yLmVtcHR5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvci5odG1sKG1zZylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlR0NGaWVsZHMoKSB7XG4gICAgICAgIHZhciBpc1ZhbGlkRmllbGRzID0gKCRnY0NvZGUudmFsKCkgIT09IHVuZGVmaW5lZCAmJiAkZ2NDb2RlLnZhbCgpLnRyaW0oKSAhPT0gJydcbiAgICAgICAgICAgICYmICRnY1Bpbi52YWwoKSAhPT0gdW5kZWZpbmVkICYmICRnY1Bpbi52YWwoKS50cmltKCkgIT09ICcnKTtcbiAgICAgICAgJGdjQXBwbHkucHJvcCgnZGlzYWJsZWQnLCAhaXNWYWxpZEZpZWxkcyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uIGxvYWRzIGJpbGxpbmcgYWRkcmVzcywgR2lmdCBDZXJ0aWZpY2F0ZXMsIENvdXBvbiBhbmQgUGF5bWVudCBtZXRob2RzXG4gKi9cbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJGFkZENvdXBvbiA9ICQoJyNhZGQtY291cG9uJyk7XG4gICAgdmFyICRjb3Vwb25Db2RlID0gJCgnaW5wdXRbbmFtZSQ9XCJfY291cG9uQ29kZVwiXScpO1xuICAgIHZhciAkZ2lmdE9yUHJvbW9DaGVja0JveCA9ICQoJyNkd2ZybV9iaWxsaW5nX3VzZWdpZnRvcnByb21vJyk7XG4gICAgdmFyICRnaWZ0T3JQcm9tb1NlY3Rpb24gPSAkKCcuYmlsbGluZy1jb3Vwb24tY29kZScpO1xuICAgIHZhciAkc2VsZWN0UGF5bWVudE1ldGhvZCA9ICQoJy5wYXltZW50LW1ldGhvZC1vcHRpb25zJyk7XG4gICAgdmFyIHNlbGVjdGVkUGF5bWVudE1ldGhvZCA9ICRzZWxlY3RQYXltZW50TWV0aG9kLmZpbmQoJzpjaGVja2VkJykudmFsKCk7XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgLypcdFx0XHRcdFx0XHRcdFx0XHRcdEdJRlQgQ0FSRCBBTkQgUFJPTU8gSEFORExJTkdcdFx0XHRcdFx0XHRcdFx0ICovXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgXHQvLyBTaG93IGFuZC9vciBoaWRlIHRoZSBHaWZ0IENhcmQgUHJvbW90aW9uYWwgc2VjdGlvblxuICAgIFx0Ly8gd2hlbiBhIHVzZXIgc2VsZWN0cyB0aGUgZ2lmdCBjYXJkIHByb21vIGNoZWNrYm94LlxuICAgIFx0JGdpZnRPclByb21vQ2hlY2tCb3gub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICBcdFx0JGdpZnRPclByb21vU2VjdGlvbi50b2dnbGUoKTtcbiAgICBcdH0pO1xuICAgIFx0aWYgKCRnaWZ0T3JQcm9tb0NoZWNrQm94LnByb3AoJ2NoZWNrZWQnKSkge1xuICAgIFx0ICAgICRnaWZ0T3JQcm9tb1NlY3Rpb24uc2hvdygpO1xuICAgIFx0fVxuICAgIFx0XG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIC8qXHRcdFx0XHRcdFx0XHRcdFx0XHRDUkVESVQgQ0FSRCBIQU5ETElORyBcdFx0XHRcdFx0XHRcdFx0XHRcdCAqL1xuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgIFxuXHQgICAgdmFyIGNyZWRpdENhcmROdW1iZXIgPSBcIlwiO1xuXHRcdHZhciAkdGV4dEJveCA9ICQoXCIjZHdmcm1fYmlsbGluZ19wYXltZW50TWV0aG9kc19jcmVkaXRDYXJkX251bWJlclwiKTtcblx0XHR2YXIgJHNlbGVjdEZpZWxkID0gJCgnI2R3ZnJtX2JpbGxpbmdfcGF5bWVudE1ldGhvZHNfY3JlZGl0Q2FyZF90eXBlJyk7XG5cdFx0dmFyICR0ZXh0Qm94RXhwaXJhdGlvbkRhdGUgPSAkKFwiI2R3ZnJtX2JpbGxpbmdfcGF5bWVudE1ldGhvZHNfY3JlZGl0Q2FyZF9leHBpcmF0aW9uZGF0ZVwiKTtcblx0XHR2YXIgJHRleHRCb3hDdm4gPSAkKCdpbnB1dFtpZCo9XCJfY3JlZGl0Q2FyZF9jdm5cIl0nKTtcblx0XHR2YXIgJHNlbGVjdEZpZWxkTW9udGggPSAkKFwiI2R3ZnJtX2JpbGxpbmdfcGF5bWVudE1ldGhvZHNfY3JlZGl0Q2FyZF9tb250aFwiKTtcblx0XHR2YXIgJHNlbGVjdEZpZWxkWWVhciA9ICQoXCIjZHdmcm1fYmlsbGluZ19wYXltZW50TWV0aG9kc19jcmVkaXRDYXJkX3llYXJcIik7XG5cblx0ICAgICR0ZXh0Qm94Q3ZuLm9uKCdrZXl1cCBjaGFuZ2UnLCBmdW5jdGlvbigpe1xuXHQgICAgICAgICQodGhpcykudmFsKCQodGhpcykudmFsKCkucmVwbGFjZSgvW14wLTldL2csICcnKSk7XG5cdCAgICB9KTtcblxuXHRcdC8vIE9ubHkgYWxsb3cgaW50ZWdlcnMgb24gdGhlIGNyZWRpdCBjYXJkIG51bWJlciBcblx0XHQvLyB0ZXh0IGJveCBmaWVsZC4gXG5cdFx0YWxsb3dPbmx5SW50ZWdlcnNPbigkdGV4dEJveCk7XG5cblx0XHQvLyBLZXkgVXAgRXZlbnQgZm9yIHRoZSBDcmVkaXQgQ2FyZCBOdW1iZXIgVGV4dCBCb3ggRmllbGRcblx0XHQkdGV4dEJveC5rZXl1cChmdW5jdGlvbiAoZSkge1xuXHRcdFx0JCgnI2NyZWRpdENhcmRMaXN0JykudmFsKCcnKTtcblx0XHRcdHZhciBjcmVkaXRDYXJkTnVtYmVyID0gZ2V0Q3JlZGl0Q2FyZE51bWJlcigkdGV4dEJveCk7XG5cdFx0XHR2YXIgY3JlZGl0Q2FyZFR5cGUgPSBnZXRDcmVkaXRDYXJkVHlwZShjcmVkaXRDYXJkTnVtYmVyKTtcblx0XHRcdHNlbGVjdEhpZGRlbkNyZWRpdENhcmRPcHRpb24oJHNlbGVjdEZpZWxkLCBjcmVkaXRDYXJkVHlwZSk7XG4gICAgICAgICAgICB2YXIgY3JlZGl0TG9nbyA9ICQoJy5wYXltZW50LW1ldGhvZC1pbWFnZS1jcmVkaXQtY2FyZCcpO1xuICAgICAgICAgICAgY3JlZGl0TG9nby5jaGlsZHJlbignZGl2JykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgaWYgKGNyZWRpdENhcmRUeXBlKSB7XG4gICAgICAgICAgICAgICAgY3JlZGl0TG9nby5jaGlsZHJlbignLicrY3JlZGl0Q2FyZFR5cGUudG9Mb3dlckNhc2UoKSsnJykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHRleHRCb3gubWFzayhcIjAwMDAgIDAwMDAgIDAwMDAgIDAwMDBcIiwgeyB3YXRjaElucHV0czogdHJ1ZSB9KTtcbiAgICAgICAgICAgIC8vc2V0TWFza0NyZWRpdENhcmROdW1iZXIoJHRleHRCb3gpO1xuXG5cdFx0fSk7XG5cblx0XHQvLyBPbmx5IGFsbG93IGludGVnZXJzIG9uIHRoZSBjcmVkaXQgY2FyZCBleHBpcmF0aW9uXG5cdFx0Ly8gdGV4dCBib3ggZmllbGQuXG5cdFx0YWxsb3dPbmx5SW50ZWdlcnNPbigkdGV4dEJveEV4cGlyYXRpb25EYXRlKTtcblx0XHRcblx0XHQvLyBLZXkgVXAgRXZlbnQgZm9yIHRoZSBDcmVkaXQgQ2FyZCdzIEV4cGlyYXRpb24gRGF0ZVxuXHRcdCR0ZXh0Qm94RXhwaXJhdGlvbkRhdGUua2V5dXAoZnVuY3Rpb24gKGUpIHtcblx0XHRcdHZhciAkdGhpcyA9ICQodGhpcyk7XG5cdFx0XHR2YXIgbW9udGggPSBnZXRNb250aCgkdGhpcyk7XG5cdFx0XHR2YXIgeWVhciA9IGdldFllYXIoJHRoaXMpO1xuXG5cdFx0XHRzZWxlY3RIaWRkZW5DcmVkaXRDYXJkTW9udGgoJHNlbGVjdEZpZWxkTW9udGgsIG1vbnRoKTtcblx0XHRcdHNlbGVjdEhpZGRlbkNyZWRpdENhcmRZZWFyKCRzZWxlY3RGaWVsZFllYXIsIHllYXIpO1xuXHRcdH0pO1xuXHRcdFxuXHRcdC8vZm9ybWF0IGlucHV0IGZpZWxkIHRvIGNvcnJlY3QgZGF0YSBpZiB3ZSBhbHJlYWR5IGhhdmUgaXQgZnJvbSBzYXZlZCBDQ1xuXHRcdGlmICgkLnRyaW0oJHRleHRCb3hFeHBpcmF0aW9uRGF0ZS52YWwoKSkgIT0gJycpIHtcblx0XHQgICAgdmFyIGV4cGlyYXRpb25QYXJ0cyA9ICQudHJpbSgkdGV4dEJveEV4cGlyYXRpb25EYXRlLnZhbCgpKS5zcGxpdCgnLycpO1xuXHRcdCAgICBpZiAoZXhwaXJhdGlvblBhcnRzLmxlbmd0aCA9PSAyKSB7XG5cdFx0ICAgICAgICB2YXIgbW9udGhWYWx1ZSA9ICQudHJpbShleHBpcmF0aW9uUGFydHNbMF0pO1xuXHRcdCAgICAgICAgaWYgKG1vbnRoVmFsdWUubGVuZ3RoID09IDEpIHtcblx0XHQgICAgICAgICAgICBtb250aFZhbHVlID0gJzAnICsgbW9udGhWYWx1ZTtcblx0XHQgICAgICAgICAgICAkdGV4dEJveEV4cGlyYXRpb25EYXRlLnZhbChtb250aFZhbHVlICsgJyAvICcgKyBleHBpcmF0aW9uUGFydHNbMV0pO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0fVxuXG5cdFx0Ly8gTWFzayB0aGUgQ3JlZGl0IENhcmQncyBFeHBpcmF0aW9uIERhdGVcblx0XHQkdGV4dEJveEV4cGlyYXRpb25EYXRlLm1hc2soXCIwMCAvIDAwXCIsIHtwbGFjZWhvbGRlcjogXCJNTSAvIFlZXCIsIHdhdGNoSW5wdXRzOiB0cnVlIH0pO1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHQvL0l0IGlzIHJlcXVpcmVkIHRvIGNhbGwgdGhpcyBtZXRob2QgYmVmb3JlIGZvcm1QcmVwYXJlIGluIG9yZGVyIHRvIHNob3cgQ0MgZGVmYXVsdCBmaWVsZHNcblx0Ly8gZGVmYXVsdCBwYXltZW50IG1ldGhvZCB0byAnQ1JFRElUX0NBUkQnXG5cdHVwZGF0ZVBheW1lbnRNZXRob2QoKHNlbGVjdGVkUGF5bWVudE1ldGhvZCkgPyBzZWxlY3RlZFBheW1lbnRNZXRob2QgOiAnQ1JFRElUX0NBUkQnKTtcblx0XG4gICAgZm9ybVByZXBhcmUuaW5pdCh7XG4gICAgICAgIGZvcm1TZWxlY3RvcjogJ2Zvcm1baWQkPVwiYmlsbGluZ1wiXScsXG4gICAgICAgIGNvbnRpbnVlU2VsZWN0b3I6ICdbbmFtZSQ9XCJiaWxsaW5nX3NhdmVcIl0nXG4gICAgfSk7XG5cbiAgICBiaWxsaW5nTG9hZCgpO1xuICAgIGluaXRHaWZ0Q2FyZHMoKTtcblxuICAgIHZhciAkZm9ybSA9ICQoJ2Zvcm1baWQkPVwiYmlsbGluZ1wiXScpO1xuICAgIHV0aWwuaW5pdFppcFNlcnZpY2UoJGZvcm0pO1xuICAgIHZhciAkc3RhdGVFbXB0eU9wdGlvbkVsID0gJGZvcm0uZmluZCgnLnN0YXRlLWZpZWxkLWNvbnRhaW5lciBzZWxlY3Qgb3B0aW9uOmZpcnN0LWNoaWxkJyk7XG4gICAgdmFyIHN0YXRlRW1wdHlPcHRpb25IdG1sID0gJCgnPGRpdj4nKS5hcHBlbmQoJHN0YXRlRW1wdHlPcHRpb25FbC5jbG9uZSgpKVxuICAgICAgICAuaHRtbCgpO1xuICAgICRmb3JtLm9uKCdjaGFuZ2UnLCAnc2VsZWN0LmNvdW50cnknLCBmdW5jdGlvbigpIHtcbiAgICBcdHZhciB2YWx1ZSA9ICQodGhpcykudmFsKCkudG9Mb3dlckNhc2UoKTtcblxuICAgIFx0aWYgKHZhbHVlID09ICd1cycgfHwgdmFsdWUgPT0gJ2NhJykge1xuICAgIFx0XHQkKCdzZWxlY3RbbmFtZSQ9XCJfc3RhdGVcIl0nKS5hZGRDbGFzcygncmVxdWlyZWQnKS5wYXJlbnQoKS5hZGRDbGFzcygncmVxdWlyZWQnKTtcbiAgICBcdH0gZWxzZSB7XG4gICAgXHRcdCQoJ3NlbGVjdFtuYW1lJD1cIl9zdGF0ZVwiXScpLnJlbW92ZUNsYXNzKCdyZXF1aXJlZCcpLnBhcmVudCgpLnJlbW92ZUNsYXNzKCdyZXF1aXJlZCcpO1xuICAgIFx0fVxuXG4gICAgICAgIHV0aWwuY2hhbmdlU3RhdGVGaWVsZCgkKHRoaXMpLnZhbCgpLCAkZm9ybSwgc3RhdGVFbXB0eU9wdGlvbkh0bWwpO1xuICAgICAgICBwb3B1bGF0ZVN0YXRlVGV4dEJveCgpOyBcbiAgICB9KTtcbiAgICAkZm9ybS5maW5kKCdzZWxlY3QuY291bnRyeScpLnRyaWdnZXIoJ2NoYW5nZScpO1xuXG4gICAgJHNlbGVjdFBheW1lbnRNZXRob2Qub24oJ2NsaWNrJywgJ2lucHV0W3R5cGU9XCJyYWRpb1wiXScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXBkYXRlUGF5bWVudE1ldGhvZCgkKHRoaXMpLnZhbCgpKTtcbiAgICB9KTtcblxuICAgIC8vIHNlbGVjdCBjcmVkaXQgY2FyZCBmcm9tIGxpc3RcbiAgICAkKCcjY3JlZGl0Q2FyZExpc3QnKS5vbignY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FyZFVVSUQgPSAkKHRoaXMpLnZhbCgpO1xuICAgICAgICBpZiAoIWNhcmRVVUlEKSB7cmV0dXJuO31cbiAgICAgICAgcG9wdWxhdGVDcmVkaXRDYXJkRm9ybShjYXJkVVVJRCk7IFxuICAgIH0pO1xuICAgIFxuICAgICRhZGRDb3Vwb24ub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgJGVycm9yID0gJGNoZWNrb3V0Rm9ybS5maW5kKCcuY291cG9uLWVycm9yJyksXG4gICAgICAgICAgICBjb2RlID0gJGNvdXBvbkNvZGUudmFsKCk7XG4gICAgICAgIGlmIChjb2RlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgJGVycm9yLmh0bWwoUmVzb3VyY2VzLkNPVVBPTl9DT0RFX01JU1NJTkcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgIHtcbiAgICAgICAgXHQkZXJyb3IuaHRtbCgnJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXJsID0gdXRpbC5hcHBlbmRQYXJhbXNUb1VybChVcmxzLmFkZENvdXBvbiwge2NvdXBvbkNvZGU6IGNvZGUsIGZvcm1hdDogJ2FqYXgnfSk7XG4gICAgICAgICQuZ2V0SlNPTih1cmwsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgZmFpbCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIG1zZyA9ICcnO1xuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgbXNnID0gUmVzb3VyY2VzLkJBRF9SRVNQT05TRTtcbiAgICAgICAgICAgICAgICBmYWlsID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIG1zZyA9IGRhdGEubWVzc2FnZS5zcGxpdCgnPCcpLmpvaW4oJyZsdDsnKS5zcGxpdCgnPicpLmpvaW4oJyZndDsnKTtcbiAgICAgICAgICAgICAgICBmYWlsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmYWlsKSB7XG4gICAgICAgICAgICAgICAgJGVycm9yLmh0bWwobXNnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgICAgXHRzaGlwcGluZy51cGRhdGVTdW1tYXJ5KCk7XG4gICAgICAgICAgICBcdHZhciAkZGl2ID0gJCgnZGl2LmNvdXBvbjpsYXN0Jyk7XG4gICAgICAgICAgICBcdHZhciAka2xvbiA9ICRkaXYuY2xvbmUoKTtcbiAgICAgICAgICAgIFx0XG4gICAgICAgICAgICBcdGlmKCRrbG9uLmhhc0NsYXNzKCdmaXJzdCcpKSB7XG4gICAgICAgICAgICBcdFx0JGtsb24ucmVtb3ZlQ2xhc3MoJ2ZpcnN0Jyk7XG4gICAgICAgICAgICBcdH1cbiAgICAgICAgICAgIFx0XG4gICAgICAgICAgICBcdCRkaXYuYWZ0ZXIoJGtsb24pO1xuICAgICAgICAgICAgXHQka2xvbi5maW5kKCcubWVzc2FnZScpLmh0bWwoJzxzcGFuIGNsYXNzPVwidmFsdWVcIj4nICsgZGF0YS5jb3Vwb25Db2RlICsgJzwvc3Bhbj4gJyArXG5cdFx0ICAgICAgICAgICAgUmVzb3VyY2VzLkNPVVBPTl9DT0RFX1NVQ0NFU1MpO1xuICAgICAgICAgICAgXHRcbiAgICAgICAgICAgIFx0aWYgKGRhdGEuYXBwbGllZCkge1xuICAgICAgICAgICAgXHRcdCRrbG9uLmZpbmQoJy5zdGF0dXMubm90LWFwcGxpZWQnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIFx0fSBlbHNlIHtcbiAgICAgICAgICAgIFx0XHQka2xvbi5maW5kKCcuc3RhdHVzLmFwcGxpZWQnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIFx0fVxuICAgICAgICAgICAgXHQkY291cG9uQ29kZS52YWwoJycpO1xuICAgICAgICAgICAgXHRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9iYXNrZXQgY2hlY2sgZm9yIGRpc3BsYXlpbmcgdGhlIHBheW1lbnQgc2VjdGlvbiwgaWYgdGhlIGFkanVzdGVkIHRvdGFsIG9mIHRoZSBiYXNrZXQgaXMgMCBhZnRlciBhcHBseWluZyB0aGUgY291cG9uXG4gICAgICAgICAgICAvL3RoaXMgd2lsbCBmb3JjZSBhIHBhZ2UgcmVmcmVzaCB0byBkaXNwbGF5IHRoZSBjb3Vwb24gbWVzc2FnZSBiYXNlZCBvbiBhIHBhcmFtZXRlciBtZXNzYWdlXG4gICAgICAgICAgICBpZiAoZGF0YS5zdWNjZXNzICYmIGRhdGEuYmFza2V0dG90YWwgPT09IDApIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKFVybHMuYmlsbGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIFxuICAgICQoZG9jdW1lbnQpLm9uKCdjbGljaycsICcuZGVsZXRlLWNvdXBvbicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyICRidXR0b24gPSAkKHRoaXMpO1xuICAgICAgICB2YXIgJGVycm9yID0gJGNoZWNrb3V0Rm9ybS5maW5kKCcuY291cG9uLWVycm9yJyksXG4gICAgICAgICAgICBjb2RlID0gJGJ1dHRvbi5wYXJlbnQoKS5wYXJlbnQoKS5maW5kKCcudmFsdWUnKS50ZXh0KCk7XG4gICAgICAgIGlmIChjb2RlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgJGVycm9yLmh0bWwoUmVzb3VyY2VzLkNPVVBPTl9DT0RFX01JU1NJTkcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgIHsgJGVycm9yLmh0bWwoJycpOyB9XG5cbiAgICAgICAgdmFyIHVybCA9IHV0aWwuYXBwZW5kUGFyYW1zVG9VcmwoVXJscy5kZWxldGVDb3Vwb24sIHtjb3Vwb25Db2RlOiBjb2RlLCBmb3JtYXQ6ICdhamF4J30pO1xuICAgICAgICAkLmdldEpTT04odXJsLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGZhaWwgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBtc2cgPSAnJztcbiAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgIG1zZyA9IFJlc291cmNlcy5CQURfUkVTUE9OU0U7XG4gICAgICAgICAgICAgICAgZmFpbCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICBtc2cgPSBkYXRhLmVycm9yLnNwbGl0KCc8Jykuam9pbignJmx0OycpLnNwbGl0KCc+Jykuam9pbignJmd0OycpO1xuICAgICAgICAgICAgICAgIGZhaWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZhaWwpIHtcbiAgICAgICAgICAgICAgICAkZXJyb3IuaHRtbChtc2cpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgICBcdHNoaXBwaW5nLnVwZGF0ZVN1bW1hcnkoKTtcbiAgICAgICAgICAgIFx0JGJ1dHRvbi5jbG9zZXN0KCcucmVkZW1wdGlvbi5jb3Vwb24uZm9ybS1yb3cnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgXG5cbiAgICAvLyB0cmlnZ2VyIGV2ZW50cyBvbiBlbnRlclxuICAgICRjb3Vwb25Db2RlLm9uKCdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUud2hpY2ggPT09IDEzKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAkYWRkQ291cG9uLmNsaWNrKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICRjb3Vwb25Db2RlLm9uKCdrZXl1cCBjaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFsaWRhdGVDb3Vwb25GaWVsZCgpO1xuICAgIH0pO1xuXG4gICAgdmFsaWRhdGVDb3Vwb25GaWVsZCgpO1xuICAgIEhhbmRsZUNyZWRpdENhcmRWYWxpZGF0aW9uT25QYWdlTG9hZCgpO1xuICAgIFxuICAgICQoJy5jb3VudHJ5LXJvdycpLmFkZENsYXNzKFwiaGFzLWZsb2F0LWxhYmVsXCIpO1xuICAgICQoJy5zdGF0ZS1yb3cnKS5hZGRDbGFzcyhcImhhcy1mbG9hdC1sYWJlbFwiKTtcbiAgICBpZiAoJCgnLnNlbGVjdC1hZGRyZXNzJykubGVuZ3RoID4gMCkge1xuICAgICAgICAkKCcuc2VsZWN0LWFkZHJlc3MnKS5hZGRDbGFzcygnaGFzLWZsb2F0LWxhYmVsJyk7XG4gICAgICAgICQoJy5zZWxlY3QtYWRkcmVzcyBzZWxlY3QnKS5vbignY2hhbmdlIGJsdXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghJCh0aGlzKS52YWwoKSkge1xuICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoJ3ZhbGlkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVDb3Vwb25GaWVsZCgpIHtcbiAgICAgICAgdmFyIGlzVmFsaWRGaWVsZCA9ICgkY291cG9uQ29kZS52YWwoKSAhPT0gdW5kZWZpbmVkICYmICRjb3Vwb25Db2RlLnZhbCgpLnRyaW0oKSAhPT0gJycpO1xuICAgICAgICAkYWRkQ291cG9uLnByb3AoJ2Rpc2FibGVkJywgIWlzVmFsaWRGaWVsZCk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBzdGlja3lDYXJ0ID0gcmVxdWlyZSgnLi4vLi4vc3RpY2t5Y2FydCcpO1xuXG52YXIgJGZvcm0sICRjb250aW51ZSwgJHJlcXVpcmVkSW5wdXRzLCB2YWxpZGF0b3I7XG5cbnZhciBoYXNFbXB0eVJlcXVpcmVkID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGZpbHRlciBvdXQgb25seSB0aGUgdmlzaWJsZSBmaWVsZHNcbiAgICB2YXIgcmVxdWlyZWRWYWx1ZXMgPSAkcmVxdWlyZWRJbnB1dHMuZmlsdGVyKCc6dmlzaWJsZScpLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAkKHRoaXMpLnZhbCgpO1xuICAgIH0pO1xuICAgIHJldHVybiBfKHJlcXVpcmVkVmFsdWVzKS5jb250YWlucygnJyk7XG59O1xuXG52YXIgdmFsaWRhdGVGb3JtID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIG9ubHkgdmFsaWRhdGUgZm9ybSB3aGVuIGFsbCByZXF1aXJlZCBmaWVsZHMgYXJlIGZpbGxlZCB0byBhdm9pZFxuICAgIC8vIHRocm93aW5nIGVycm9ycyBvbiBlbXB0eSBmb3JtXG4gICAgaWYgKCF2YWxpZGF0b3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWhhc0VtcHR5UmVxdWlyZWQoKSAmJiAhaGFzU2hpcHBpbmdNZXRob2RFcnJvcigpKSB7XG4gICAgICAgIGlmICh2YWxpZGF0b3IuZm9ybSgpKSB7XG4gICAgICAgICAgICAkY29udGludWUucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgICRjb250aW51ZS5hdHRyKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgIH1cbn07XG5cbnZhciB2YWxpZGF0ZUVsID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChoYXNTaGlwcGluZ01ldGhvZEVycm9yKCkgfHwgKCQodGhpcykudmFsKCkgPT09ICcnICYmICQodGhpcykuYXR0cignbmFtZScpLnNlYXJjaCgnX3N0YXRlJykgPCAwKSkge1xuICAgICAgICAkY29udGludWUuYXR0cignZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlbmFibGUgY29udGludWUgYnV0dG9uIG9uIGxhc3QgcmVxdWlyZWQgZmllbGQgdGhhdCBpcyB2YWxpZFxuICAgICAgICAvLyBvbmx5IHZhbGlkYXRlIHNpbmdsZSBmaWVsZFxuICAgICAgICBpZiAodmFsaWRhdG9yLmVsZW1lbnQodGhpcykgJiYgKCFoYXNFbXB0eVJlcXVpcmVkKCkgfHwgKCQodGhpcykuYXR0cignbmFtZScpLnNlYXJjaCgnX3N0YXRlJykgPiAwICYmICEkKHRoaXMpLmhhc0NsYXNzKCdyZXF1aXJlZCcpKSkpIHtcbiAgICAgICAgICAgICRjb250aW51ZS5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGNvbnRpbnVlLmF0dHIoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgYXJlIG9uIHRoZSBzaGlwcGluZyBzdGVwIFxuICogYW5kIHdlIGRvbid0IGhhdmUgYW55IHNoaXBwaW5nIG1ldGhvZCBlcnJvciBtZXNzYWdlcyBcbiAqIHRoYXQgZG9lc24ndCBhbGxvdyB0byBzaGlwIG9yZGVyXG4gKi9cbnZhciBoYXNTaGlwcGluZ01ldGhvZEVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkc2hpcHBpbmdNZXRob2RMaXN0ID0gJCgnI3NoaXBwaW5nLW1ldGhvZC1saXN0Jyk7XG4gICAgdmFyIHZhbGlkID0gZmFsc2U7XG4gICAgaWYgKCRzaGlwcGluZ01ldGhvZExpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoJHNoaXBwaW5nTWV0aG9kTGlzdC5maW5kKCcucmVzdHJpY3RlZC1zaGlwbWVudC1lcnJvcicpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgXHR2YWxpZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIFx0dmFsaWQgPSBmYWxzZTsgXG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHZhbGlkO1xufVxuXG52YXIgaW5pdCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgaWYgKCFvcHRzLmZvcm1TZWxlY3RvciB8fCAhb3B0cy5jb250aW51ZVNlbGVjdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBmb3JtIGFuZCBjb250aW51ZSBhY3Rpb24gc2VsZWN0b3JzLicpO1xuICAgIH1cbiAgICAkZm9ybSA9ICQob3B0cy5mb3JtU2VsZWN0b3IpO1xuICAgICRjb250aW51ZSA9ICQob3B0cy5jb250aW51ZVNlbGVjdG9yKTtcbiAgICB2YWxpZGF0b3IgPSAkZm9ybS52YWxpZGF0ZSgpO1xuICAgICRyZXF1aXJlZElucHV0cyA9ICQoJy5yZXF1aXJlZCcsICRmb3JtKS5maW5kKCc6aW5wdXQnKTtcbiAgICB2YWxpZGF0ZUZvcm0oKTtcbiAgICAvLyBzdGFydCBsaXN0ZW5pbmdcbiAgICAkcmVxdWlyZWRJbnB1dHMub24oJ2ZvY3Vzb3V0JywgdmFsaWRhdGVFbCk7XG4gICAgJHJlcXVpcmVkSW5wdXRzLmZpbHRlcignaW5wdXQ6bm90KFtpZCQ9XCJfY3JlZGl0Q2FyZF9leHBpcmF0aW9uZGF0ZVwiXSwgW2lkJD1cIl9jcmVkaXRDYXJkX251bWJlclwiXSknKS5vbignZm9jdXNvdXQnLCBfLmRlYm91bmNlKHZhbGlkYXRlRWwsIDIwMCkpO1xuICAgIHN0aWNreUNhcnQuaW5pdCgpO1xuXG59O1xuXG5leHBvcnRzLmluaXQgPSBpbml0O1xuZXhwb3J0cy52YWxpZGF0ZUZvcm0gPSB2YWxpZGF0ZUZvcm07XG5leHBvcnRzLnZhbGlkYXRlRWwgPSB2YWxpZGF0ZUVsO1xuZXhwb3J0cy5oYXNTaGlwcGluZ01ldGhvZEVycm9yID0gaGFzU2hpcHBpbmdNZXRob2RFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFkZHJlc3MgPSByZXF1aXJlKCcuL2FkZHJlc3MnKSxcbiAgICBiaWxsaW5nID0gcmVxdWlyZSgnLi9iaWxsaW5nJyksXG4gICAgbXVsdGlzaGlwID0gcmVxdWlyZSgnLi9tdWx0aXNoaXAnKSxcbiAgICBzaGlwcGluZyA9IHJlcXVpcmUoJy4vc2hpcHBpbmcnKSxcbiAgICBzbWFydFJlc2l6ZSA9IHJlcXVpcmUoJy4uLy4uL3NtYXJ0cmVzaXplJyksXG4gICAgcXVpY2t2aWV3ID0gcmVxdWlyZSgnLi4vLi4vcXVpY2t2aWV3JyksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKSxcbiAgICBtZWRpdW1CcmVha3BvaW50ID0gNDgwO1xuXG5mdW5jdGlvbiBzdXBwb3J0TWVzc2FnZVBvc2l0aW9uKCkge1xuICAgIHZhciBzdXBwb3J0TWVzc2FnZSA9ICQoJy5zdXBwb3J0LW1lc3NhZ2UtcGhvbmUuY2hlY2tvdXQtcHJvZ3Jlc3MnKTtcbiAgICBpZiAod2luZG93LmlubmVyV2lkdGggPD0gbWVkaXVtQnJlYWtwb2ludCAmJiAkKCcjZm9vdGVyLXdyYXBwZXInKS5maW5kKHN1cHBvcnRNZXNzYWdlKS5sZW5ndGggPCAxKSB7XG4gICAgICAgIHN1cHBvcnRNZXNzYWdlLnByZXBlbmRUbygnI2Zvb3Rlci13cmFwcGVyJyk7XG4gICAgfSBlbHNlIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA+IG1lZGl1bUJyZWFrcG9pbnQgJiYgJCgnLnRhYmxldC1wcm9ncmVzcy1pbmRpY2F0b3InKS5maW5kKHN1cHBvcnRNZXNzYWdlKS5sZW5ndGggPCAxKSB7XG4gICAgICAgIHN1cHBvcnRNZXNzYWdlLmFwcGVuZFRvKCcudGFibGV0LXByb2dyZXNzLWluZGljYXRvciAuY2hlY2tvdXQtcHJvZ3Jlc3MtaW5kaWNhdG9yJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbW9iaWxlU3VtbWFyeUFkZENsYXNzKCkge1xuICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA8PSBtZWRpdW1CcmVha3BvaW50KSB7XG4gICAgICAgICQoJyNjaGVja291dC1taW5pLXN1bW1hcnknKS5hZGRDbGFzcygnY2hlY2tvdXQtbWluaS1zdW1tYXJ5LW1vYmlsZScpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1vYmlsZVNob3dTdW1tYXJ5ICgpIHtcbiAgICAkKCcuY2hlY2tvdXQtbW9iaWxlLXN1bW1hcnkgLmZhJykuY3NzKCd2aXNpYmlsaXR5JywndmlzaWJsZScpO1xuICAgICQoJy5jaGVja291dC1tb2JpbGUtc3VtbWFyeScpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCl7XG4gICAgICAgICQodGhpcykudG9nZ2xlQ2xhc3MoJ2NoZWNrb3V0LW1vYmlsZS1zdW1tYXJ5LWFjdGl2ZScpO1xuICAgICAgICAkKCcuY2hlY2tvdXQtbWluaS1zdW1tYXJ5LW1vYmlsZScpLnRvZ2dsZUNsYXNzKCdjaGVja291dC1taW5pLXN1bW1hcnktbW9iaWxlLWFjdGl2ZScpO1xuICAgICAgICBpZiAoJCh0aGlzKS5jbG9zZXN0KCcudG9wLWJhbm5lcicpLmhhc0NsYXNzKCdzdGlja3knKSkge1xuXHQgICAgICAgICQoXCJodG1sLCBib2R5XCIpLmFuaW1hdGUoe1xuXHQgICAgICAgICAgICBzY3JvbGxUb3A6IDBcblx0ICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgICQoJ2JvZHknKS5vbignY2xpY2snLCAnLm1pbmktc3VtbWFyeS1jbG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAkKCcuY2hlY2tvdXQtbW9iaWxlLXN1bW1hcnknKS5yZW1vdmVDbGFzcygnY2hlY2tvdXQtbW9iaWxlLXN1bW1hcnktYWN0aXZlJyk7XG4gICAgICAgICQoJy5jaGVja291dC1taW5pLXN1bW1hcnktbW9iaWxlJykucmVtb3ZlQ2xhc3MoJ2NoZWNrb3V0LW1pbmktc3VtbWFyeS1tb2JpbGUtYWN0aXZlJyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzdGlja3lCbG9jaygpIHtcbiAgICBpZiAod2luZG93LmlubmVyV2lkdGggPiA5NjApIHtcbiAgICAgICAgJChcIi5jYXJ0LW9yZGVyLXRvdGFsc1wiKS5zdGlja19pbl9wYXJlbnQoe29mZnNldF90b3AgOiAkKCcudG9wLWJhbm5lcicpLmhlaWdodCgpfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZWxlY3RGcm9tQmFrKCkge1xuICAgIGlmICgkKCcjc3RhdGUtaWQtYmFrJykubGVuZ3RoICYmICQoJyNzdGF0ZS1pZC1iYWsnKS52YWwoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9ICQoJyNzdGF0ZS1pZC1iYWsnKS52YWwoKTtcbiAgICAgICAgJCgnc2VsZWN0W25hbWUkPVwiX3N0YXRlXCJdJykudmFsKHN0YXRlKS5hdHRyKCdzZWxlY3RlZCcsIHRydWUpO1xuICAgICAgICAkKCdzZWxlY3RbbmFtZSQ9XCJfc3RhdGVcIl0nKS5ibHVyKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1BvcHVsYXRlZEZpZWxkcygpIHtcbiAgICAkKCdmb3JtW25hbWUkPVwiX2JpbGxpbmdcIl0gaW5wdXQsIGZvcm1bbmFtZSQ9XCJfYmlsbGluZ1wiXSBzZWxlY3QnKS5lYWNoKGZ1bmN0aW9uIChpbmRleCwgZWxlbWVudCkge1xuICAgICAgICBpZiAoJChlbGVtZW50KS52YWwoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAkKGVsZW1lbnQpLmJsdXIoKTtcbiAgICAgICAgfVxuICAgIH0pXG59XG5cbmZ1bmN0aW9uIGhpZGVTdW1tYXJ5T25Mb2dpbigpIHtcbiAgICBpZigkKCcucHRfY2hlY2tvdXQnKS5sZW5ndGggJiYgJCgnI21haW4gLmFjY291bnQtbG9naW4nKS5sZW5ndGgpIHtcbiAgICAgICAgJCgnLmNoZWNrb3V0LW1vYmlsZS1zdW1tYXJ5JykuaGlkZSgpO1xuICAgIH1cbn1cblxuZXhwb3J0cy5zdGlja3lCbG9jayA9IGZ1bmN0aW9uICgpIHtzdGlja3lCbG9jaygpO31cblxuLyoqXG4gKiBAZnVuY3Rpb24gSW5pdGlhbGl6ZXMgdGhlIHBhZ2UgZXZlbnRzIGRlcGVuZGluZyBvbiB0aGUgY2hlY2tvdXQgc3RhZ2UgKHNoaXBwaW5nL2JpbGxpbmcpXG4gKi9cbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBhZGRyZXNzLmluaXQoKTtcbiAgICBpZiAoJCgnLmNoZWNrb3V0LXNoaXBwaW5nJykubGVuZ3RoID4gMCAmJiAkKCcuY2hlY2tvdXRtdWx0aXNoaXBwaW5nJykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNoaXBwaW5nLmluaXQoKTtcbiAgICB9IGVsc2UgaWYgKCQoJy5jaGVja291dG11bHRpc2hpcHBpbmcnKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIG11bHRpc2hpcC5pbml0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYmlsbGluZy5pbml0KCk7XG4gICAgfVxuXG4gICAgJCgnLml0ZW0tZWRpdC1kZXRhaWxzIGEnKS5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHF1aWNrdmlldy5zaG93KHtcbiAgICAgICAgICAgIHVybDogZS50YXJnZXQuaHJlZixcbiAgICAgICAgICAgIHNvdXJjZTogJ2NhcnQnLFxuICAgICAgICAgICAgY3VzdG9tQ2xhc3M6ICd1aS1kaWFsb2dfdXBkYXRlLWl0ZW0nXG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy9pZiBvbiB0aGUgb3JkZXIgcmV2aWV3IHBhZ2UgYW5kIHRoZXJlIGFyZSBwcm9kdWN0cyB0aGF0IGFyZSBub3QgYXZhaWxhYmxlIGRpYWJsZSB0aGUgc3VibWl0IG9yZGVyIGJ1dHRvblxuICAgIGlmICgkKCcub3JkZXItc3VtbWFyeS1mb290ZXInKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICgkKCcubm90YXZhaWxhYmxlJykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgJCgnLm9yZGVyLXN1bW1hcnktZm9vdGVyIC5zdWJtaXQtb3JkZXIgLmJ1dHRvbi1mYW5jeS1sYXJnZScpLmF0dHIoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy9zZXQgc2VsZWN0ZWQgY2xhc3MgZm9yIGFsbCBzZWxlY3RzXG4gICAgJCgnLnB0X2NoZWNrb3V0Jykub24oJ2NoYW5nZScsICdzZWxlY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICQodGhpcykuYWRkQ2xhc3MoJ3NlbGVjdGVkJyk7XG4gICAgICAgICQodGhpcykucGFyZW50KCkucmVtb3ZlQ2xhc3MoJ3VuZmxvYXQnKTtcbiAgICB9KTtcblxuICAgICQod2luZG93KS5sb2FkKGZ1bmN0aW9uKCl7XG4gICAgICAgIHN0aWNreUJsb2NrKCk7XG4gICAgfSk7XG4gICAgaGlkZVN1bW1hcnlPbkxvZ2luKCk7XG4gICAgc3VwcG9ydE1lc3NhZ2VQb3NpdGlvbigpO1xuICAgIG1vYmlsZVN1bW1hcnlBZGRDbGFzcygpO1xuICAgIG1vYmlsZVNob3dTdW1tYXJ5KCk7XG4gICAgc21hcnRSZXNpemUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHN1cHBvcnRNZXNzYWdlUG9zaXRpb24oKTtcbiAgICAgICAgbW9iaWxlU3VtbWFyeUFkZENsYXNzKCk7XG4gICAgfSk7XG4gICAgc2VsZWN0RnJvbUJhaygpO1xuICAgIGNoZWNrUG9wdWxhdGVkRmllbGRzKCk7XG4gICAgdXRpbC5zZWxlY3RVbmZsb2F0KCk7XG5cbiAgICAkKCcub0F1dGhJY29uJykub2ZmKCdjbGljaycpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICQoJy5PQXV0aFByb3ZpZGVyJykudmFsKHRoaXMuaWQpO1xuICAgIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFkZHJlc3MgPSByZXF1aXJlKCcuL2FkZHJlc3MnKSxcbiAgICBmb3JtUHJlcGFyZSA9IHJlcXVpcmUoJy4vZm9ybVByZXBhcmUnKSxcbiAgICBkaWFsb2cgPSByZXF1aXJlKCcuLi8uLi9kaWFsb2cnKSxcbiAgICBzdGlja3lDYXJ0ID0gcmVxdWlyZSgnLi4vLi4vc3RpY2t5Y2FydCcpLFxuICAgIHZhbGlkYXRvciA9IHJlcXVpcmUoJy4uLy4uL3ZhbGlkYXRvcicpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyksXG4gICAgYWpheCA9IHJlcXVpcmUoJy4uLy4uL2FqYXgnKSxcbiAgICBwYWdlID0gcmVxdWlyZSgnLi4vLi4vcGFnZScpLFxuICAgIHVwZGF0ZVN1bW1hcnkgPSByZXF1aXJlKCcuL3NoaXBwaW5nJykudXBkYXRlU3VtbWFyeSxcbiAgICBzZWxlY3RCb3hJdCA9IHJlcXVpcmUoJy4uLy4uL3NlbGVjdGJveGl0JyksXG4gICAgZmxvYXRMYWJlbHMgPSByZXF1aXJlKCcuLi8uLi9mbG9hdC1sYWJlbHMnKSxcbiAgICAkY2FjaGUgPSB7fTtcblxuXG5mdW5jdGlvbiByZXN0cmljdGVkU3RhdGUoc3RhdGVMaXN0LHN0YXRlKSB7XG4gICAgdmFyIGxlbiA9IHN0YXRlTGlzdC5sZW5ndGg7XG4gICAgdmFyIHN0YXRlTGlzdFN0YXRlO1xuICAgIGlmKGxlbiA9PSAwKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHN0YXRlTGlzdFN0YXRlID0gc3RhdGVMaXN0LnN0YXRlc1tpXTtcbiAgICAgICAgaWYoc3RhdGVMaXN0U3RhdGUgPT0gc3RhdGUpe1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbmZ1bmN0aW9uIGluaXRpYWxpemVBZGRyZXNzRm9ybShmb3JtKSB7XG4gICAgdmFyIGZvcm0gPSAkKFwiI0VkaXRBZGRyZXNzRm9ybSwgI2VkaXQtYWRkcmVzcy1mb3JtXCIpO1xuICAgIGZvcm0uZmluZChcImlucHV0W25hbWU9J2Zvcm1hdCddXCIpLnJlbW92ZSgpO1xuICAgIGZsb2F0TGFiZWxzLmluaXQoKTtcbiAgICB2YWxpZGF0b3IuaW5pdEZvcm0oZm9ybSk7XG4gICAgZm9ybS5vbignY2hhbmdlJywgJy5pbnB1dC10ZXh0LnBob25lJywgdmFsaWRhdG9yLmZvcm1hdHRlci5waG9uZSk7XG4gICAgJCgnLnVpLWRpYWxvZy10aXRsZWJhci1jbG9zZScpLmJsdXIoKTtcbiAgICBmb3JtLmZpbmQoJCgnYS50b29sdGlwJykpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgXHRlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSk7XG5cbiAgICAvL2luaXRpYWxpemUgZm9ybSBmaWVsZHNcbiAgICBmb3JtLmZpbmQoJ2lucHV0LCBzZWxlY3QnKS5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB2YWwgPSAkKHRoaXMpLnZhbCgpO1xuICAgICAgICBpZiAodmFsICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAkKHRoaXMpLnZhbGlkKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvcm0uZmluZCgncGhvbmUnKS5ibHVyKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gJCh0aGlzKS52YWwoKTtcbiAgICAgICAgLy8gYXV0b2ZpbGwgZml4IGZvciBtYXNrZWQgZmllbGRcbiAgICAgICAgJCh0aGlzKS52YWwodmFsKTtcbiAgICB9KTtcblxuICAgIC8vYmluZCBjaGVjYm94IHN0eWxlc1xuICAgIGZvcm0uZmluZCgnaW5wdXQuaW5wdXQtY2hlY2tib3gnKS5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmICgkKHRoaXMpLnBhcmVudHMoJy5jaGVja2JveCcpLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgd3JhcCA9ICQodGhpcykuY2xvc2VzdCgnLmZvcm0tcm93JyksXG4gICAgICAgICAgICBjaGVja2VkID0gJCh0aGlzKS5pcygnOmNoZWNrZWQnKTtcblxuICAgICAgICBpZiAod3JhcC5sZW5ndGgpe1xuICAgICAgICAgICAgd3JhcC53cmFwSW5uZXIoJzxkaXYgY2xhc3M9XCJjaGVja2JveFwiIC8+JylcbiAgICAgICAgICAgIGlmIChjaGVja2VkKVxuICAgICAgICAgICAgICAgIHdyYXAuZmluZChcIi5jaGVja2JveFwiKS5hZGRDbGFzcygnY2hlY2tlZCcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZihjaGVja2VkKXtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLnBhcmVudCgpLndyYXBJbm5lcignPGRpdiBjbGFzcz1cImNoZWNrYm94IGNoZWNrZWRcIiAvPicpXG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLnBhcmVudCgpLndyYXBJbm5lcignPGRpdiBjbGFzcz1cImNoZWNrYm94XCIgLz4nKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkKHRoaXMpLndyYXAoJzxkaXYgY2xhc3M9XCJjaC1maWVsZFwiIC8+JylcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUHJlcG9wdWxhdGUgY2l0eSBmb3IgY2hlY2tvdXQgcmVkZXNpZ25cbiAgICB1dGlsLmluaXRaaXBTZXJ2aWNlKGZvcm0pO1xuICAgIHZhciAkc3RhdGVFbXB0eU9wdGlvbkVsID0gZm9ybS5maW5kKCcuc3RhdGUtZmllbGQtY29udGFpbmVyIHNlbGVjdCBvcHRpb246Zmlyc3QtY2hpbGQnKTtcblxuICAgIHZhciBzdGF0ZUVtcHR5T3B0aW9uSHRtbCA9ICQoJzxkaXY+JykuYXBwZW5kKCRzdGF0ZUVtcHR5T3B0aW9uRWwuY2xvbmUoKSlcbiAgICAgICAgLmh0bWwoKTtcbiAgICBmb3JtLm9uKCdjaGFuZ2UnLCAnc2VsZWN0LmNvdW50cnknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdXRpbC5jaGFuZ2VTdGF0ZUZpZWxkKCQodGhpcykudmFsKCksIGZvcm0sIHN0YXRlRW1wdHlPcHRpb25IdG1sKTtcbiAgICAgICAgZm9ybS5vbignY2hhbmdlJywgJy5pbnB1dC10ZXh0LnBob25lJywgdmFsaWRhdG9yLmZvcm1hdHRlci5waG9uZSk7XG4gICAgfSk7XG4gICAgZm9ybS5maW5kKCdzZWxlY3QuY291bnRyeScpLnRyaWdnZXIoJ2NoYW5nZScpO1xuXG4gICAgZm9ybS5vbihcImNsaWNrXCIsIFwiI2RpYWxvZ0FwcGx5QnRuLCAuYXBwbHktYnV0dG9uXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmICgkKCcuc2luZ2xlLXNoaXBtZW50JykubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHZhciBhZGRyZXNzSWQgPSBmb3JtLmZpbmQoXCJpbnB1dFtuYW1lJD0nX2FkZHJlc3NpZCddXCIpO1xuICAgICAgICAgICAgLy8gUmVwbGFjZSBmdW5reSBjaGFycyBpbiB0aGUgYWRkcmVzcyBpZFxuICAgICAgICAgICAgYWRkcmVzc0lkLnZhbChhZGRyZXNzSWQudmFsKCkucmVwbGFjZSgvW15cXHcrLV0vZywgXCItXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZm9ybS52YWxpZCgpKSB7XG4gICAgICAgICAgICAvL2luaXRpYWxpemVBZGRyZXNzRm9ybShmb3JtKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXJsID0gdXRpbC5hcHBlbmRQYXJhbXNUb1VybChmb3JtLmF0dHIoJ2FjdGlvbicpLHtmb3JtYXQ6XCJhamF4XCJ9KTtcbiAgICAgICAgdmFyIGFwcGx5TmFtZSA9ICQodGhpcykuYXR0cignbmFtZScpO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgZGF0YTogZm9ybS5zZXJpYWxpemUoKStcIiZcIithcHBseU5hbWUrJz14JyxcbiAgICAgICAgICAgIHR5cGU6IFwiUE9TVFwiXG4gICAgICAgIH07XG4gICAgICAgICQuYWpheCggb3B0aW9ucyApLmRvbmUoZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBpZiAodHlwZW9mKGRhdGEpICE9PSAnc3RyaW5nJyB8fCAkLnRyaW0oZGF0YSkgPT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuc3VjY2VzcyB8fCAkLnRyaW0oZGF0YSkgPT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoJCgnLnNpbmdsZS1zaGlwbWVudCcpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRyZXNzSURzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJGNhY2hlLnNpbmdsZVNoaXBtZW50QWRkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnLmFkZHJlc3NlbnRyeScpLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc0lEcy5wdXNoKCQodGhpcykuZGF0YSgndXVpZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICQoJy5hZGRyZXNzbGlzdCcpLmxvYWQoVXJscy5hZGRyZXNzTGlzdCwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgYSBzaGlwcGluZyBhZGRyZXNzIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRjYWNoZS5zaW5nbGVTaGlwbWVudEFkZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWxlY3QgdGhlIG5ld2VzdCBhZGRyZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJy5hZGRyZXNzZW50cnknKS5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzc0lEcy5pbmRleE9mKCQodGhpcykuZGF0YSgndXVpZCcpKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykuZmluZCgnaW5wdXQnKS5wcm9wKCdjaGVja2VkJywgdHJ1ZSkuY2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQoXCJpbnB1dFtuYW1lJD0nX3NoaXBwaW5nQWRkcmVzc0lEJ11cIikubGVuZ3RoID4gMCAmJiAkKFwiaW5wdXRbbmFtZSQ9J19zaGlwcGluZ0FkZHJlc3NJRCddOmNoZWNrZWRcIikubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJy5wcmVmZXJyZWQtYWRkcmVzcyBpbnB1dCcpLnByb3AoJ2NoZWNrZWQnLCB0cnVlKS5jbGljaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnLmFkZHJlc3NsaXN0IGlucHV0OmNoZWNrZWQnKS5jbGljaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJy5hZGRyZXNzZW50cnksIC5hZGRyZXNzLWNyZWF0ZSwgLmFkZHJlc3MtYWRkJykuc3luY0hlaWdodCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgkKCcuY2hlY2tvdXRtdWx0aXNoaXBwaW5nLnNoaXBtZW50cycpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2UucmVkaXJlY3QoVXJscy5tdWx0aVNoaXBTaGlwbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZS5yZWRpcmVjdChVcmxzLm11bHRpU2hpcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KGRhdGEubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgkKCcuZ3Vlc3QtbWluaWFkZHJlc3MnKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZGlhbG9nLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgdmFyIG11bHRpc2hpcCA9ICQoJy5tdWx0aXNoaXBtZXRob2RzJyk7XG4gICAgICAgICAgICAgICAgaWYgKG11bHRpc2hpcC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpc2hpcC5sb2FkKFVybHMubXVsdGlTaGlwTWV0aG9kcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVN1bW1hcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKnVwZGF0ZVNoaXBwaW5nTWV0aG9kTGlzdCgpOyovXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVN1bW1hcnkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJCgnLmd1ZXN0LW1pbmlhZGRyZXNzJykuaHRtbChkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICQoJyNkaWFsb2ctY29udGFpbmVyJykuaHRtbChkYXRhKTtcbiAgICAgICAgICAgICAgICAvKmFwcC5hY2NvdW50LmluaXQoKTtcbiAgICAgICAgICAgICAgICBhcHAudG9vbHRpcHMuaW5pdCgpOyovXG4gICAgICAgICAgICAgICAgLy8gUERTIE1FUkdFXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZUFkZHJlc3NGb3JtKGZvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KVxuICAgIC5vbihcImNsaWNrXCIsIFwiI2RpYWxvZ0NhbmNlbEJ0biwgLmNsb3NlLWJ1dHRvbiwgLmNhbmNlbFwiLCBmdW5jdGlvbihlKXtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAgICB9KVxuICAgIC5vbihcImNsaWNrXCIsIFwiI2RpYWxvZ0RlbGV0ZUJ0blwiLCBmdW5jdGlvbihlKXtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAoIWZvcm0udmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cmwgPSB1dGlsLmFwcGVuZFBhcmFtc1RvVXJsKGZvcm0uYXR0cignYWN0aW9uJykse2Zvcm1hdDpcImFqYXhcIn0pO1xuICAgICAgICB2YXIgYXBwbHlOYW1lID0gZm9ybS5maW5kKCcjZGlhbG9nRGVsZXRlQnRuJykuYXR0cignbmFtZScpO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgZGF0YTogZm9ybS5zZXJpYWxpemUoKStcIiZcIithcHBseU5hbWUrJz14JyxcbiAgICAgICAgICAgIHR5cGU6IFwiUE9TVFwiXG4gICAgICAgIH07XG4gICAgICAgICQuYWpheCggb3B0aW9ucyApLmRvbmUoZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBpZiggdHlwZW9mKGRhdGEpIT09J3N0cmluZycgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLnN1Y2Nlc3MgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBwYWdlLnJlZGlyZWN0KFVybHMubXVsdGlTaGlwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbGVydChkYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKCcjZGlhbG9nLWNvbnRhaW5lcicpLmh0bWwoZGF0YSk7XG4gICAgICAgICAgICAgICAgLyphcHAuYWNjb3VudC5pbml0KCk7XG4gICAgICAgICAgICAgICAgYXBwLnRvb2x0aXBzLmluaXQoKTsqL1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gc2hpcHBpbmdMb2FkKCl7XG4gICAgaWYgKCRjYWNoZS5jaGVja291dEZvcm0uaGFzQ2xhc3MoXCJzaGlwcGluZy1hZGRyZXNzZXNcIikpIHtcbiAgICAgICAgJCgnI211bHRpU2hpcEFkZHJlc3NGb3JtJykub24oJ3N1Ym1pdCcsZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAvL3ByZXZlbnQgY2hlY2tvdXQgd2hlbiBhZGRyZXNzIG91dHNpZGUgb2YgVVMgYW5kIGNvbnRhaW5zIGhhem1hdCBvciBkcm9wc2hpcCBpdGVtc1xuICAgICAgICAgICAgLyphcHAucHJvZ3Jlc3Muc2hvdyh0aGlzKTsqL1xuXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAkKFwiI2F2c0RpdlwiKS5hcHBlbmQoXCI8ZGl2IGlkPVxcXCJuZXdBdnNEaXZcXFwiPjwvZGl2PlwiKTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gJCh0aGlzKS5zZXJpYWxpemUoKTtcbiAgICAgICAgICAgIHZhciB1cmwgPSAgVXJscy52ZXJpZnlBZGRyZXNzTXVsdGlwbGU7XG4gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBhamF4LmxvYWQoe1xuICAgICAgICAgICAgICAgIHVybDp1cmwsXG4gICAgICAgICAgICAgICAgZGF0YTpkYXRhLFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHR5cGU6XCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChyZXNwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKCQudHJpbShyZXNwKSAhPSBcInt9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgXHQkKFwiI2F2c0RpdlwiKS5odG1sKCQoXCIjbmV3QXZzRGl2XCIpLmh0bWwoKSk7XG4gICAgICAgICAgICAgICAgICAgIFx0ZGlhbG9nLm9wZW4oe3VybDogdXJsLCB0YXJnZXQ6JChcIiNuZXdBdnNEaXZcIiksIG9wdGlvbnM6e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDo2MzAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDo0NTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOicnXG4gICAgICAgICAgICAgICAgICAgICAgICAgfX0pO1xuICAgICAgICAgICAgICAgICAgICBcdFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBcdFxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnI3ZlcmlmeUJ0bicpLmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0aWNreUNhcnQuaW5pdCgpO1xuXG4gICAgdmFyIG11bHRpc2hpcCA9ICQoXCIuY2hlY2tvdXRtdWx0aXNoaXBwaW5nXCIpO1xuICAgIGlmKG11bHRpc2hpcC5sZW5ndGggPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgICAvKnNlbGVjdEJveEl0LnNlbGVjdEJveEl0KCQoJy5zZWxlY3QtZmllbGQnKSk7Ki9cblxuICAgIHZhciBzaGlwcGluZ0FkZHJlc3NMaXN0cyA9ICQoXCIubXVsdGlzaGlwLWFkZHJlc3Nlcy10YWJsZVwiKS5maW5kKFwidGQuc2hpcHBpbmdhZGRyZXNzXCIpO1xuXG4gICAgJChzaGlwcGluZ0FkZHJlc3NMaXN0cykuZWFjaChmdW5jdGlvbihpbmRleCl7XG4gICAgICAgIHZhciBhZGRyZXNzTGlzdCA9ICQodGhpcyk7XG4gICAgICAgIHZhciB1dWlkID0gJCh0aGlzKS5hdHRyKFwiZGF0YS11dWlkXCIpO1xuICAgICAgICB2YXIgaXNIYXptYXQgPSAkKHRoaXMpLmRhdGEoXCJoYXptYXRcIik7XG4gICAgICAgIHZhciBpc0Ryb3BTaGlwID0gJCh0aGlzKS5kYXRhKFwiZHJvcHNoaXBcIik7XG4gICAgICAgIHZhciBpc05vSW50bFNoaXAgPSAkKHRoaXMpLmRhdGEoXCJub2ludGxzaGlwXCIpO1xuICAgICAgICB2YXIgYWRkcmVzc0lEID0gJCh0aGlzKS5maW5kKFwiLnNlbGVjdGJveFwiKS52YWwoKTtcblxuICAgICAgICB2YXIgaGF6bWF0U3RhdGVzID0gd2luZG93Lmhhem1hdHN0YXRlcztcbiAgICAgICAgdmFyIGRyb3BzaGlwU3RhdGVzID0gd2luZG93LmRyb3BzaGlwc3RhdGVzO1xuICAgICAgICB2YXIgaGF6bWF0U3RhdGVzID0gJyc7XG4gICAgICAgIHZhciBkcm9wc2hpcFN0YXRlcyA9ICcnO1xuXG4gICAgICAgIHZhciBzdGF0ZSA9ICQodGhpcykuZmluZChcIm9wdGlvbjpzZWxlY3RlZFwiKS5kYXRhKFwic3RhdGVcIikgfHwgZmFsc2U7XG5cbiAgICAgICAgdmFyIGluaXRDb3VudHJ5ID0gJCh0aGlzKS5maW5kKFwib3B0aW9uOnNlbGVjdGVkXCIpLmRhdGEoXCJjb3VudHJ5XCIpO1xuICAgICAgICB2YXIgaXNVUyA9IChpbml0Q291bnRyeSA9PSAnVVMnIHx8IGluaXRDb3VudHJ5ID09ICcnKSB8fCBmYWxzZTtcblxuICAgICAgICB2YXIgcmVzdHJpY3RlZEhhem1hdFN0YXRlID0gcmVzdHJpY3RlZFN0YXRlKGhhem1hdFN0YXRlcywgc3RhdGUpO1xuICAgICAgICB2YXIgcmVzdHJpY3RlZERyb3BTaGlwU3RhdGUgPSByZXN0cmljdGVkU3RhdGUoZHJvcHNoaXBTdGF0ZXMsIHN0YXRlKTtcblxuXG4gICAgICAgIGlmKGFkZHJlc3NJRCl7XG4gICAgICAgICAgICAkKHRoaXMpLmZpbmQoXCJhLmFkZHJlc3MtZWRpdFwiKS5yZW1vdmVDbGFzcyhcInZpc3VhbGx5LWhpZGRlblwiKTtcbiAgICAgICAgICAgICQodGhpcykuZmluZChcIi5zZWxlY3Rib3hcIikudHJpZ2dlcignY2xpY2snKS5hZGRDbGFzcygnc2VsZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAvL2Rpc3BsYXkgZXJyb3IgbWVzc2FnZXMgZm9yIHNlbGVjdGVkIGFkZHJlc3NlcyBvbmxvYWRcblxuICAgICAgICBpZigoIWlzVVMgfHwgKGlzVVMgJiYgcmVzdHJpY3RlZEhhem1hdFN0YXRlKSkgJiYgaXNIYXptYXQpe1xuICAgICAgICAgICAgJCh0aGlzKS5maW5kKFwiLm5vc2hpcC1lcnJvclwiKS5yZW1vdmVDbGFzcyhcInZpc3VhbGx5LWhpZGRlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZighaXNVUyAmJiBpc05vSW50bFNoaXApe1xuICAgICAgICAgICAgJCh0aGlzKS5maW5kKFwiLm5vc2hpcC1lcnJvclwiKS5yZW1vdmVDbGFzcyhcInZpc3VhbGx5LWhpZGRlblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZGlzcGxheSBlcnJvciBtZXNzYWdlcyBmb3Igc2VsZWN0ZWQgYWRkcmVzc2VzIG9uIHNlbGVjdGlvbiBjaGFuZ2VcbiAgICAgICAgJCh0aGlzKS5vbihcImNoYW5nZVwiLFwiLnNlbGVjdGJveFwiLGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgdmFyIG5ld0FkZHJlc3NJRCA9ICQodGhpcykudmFsKCk7XG5cbiAgICAgICAgICAgIHZhciBzaGlwQ291bnRyeSA9ICQodGhpcykuZmluZChcIm9wdGlvbjpzZWxlY3RlZFwiKS5kYXRhKFwiY291bnRyeVwiKTtcbiAgICAgICAgICAgIHZhciBzaGlwU3RhdGUgPSAkKHRoaXMpLmZpbmQoXCJvcHRpb246c2VsZWN0ZWRcIikuZGF0YShcInN0YXRlXCIpIHx8IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGlzVVMgPSAoc2hpcENvdW50cnkgPT0gJ1VTJyB8fCBzaGlwQ291bnRyeSA9PSAnJykgfHwgZmFsc2U7XG4gICAgICAgICAgICB2YXIgcmVzdHJpY3RlZEhhem1hdFN0YXRlID0gcmVzdHJpY3RlZFN0YXRlKGhhem1hdFN0YXRlcyxzaGlwU3RhdGUpO1xuICAgICAgICAgICAgdmFyIHJlc3RyaWN0ZWREcm9wU2hpcFN0YXRlID0gcmVzdHJpY3RlZFN0YXRlKGRyb3BzaGlwU3RhdGVzLHNoaXBTdGF0ZSk7XG5cbiAgICAgICAgICAgIGlmKCFuZXdBZGRyZXNzSUQpe1xuICAgICAgICAgICAgXHQgJCh0aGlzKS5wYXJlbnRzKFwiLnNlbGVjdC1hZGRyZXNzXCIpLnNpYmxpbmdzKFwiLmFkZHJlc3MtZXJyb3JcIikucmVtb3ZlQ2xhc3MoXCJ2aXN1YWxseS1oaWRkZW5cIik7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnRzKFwiLnNoaXBwaW5nYWRkcmVzc1wiKS5maW5kKFwiYS5hZGRyZXNzLWVkaXRcIikuYWRkQ2xhc3MoXCJ2aXN1YWxseS1oaWRkZW5cIik7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLnBhcmVudHMoXCIuc2hpcHBpbmdhZGRyZXNzXCIpLmZpbmQoXCJhLmFkZHJlc3MtZWRpdFwiKS5yZW1vdmVDbGFzcyhcInZpc3VhbGx5LWhpZGRlblwiKTtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLnBhcmVudHMoXCIuc2VsZWN0LWFkZHJlc3NcIikuc2libGluZ3MoXCIuYWRkcmVzcy1lcnJvclwiKS5hZGRDbGFzcyhcInZpc3VhbGx5LWhpZGRlblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBpZighaXNVUyAmJiAoaXNIYXptYXQgfHwgaXNOb0ludGxTaGlwKSl7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnRzKFwiLnNlbGVjdC1hZGRyZXNzXCIpLnNpYmxpbmdzKFwiLm5vc2hpcC1lcnJvclwiKS5yZW1vdmVDbGFzcyhcInZpc3VhbGx5LWhpZGRlblwiKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1VTICYmIGlzSGF6bWF0ICYmIHJlc3RyaWN0ZWRIYXptYXRTdGF0ZSl7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnRzKFwiLnNlbGVjdC1hZGRyZXNzXCIpLnNpYmxpbmdzKFwiLm5vc2hpcC1lcnJvclwiKS5yZW1vdmVDbGFzcyhcInZpc3VhbGx5LWhpZGRlblwiKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1VTICYmIGlzRHJvcFNoaXAgJiYgcmVzdHJpY3RlZERyb3BTaGlwU3RhdGUpe1xuICAgICAgICAgICAgICAgICQodGhpcykucGFyZW50cyhcIi5zZWxlY3QtYWRkcmVzc1wiKS5zaWJsaW5ncyhcIi5ub3NoaXAtZXJyb3JcIikucmVtb3ZlQ2xhc3MoXCJ2aXN1YWxseS1oaWRkZW5cIik7XG5cbiAgICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLnBhcmVudHMoXCIuc2VsZWN0LWFkZHJlc3NcIikuc2libGluZ3MoXCIubm9zaGlwLWVycm9yXCIpLmFkZENsYXNzKFwidmlzdWFsbHktaGlkZGVuXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3ByZXZlbnQgY2hlY2tvdXQgaWYgbWlzc2luZyBhZGRyZXNzIG9yIGRyb3BzaGlwL2hhem1hdCBzaGlwbWVudHMgb3V0c2lkZSBVUyBldmVuIGlmIHZhbGlkYXRlZCBhZGRyZXNzXG4gICAgICAgICAgICBpc0Zvcm1BdmFpbGFibGVGb3JDaGVja291dCgpO1xuXG4gICAgICAgICAgICAvL3N0b3JlIHRoZSBzaGlwcGluZyBhZGRyZXNzIHRvIHNlc3Npb25cbiAgICAgICAgICAgIHZhciB1cmwgPSBVcmxzLnN0b3JlU2hpcHBpbmdBZGRyZXNzO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAncGxpVVVJRCc6IHV1aWQsXG4gICAgICAgICAgICAgICAgICAgICdhZGRyZXNzVVVJRCcgOiAkKHRoaXMpLnZhbCgpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlBPU1RcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICQuYWpheCggb3B0aW9ucyApLmRvbmUoZnVuY3Rpb24oZGF0YSl7XG5cbiAgICAgICAgICAgICAgICBpZihkYXRhLnN1Y2Nlc3Mpe1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vcHJldmVudCBjaGVja291dCBpZiBtaXNzaW5nIGFkZHJlc3Mgb3IgZHJvcHNoaXAvaGF6bWF0IHNoaXBtZW50cyBvdXRzaWRlIFVTIGV2ZW4gaWYgdmFsaWRhdGVkIGFkZHJlc3NcbiAgICBpc0Zvcm1BdmFpbGFibGVGb3JDaGVja291dChmYWxzZSk7XG5cbiAgICB2YXIgc2hpcG1lbnRNZXRob2RzTGlzdHMgPSAkKFwiLnNoaXBwaW5nLW1ldGhvZFwiKS5maW5kKFwidGQuc2hpcHBpbmdhZGRyZXNzXCIpO1xuXG4gICAgJChzaGlwbWVudE1ldGhvZHNMaXN0cykuZWFjaChmdW5jdGlvbihpbmRleCl7XG4gICAgICAgIHZhciB1dWlkID0gJCh0aGlzKS5hdHRyKFwiZGF0YS11dWlkXCIpO1xuICAgICAgICAkKHRoaXMpLm9uKFwiY2hhbmdlXCIsXCIuc2VsZWN0Ym94XCIsZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAvL3N0b3JlIHRoZSBzaGlwcGluZyBhZGRyZXNzIHRvIHNlc3Npb25cbiAgICAgICAgICAgIHZhciB1cmwgPSBVcmxzLnN0b3JlU2hpcHBpbmdNZXRob2Q7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICdzaGlwbWVudFVVSUQnOiB1dWlkLFxuICAgICAgICAgICAgICAgICAgICAnc2hpcHBpbmdNZXRob2RJRCcgOiAkKHRoaXMpLnZhbCgpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlBPU1RcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICQuYWpheCggb3B0aW9ucyApLmRvbmUoZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICAgICAgaWYoZGF0YS5zdWNjZXNzKXtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlU3VtbWFyeSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBtdWx0aXNoaXAuZmluZCgnW25hbWUkPVwiX3NoaXBwaW5nTWV0aG9kSURcIl0nKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICQodGhpcykucGFyZW50KCkuYWRkQ2xhc3MoJ3JhZGlvLWJ1dHRvbi1zZWxlY3RlZCcpO1xuICAgICAgICAkKHRoaXMpLnBhcmVudCgpLnNpYmxpbmdzKCdkaXYuZm9ybS1yb3cnKS5yZW1vdmVDbGFzcygncmFkaW8tYnV0dG9uLXNlbGVjdGVkJyk7XG4gICAgfSk7XG5cbiAgICBtdWx0aXNoaXAub24oXCJjaGFuZ2VcIixcIi5zaGlwcGluZy1tZXRob2QtcmFkaW9zIC5pbnB1dC1yYWRpb1wiLGZ1bmN0aW9uKGUpe1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVybDogVXJscy5zdG9yZVNoaXBwaW5nTWV0aG9kLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICdzaGlwbWVudFVVSUQnOiAkKHRoaXMpLmF0dHIoXCJkYXRhLXV1aWRcIiksXG4gICAgICAgICAgICAgICAgJ3NoaXBwaW5nTWV0aG9kSUQnIDogJCh0aGlzKS52YWwoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHR5cGU6IFwiUE9TVFwiXG4gICAgICAgIH07XG4gICAgICAgICQuYWpheCggb3B0aW9ucyApLmRvbmUoZnVuY3Rpb24oZGF0YSl7XG5cbiAgICAgICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVTdW1tYXJ5KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vYmluZCBhZGQgYWRkcmVzcyBpbiBtdWx0aXNoaXBwaW5nXG4gICAgJChcImEuYWRkcmVzcy1lZGl0LCBhLmFkZHJlc3MtY3JlYXRlXCIpLm9uKFwiY2xpY2tcIixmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIGFuY2hvciA9ICQodGhpcyk7XG4gICAgICAgIHZhciB1cmwgPSBhbmNob3IuYXR0cihcImhyZWZcIik7XG4gICAgICAgIHZhciB0aXRsZSA9IGFuY2hvci5hdHRyKFwidGl0bGVcIik7XG4gICAgICAgIGlmKGFuY2hvci5oYXNDbGFzcyhcImVkaXRcIikpIHtcbiAgICAgICAgICAgIHZhciBhZGRyZXNzSUQgPSBhbmNob3IucGFyZW50cyhcInRkLnNoaXBwaW5nYWRkcmVzc1wiKS5maW5kKFwiLnNlbGVjdGJveFwiKS52YWwoKTtcbiAgICAgICAgICAgIGlmKCFhZGRyZXNzSUQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cmwgPSB1dGlsLmFwcGVuZFBhcmFtVG9VUkwodXJsLCBcImFkZHJlc3NJRFwiLCBhZGRyZXNzSUQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaWFsb2dXaWR0aCA9ICh3aW5kb3cuaW5uZXJXaWR0aCA8PSA2NjgpID8gKHdpbmRvdy5pbm5lcldpZHRoKS50b1N0cmluZygpIDogJzY2OCc7XG4gICAgICAgIHZhciBvcHRpb25zID0ge29wZW46IGluaXRpYWxpemVBZGRyZXNzRm9ybSwgZGlhbG9nQ2xhc3M6J2NoZWNrb3V0LXBvcHVwJywgd2lkdGg6IGRpYWxvZ1dpZHRoLTQwfTtcbiAgICAgICAgZGlhbG9nLm9wZW4oe3VybDp1cmwsIG9wdGlvbnM6b3B0aW9uc30pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICAkKFwiLnNoaXBwaW5nYWRkcmVzcyAudXNlci1sb2dpbi1ob3B1cFwiKS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgJCgnaHRtbCwgYm9keScpLmFuaW1hdGUoe3Njcm9sbFRvcDogMH0sIDIwMCk7XG4gICAgfSk7XG5cbiAgICAvL3ByZXZlbnQgY2hlY2tvdXQgaWYgbWlzc2luZyBhZGRyZXNzIG9yIGRyb3BzaGlwL2hhem1hdCBzaGlwbWVudHMgb3V0c2lkZSBVUyBldmVuIGlmIHZhbGlkYXRlZCBhZGRyZXNzXG4gICAgZnVuY3Rpb24gaXNGb3JtQXZhaWxhYmxlRm9yQ2hlY2tvdXQoc2hvd0Vycm9yKSB7XG4gICAgICAgIHZhciBtaXNzaW5nQWRkcmVzcyA9IGZhbHNlO1xuICAgICAgICB2YXIgaXNIYXptYXQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGlzRHJvcHNoaXAgPSBmYWxzZTtcbiAgICAgICAgJChzaGlwcGluZ0FkZHJlc3NMaXN0cykuZWFjaChmdW5jdGlvbihpbmRleCl7XG4gICAgICAgICAgICBpZih0aGlzLmNsYXNzTGlzdC5jb250YWlucygncGlja3VwJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFkZHJlc3NJRCA9ICQodGhpcykuZmluZChcIi5zZWxlY3Rib3hcIikudmFsKCk7XG4gICAgICAgICAgICBpZighYWRkcmVzc0lEKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZ0FkZHJlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmKHNob3dFcnJvciA9PSB0cnVlKXtcbiAgICAgICAgICAgICAgICBcdCQodGhpcykuZmluZChcIi5hZGRyZXNzLWVycm9yXCIpLnJlbW92ZUNsYXNzKFwidmlzdWFsbHktaGlkZGVuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9kZXRlcm1pbmUgaWYgdHJ5aW5nIHRvIHNlbmQgaGF6bWF0L2Ryb3BzaGlwIHRvIGltcHJvcGVyIGFkZHJlc3Mgb3V0c2lkZSBVU1xuICAgICAgICAgICAgdmFyIGJhZGFkZHJlc3MgPSAkKHRoaXMpLmZpbmQoXCIubm9zaGlwLWVycm9yXCIpLmhhc0NsYXNzKFwidmlzdWFsbHktaGlkZGVuXCIpO1xuICAgICAgICAgICAgaWYoIWJhZGFkZHJlc3Mpe1xuICAgICAgICAgICAgICAgIGlzSGF6bWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWlzc2luZ0FkZHJlc3MgfHwgaXNIYXptYXQpe1xuICAgICAgICAgICAgJGNhY2hlLnNhdmUuYXR0cignZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRjYWNoZS5zYXZlLnJlbW92ZUF0dHIoJ2Rpc2FibGVkJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoJGNhY2hlLmNoZWNrb3V0Rm9ybS5oYXNDbGFzcyhcInNoaXBwaW5nLWFkZHJlc3Nlc1wiKSkge1xuICAgICAgICAkY2FjaGUuc2F2ZS5vbihcImNsaWNrXCIsIGlzRm9ybUF2YWlsYWJsZUZvckNoZWNrb3V0KTtcbiAgICB9XG5cbn1cblxuXG5mdW5jdGlvbiBpbml0aWFsaXplQ2FjaGUoKSB7XG4gICAgJGNhY2hlLmNoZWNrb3V0Rm9ybSA9ICQoXCJmb3JtLmFkZHJlc3NcIik7XG4gICAgJGNhY2hlLmNoZWNrb3V0UmVkZXNpZ24gPSAkKCcuY2hlY2tvdXQtcmVkZXNpZ24nKTtcbiAgICAkY2FjaGUuYWRkcmVzc0xpc3QgPSAkY2FjaGUuY2hlY2tvdXRGb3JtLmZpbmQoXCIuc2VsZWN0LWFkZHJlc3Mgc2VsZWN0W2lkJD0nX2FkZHJlc3NMaXN0J11cIik7XG4gICAgJGNhY2hlLmFkZHJlc3NpZCA9ICRjYWNoZS5jaGVja291dEZvcm0uZmluZChcImlucHV0W25hbWUkPSdfYWRkcmVzc2lkJ11cIik7XG4gICAgJGNhY2hlLmZpcnN0TmFtZSA9ICRjYWNoZS5jaGVja291dEZvcm0uZmluZChcImlucHV0W25hbWUkPSdfZmlyc3ROYW1lJ11cIik7XG4gICAgJGNhY2hlLmxhc3ROYW1lID0gJGNhY2hlLmNoZWNrb3V0Rm9ybS5maW5kKFwiaW5wdXRbbmFtZSQ9J19sYXN0TmFtZSddXCIpO1xuICAgICRjYWNoZS5hZGRyZXNzMSA9ICRjYWNoZS5jaGVja291dEZvcm0uZmluZChcImlucHV0W25hbWUkPSdfYWRkcmVzczEnXVwiKTtcbiAgICAkY2FjaGUuYWRkcmVzczIgPSAkY2FjaGUuY2hlY2tvdXRGb3JtLmZpbmQoXCJpbnB1dFtuYW1lJD0nX2FkZHJlc3MyJ11cIik7XG4gICAgJGNhY2hlLmNpdHkgPSAkY2FjaGUuY2hlY2tvdXRGb3JtLmZpbmQoXCJpbnB1dFtuYW1lJD0nX2NpdHknXVwiKTtcbiAgICAkY2FjaGUucG9zdGFsQ29kZSA9ICRjYWNoZS5jaGVja291dEZvcm0uZmluZChcImlucHV0W25hbWUkPSdfemlwJ11cIik7XG4gICAgJGNhY2hlLnBob25lID0gJGNhY2hlLmNoZWNrb3V0Rm9ybS5maW5kKFwiaW5wdXRbbmFtZSQ9J19waG9uZSddXCIpO1xuICAgICRjYWNoZS5jb3VudHJ5Q29kZSA9ICRjYWNoZS5jaGVja291dEZvcm0uZmluZChcInNlbGVjdFtpZCQ9J19jb3VudHJ5J11cIik7XG4gICAgJGNhY2hlLnN0YXRlQ29kZSA9ICRjYWNoZS5jaGVja291dEZvcm0uZmluZChcInNlbGVjdFtpZCQ9J19zdGF0ZSddXCIpO1xuICAgICRjYWNoZS5hZGRUb0FkZHJlc3NCb29rID0gJGNhY2hlLmNoZWNrb3V0Rm9ybS5maW5kKFwiaW5wdXRbbmFtZSQ9J19hZGRUb0FkZHJlc3NCb29rJ11cIik7XG4gICAgJGNhY2hlLnNpbmdsZVNoaXBtZW50QWRkID0gZmFsc2U7XG4gICAgaWYgKCRjYWNoZS5jaGVja291dEZvcm0uaGFzQ2xhc3MoXCJjaGVja291dC1zaGlwcGluZ1wiKSkge1xuICAgICAgICAvLyBzaGlwcGluZyBvbmx5XG4gICAgICAgICRjYWNoZS51c2VGb3JCaWxsaW5nID0gJGNhY2hlLmNoZWNrb3V0Rm9ybS5maW5kKFwiaW5wdXRbbmFtZSQ9J191c2VBc0JpbGxpbmdBZGRyZXNzJ11cIik7XG4gICAgICAgICRjYWNoZS5naWZ0TWVzc2FnZSA9ICRjYWNoZS5jaGVja291dEZvcm0uZmluZChcIi5naWZ0LW1lc3NhZ2UtdGV4dFwiKTtcbiAgICAgICAgJGNhY2hlLnNoaXBwaW5nTWV0aG9kTGlzdCA9ICQoXCIjc2hpcHBpbmctbWV0aG9kLWxpc3RcIik7XG4gICAgICAgICRjYWNoZS5zYXZlID0gJGNhY2hlLmNoZWNrb3V0Rm9ybS5maW5kKFwiYnV0dG9uW25hbWUkPSdfc2hpcHBpbmdBZGRyZXNzX3NhdmUnXVwiKTtcbiAgICAgICAgJGNhY2hlLnNoaXBwaW5nRW1haWxMaXN0ID0gJGNhY2hlLmNoZWNrb3V0Rm9ybS5maW5kKFwiaW5wdXRbbmFtZSQ9J19lbWFpbExpc3RzX2tzcCddXCIpO1xuICAgICAgICAkY2FjaGUuc2F2ZUluZm8gPSAkY2FjaGUuY2hlY2tvdXRGb3JtLmZpbmQoXCJpbnB1dFtuYW1lJD0nX3NhdmVJbmZvJ11cIik7XG4gICAgICAgICRjYWNoZS5zYXZlSW5mb1Bhc3N3b3JkID0gJGNhY2hlLmNoZWNrb3V0Rm9ybS5maW5kKFwiLnBhc3N3b3JkLWlucHV0XCIpO1xuICAgICAgICAkY2FjaGUuZW1haWwgPSAkY2FjaGUuY2hlY2tvdXRGb3JtLmZpbmQoXCJpbnB1dFtuYW1lJD0nX2VtYWlsQWRkcmVzcyddXCIpO1xuICAgICAgICAkY2FjaGUuc2luZ2xlU2hpcG1lbnQgPSAkKCcuc2luZ2xlLXNoaXBtZW50Jyk7XG4gICAgfVxuICAgIGlmICgkY2FjaGUuY2hlY2tvdXRGb3JtLmhhc0NsYXNzKFwic2hpcHBpbmctYWRkcmVzc2VzXCIpKSB7XG4gICAgICAgICRjYWNoZS5zYXZlID0gJGNhY2hlLmNoZWNrb3V0Rm9ybS5maW5kKFwiYnV0dG9uW25hbWUkPSdfYWRkcmVzc1NlbGVjdGlvbl9zYXZlJ11cIik7XG4gICAgfVxuICAgIGlmICgkY2FjaGUuY2hlY2tvdXRGb3JtLmhhc0NsYXNzKFwibXVsdGlzaGlwLWRlbGl2ZXJ5LWZvcm1cIikpIHtcbiAgICAgICAgJGNhY2hlLnNhdmUgPSAkY2FjaGUuY2hlY2tvdXRGb3JtLmZpbmQoXCJidXR0b25bbmFtZSQ9J19zaGlwcGluZ09wdGlvbnNfc2F2ZSddXCIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZUV2ZW50cygpIHtcbiAgICBzaGlwcGluZ0xvYWQoKTtcbn1cbmZ1bmN0aW9uIHNldEdpZnROb3RlKGdpZnROb3RlLCB2YWwpIHtcbiAgICB2YXIgbXNnVHh0ID0gZ2lmdE5vdGUuZmluZCgnLnRleHRhcmVhY29udGFpbmVyJyk7XG5cbiAgICBpZiAodmFsICE9PSAncGVyc29uYWxpemVkZ2lmdG5vdGUnICYmIHZhbCAhPT0gJ2JsYW5rZ2lmdG5vdGUnKSB7XG4gICAgICAgIG1zZ1R4dC5hZGRDbGFzcygnaGlkZScpO1xuICAgICAgICAkKG1zZ1R4dCkuZmluZCgndGV4dGFyZWEnKS5ibHVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbXNnVHh0LnJlbW92ZUNsYXNzKCdoaWRlJyk7XG4gICAgICAgICQobXNnVHh0KS5maW5kKCd0ZXh0YXJlYScpLmZvY3VzKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplTXVsdGlHaWZ0T3B0aW9ucyhmb3JtKSB7XG5cbiAgICBmb3JtLmZpbmQoJy5naWZ0LW5vdGUnKS5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBtZXNzYWdlUmFkaW9WYWwgPSAkKHRoaXMpLmZpbmQoJ2lucHV0W25hbWUkPVwiX2dpZnRNZXNzYWdlT3B0aW9uXCJdOmNoZWNrZWQnKS52YWwoKTtcbiAgICAgICAgc2V0R2lmdE5vdGUoJCh0aGlzKSwgbWVzc2FnZVJhZGlvVmFsKTtcbiAgICB9KTtcblxuICAgIGZvcm0ub24oJ2NoYW5nZScsICdpbnB1dFtuYW1lJD1cIl9naWZ0TWVzc2FnZU9wdGlvblwiXScsIGZ1bmN0aW9uKGUpe1xuICAgICAgICB2YXIgZ2lmdE5vdGUgPSAkKHRoaXMpLmNsb3Nlc3QoJy5naWZ0LW5vdGUnKTtcbiAgICAgICAgc2V0R2lmdE5vdGUoZ2lmdE5vdGUsICQodGhpcykudmFsKCkpO1xuICAgIH0pXG4gICAgLm9uKCdjaGFuZ2UnLCAnaW5wdXRbbmFtZSQ9XCJfaGFzR2lmdFdyYXBcIl0nLCBmdW5jdGlvbihlKXtcbiAgICAgICAgdmFyIGdpZnRXcmFwID0gJCh0aGlzKS5jbG9zZXN0KCcuZ2lmdC13cmFwJyk7XG4gICAgICAgIGlmICgkKHRoaXMpLnByb3AoJ2NoZWNrZWQnKSkge1xuICAgICAgICAgICAgZ2lmdFdyYXAuZmluZCgnaW5wdXQud3JhcHBpbmcnKS5jbGljaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2lmdFdyYXAuZmluZCgnaW5wdXQubm93cmFwcGluZycpLmNsaWNrKCk7XG4gICAgICAgIH1cbiAgICB9KVxuICAgIC5vbignY2hhbmdlJywgJ2lucHV0W25hbWUkPVwiX2hhc05vdGVcIl0nLCBmdW5jdGlvbihlKXtcbiAgICAgICAgdmFyIGdpZnROb3RlID0gJCh0aGlzKS5jbG9zZXN0KCcuZ2lmdC1ub3RlJyk7XG4gICAgICAgIGlmICgkKHRoaXMpLnByb3AoJ2NoZWNrZWQnKSkge1xuICAgICAgICAgICAgZ2lmdE5vdGUuZmluZCgnaW5wdXQjcGVyc29uYWxpemVkZ2lmdG5vdGUnKS5jbGljaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2lmdE5vdGUuZmluZCgnaW5wdXQjbm9naWZ0bm90ZScpLmNsaWNrKCk7XG4gICAgICAgIH1cbiAgICB9KVxuICAgIC5vbignY2xpY2snLCAnYnV0dG9uW3R5cGU9XCJzdWJtaXRcIl0nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAvLyBSZXBsYWNlIGxpbmUgYnJlYWtzIHdpdGggc3BhY2VzXG4gICAgICAgIGZvcm0uZmluZCgnLmdpZnRtZXNzYWdlJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAgICAgICAkdGhpcy52YWwoJHRoaXMudmFsKCkucmVwbGFjZSgvXFxuL2csICcgJykpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTZWxlY3QgcmFkaW8gYnV0dG9uICdibGFua2dpZnRub3RlJyBpZiB0aGUgdGV4dGFyZWEoJy5naWZ0bWVzc2FnZScpIGlzIGVtcHR5XG4gICAgICAgIGZvcm0uZmluZCgnLmdpZnRtZXNzYWdlJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAgICAgICB2YXIgJHBhcmVudCA9ICR0aGlzLnBhcmVudHMoJy5naWZ0LW5vdGUnKTtcbiAgICAgICAgICAgIHZhciAkY2hlY2tib3ggPSAkcGFyZW50LmZpbmQoJ2lucHV0W25hbWUkPV9naWZ0b3B0aW9uc19oYXNOb3RlXScpO1xuXG4gICAgICAgICAgICBpZiAoJHRoaXMudmFsKCkgPT0gJycgJiYgJGNoZWNrYm94LmlzKCc6Y2hlY2tlZCcpKSB7XG4gICAgICAgICAgICAgICAgJHBhcmVudC5maW5kKCdpbnB1dFtpZD1ibGFua2dpZnRub3RlXScpLnByb3AoJ2NoZWNrZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9ybS5zdWJtaXQoKTtcbiAgICB9KTtcblxuICAgIHZhbGlkYXRvci5pbml0Rm9ybShmb3JtKTtcbiAgICAvLyBhcHAudXRpbC5saW1pdENoYXJhY3RlcnMoKTsgLy9UT0RPXG59XG5cbmZ1bmN0aW9uIGluaXRHaWZ0SG9wdXBNUygpIHtcblxuICAgICQoJy5lZGl0LWFsbC1naWZ0cycpLm9uKCdjbGljaycsICcuZ2lmdC1jaGVjaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgZGlhbG9nV2lkdGggPSAod2luZG93LmlubmVyV2lkdGggPCA3NjgpID8gKHdpbmRvdy5pbm5lcldpZHRoIC0gNDApLnRvU3RyaW5nKCkgOiAnNzIwJztcbiAgICAgICAgZGlhbG9nLmNyZWF0ZSh7XG4gICAgICAgICAgICB0YXJnZXQ6ICQoJyNnaWZ0LW9wdGlvbnMtZGlhbG9nJyksXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGRpYWxvZ1dpZHRoLFxuICAgICAgICAgICAgICAgIHRpdGxlOiAnJyxcbiAgICAgICAgICAgICAgICBkaWFsb2dDbGFzczogJ2dpZnQtb3B0aW9ucy1jb250YWluZXInLFxuICAgICAgICAgICAgICAgIGF1dG9PcGVuOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBhcHAuYWpheC5sb2FkKHtcbiAgICAgICAgICAgIHVybDogYXBwLnV0aWwuYWpheFVybCggJCh0aGlzKS5hdHRyKCdyZWwnKSApLFxuICAgICAgICAgICAgdGFyZ2V0OiAkKCcjZ2lmdC1vcHRpb25zLWRpYWxvZycpLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemVNdWx0aUdpZnRPcHRpb25zKCQoJyNlZGl0LWdpZnRvcHRpb25zLWZvcm0nKSk7XG4gICAgICAgICAgICAgICAgJCgnI2dpZnQtb3B0aW9ucy1kaWFsb2cnKS5kaWFsb2coJ29wZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cblxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uIHNob3dzIGdpZnQgbWVzc2FnZSBib3ggaW4gbXVsdGlzaGlwLCBhbmQgaWYgdGhlIHBhZ2UgaXMgdGhlIG11bHRpIHNoaXBwaW5nIGFkZHJlc3MgcGFnZSBpdCB3aWxsIGNhbGwgaW5pdG11bHRpc2hpcHNoaXBhZGRyZXNzKCkgdG8gaW5pdGlhbGl6ZSB0aGUgZm9ybVxuICovXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaW5pdGlhbGl6ZUNhY2hlKCk7XG4gICAgaW5pdGlhbGl6ZUV2ZW50cygpO1xuICAgIGluaXRHaWZ0SG9wdXBNUygpO1xufTtcbiIsImV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpbml0aWFsaXplRXZlbnRzKCk7XG4gICAgdmFyIHBhc3N3b3JkID0gJCgnLmlucHV0LXRleHQucGFzc3dvcmQnKTtcbiAgICBmdW5jdGlvbiBpbml0aWFsaXplRXZlbnRzKCkge1xuXG4gICAgICAgIGVtYWlsQWNjb3VudExvb2t1cFByb2Nlc3MoKTtcblxuICAgICAgICAvKiBEaXNhYmxlIG9yIEVuYWJsZSB0aGUgQ29uZmlybSBidXR0b24gKi9cbiAgICAgICAgdmFyICRyZWdpc3RlckZvcm0gPSAkKCcjUmVnaXN0cmF0aW9uRm9ybScpLFxuICAgICAgICAgICAgJHJlZ2lzdGVyRm9ybUNvbmZpcm1CdXR0b24gPSAkcmVnaXN0ZXJGb3JtLmZpbmQoJ1tuYW1lJD1wcm9maWxlX2NvbmZpcm1dJyk7XG4gICAgICAgICRyZWdpc3RlckZvcm0uZmluZCgnaW5wdXQnKS5vbignYmx1cicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpc1ZhbGlkID0gJHJlZ2lzdGVyRm9ybS52YWxpZGF0ZSgpLmNoZWNrRm9ybSgpO1xuICAgICAgICAgICAgaWYgKGlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAkcmVnaXN0ZXJGb3JtLnZhbGlkKCk7XG4gICAgICAgICAgICAgICAgJHJlZ2lzdGVyRm9ybUNvbmZpcm1CdXR0b24ucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHJlZ2lzdGVyRm9ybUNvbmZpcm1CdXR0b24uYXR0cignZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gT3JkZXIgY29uZmlybWF0aW9uIGRldGFpbHMgdG9nZ2xlXG4gICAgICAgICQoZG9jdW1lbnQpLm9uKCdjbGljaycsICcuanMtb3JkZXJjb25maXJtYXRpb24tZGV0YWlscy10b2dnbGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciAkb3JkZXJEZXRhaWxzID0gJCh0aGlzKS5jbG9zZXN0KCcuanMtb3JkZXItZGV0YWlscy1jb250YWluZXInKTtcbiAgICAgICAgICAgIGlmICgkb3JkZXJEZXRhaWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgJG9yZGVyRGV0YWlsc0JvZHkgPSAkb3JkZXJEZXRhaWxzLmZpbmQoJy5qcy1vcmRlci1kZXRhaWxzLWJvZHknKTtcbiAgICAgICAgICAgICAgICBpZiAoJG9yZGVyRGV0YWlscy5oYXNDbGFzcygnZXhwYW5kZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAkb3JkZXJEZXRhaWxzQm9keS5zbGlkZVVwKDMwMCk7XG4gICAgICAgICAgICAgICAgICAgICRvcmRlckRldGFpbHMucmVtb3ZlQ2xhc3MoJ2V4cGFuZGVkJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJG9yZGVyRGV0YWlsc0JvZHkuc2xpZGVEb3duKDMwMCk7XG4gICAgICAgICAgICAgICAgICAgICRvcmRlckRldGFpbHMuYWRkQ2xhc3MoJ2V4cGFuZGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbWFpbEFjY291bnRMb29rdXBQcm9jZXNzKCkge1xuICAgICAgICB2YXIgJGVtYWlsQWNjb3VudExvb2t1cCA9ICQoJy5lbWFpbGFjY291bnRsb29rdXAnKTtcblxuICAgICAgICAvLyBJZiBub3QgYWxyZWFkeSBhbiBlcnJvciBhbmQgaGFzIHNvbWUgZGF0YVxuICAgICAgICBpZiAoJGVtYWlsQWNjb3VudExvb2t1cC5sZW5ndGggPiAwICYmICEkZW1haWxBY2NvdW50TG9va3VwLmhhc0NsYXNzKCdlcnJvcicpXG4gICAgICAgICAgICAmJiAkZW1haWxBY2NvdW50TG9va3VwLnZhbCgpLmxlbmd0aCA+IDMpe1xuXG4gICAgICAgICAgICB2YXIgZW1haWxUb0xvb2t1cCA9ICRlbWFpbEFjY291bnRMb29rdXAudmFsKCk7XG4gICAgICAgICAgICB2YXIgZW1haWxBY2NvdW50TG9va3VwTmFtZSA9ICRlbWFpbEFjY291bnRMb29rdXAuYXR0cignbmFtZScpO1xuXG4gICAgICAgICAgICBwYXJhbXMgPSB7ZW1haWwgOiBlbWFpbFRvTG9va3VwfTtcbiAgICAgICAgICAgIGFwcC5hamF4LmdldEpzb24oe1xuICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgICAgIHVybDogVXJscy5BY2NvdW50TG9naW5DaGVjayxcbiAgICAgICAgICAgICAgICBkYXRhOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGRhdGEgJiYgZGF0YS5zdWNjZXNzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVtYWlsIEFscmVhZHkgRXhpc3RzXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsaWRhdG9yID0gJCggXCIjUmVnaXN0cmF0aW9uRm9ybVwiICkudmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JbZW1haWxBY2NvdW50TG9va3VwTmFtZV0gPSBSZXNvdXJjZXMuSU5WQUxJRF9VU0VSTkFNRVRBS0VOO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yLnNob3dFcnJvcnMoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWpheCA9IHJlcXVpcmUoJy4uLy4uL2FqYXgnKSxcblx0ZGlhbG9nID0gcmVxdWlyZSgnLi4vLi4vZGlhbG9nJyksXG5cdHN0aWNreUNhcnQgPSByZXF1aXJlKCcuLi8uLi9zdGlja3ljYXJ0JyksXG4gICAgZm9ybVByZXBhcmUgPSByZXF1aXJlKCcuL2Zvcm1QcmVwYXJlJyksXG4gICAgcHJvZ3Jlc3MgPSByZXF1aXJlKCcuLi8uLi9wcm9ncmVzcycpLFxuICAgIHRvb2x0aXAgPSByZXF1aXJlKCcuLi8uLi90b29sdGlwJyksXG4gICAgdmFsaWRhdG9yID0gcmVxdWlyZSgnLi4vLi4vdmFsaWRhdG9yJyksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKSxcbiAgICBpbmRleCA9IHJlcXVpcmUoJy4vaW5kZXgnKSxcbiAgICBzaGlwcGluZ0ludmVudG9yeSA9IHJlcXVpcmUoJy4uLy4uL3N0b3JlaW52ZW50b3J5L3NoaXBwaW5nJyk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uIE9ubHkgYWxsb3dzIGludGVnZXJzIGZvciB0aGUgY3JlZGl0IGNhcmQgZmllbGRcbiAqIEBwYXJhbSBqUXVlcnkgVGV4dCBCb3ggT2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGFsbG93T25seUludGVnZXJzT24oJHRleHRCb3gpIHtcblx0JHRleHRCb3gua2V5ZG93bihmdW5jdGlvbiAoZSkge1xuXHRcdC8vIFJldHVybiB0cnVlIGlmIGtleSBzdHJva2UgaXMgYSBudW1iZXIuXG5cdFx0Ly8gT3RoZXJ3aXNlLCByZXR1cm4gZmFsc2UuXG4gICAgICAgIHZhciBpc051bWJlciA9IChlLnNoaWZ0S2V5IHx8IChlLmtleUNvZGUgPj0gNDggJiYgZS5rZXlDb2RlIDw9NTcpIHx8IChlLmtleUNvZGUgPj0gOTYgJiYgZS5rZXlDb2RlIDw9MTA1KSk7XG5cblx0XHQvLyBSZXR1cm4gdHJ1ZSBpZiBrZXkgc3Ryb2tlIGlzIGEgYmFja3NwYWNlLCBkZWxldGUsIHRhYiwgZXNjYXBlLCBhbmQvb3IgZW50ZXJcblx0XHQvLyBPdGhlcndpc2UsIHJldHVybiBmYWxzZS5cblx0XHR2YXIgYWxsb3dlZEtleTEgPSAkLmluQXJyYXkoZS5rZXlDb2RlLCBbNDYsIDgsIDksIDI3LCAxMywgMTEwLCAxOTBdKSAhPT0gLTE7XG5cblx0XHQvLyBSZXR1cm4gdHJ1ZSBpZiBrZXkgc3Ryb2tlIGlzIEN0cmwrQSBvciBDb21tYW5kK0Fcblx0XHQvLyBPdGhlcndpc2UsIHJldHVybiBmYWxzZS5cblx0XHR2YXIgYWxsb3dlZEtleTIgPSAoZS5rZXlDb2RlID09PSA2NSAmJiAoZS5jdHJsS2V5ID09PSB0cnVlIHx8IGUubWV0YUtleSA9PT0gdHJ1ZSkpO1xuXG5cdFx0Ly8gUmV0dXJuIHRydWUgaWYga2V5IHN0cm9rZSBpcyBob21lLCBlbmQsIGxlZnQsIHJpZ2h0LCBkb3duLCBvciB1cC5cblx0XHQvLyBPdGhlcndpc2UsIHJldHVybiBmYWxzZS5cblx0XHR2YXIgYWxsb3dlZEtleTMgPSAoZS5rZXlDb2RlID49IDM1ICYmIGUua2V5Q29kZSA8PSA0MCk7XG5cbiAgICAgICAgLy8gRG8gbm90IGRvIGFueXRoaW5nIGlmIHRoZSBjdXJyZW50IGtleSBzdHJva2UgaXMgb25lIG9mIHRoZVxuXHRcdC8vIGFsbG93ZWQga2V5cy5cbiAgICAgICAgaWYgKGFsbG93ZWRLZXkxIHx8IGFsbG93ZWRLZXkyIHx8IGFsbG93ZWRLZXkzKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0Ly8gRG8gbm90IGFsbG93IGtleSBwcmVzcyBpZiB0aGUgdXNlciBpbnB1dCBpcyBub3QgYSBudW1iZXIuXG4gICAgICAgIGlmICghaXNOdW1iZXIpXG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSk7XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgc2hpcHBpbmdNZXRob2RzO1xudmFyICRjaGVja291dEZvcm0gPSAkKCcuY2hlY2tvdXQtc2hpcHBpbmcnKTtcbnZhciAkYXZzQ29udGFpbmVyID0gJChcIiNhdnNEaXZcIik7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAZGVzY3JpcHRpb24gSW5pdGlhbGl6ZXMgZ2lmdCBtZXNzYWdlIGJveCwgaWYgc2hpcG1lbnQgaXMgZ2lmdFxuICovXG5mdW5jdGlvbiBnaWZ0TWVzc2FnZUJveCgpIHtcbiAgICAvLyBzaG93IGdpZnQgbWVzc2FnZSBib3gsIGlmIHNoaXBtZW50IGlzIGdpZnRcbiAgICAkKCcuZ2lmdC1tZXNzYWdlLXRleHQnKS50b2dnbGVDbGFzcygnaGlkZGVuJywgJCgnaW5wdXRbbmFtZSQ9XCJfc2hpcHBpbmdBZGRyZXNzX2lzR2lmdFwiXTpjaGVja2VkJykudmFsKCkgIT09ICd0cnVlJyk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAZGVzY3JpcHRpb24gdXBkYXRlcyB0aGUgb3JkZXIgc3VtbWFyeSBiYXNlZCBvbiBhIHBvc3NpYmx5IHJlY2FsY3VsYXRlZCBiYXNrZXQgYWZ0ZXIgYSBzaGlwcGluZyBwcm9tb3Rpb24gaGFzIGJlZW4gYXBwbGllZFxuICovXG5mdW5jdGlvbiB1cGRhdGVTdW1tYXJ5KCkge1xuICAgIHZhciAkc3VtbWFyeSA9ICQoJyNjaGVja291dC1taW5pLXN1bW1hcnknKTtcblxuICAgIC8vIENvcHkgdGhlIG15IGJhZyBjb250ZW50LlxuICAgIC8vIFRoaXMgaXMgYmVpbmcgZG9uZSBzaW5jZSBTaG9wIFJ1bm5lciBKUyBydW5zIGFmdGVyIGFwcC5qcy5cbiAgICAkKCcjbXktYmFnLWNvbnRlbnQtY29weScpLmh0bWwoJCgnLm15LWJhZy1jb250ZW50JykuY2xvbmUoKSk7XG5cbiAgICAvLyBsb2FkIHRoZSB1cGRhdGVkIHN1bW1hcnkgYXJlYVxuICAgICRzdW1tYXJ5LmxvYWQoVXJscy5zdW1tYXJ5UmVmcmVzaFVSTCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBoaWRlIGVkaXQgc2hpcHBpbmcgbWV0aG9kIGxpbmtcbiAgICAgICAgJHN1bW1hcnkuZmFkZUluKCdmYXN0Jyk7XG4gICAgICAgICRzdW1tYXJ5LmZpbmQoJy5jaGVja291dC1taW5pLWNhcnQgLm1pbmlzaGlwbWVudCAuaGVhZGVyIGEnKS5oaWRlKCk7XG4gICAgICAgICRzdW1tYXJ5LmZpbmQoJy5vcmRlci10b3RhbHMtdGFibGUgLm9yZGVyLXNoaXBwaW5nIC5sYWJlbCBhJykuaGlkZSgpO1xuXG4gICAgICAgIC8vdXBkYXRlIG1pbmljYXJ0IHN1bW1hcnkgb24gbW9iaWxlXG4gICAgICAgIHZhciBvcmRlclZhbHVlID0gJHN1bW1hcnkuZmluZCgnLm9yZGVyLXRvdGFsIC5vcmRlci12YWx1ZScpLmh0bWwoKTtcbiAgICAgICAgdmFyICRtb2JpbGVTdW1tYXJ5ID0gJCgnLmNoZWNrb3V0LW1vYmlsZS1zdW1tYXJ5IGRpdiBkaXYuZmxvYXQtcmlnaHQnKTtcbiAgICAgICAgJG1vYmlsZVN1bW1hcnkuaHRtbChvcmRlclZhbHVlKTtcblxuICAgICAgICAvLyBHZXQgTXkgQmFnJ3MgY29weSBmcm9tIHRoZSBpbml0aWFsIHBhZ2UgbG9hZCwgYW5kIHJlcGxhY2UgdGhlXG4gICAgICAgIC8vIGN1cnJlbnQgTXkgQmFnIHJldHVybmVkIGZyb20gdGhpcyBBSkFYIGNhbGwuXG4gICAgICAgICQoJy5teS1iYWctY29udGVudCcpLnJlcGxhY2VXaXRoKCQoJyNteS1iYWctY29udGVudC1jb3B5JykuaHRtbCgpKTtcbiAgICAgICAgJCgnI215LWJhZy1jb250ZW50LWNvcHknKS5odG1sKCcnKTtcbiAgICAgICAgc3RpY2t5Q2FydC5pbml0KCk7XG4gICAgICAgIGluZGV4LnN0aWNreUJsb2NrKCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAZGVzY3JpcHRpb24gSGVscGVyIG1ldGhvZCB3aGljaCBjb25zdHJ1Y3RzIGEgVVJMIGZvciBhbiBBSkFYIHJlcXVlc3QgdXNpbmcgdGhlXG4gKiBlbnRlcmVkIGFkZHJlc3MgaW5mb3JtYXRpb24gYXMgVVJMIHJlcXVlc3QgcGFyYW1ldGVycy5cbiAqL1xuZnVuY3Rpb24gZ2V0U2hpcHBpbmdNZXRob2RVUkwodXJsLCBleHRyYVBhcmFtcykge1xuICAgIHZhciAkZm9ybSA9ICQoJy5hZGRyZXNzJyk7XG4gICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgYWRkcmVzczE6ICgkZm9ybS5maW5kKCdpbnB1dFtuYW1lJD1cIl9hZGRyZXNzMVwiXScpLmxlbmd0aCkgPyAkZm9ybS5maW5kKCdpbnB1dFtuYW1lJD1cIl9hZGRyZXNzMVwiXScpLnZhbCgpIDogJycsXG4gICAgICAgIGFkZHJlc3MyOiAoJGZvcm0uZmluZCgnaW5wdXRbbmFtZSQ9XCJfYWRkcmVzczJcIl0nKS5sZW5ndGgpID8gJGZvcm0uZmluZCgnaW5wdXRbbmFtZSQ9XCJfYWRkcmVzczJcIl0nKS52YWwoKSA6ICcnLFxuICAgICAgICBjb3VudHJ5Q29kZTogKCRmb3JtLmZpbmQoJ3NlbGVjdFtpZCQ9XCJfY291bnRyeVwiXScpLmxlbmd0aCkgPyAkZm9ybS5maW5kKCdzZWxlY3RbaWQkPVwiX2NvdW50cnlcIl0nKS52YWwoKSA6ICcnLFxuICAgICAgICBzdGF0ZUNvZGU6ICgkZm9ybS5maW5kKCdzZWxlY3RbaWQkPVwiX3N0YXRlXCJdLCBpbnB1dFtpZCQ9XCJfc3RhdGVcIl0nKS5sZW5ndGgpID8gJGZvcm0uZmluZCgnc2VsZWN0W2lkJD1cIl9zdGF0ZVwiXSwgaW5wdXRbaWQkPVwiX3N0YXRlXCJdJykudmFsKCkgOiAnJyxcbiAgICAgICAgcG9zdGFsQ29kZTogKCRmb3JtLmZpbmQoJ2lucHV0W25hbWUkPVwiX3ppcFwiXScpLmxlbmd0aCkgPyAkZm9ybS5maW5kKCdpbnB1dFtuYW1lJD1cIl96aXBcIl0nKS52YWwoKSA6ICcnLFxuICAgICAgICBjaXR5OiAoJGZvcm0uZmluZCgnaW5wdXRbbmFtZSQ9XCJfY2l0eVwiXScpLmxlbmd0aCkgPyAkZm9ybS5maW5kKCdpbnB1dFtuYW1lJD1cIl9jaXR5XCJdJykudmFsKCkgOiAnJ1xuICAgIH07XG4gICAgcmV0dXJuIHV0aWwuYXBwZW5kUGFyYW1zVG9VcmwodXJsLCAkLmV4dGVuZChwYXJhbXMsIGV4dHJhUGFyYW1zKSk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAZGVzY3JpcHRpb24gc2VsZWN0cyBhIHNoaXBwaW5nIG1ldGhvZCBmb3IgdGhlIGRlZmF1bHQgc2hpcG1lbnQgYW5kIHVwZGF0ZXMgdGhlIHN1bW1hcnkgc2VjdGlvbiBvbiB0aGUgcmlnaHQgaGFuZCBzaWRlXG4gKiBAcGFyYW1cbiAqL1xuZnVuY3Rpb24gc2VsZWN0U2hpcHBpbmdNZXRob2Qoc2hpcHBpbmdNZXRob2RJRCkge1xuICAgIC8vIG5vdGhpbmcgZW50ZXJlZFxuICAgIGlmICghc2hpcHBpbmdNZXRob2RJRCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGF0dGVtcHQgdG8gc2V0IHNoaXBwaW5nIG1ldGhvZFxuICAgIHZhciB1cmwgPSBnZXRTaGlwcGluZ01ldGhvZFVSTChVcmxzLnNlbGVjdFNoaXBwaW5nTWV0aG9kc0xpc3QsIHtzaGlwcGluZ01ldGhvZElEOiBzaGlwcGluZ01ldGhvZElEfSk7XG4gICAgYWpheC5nZXRKc29uKHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdXBkYXRlU3VtbWFyeSgpO1xuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLnNoaXBwaW5nTWV0aG9kSUQpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWxlcnQoJ0NvdWxkblxcJ3Qgc2VsZWN0IHNoaXBwaW5nIG1ldGhvZC4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkaXNwbGF5IHByb21vdGlvbiBpbiBVSSBhbmQgdXBkYXRlIHRoZSBzdW1tYXJ5IHNlY3Rpb24sXG4gICAgICAgICAgICAvLyBpZiBzb21lIHByb21vdGlvbnMgd2VyZSBhcHBsaWVkXG4gICAgICAgICAgICAkKCcuc2hpcHBpbmdwcm9tb3Rpb25zJykuZW1wdHkoKTtcblxuXG4gICAgICAgICAgICAvLyBpZiAoZGF0YS5zaGlwcGluZ1ByaWNlQWRqdXN0bWVudHMgJiYgZGF0YS5zaGlwcGluZ1ByaWNlQWRqdXN0bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gICAgIHZhciBsZW4gPSBkYXRhLnNoaXBwaW5nUHJpY2VBZGp1c3RtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAvLyAgICAgZm9yICh2YXIgaT0wOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgdmFyIHNwYSA9IGRhdGEuc2hpcHBpbmdQcmljZUFkanVzdG1lbnRzW2ldO1xuICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBcdFx0XHRcdFx0XHRcdFx0XHRcdE5FV1NMRVRURVIgU1VCU0NSSVBUSU9OXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIHNldEtTTmV3c2xldHRlckNoZWNrQm94KCkge1xuXHQvLyBHZXQgdGhlIGZvbGxvd2luZyBmb3JtIGZpZWxkIHZhbHVlcy5cblx0dmFyIGVtYWlsID0gICAkKCcuZW1haWwtcm93JykuZmluZCgnaW5wdXRbdHlwZT10ZXh0XScpLnZhbCgpO1xuXHR2YXIgY291bnRyeSA9ICQoJ3NlbGVjdC5zZWxlY3QtZmllbGRjb3VudHJ5IG9wdGlvbjpzZWxlY3RlZCcpLnRleHQoKTtcblx0dmFyIHN1YnNjcmliZSA9ICQoJy5zdWJzY3JpYmUtcm93JykuZmluZCgnaW5wdXRbdHlwZT1jaGVja2JveF0nKS5pcygnOmNoZWNrZWQnKTtcblxuXHQvLyBSUi0yMzE6XG5cdC8vIFx0LSBEZWZhdWx0IHN1YnNjcmliZSBjaGVja2JveCB0byBjaGVja2VkIGZvciBhbnkgY291bnRyeSB0aGF0XG5cdC8vIFx0ICBpcyBOT1QgQ2FuYWRhLlxuXHQvLyBcdC0gT3RoZXJ3aXNlLCBkZWZhdWx0IHRoZSBzdWJzY3JpYmUgY2hlY2tib3ggdG8gTk9UIENIRUNLRUQuXG5cblx0aWYoY291bnRyeS50b0xvd2VyQ2FzZSgpICE9IFwiY2FuYWRhXCIpIHtcblx0XHQvLyBEZWZhdWx0IHRoZSBzdWJjcmliZSB0byBuZXdzbGV0dGVyIGNoZWNrYm94IHRvIENIRUNLRURcblx0XHQvLyBzaW5jZSB0aGlzIGlzIE5PVCBDYW5hZGEuXG5cdFx0JCgnLnN1YnNjcmliZS1yb3cnKS5maW5kKCdpbnB1dFt0eXBlPWNoZWNrYm94XScpLnByb3AoJ2NoZWNrZWQnLCB0cnVlKTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBEZWZhdWx0IHRoZSBzdWJjcmliZSB0byBuZXdzbGV0dGVyIGNoZWNrYm94IHRvIE5PVCBDSEVDS0VEXG5cdFx0Ly8gc2luY2UgdGhpcyBpcyBDYW5hZGEuXG5cdFx0JCgnLnN1YnNjcmliZS1yb3cnKS5maW5kKCdpbnB1dFt0eXBlPWNoZWNrYm94XScpLnByb3AoJ2NoZWNrZWQnLCBmYWxzZSk7XG5cdH1cbn1cblxuLy9SUi0yMzE6XG4vLyBcdFNldCB0aGUgc3Vic2NyaWJlIGNoZWNrYm94IHRvIENIRUNLRUQgaWYgdGhlIGNvdW50cnkgc2VsZWN0ZWQgb25cbi8vIFx0dGhlIGNoYW5nZSBldmVudCBpcyBOT1QgQ2FuYWRhLlxuLy8gXHRPdGhlcndpc2UsIHNldCBpdCB0byBOT1QgQ0hFQ0tFRC5cblxuJCgnc2VsZWN0LnNlbGVjdC1maWVsZGNvdW50cnknKS5jaGFuZ2UoZnVuY3Rpb24oKSB7XG5cdHNldEtTTmV3c2xldHRlckNoZWNrQm94KCk7XG59KTtcblxuLy8gRU1BSUwgU1VCU0NSSVBUSU9OIC0gT04gRk9STSBTVUJNSVNTSU9OXG5cbiQoJyNkd2ZybV9zaW5nbGVzaGlwcGluZ19zaGlwcGluZ0FkZHJlc3MnKS5zdWJtaXQoZnVuY3Rpb24oKXtcblx0Ly9wdXNoIGVtYWlsIHNpZ251cCB0byBkYXRhTGF5ZXJcblx0aWYgKCQoXCIjZHdmcm1fc2luZ2xlc2hpcHBpbmdfc2hpcHBpbmdBZGRyZXNzX2VtYWlsX2VtYWlsTGlzdHNfa3NwXCIpLmlzKCc6Y2hlY2tlZCcpKSB7XG5cdFx0ZGF0YUxheWVyLnB1c2goe1wiZXZlbnRcIiA6IFwiZW1haWwtc3Vic2NyaWJlXCIsIFwic3Vic2NyaWJlVHlwZVwiOiBcImNoZWNrb3V0XCJ9KTtcblx0fVxufSk7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvbiBNYWtlIGFuIEFKQVggcmVxdWVzdCB0byB0aGUgc2VydmVyIHRvIHJldHJpZXZlIHRoZSBsaXN0IG9mIGFwcGxpY2FibGUgc2hpcHBpbmcgbWV0aG9kc1xuICogYmFzZWQgb24gdGhlIG1lcmNoYW5kaXNlIGluIHRoZSBjYXJ0IGFuZCB0aGUgY3VycmVudGx5IGVudGVyZWQgc2hpcHBpbmcgYWRkcmVzc1xuICogKHRoZSBhZGRyZXNzIG1heSBiZSBvbmx5IHBhcnRpYWxseSBlbnRlcmVkKS4gIElmIHRoZSBsaXN0IG9mIGFwcGxpY2FibGUgc2hpcHBpbmcgbWV0aG9kc1xuICogaGFzIGNoYW5nZWQgYmVjYXVzZSBuZXcgYWRkcmVzcyBpbmZvcm1hdGlvbiBoYXMgYmVlbiBlbnRlcmVkLCB0aGVuIGlzc3VlIGFub3RoZXIgQUpBWFxuICogcmVxdWVzdCB3aGljaCB1cGRhdGVzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgc2hpcHBpbmcgbWV0aG9kIChpZiBuZWVkZWQpIGFuZCBhbHNvIHVwZGF0ZXNcbiAqIHRoZSBVSS5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlU2hpcHBpbmdNZXRob2RMaXN0KCkge1xuICAgIHZhciAkc2hpcHBpbmdNZXRob2RMaXN0ID0gJCgnI3NoaXBwaW5nLW1ldGhvZC1saXN0Jyk7XG4gICAgaWYgKCEkc2hpcHBpbmdNZXRob2RMaXN0IHx8ICRzaGlwcGluZ01ldGhvZExpc3QubGVuZ3RoID09PSAwKSB7IHJldHVybjsgfVxuICAgIHZhciB1cmwgPSBnZXRTaGlwcGluZ01ldGhvZFVSTChVcmxzLnNoaXBwaW5nTWV0aG9kc0pTT04pO1xuXG4gICAgYWpheC5nZXRKc29uKHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNoaXBwaW5nTWV0aG9kcyAmJiBzaGlwcGluZ01ldGhvZHMudG9TdHJpbmcoKSA9PT0gZGF0YS50b1N0cmluZygpKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byB1cGRhdGUgdGhlIFVJLiAgVGhlIGxpc3QgaGFzIG5vdCBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHVwZGF0ZSB0aGUgVUkuICBUaGUgbGlzdCBoYXMgY2hhbmdlZC5cbiAgICAgICAgICAgIC8vIENhY2hlIHRoZSBhcnJheSBvZiByZXR1cm5lZCBzaGlwcGluZyBtZXRob2RzLlxuICAgICAgICAgICAgc2hpcHBpbmdNZXRob2RzID0gZGF0YTtcblxuICAgICAgICAgICAgLy8gbG9hZCB0aGUgc2hpcHBpbmcgbWV0aG9kIGZvcm1cbiAgICAgICAgICAgIHZhciBzbWxVcmwgPSBnZXRTaGlwcGluZ01ldGhvZFVSTChVcmxzLnNoaXBwaW5nTWV0aG9kc0xpc3QpO1xuICAgICAgICAgICAgJHNoaXBwaW5nTWV0aG9kTGlzdC5sb2FkKHNtbFVybCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICRzaGlwcGluZ01ldGhvZExpc3QuZmFkZUluKCdmYXN0Jyk7XG4gICAgICAgICAgICAgICAgLy93ZSBuZWVkIHRvIGRpc2FibGUgY29udGludWUgYnV0dG9uIGlmIHdlIGhhdmUgYW55IHNoaXBwaW5nIHJlc3RyaWN0aW9uXG4gICAgICAgICAgICAgICAgdmFyIHNhdmVTaGlwcGluZ0FkZHJlc3NCdXR0b24gPSAkKCdbbmFtZSQ9XCJfc2hpcHBpbmdBZGRyZXNzX3NhdmVcIl0nKTtcbiAgICAgICAgICAgICAgICBpZiAoZm9ybVByZXBhcmUuaGFzU2hpcHBpbmdNZXRob2RFcnJvcigpKSB7XG4gICAgICAgICAgICAgICAgXHRzYXZlU2hpcHBpbmdBZGRyZXNzQnV0dG9uLmF0dHIoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBcdHNhdmVTaGlwcGluZ0FkZHJlc3NCdXR0b24ucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmViaW5kIHRoZSByYWRpbyBidXR0b25zIG9uY2xpY2sgZnVuY3Rpb24gdG8gYSBoYW5kbGVyLlxuICAgICAgICAgICAgICAgICRzaGlwcGluZ01ldGhvZExpc3QuZmluZCgnW25hbWUkPVwiX3NoaXBwaW5nTWV0aG9kSURcIl0nKS5jbGljayhmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICBcdC8vIEFkZCBhIGNsYXNzIG9mIHJhZGlvLWJ1dHRvbi1zZWxlY3RlZCB0byB0aGUgc2VsZWN0ZWQgcmFkaW8gYnV0dG9uJ3MgZm9ybSByb3cgd3JhcHBlclxuICAgICAgICAgICAgICAgIFx0JCh0aGlzKS5wYXJlbnQoKS5hZGRDbGFzcygncmFkaW8tYnV0dG9uLXNlbGVjdGVkJyk7XG5cbiAgICAgICAgICAgICAgICBcdC8vIFJlbW92ZSB0aGUgY2xhc3Mgb2YgcmFkaW8tYnV0dG9uLXNlbGVjdGVkIG9uIGFsbCB0aGUgbm9uLXNlbGVjdGVkIHJhZGlvIGJ1dHRvbidzIGZvcm0gcm93IHdyYXBwZXIocylcbiAgICAgICAgICAgICAgICBcdCQodGhpcykucGFyZW50KCkuc2libGluZ3MoJ2Rpdi5mb3JtLXJvdycpLnJlbW92ZUNsYXNzKCdyYWRpby1idXR0b24tc2VsZWN0ZWQnKTtcblxuICAgICAgICAgICAgICAgIFx0Ly8gUGFzcyB0aGUgc2VsZWN0ZWQgc2hpcHBpbmcgbWV0aG9kIElEIGludG8gc2VsZWN0U2hpcHBpbmdNZXRob2RcbiAgICAgICAgICAgICAgICAgICBcdHNlbGVjdFNoaXBwaW5nTWV0aG9kKCQodGhpcykudmFsKCkpO1xuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy90cmlnZ2VyIGNvdW50cnkgY2hhbmdlIGV2ZW50IGluIG9yZGVyIHRvIHZhbGlkYXRlIGZvcm0gYW5kIGVuYWJsZSBjb250aW51ZSBidXR0b25cbiAgICAgICAgICAgICAgICAvL2l0IGlzIHJlcXVpcmVkIGZvciBpbnRlcm5hdGlvbmFsIGFkZHJlc3NlcyB3aGVyZSB3ZSBkb24ndCBoYXZlIHN0YXRlL3Byb3ZpbmNlIGRyb3Bkb3duXG4gICAgICAgICAgICAgICAgJCgnZm9ybVtpZCQ9XCJzaW5nbGVzaGlwcGluZ19zaGlwcGluZ0FkZHJlc3NcIl0nKS5maW5kKCdzZWxlY3QuY291bnRyeScpLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgc3VtbWFyeVxuICAgICAgICAgICAgICAgIHVwZGF0ZVN1bW1hcnkoKTtcbiAgICAgICAgICAgICAgICB0b29sdGlwLmluaXQoKTtcbiAgICAgICAgICAgICAgICAvL2lmIG5vdGhpbmcgaXMgc2VsZWN0ZWQgaW4gdGhlIHNoaXBwaW5nIG1ldGhvZHMgc2VsZWN0IHRoZSBmaXJzdCBvbmVcbiAgICAgICAgICAgICAgICBpZiAoJHNoaXBwaW5nTWV0aG9kTGlzdC5maW5kKCcuaW5wdXQtcmFkaW86Y2hlY2tlZCcpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAkc2hpcHBpbmdNZXRob2RMaXN0LmZpbmQoJy5pbnB1dC1yYWRpbzpmaXJzdCcpLnByb3AoJ2NoZWNrZWQnLCAnY2hlY2tlZCcpLnBhcmVudCgpLmFkZENsYXNzKCdyYWRpby1idXR0b24tc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBpbml0UGlja1VwKCkge1xuICAgIHZhciBwaWNrVXBPcHRpb25zID0gJCgnI3BpY2stdXAtb3JkZXItZmllbGRzIC5pbnB1dC1yYWRpbycpLFxuICAgICAgICBwaWNrVXBGaWVsZHMgPSAkKCcjcGljay11cC1vcmRlci1maWVsZHMgLnBpY2stdXAtZmllbGRzJyk7XG5cbiAgICBwaWNrVXBPcHRpb25zLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGVsLnZhbHVlID09PSAnb3RoZXInKSB7XG4gICAgICAgICAgICBwaWNrVXBGaWVsZHMuc2hvdygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGlja1VwRmllbGRzLmhpZGUoKTtcbiAgICAgICAgICAgIHBpY2tVcEZpZWxkcy5maW5kKCdpbnB1dCcpLnZhbCgnJyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvbiBUaGlzIG1ldGhvZCdzIG1haW4gcHVycG9zZSBpcyB0byBzdG9wIHRoZSBmb3JtIHBvc3QgaWYgYW4gaW52YWxpZCBhZGRyZXNzIGhhcyBiZWVuIGVudGVyZWQsIGFuZCBwb3AgdXAgdGhlXG4gKiAgICAgICAgICAgICAgQVZTIE1vZGFsLiBUaGUgQVZTIE1vZGFsIHdpbGwgYWxsb3cgdGhlIHVzZXIgdG8gbW9kaWZ5IHRoZWlyIGFkZHJlc3MuXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF5bWVudE1ldGhvZElEIHRoZSBJRCBvZiB0aGUgcGF5bWVudCBtZXRob2QsIHRvIHdoaWNoIHRoZSBwYXltZW50IG1ldGhvZCBmb3JtIHNob3VsZCBiZSBjaGFuZ2VkIHRvXG4gKi9cbmZ1bmN0aW9uIHNoaXBwaW5nTG9hZCgpIHtcblxuXHRmdW5jdGlvbiBjRXJyb3IoKXtcblx0XHR2YXIgY291bnRyeUVycm9yID0gJCgnc2VsZWN0I2R3ZnJtX3NpbmdsZXNoaXBwaW5nX3NoaXBwaW5nQWRkcmVzc19hZGRyZXNzRmllbGRzX2NvdW50cnknKS5oYXNDbGFzcygnZXJyb3InKTtcblx0XHRyZXR1cm4gY291bnRyeUVycm9yO1xuXHR9XG5cblx0ZnVuY3Rpb24gc0Vycm9yKCl7XG5cdFx0dmFyIHN0YXRlRXJyb3IgPSAkKCdzZWxlY3QjZHdmcm1fc2luZ2xlc2hpcHBpbmdfc2hpcHBpbmdBZGRyZXNzX2FkZHJlc3NGaWVsZHNfc3RhdGVzX3N0YXRlJykuaGFzQ2xhc3MoJ2Vycm9yJyk7XG5cdFx0cmV0dXJuIHN0YXRlRXJyb3I7XG5cdH1cblxuXHRmdW5jdGlvbiBwcmVWYWxpZGF0ZSgpe1xuXHRcdHZhciBwdiA9ICRjaGVja291dEZvcm0udmFsaWRhdGUoKS5mb3JtKCk7XG5cblx0XHRpZihjRXJyb3IoKSl7XG5cdFx0XHQkKCcjZHdmcm1fc2luZ2xlc2hpcHBpbmdfc2hpcHBpbmdBZGRyZXNzX2FkZHJlc3NGaWVsZHNfY291bnRyeScpLmFkZENsYXNzKCdlcnJvcicpO1xuXHRcdFx0JChcImxhYmVsW2Zvcj0nZHdmcm1fc2luZ2xlc2hpcHBpbmdfc2hpcHBpbmdBZGRyZXNzX2FkZHJlc3NGaWVsZHNfY291bnRyeSddXCIpLmluc2VydEFmdGVyKCcjZHdmcm1fc2luZ2xlc2hpcHBpbmdfc2hpcHBpbmdBZGRyZXNzX2FkZHJlc3NGaWVsZHNfY291bnRyeScpO1xuXG5cdFx0fVxuXG5cdFx0aWYoc0Vycm9yKCkpe1xuXHRcdFx0JCgnI2R3ZnJtX3NpbmdsZXNoaXBwaW5nX3NoaXBwaW5nQWRkcmVzc19hZGRyZXNzRmllbGRzX3N0YXRlc19zdGF0ZScpLmFkZENsYXNzKCdlcnJvcicpO1xuXHRcdFx0JChcImxhYmVsW2Zvcj0nZHdmcm1fc2luZ2xlc2hpcHBpbmdfc2hpcHBpbmdBZGRyZXNzX2FkZHJlc3NGaWVsZHNfc3RhdGVzX3N0YXRlJ11cIikucmVtb3ZlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHB2O1xuXHR9XG5cblx0ZnVuY3Rpb24gc2luZ2xlU2hpcHBpbmdWYWxpZGF0ZSgpIHtcblx0XHRpZihwcmVWYWxpZGF0ZSgpKSB7XG5cdFx0XHR2YXIgdXJsID0gIFVybHMudmVyaWZ5QWRkcmVzcztcblx0XHRcdHZhciBkYXRhID0gJGNoZWNrb3V0Rm9ybS5zZXJpYWxpemUoKTtcblx0XHRcdCRhdnNDb250YWluZXIuYXBwZW5kKFwiPGRpdiBpZD1cXFwibmV3QXZzRGl2XFxcIj48L2Rpdj5cIik7XG5cblx0XHRcdHZhciB3aWR0aCA9ICc2MDAnLFxuICAgICAgICAgICAgICAgIGxlZnQgPSAnMCc7XG5cblx0XHRcdGlmICh1dGlsLmlzTW9iaWxlKCkgJiYgd2luZG93LmlubmVyV2lkdGggPCA2MzApIHtcblx0XHRcdCAgICB3aWR0aCA9ICh3aW5kb3cuaW5uZXJXaWR0aCAtIDMwKSArICcnO1xuXHRcdFx0ICAgIGxlZnQgPSAnMTUnO1xuICAgICAgICAgICAgfVxuXG5cdFx0XHR2YXIgb3B0aW9ucyA9IHtcblx0XHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6ICdhdXRvJyxcblx0XHRcdFx0dGl0bGU6JycsXG4gICAgICAgICAgICAgICAgbGVmdDpsZWZ0XG5cdFx0XHR9O1xuXG5cdFx0XHRhamF4LmxvYWQoe1xuXHRcdFx0XHR1cmw6IHVybCxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0dHlwZTpcIlBPU1RcIixcblx0XHRcdFx0Y2FsbGJhY2s6IGZ1bmN0aW9uIChyZXNwKSB7XG5cdFx0XHRcdFx0YXBwLnByb2dyZXNzLmhpZGUoJCh0aGlzKSk7XG5cdFx0XHRcdFx0aWYoJC50cmltKHJlc3ApICE9IFwie31cIikge1xuXHRcdFx0XHRcdFx0JChcIiNhdnNEaXZcIikuaHRtbCgkKFwiI25ld0F2c0RpdlwiKS5odG1sKCkpO1xuXHRcdFx0XHQgICAgICAgIGRpYWxvZy5vcGVuKHtcblx0XHRcdFx0ICAgICAgICAgICAgdXJsOiB1cmwsXG5cdFx0XHRcdCAgICAgICAgICAgIHRhcmdldDogJChcIiNuZXdBdnNEaXZcIiksXG5cdFx0XHRcdCAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcblx0XHRcdFx0ICAgICAgICB9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0JCgnI3ZlcmlmeUJ0bicpLmNsaWNrKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRhcHAucHJvZ3Jlc3MuaGlkZSgkKHRoaXMpKTtcblx0XHR9XG5cdH1cblxuXHQvLyBFeGVjdXRlIG9uIGZvcm0gc3VibWlzc2lvbi5cblx0JCgnI2R3ZnJtX3NpbmdsZXNoaXBwaW5nX3NoaXBwaW5nQWRkcmVzcycpLm9uKFwic3VibWl0XCIsZnVuY3Rpb24oZSkge1xuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblxuXHRcdGlmICghJCh0aGlzKS52YWxpZCgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0c2luZ2xlU2hpcHBpbmdWYWxpZGF0ZSgpO1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9KS5vbignY2hhbmdlJywgJy5pbnB1dC10ZXh0LnBob25lJywgdmFsaWRhdG9yLmZvcm1hdHRlci5waG9uZSk7XG5cdCQoJy5pbnB1dC10ZXh0LnBob25lJykudHJpZ2dlcignY2hhbmdlJyk7XG5cbiAgICAvLyBWYWxpZGF0ZSBwaG9uZSBudW1iZXJcbiAgICAkKCcuaW5wdXQtdGV4dC5waG9uZScpLm9uKCdmb2N1cyBjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICQodGhpcykucGFyZW50KCkuYWRkQ2xhc3MoJ2ZvY3VzZWQnKTtcbiAgICB9KS5vbignYmx1cicsIGZ1bmN0aW9uKCl7XG4gICAgICAgICQodGhpcykucGFyZW50KCkucmVtb3ZlQ2xhc3MoJ2ZvY3VzZWQnKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gc2V0R2lmdE5vdGUoZ2lmdE5vdGUsIHZhbCkge1xuICAgIHZhciBtc2dUeHQgPSBnaWZ0Tm90ZS5maW5kKCcudGV4dGFyZWFjb250YWluZXInKTtcblxuICAgIGlmICh2YWwgIT09ICdwZXJzb25hbGl6ZWRnaWZ0bm90ZScgJiYgdmFsICE9PSAnYmxhbmtnaWZ0bm90ZScpIHtcbiAgICAgICAgbXNnVHh0LmFkZENsYXNzKCdoaWRlJyk7XG4gICAgICAgICQobXNnVHh0KS5maW5kKCd0ZXh0YXJlYScpLmJsdXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtc2dUeHQucmVtb3ZlQ2xhc3MoJ2hpZGUnKTtcbiAgICAgICAgJChtc2dUeHQpLmZpbmQoJ3RleHRhcmVhJykuZm9jdXMoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVNdWx0aUdpZnRPcHRpb25zKGZvcm0pIHtcblxuICAgIGZvcm0uZmluZCgnLmdpZnQtbm90ZScpLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIG1lc3NhZ2VSYWRpb1ZhbCA9ICQodGhpcykuZmluZCgnaW5wdXRbbmFtZSQ9XCJfZ2lmdE1lc3NhZ2VPcHRpb25cIl06Y2hlY2tlZCcpLnZhbCgpO1xuICAgICAgICBzZXRHaWZ0Tm90ZSgkKHRoaXMpLCBtZXNzYWdlUmFkaW9WYWwpO1xuICAgIH0pO1xuXG4gICAgZm9ybS5vbignY2hhbmdlJywgJ2lucHV0W25hbWUkPVwiX2dpZnRNZXNzYWdlT3B0aW9uXCJdJywgZnVuY3Rpb24oZSl7XG4gICAgICAgIHZhciBnaWZ0Tm90ZSA9ICQodGhpcykuY2xvc2VzdCgnLmdpZnQtbm90ZScpO1xuICAgICAgICBzZXRHaWZ0Tm90ZShnaWZ0Tm90ZSwgJCh0aGlzKS52YWwoKSk7XG4gICAgfSlcbiAgICAub24oJ2NoYW5nZScsICdpbnB1dFtuYW1lJD1cIl9oYXNHaWZ0V3JhcFwiXScsIGZ1bmN0aW9uKGUpe1xuICAgICAgICB2YXIgZ2lmdFdyYXAgPSAkKHRoaXMpLmNsb3Nlc3QoJy5naWZ0LXdyYXAnKTtcbiAgICAgICAgaWYgKCQodGhpcykucHJvcCgnY2hlY2tlZCcpKSB7XG4gICAgICAgICAgICBnaWZ0V3JhcC5maW5kKCdpbnB1dC53cmFwcGluZycpLmNsaWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnaWZ0V3JhcC5maW5kKCdpbnB1dC5ub3dyYXBwaW5nJykuY2xpY2soKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgLm9uKCdjaGFuZ2UnLCAnaW5wdXRbbmFtZSQ9XCJfaGFzTm90ZVwiXScsIGZ1bmN0aW9uKGUpe1xuICAgICAgICB2YXIgZ2lmdE5vdGUgPSAkKHRoaXMpLmNsb3Nlc3QoJy5naWZ0LW5vdGUnKTtcbiAgICAgICAgaWYgKCQodGhpcykucHJvcCgnY2hlY2tlZCcpKSB7XG4gICAgICAgICAgICBnaWZ0Tm90ZS5maW5kKCdpbnB1dCNwZXJzb25hbGl6ZWRnaWZ0bm90ZScpLmNsaWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnaWZ0Tm90ZS5maW5kKCdpbnB1dCNub2dpZnRub3RlJykuY2xpY2soKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgLm9uKCdjbGljaycsICdidXR0b25bdHlwZT1cInN1Ym1pdFwiXScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgbGluZSBicmVha3Mgd2l0aCBzcGFjZXNcbiAgICAgICAgZm9ybS5maW5kKCcuZ2lmdG1lc3NhZ2UnKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcbiAgICAgICAgICAgICR0aGlzLnZhbCgkdGhpcy52YWwoKS5yZXBsYWNlKC9cXG4vZywgJyAnKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNlbGVjdCByYWRpbyBidXR0b24gJ2JsYW5rZ2lmdG5vdGUnIGlmIHRoZSB0ZXh0YXJlYSgnLmdpZnRtZXNzYWdlJykgaXMgZW1wdHlcbiAgICAgICAgZm9ybS5maW5kKCcuZ2lmdG1lc3NhZ2UnKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcbiAgICAgICAgICAgIHZhciAkcGFyZW50ID0gJHRoaXMucGFyZW50cygnLmdpZnQtbm90ZScpO1xuICAgICAgICAgICAgdmFyICRjaGVja2JveCA9ICRwYXJlbnQuZmluZCgnaW5wdXRbbmFtZSQ9X2dpZnRvcHRpb25zX2hhc05vdGVdJyk7XG5cbiAgICAgICAgICAgIGlmICgkdGhpcy52YWwoKSA9PSAnJyAmJiAkY2hlY2tib3guaXMoJzpjaGVja2VkJykpIHtcbiAgICAgICAgICAgICAgICAkcGFyZW50LmZpbmQoJ2lucHV0W2lkPWJsYW5rZ2lmdG5vdGVdJykucHJvcCgnY2hlY2tlZCcsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBmb3JtLnN1Ym1pdCgpO1xuICAgIH0pO1xuXG4gICAgdmFsaWRhdG9yLmluaXRGb3JtKGZvcm0pO1xuICAgIC8vIGFwcC51dGlsLmxpbWl0Q2hhcmFjdGVycygpOyAvL1RPRE9cbn1cblxuZnVuY3Rpb24gaW5pdEdpZnRIb3B1cCgpIHtcblxuICAgICQoJy5lZGl0LWFsbC1naWZ0cycpLm9uKCdjbGljaycsICcuZ2lmdC1jaGVjaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgZGlhbG9nV2lkdGggPSAod2luZG93LmlubmVyV2lkdGggPCA3NjgpID8gKHdpbmRvdy5pbm5lcldpZHRoIC0gNDApLnRvU3RyaW5nKCkgOiAnNzIwJztcbiAgICAgICAgZGlhbG9nLmNyZWF0ZSh7XG4gICAgICAgICAgICB0YXJnZXQ6ICQoJyNnaWZ0LW9wdGlvbnMtZGlhbG9nJyksXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGRpYWxvZ1dpZHRoLFxuICAgICAgICAgICAgICAgIHRpdGxlOiAnJyxcbiAgICAgICAgICAgICAgICBkaWFsb2dDbGFzczogJ2dpZnQtb3B0aW9ucy1jb250YWluZXInLFxuICAgICAgICAgICAgICAgIGF1dG9PcGVuOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBhcHAuYWpheC5sb2FkKHtcbiAgICAgICAgICAgIHVybDogYXBwLnV0aWwuYWpheFVybCggJCh0aGlzKS5hdHRyKCdyZWwnKSApLFxuICAgICAgICAgICAgdGFyZ2V0OiAkKCcjZ2lmdC1vcHRpb25zLWRpYWxvZycpLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemVNdWx0aUdpZnRPcHRpb25zKCQoJyNlZGl0LWdpZnRvcHRpb25zLWZvcm0nKSk7XG4gICAgICAgICAgICAgICAgJCgnI2dpZnQtb3B0aW9ucy1kaWFsb2cnKS5kaWFsb2coJ29wZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9ybVByZXBhcmUuaW5pdCh7XG4gICAgICAgIGNvbnRpbnVlU2VsZWN0b3I6ICdbbmFtZSQ9XCJzaGlwcGluZ0FkZHJlc3Nfc2F2ZVwiXScsXG4gICAgICAgIGZvcm1TZWxlY3RvcjonW2lkJD1cInNpbmdsZXNoaXBwaW5nX3NoaXBwaW5nQWRkcmVzc1wiXSdcbiAgICB9KTtcblxuICAgIHNoaXBwaW5nTG9hZCgpO1xuXG4gICAgJCgnaW5wdXRbbmFtZSQ9XCJfc2hpcHBpbmdBZGRyZXNzX2lzR2lmdFwiXScpLm9uKCdjbGljaycsIGdpZnRNZXNzYWdlQm94KTtcblxuICAgICQoJy5hZGRyZXNzJykub24oJ2NoYW5nZScsXG4gICAgICAgICdpbnB1dFtuYW1lJD1cIl9hZGRyZXNzRmllbGRzX2FkZHJlc3MxXCJdLCBpbnB1dFtuYW1lJD1cIl9hZGRyZXNzRmllbGRzX2FkZHJlc3MyXCJdLCBzZWxlY3RbbmFtZSQ9XCJfYWRkcmVzc0ZpZWxkc19zdGF0ZXNfc3RhdGVcIl0sIGlucHV0W25hbWUkPVwiX2FkZHJlc3NGaWVsZHNfY2l0eVwiXSwgaW5wdXRbbmFtZSQ9XCJfYWRkcmVzc0ZpZWxkc196aXBcIl0nLFxuICAgICAgICB1cGRhdGVTaGlwcGluZ01ldGhvZExpc3RcbiAgICApO1xuXG4gICAgJCgnLmNvdW50cnktcm93JykuYWRkQ2xhc3MoXCJoYXMtZmxvYXQtbGFiZWxcIik7XG4gICAgJCgnLnN0YXRlLXJvdycpLmFkZENsYXNzKFwiaGFzLWZsb2F0LWxhYmVsXCIpO1xuXG4gICAgaWYgKCQoJy5zZWxlY3QtYWRkcmVzcycpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgJCgnLnNlbGVjdC1hZGRyZXNzJykuYWRkQ2xhc3MoJ2hhcy1mbG9hdC1sYWJlbCcpO1xuICAgICAgICAkKCcuc2VsZWN0LWFkZHJlc3Mgc2VsZWN0Jykub24oJ2NoYW5nZSBibHVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoISQodGhpcykudmFsKCkpIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLnJlbW92ZUNsYXNzKCd2YWxpZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHZhciAkZm9ybSA9ICQoJ2Zvcm1baWQkPVwic2luZ2xlc2hpcHBpbmdfc2hpcHBpbmdBZGRyZXNzXCJdJyk7XG4gICAgdXRpbC5pbml0WmlwU2VydmljZSgkZm9ybSk7XG4gICAgdmFyICRzdGF0ZUVtcHR5T3B0aW9uRWwgPSAkZm9ybS5maW5kKCcuc3RhdGUtZmllbGQtY29udGFpbmVyIHNlbGVjdCBvcHRpb246Zmlyc3QtY2hpbGQnKTtcbiAgICB2YXIgc3RhdGVFbXB0eU9wdGlvbkh0bWwgPSAkKCc8ZGl2PicpLmFwcGVuZCgkc3RhdGVFbXB0eU9wdGlvbkVsLmNsb25lKCkpLmh0bWwoKTtcbiAgICAkZm9ybS5vbignY2hhbmdlJywgJ3NlbGVjdC5jb3VudHJ5JywgZnVuY3Rpb24oKSB7XG4gICAgXHR2YXIgdmFsdWUgPSAkKHRoaXMpLnZhbCgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBcdGlmICh2YWx1ZSA9PSAndXMnIHx8IHZhbHVlID09ICdjYScpIHtcbiAgICBcdFx0JCgnc2VsZWN0W25hbWUkPVwiX3N0YXRlXCJdJykuYWRkQ2xhc3MoJ3JlcXVpcmVkJykucGFyZW50KCkuYWRkQ2xhc3MoJ3JlcXVpcmVkJyk7XG4gICAgXHR9IGVsc2Uge1xuICAgIFx0XHQkKCdzZWxlY3RbbmFtZSQ9XCJfc3RhdGVcIl0nKS5yZW1vdmVDbGFzcygncmVxdWlyZWQnKS5wYXJlbnQoKS5yZW1vdmVDbGFzcygncmVxdWlyZWQnKTtcbiAgICBcdH1cblxuICAgICAgICB1dGlsLmNoYW5nZVN0YXRlRmllbGQoJCh0aGlzKS52YWwoKSwgJGZvcm0sIHN0YXRlRW1wdHlPcHRpb25IdG1sKTtcbiAgICAgICAgZm9ybVByZXBhcmUuaW5pdCh7XG4gICAgICAgICAgICBjb250aW51ZVNlbGVjdG9yOiAnW25hbWUkPVwic2hpcHBpbmdBZGRyZXNzX3NhdmVcIl0nLFxuICAgICAgICAgICAgZm9ybVNlbGVjdG9yOidbaWQkPVwic2luZ2xlc2hpcHBpbmdfc2hpcHBpbmdBZGRyZXNzXCJdJ1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAkZm9ybS5maW5kKCdzZWxlY3QuY291bnRyeScpLnRyaWdnZXIoJ2NoYW5nZScpO1xuXG4gICAgZ2lmdE1lc3NhZ2VCb3goKTtcbiAgICB1cGRhdGVTaGlwcGluZ01ldGhvZExpc3QoKTtcbiAgICBzZXRLU05ld3NsZXR0ZXJDaGVja0JveCgpO1xuICAgIGluaXRQaWNrVXAoKTtcbiAgICBpbml0R2lmdEhvcHVwKCk7XG4gICAgc2hpcHBpbmdJbnZlbnRvcnkuaW5pdCgpO1xufTtcblxuZXhwb3J0cy51cGRhdGVTaGlwcGluZ01ldGhvZExpc3QgPSB1cGRhdGVTaGlwcGluZ01ldGhvZExpc3Q7XG5leHBvcnRzLnVwZGF0ZVN1bW1hcnkgPSB1cGRhdGVTdW1tYXJ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWRkUHJvZHVjdFRvQ2FydCA9IHJlcXVpcmUoJy4vcHJvZHVjdC9hZGRUb0NhcnQnKSxcbiAgICBhamF4ID0gcmVxdWlyZSgnLi4vYWpheCcpLFxuICAgIHBhZ2UgPSByZXF1aXJlKCcuLi9wYWdlJyksXG4gICAgcHJvZHVjdFRpbGUgPSByZXF1aXJlKCcuLi9wcm9kdWN0LXRpbGUnKSxcbiAgICBxdWlja3ZpZXcgPSByZXF1aXJlKCcuLi9xdWlja3ZpZXcnKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKiBAZGVzY3JpcHRpb24gQmluZHMgdGhlIGNsaWNrIGV2ZW50cyB0byB0aGUgcmVtb3ZlLWxpbmsgYW5kIHF1aWNrLXZpZXcgYnV0dG9uXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVFdmVudHMoKSB7XG4gICAgJCgnI2NvbXBhcmUtdGFibGUnKS5vbignY2xpY2snLCAnLnJlbW92ZS1saW5rJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBhamF4LmdldEpzb24oe1xuICAgICAgICAgICAgdXJsOiB0aGlzLmhyZWYsXG4gICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHBhZ2UucmVmcmVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KVxuICAgIC5vbignY2xpY2snLCAnLm9wZW4tcXVpY2stdmlldycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIHVybCA9ICQodGhpcykuY2xvc2VzdCgnLnByb2R1Y3QnKS5maW5kKCcudGh1bWItbGluaycpLmF0dHIoJ2hyZWYnKTtcbiAgICAgICAgLy9WZXJ5IHNwZWNpZmljIGNhc2UgZm9yIG1ha2luZyBpbnB1dHMgb3V0c2lkZSBvZiBkaWFsb2cgYXZhaWxhYmxlXG4gICAgICAgICQud2lkZ2V0KCBcInVpLmRpYWxvZ1wiLCAkLnVpLmRpYWxvZywge1xuICAgICAgICAgICAgX2FsbG93SW50ZXJhY3Rpb246IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISEkKCBldmVudC50YXJnZXQgKS5pcyggXCJpbnB1dFwiICkgfHwgdGhpcy5fc3VwZXIoIGV2ZW50ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBxdWlja3ZpZXcuc2hvdyh7XG4gICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgIHNvdXJjZTogJ3F1aWNrdmlldydcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAkKCcjY29tcGFyZS1jYXRlZ29yeS1saXN0Jykub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJCh0aGlzKS5jbG9zZXN0KCdmb3JtJykuc3VibWl0KCk7XG4gICAgfSk7XG59XG5cbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9kdWN0VGlsZS5pbml0KCk7XG4gICAgaW5pdGlhbGl6ZUV2ZW50cygpO1xuICAgIGFkZFByb2R1Y3RUb0NhcnQoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkaWFsb2cgPSByZXF1aXJlKCcuLi8uLi9kaWFsb2cnKSxcblx0YXZhaWxhYmlsaXR5ID0gcmVxdWlyZSgnLi9hdmFpbGFiaWxpdHknKSxcblx0dmFsaWRhdG9yID0gcmVxdWlyZSgnLi4vLi4vdmFsaWRhdG9yJyksXG4gICAgbWluaWNhcnQgPSByZXF1aXJlKCcuLi8uLi9taW5pY2FydCcpLFxuICAgIHBhZ2UgPSByZXF1aXJlKCcuLi8uLi9wYWdlJyksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKSxcbiAgICBQcm9taXNlID0gcmVxdWlyZSgncHJvbWlzZScpLFxuICAgIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcbiAgICBtb25vZ3JhbVJlc2V0ID0gcmVxdWlyZSgnLi4vLi4vc3RvcmVpbnZlbnRvcnkvcHJvZHVjdCcpLm1vbm9ncmFtUmVzZXQsXG4gICAgdmFsaWRhdGVGb3JtRmllbGRzID0gcmVxdWlyZSgnLi4vLi4vc3RvcmVpbnZlbnRvcnkvcHJvZHVjdCcpLnZhbGlkYXRlRm9ybUZpZWxkcztcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gTWFrZSB0aGUgQUpBWCByZXF1ZXN0IHRvIGFkZCBhbiBpdGVtIHRvIGNhcnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gZm9ybSBUaGUgZm9ybSBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIGl0ZW0gcXVhbnRpdHkgYW5kIElEIGRhdGFcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG52YXIgYWRkSXRlbVRvQ2FydCA9IGZ1bmN0aW9uIChmb3JtKSB7XG4gICAgdmFyICRmb3JtID0gJChmb3JtKSxcbiAgICAgICAgJHF0eSA9ICRmb3JtLmZpbmQoJ2lucHV0W25hbWU9XCJRdWFudGl0eVwiXScpLFxuICAgICAgICAkcHNwQ29udGFpbmVyID0gJGZvcm0ucGFyZW50cygnLnByb2R1Y3Qtc2V0LWl0ZW0nKSxcbiAgICAgICAgaXRlbUlEID0gJyc7XG5cblx0aWYoJHF0eS5sZW5ndGggPT0gMCl7XG5cdFx0JHF0eSA9ICRmb3JtLmZpbmQoJ3NlbGVjdFtuYW1lPVwiUXVhbnRpdHlcIl0nKTtcblx0fVxuXHQvLyBGaXggZm9yIFByb2R1Y3RTZXRzLCBhcyB0aGUgcXVhbnRpdHkgc2VsZWN0IGlzbid0IHdpdGhpbiB0aGUgZm9ybS5cbiAgICBpZiAoJHBzcENvbnRhaW5lci5sZW5ndGgpIHtcbiAgICBcdC8vIEZpbmQgdGhlIFBTUCBxdWFudGl0eVxuICAgIFx0JHF0eSA9ICRwc3BDb250YWluZXIuZmluZCgnc2VsZWN0W25hbWU9XCJRdWFudGl0eVwiXScpO1xuICAgIFx0Ly8gUmVtb3ZlIGFueSBwcmlvciBpbmplY3RlZCBpbnB1dHNcbiAgICBcdCRmb3JtLmZpbmQoJ2lucHV0W25hbWU9XCJRdWFudGl0eVwiXScpLnJlbW92ZSgpO1xuICAgIFx0Ly8gQXBwZW5kIGl0IHRvIHRoZSBmb3JtXG5cdFx0JGZvcm0uYXBwZW5kKCc8aW5wdXQgbmFtZT1cIlF1YW50aXR5XCIgdHlwZT1cImhpZGRlblwiIHZhbHVlPVwiJyArICRxdHkudmFsKCkgKyAnXCIvPicpO1xuXHRcdCRxdHkgPSAkZm9ybS5maW5kKCdpbnB1dFtuYW1lPVwiUXVhbnRpdHlcIl0nKTtcblx0XHRpdGVtSUQgPSAkcHNwQ29udGFpbmVyLmF0dHIoJ2lkJyk7XG4gICAgfVxuICAgIGlmICgkcXR5Lmxlbmd0aCA9PT0gMCB8fCBpc05hTigkcXR5LnZhbCgpKSB8fCBwYXJzZUludCgkcXR5LnZhbCgpLCAxMCkgPT09IDApIHtcbiAgICAgICAgJHF0eS52YWwoJzEnKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgkLmFqYXgoe1xuICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgIHVybDogdXRpbC5hamF4VXJsKHV0aWwuYXBwZW5kUGFyYW1Ub1VSTChVcmxzLmFkZFByb2R1Y3QsICdpdGVtSUQnLCBpdGVtSUQpKSxcbiAgICAgICAgZGF0YTogJGZvcm0uc2VyaWFsaXplKClcbiAgICB9KSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgLy8gaGFuZGxlIGVycm9yIGluIHRoZSByZXNwb25zZVxuICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgXHRhdmFpbGFiaWxpdHkudXBkYXRlQ29udGFpbmVyKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5lcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEhhbmRsZXIgdG8gaGFuZGxlIHRoZSBhZGQgdG8gY2FydCBldmVudFxuICovXG52YXIgYWRkVG9DYXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyICRmb3JtID0gJCh0aGlzKS5jbG9zZXN0KCdmb3JtJyk7XG5cbiAgICB2YWxpZGF0b3IuaW5pdEZvcm0oJGZvcm0pO1xuICAgIGlmICghJGZvcm0udmFsaWQoKSB8fCAhdmFsaWRhdGVGb3JtRmllbGRzKCkpIHtcbiAgICBcdHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBhZGRJdGVtVG9DYXJ0KCRmb3JtKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICB2YXIgJHV1aWQgPSAkZm9ybS5maW5kKCdpbnB1dFtuYW1lPVwidXVpZFwiXScpO1xuICAgICAgICBpZiAoKCR1dWlkLmxlbmd0aCAmJiAkdXVpZC52YWwoKS5sZW5ndGgpIHx8ICQoJy5zZmwtcXVpY2t2aWV3JykubGVuZ3RoKSB7XG4gICAgICAgICAgICBwYWdlLnJlZnJlc2goKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdCBjbG9zZSBxdWlja3ZpZXcgaWYgYWRkaW5nIGluZGl2aWR1YWwgaXRlbSB0aGF0IGlzIHBhcnQgb2YgcHJvZHVjdCBzZXRcbiAgICAgICAgICAgIC8vIEBUT0RPIHNob3VsZCBub3RpZnkgdGhlIHVzZXIgc29tZSBvdGhlciB3YXkgdGhhdCB0aGUgYWRkIGFjdGlvbiBoYXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseVxuICAgICAgICAgICAgaWYgKCEkKHRoaXMpLmhhc0NsYXNzKCdzdWItcHJvZHVjdC1pdGVtJykpIHtcbiAgICAgICAgICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoJCgnI2djQW1vdW50c2VsZWN0JykubGVuZ3RoID4gMCApe1xuICAgICAgICAgICAgXHQkKFwiI2djQW1vdW50XCIpLnZhbCgkKFwiI2djQW1vdW50c2VsZWN0IG9wdGlvbjpmaXJzdFwiKS52YWwoKSk7XG4gICAgICAgICAgICBcdCQoXCIjZ2NBbW91bnRzZWxlY3RTZWxlY3RCb3hJdFRleHRcIikudGV4dCgkKFwiI2djQW1vdW50c2VsZWN0IG9wdGlvbjpmaXJzdFwiKS50ZXh0KCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgXHRcdGlmICh0eXBlb2YgZGF0YUxheWVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgXHRcdFx0dmFyIGlzUHJvZHVjdFNldCA9ICQoJyNwZHBNYWluIGRpdi5wcm9kdWN0LXNldCcpLmxlbmd0aCA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNhY3Rpb25Qcm9kdWN0cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBkbFBpZCwgZGxTa3UsIGRsUHJvZHVjdE5hbWUsIGRsQ2F0ZWdvcnlJRCwgZGxQcmljZSwgZGxWYXJpYW50LCBkbFF1YW50aXR5LCBkbFNpemUsIGRsU2Vhc29uYWxDb2xsZWN0aW9uLCBkbENvbG9yd2F5LCBkbEl0ZW1BdEZ1bGxQcmljZSwgZGxBdmFpbGFiaWxpdHksIGRsRGlzY291bnQsIGRsTW9ub2dyYW1taW5nLCBkbEJWQXZlcmFnZSwgZGxNb25vZ3JhbVN0eWxlLCBkbE1vbm9ncmFtRm9udCwgZGxNb25vZ3JhbUNoYXJzLCBkbE1vbm9ncmFtQ29sb3I7XG4gICAgICAgICAgICAgICAgdmFyIGVjb21EZXRhaWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUxheWVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhTGF5ZXJbaV0uZXZlbnQgPT0gJ2Vjb21EZXRhaWwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlY29tRGV0YWlsID0gZGF0YUxheWVyW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICBcdFx0XHR2YXIgcHJvZHVjdHRpbGVzID0gJCgnLnByb2R1Y3QtdGlsZScpO1xuICAgICAgICAgICAgICAgIGZvcihpPTA7aTxwcm9kdWN0dGlsZXMubGVuZ3RoO2krKyl7XG4gICAgICAgICAgICAgICAgXHRjb25zb2xlLmxvZyhwcm9kdWN0dGlsZXMuZXEoaSkuYXR0cignZGF0YS1jZ2lkJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZWNvbURldGFpbCAmJiAnZWNvbW1lcmNlJyBpbiBlY29tRGV0YWlsXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAnZGV0YWlsJyBpbiBlY29tRGV0YWlsLmVjb21tZXJjZVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgJ3Byb2R1Y3RzJyBpbiBlY29tRGV0YWlsLmVjb21tZXJjZS5kZXRhaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGVjb21EZXRhaWwuZWNvbW1lcmNlLmRldGFpbC5wcm9kdWN0cy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICYmICdjYXRlZ29yeScgaW4gZWNvbURldGFpbC5lY29tbWVyY2UuZGV0YWlsLnByb2R1Y3RzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGRsQ2F0ZWdvcnlJRCA9IGVjb21EZXRhaWwuZWNvbW1lcmNlLmRldGFpbC5wcm9kdWN0c1swXS5jYXRlZ29yeTtcbiAgICAgICAgICAgICAgICAgICAgZGxQaWQgPSBlY29tRGV0YWlsLmVjb21tZXJjZS5kZXRhaWwucHJvZHVjdHNbMF0uaWQ7XG4gICAgICAgICAgICAgICAgICAgIGRsUHJvZHVjdE5hbWUgPSBlY29tRGV0YWlsLmVjb21tZXJjZS5kZXRhaWwucHJvZHVjdHNbMF0ubmFtZVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNtUHJvZHVjdE5hbWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGxQcm9kdWN0TmFtZSA9IGNtUHJvZHVjdE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGRsQ2F0ZWdvcnlJRCA9IGNtQ2F0ZWdvcnlJRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGZvcm0gPSAkKCcucGRwRm9ybScpO1xuICAgICAgICAgICAgICAgIHZhciBzdGFuZGFyZFByaWNlID0gJCgnI3BkcE1haW4gLnByb2R1Y3QtZGV0YWlsIC5wcmljZS1zdGFuZGFyZCcpLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgZGxRdWFudGl0eSA9IHBhcnNlSW50KCQoJy5xdWFudGl0eS1kcm9wZG93biAuc2VsZWN0Ym94aXQnKS5maW5kKCc6c2VsZWN0ZWQnKS50ZXh0KCkpO1xuICAgIFx0XHQgICAgZGxRdWFudGl0eSA9IGRsUXVhbnRpdHkgPiAwID8gZGxRdWFudGl0eSA6IDE7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJvZHVjdFNldCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvZHVjdFNldEl0ZW0gPSAkKHRoaXMpLmNsb3Nlc3QoJ2RpdltjbGFzc149XCJwcm9kdWN0LXNldC1pdGVtXCJdJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwaWRBdHRyID0gcHJvZHVjdFNldEl0ZW0uYXR0cihcImlkXCIpO1xuICAgICAgICAgICAgICAgICAgICBkbFNrdSA9ICQodGhpcykucGFyZW50KCkuZmluZCgnaW5wdXRbbmFtZT1cInBpZFwiXScpLnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICBkbFBpZCA9IHBpZEF0dHIuc3Vic3RyKHBpZEF0dHIuaW5kZXhPZihcIi1cIikgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgZGxQcm9kdWN0TmFtZSA9ICQudHJpbShwcm9kdWN0U2V0SXRlbS5maW5kKCcucHJvZHVjdC1uYW1lJykudGV4dCgpKTtcbiAgICAgICAgICAgICAgICAgICAgZGxDYXRlZ29yeUlEID0gJC50cmltKHByb2R1Y3RTZXRJdGVtLmZpbmQoJ2lucHV0W25hbWU9XCJjZ2lkXCJdJykudmFsKCkpO1xuICAgICAgICAgICAgICAgICAgICBkbFByaWNlID0gKCQudHJpbShwcm9kdWN0U2V0SXRlbS5maW5kKCcucHJpY2Utc2FsZXMnKS5odG1sKCkpLnJlcGxhY2UoXCIkXCIsIFwiXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgZGxWYXJpYW50ID0gJC50cmltKHByb2R1Y3RTZXRJdGVtLmZpbmQoXCIucHJvZHVjdC12YXJpYXRpb25zIC5zd2F0Y2hlcyAuc2VsZWN0ZWQgLnRpdGxlXCIpLnRleHQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGRsU2l6ZSA9ICQudHJpbShwcm9kdWN0U2V0SXRlbS5maW5kKFwiLnByb2R1Y3QtdmFyaWF0aW9ucyAuc3dhdGNoZXMuc2l6ZSAuc2VsZWN0ZWQgYVwiKS50ZXh0KCkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBkbFNlYXNvbmFsQ29sbGVjdGlvbiA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBkbENvbG9yd2F5ID0gJC50cmltKHByb2R1Y3RTZXRJdGVtLmZpbmQoXCIucHJvZHVjdC12YXJpYXRpb25zIC5zd2F0Y2hlcy5Db2xvciAuc2VsZWN0ZWQgYVwiKS5hdHRyKCd0aXRsZScpKTtcbiAgICAgICAgICAgICAgICAgICAgZGxJdGVtQXRGdWxsUHJpY2UgPSAkLnRyaW0ocHJvZHVjdFNldEl0ZW0uZmluZChcIi5wcm9kdWN0LXByaWNlIHNwYW5cIikuaHRtbCgpKS5yZXBsYWNlKFwiJFwiLFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICBkbEF2YWlsYWJpbGl0eSA9ICQudHJpbShwcm9kdWN0U2V0SXRlbS5maW5kKCcuYXZhaWxhYmlsaXR5LW1zZycpLmF0dHIoJ2RhdGEtYXZhaWxpYmxlJykpO1xuICAgICAgICAgICAgICAgICAgICAvLyBkbERpc2NvdW50ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGRsTW9ub2dyYW1taW5nID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGRsQlZBdmVyYWdlID0gJC50cmltKHByb2R1Y3RTZXRJdGVtLmZpbmQoXCIjQlZJbmxpbmVSYXRpbmdzXCIpLnRleHQoKSk7XG4gICAgICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkbFNrdSA9ICQoXCIjcGlkXCIpLnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICBkbFBpZCA9IGRsUGlkIHx8ICQoJyNwcm9kdWN0LWNvbnRlbnQnKS5maW5kKCdkaXZbZGF0YS1tYXN0ZXJdJykuYXR0cignZGF0YS1tYXN0ZXInKTtcbiAgICAgICAgICAgICAgICAgICAgZGxQcm9kdWN0TmFtZSA9ICQudHJpbSgkKFwiI3Byb2R1Y3QtY29udGVudCAucHJvZHVjdC1uYW1lXCIpLnRleHQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGRsQ2F0ZWdvcnlJRCA9ICQoJyNwZHBNYWluJykuYXR0cignZGF0YS1jYXRlZ29yeScpO1xuICAgICAgICAgICAgICAgICAgICBkbFByaWNlID0gJChcIiNwZHBNYWluIC5wcm9kdWN0LWRldGFpbCAucHJpY2Utc2FsZXNcIikuZXEoMCkudGV4dCgpLnNwbGl0KCcgJylbMF0udHJpbSgpLnJlcGxhY2UoJyQnLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGRsVmFyaWFudCA9ICQudHJpbSgkKFwiLnByb2R1Y3QtdmFyaWF0aW9ucyAuc3dhdGNoZXMgLnNlbGVjdGVkIC50aXRsZVwiKS50ZXh0KCkpO1xuICAgICAgICAgICAgICAgICAgICBkbFNpemUgPSAkKFwiLnByb2R1Y3QtdmFyaWF0aW9ucyAuc3dhdGNoZXMuc2l6ZSAuc2VsZWN0ZWQgYVwiKS5sZW5ndGggPiAwID8gJC50cmltKCQoXCIucHJvZHVjdC12YXJpYXRpb25zIC5zd2F0Y2hlcy5zaXplIC5zZWxlY3RlZCBhXCIpLnRleHQoKSkgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgLy8gZGxTZWFzb25hbENvbGxlY3Rpb24gPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZGxDb2xvcndheSA9ICQudHJpbSgkKFwiLnByb2R1Y3QtdmFyaWF0aW9ucyAuc3dhdGNoZXMuQ29sb3IgLnNlbGVjdGVkIGFcIikuYXR0cigndGl0bGUnKSk7XG4gICAgICAgICAgICAgICAgICAgIGRsSXRlbUF0RnVsbFByaWNlID0gJCgnI3BkcE1haW4nKS5maW5kKCcucHJpY2Utc3RhbmRhcmQnKS5sZW5ndGggPiAwID8gJ04nIDogJ1knOyAvLyBmdWxsIHByaWNlP1xuICAgICAgICAgICAgICAgICAgICBpZigkKFwiLmF2YWlsYWJpbGl0eS1tc2dcIikubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICAgICAgICAgIFx0ZGxBdmFpbGFiaWxpdHkgPSAkLnRyaW0oJChcIi5hdmFpbGFiaWxpdHktbXNnXCIpLmF0dHIoJ2RhdGEtYXZhaWxpYmxlJykpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCQoXCIuYXZhaWxhYmlsaXR5XCIpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgXHRkbEF2YWlsYWJpbGl0eSA9ICQoXCIuYXZhaWxhYmlsaXR5XCIpLnRleHQoKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGxEaXNjb3VudCA9IHN0YW5kYXJkUHJpY2UgPyBwYXJzZUZsb2F0KCQoJyNwZHBNYWluIC5wcm9kdWN0LWRldGFpbCAucHJpY2Utc3RhbmRhcmQnKS5lcSgwKS50ZXh0KCkucmVwbGFjZSgnJCcsICcnKSAtICQoJyNwZHBNYWluIC5wcm9kdWN0LWRldGFpbCAucHJpY2Utc2FsZXMnKS5lcSgwKS50ZXh0KCkudHJpbSgpLnJlcGxhY2UoJyQnLCcnKSkudG9GaXhlZCgyKSA6ICcnO1xuICAgICAgICAgICAgICAgICAgICBkbE1vbm9ncmFtbWluZyA9ICQoJyNwZHBNYWluIC5tb25vZ3JhbS13cmFwcGVyJykubGVuZ3RoID4gMCA/ICdZZXMnIDogJ05vJztcbiAgICAgICAgICAgICAgICAgICAgZGxCVkF2ZXJhZ2UgPSAkLnRyaW0oJCgnLkJWUlJSYXRpbmdPdmVyYWxsIC5CVlJSUmF0aW5nTm9ybWFsSW1hZ2UgaW1nJykuZXEoMCkuYXR0cigndGl0bGUnKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkbE1vbm9ncmFtbWluZyA9PT0nWWVzJykge1xuICAgICAgICAgICAgICAgICAgICBcdGRsTW9ub2dyYW1TdHlsZSA9ICQoJyNwZHBNYWluIC5tb25vZ3JhbS1zdHlsZS10aWxlLnNlbGVjdGVkIC5tb25vZ3JhbS1zdHlsZS1uYW1lJykudGV4dCgpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgXHRkbE1vbm9ncmFtRm9udCA9ICQoJyNwZHBNYWluIC5tb25vZ3JhbS1mb250LnNlbGVjdGVkIHNwYW4nKS50ZXh0KCkudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBcdGRsTW9ub2dyYW1DaGFycyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBcdGRsTW9ub2dyYW1Db2xvciA9ICQoJyNwZHBNYWluIC5tb25vZ3JhbS1jb2xvci1zd2F0Y2guc2VsZWN0ZWQnKS5kYXRhKCdjb2xvci1jb25maWcnKS5jb2xvck5hbWU7XG4gICAgICAgICAgICAgICAgXHRcdCQoJy5tb25vZ3JhbS10ZXh0LWlucHV0LWZpZWxkJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIFx0XHR2YXIgdmFsID0gJCh0aGlzKS52YWwoKTtcbiAgICAgICAgICAgICAgICAgICAgXHRcdGRsTW9ub2dyYW1DaGFycyArPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIFx0fSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvblByb2R1Y3RzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBcImJyYW5kXCIgOiAna2F0ZScsXG4gICAgICAgICAgICAgICAgICAgIFwic2t1XCIgOiBkbFNrdSxcbiAgICAgICAgICAgICAgICAgICAgXCJpZFwiIDogZGxQaWQsXG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiIDogZGxQcm9kdWN0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgXCJjYXRlZ29yeVwiIDogZGxDYXRlZ29yeUlELFxuICAgICAgICAgICAgICAgICAgICBcInByaWNlXCIgOiBkbFByaWNlLFxuICAgICAgICAgICAgICAgICAgICBcInF1YW50aXR5XCIgOiBkbFF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICBcInZhcmlhbnRcIiA6IGRsVmFyaWFudCxcbiAgICAgICAgICAgICAgICAgICAgXCJkaW1lbnNpb241XCIgOiBkbFNpemUsIC8vcHJvZHVjdCBzaXplXG4gICAgICAgICAgICAgICAgICAgIC8vXCJkaW1lbnNpb245XCIgOiBkbFNlYXNvbmFsQ29sbGVjdGlvbiwgLy8gc2Vhc29uYWwgY29sbGVjdGlvbiB0aGUgcHJvZHVjdCBpcyBwYXJ0IG9mXG4gICAgICAgICAgICAgICAgICAgIFwiZGltZW5zaW9uMTBcIiA6IGRsQ29sb3J3YXksIC8vY29sb3J3YXlcbiAgICAgICAgICAgICAgICAgICAgXCJkaW1lbnNpb24xMVwiIDogZGxJdGVtQXRGdWxsUHJpY2UsIC8vV2FzIHRoZSBpdGVtIGF0IGZ1bGwgcHJpY2VcbiAgICAgICAgICAgICAgICAgICAgXCJkaW1lbnNpb24xMlwiIDogZGxBdmFpbGFiaWxpdHksIC8vYXZhaWxhYmlsaXR5IG9mIHByb2R1Y3RcbiAgICAgICAgICAgICAgICAgICAgXCJkaW1lbnNpb24xM1wiIDogZGxEaXNjb3VudCwgLy9kaXNjb3VudCBhbW91bnQgaWYgYXBwbGljYWJsZVxuICAgICAgICAgICAgICAgICAgICBcImRpbWVuc2lvbjE0XCIgOiBkbE1vbm9ncmFtbWluZywgLy93YXMgbW9ub2dyYW1taW5nIGFwcGxpZWRcbiAgICAgICAgICAgICAgICAgICAgLy9cImRpbWVuc2lvbjE1XCIgOiBkbEdpZnRXcmFwLCAvL3dhcyBnaWZ0IHdyYXAgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgXCJkaW1lbnNpb24xNlwiIDogZGxCVkF2ZXJhZ2UsIC8vYnYgYXZlcmFnZSBzdGFyIHJhdGluZ1xuICAgICAgICAgICAgICAgICAgICBcImRpbWVuc2lvbjMzXCIgOiBkbE1vbm9ncmFtU3R5bGUgPT09IHVuZGVmaW5lZCA/ICcnIDogZGxNb25vZ3JhbVN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBcImRpbWVuc2lvbjM0XCIgOiBkbE1vbm9ncmFtRm9udCA9PT0gdW5kZWZpbmVkID8gJycgOiBkbE1vbm9ncmFtRm9udCxcbiAgICAgICAgICAgICAgICAgICAgXCJkaW1lbnNpb24zNVwiIDogZGxNb25vZ3JhbUNoYXJzID09PSB1bmRlZmluZWQgPyAnJyA6IGRsTW9ub2dyYW1DaGFycyxcbiAgICAgICAgICAgICAgICAgICAgXCJkaW1lbnNpb24zNlwiIDogZGxNb25vZ3JhbUNvbG9yID09PSB1bmRlZmluZWQgPyAnJyA6IGRsTW9ub2dyYW1Db2xvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRhdGFMYXllci5wdXNoKGFwcC5kYXRhbGF5ZXIuZ2V0RXZlbnQoXCJldmVudFwiLFwiZWNvbUFkZFwiLCBcImVjb21tZXJjZVwiLCBcIiBcIiwgXCJhZGRcIiwgdHJhbnNhY3Rpb25Qcm9kdWN0cykpO1xuICAgIFx0XHR9XG4gICAgICAgIH1cbiAgICAgICAgbWluaWNhcnQuc2hvdyhyZXNwb25zZSk7XG4gICAgICAgIGVHaWZ0Q2FyZENsZWFuRmllbGRzKCk7XG4gICAgICAgIG1vbm9ncmFtUmVzZXQoKTtcblxuICAgIH0uYmluZCh0aGlzKSk7XG59O1xuXG52YXIgZUdpZnRDYXJkQ2xlYW5GaWVsZHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciB2Z2NSZWNpcGllbnROYW1lID0gJCgnLnBkcEZvcm0gaW5wdXRbbmFtZT1cInZnY1JlY2lwaWVudE5hbWVcIl0nKTtcblx0dmFyIHZnY1JlY2lwaWVudEVtYWlsID0gJCgnLnBkcEZvcm0gaW5wdXRbbmFtZT1cInZnY1JlY2lwaWVudEVtYWlsXCJdJyk7XG5cdHZhciB2Z2NGcm9tTmFtZSA9ICQoJy5wZHBGb3JtIGlucHV0W25hbWU9XCJ2Z2NGcm9tTmFtZVwiXScpO1xuXHR2YXIgdmdjUmVjaXBpZW50RW1haWxDb25maXJtID0gJCgnLnBkcEZvcm0gaW5wdXRbbmFtZT1cInZnY1JlY2lwaWVudEVtYWlsQ29uZmlybVwiXScpO1xuXHR2YXIgdmdjR2lmdENhcmRNZXNzYWdlID0gJCgnLnBkcEZvcm0gdGV4dGFyZWFbbmFtZT1cInZnY0dpZnRDYXJkTWVzc2FnZVwiXScpO1xuXHRcblx0aWYodHlwZW9mIHZnY1JlY2lwaWVudE5hbWUgIT0gJ3VuZGVmaW5lZCcpe3ZnY1JlY2lwaWVudE5hbWUudmFsKCcnKTt9XG5cdGlmKHR5cGVvZiB2Z2NSZWNpcGllbnRFbWFpbCAhPSAndW5kZWZpbmVkJyl7dmdjUmVjaXBpZW50RW1haWwudmFsKCcnKTt9XG5cdGlmKHR5cGVvZiB2Z2NGcm9tTmFtZSAhPSAndW5kZWZpbmVkJyl7dmdjRnJvbU5hbWUudmFsKCcnKTt9XG5cdGlmKHR5cGVvZiB2Z2NSZWNpcGllbnRFbWFpbENvbmZpcm0gIT0gJ3VuZGVmaW5lZCcpe3ZnY1JlY2lwaWVudEVtYWlsQ29uZmlybS52YWwoJycpO31cblx0aWYodHlwZW9mIHZnY0dpZnRDYXJkTWVzc2FnZSAhPSAndW5kZWZpbmVkJyl7dmdjR2lmdENhcmRNZXNzYWdlLnZhbCgnJyk7fVxuXG4gICAgdmFyIGdpZnRDYXJkUERQSW5mbyA9ICQoJy5qcy1pcy1naWZ0LWNhcmQtcGRwLWZvcm0nKTtcbiAgICBpZiAoZ2lmdENhcmRQRFBJbmZvLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gcmVtb3ZlIHZhbGlkYXRpb24gY2hlY2ttYXJrc1xuICAgICAgICB2YXIgdmFsaWRhdG9yID0gJCgnZm9ybS5wZHBGb3JtJykudmFsaWRhdGUoKTtcbiAgICAgICAgdmFsaWRhdG9yLnJlc2V0Rm9ybSgpO1xuXG4gICAgICAgIC8vIHJlc3RvcmUgZmxvYXQgbGFiZWxzXG4gICAgICAgIGdpZnRDYXJkUERQSW5mby5maW5kKCcuaGFzLWZsb2F0LWxhYmVsIGxhYmVsJykuY3NzKHsgb3BhY2l0eTogMSB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBIYW5kbGVyIHRvIGhhbmRsZSB0aGUgYWRkIGFsbCBpdGVtcyB0byBjYXJ0IGV2ZW50XG4gKi9cbnZhciBhZGRBbGxUb0NhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgJHByb2R1Y3RGb3JtcyA9ICQoJyNwcm9kdWN0LXNldC1saXN0JykuZmluZCgnZm9ybScpLnRvQXJyYXkoKTtcbiAgICBQcm9taXNlLmFsbChfLm1hcCgkcHJvZHVjdEZvcm1zLCBhZGRJdGVtVG9DYXJ0KSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlcykge1xuICAgICAgICAgICAgZGlhbG9nLmNsb3NlKCk7XG4gICAgICAgICAgICAvLyBzaG93IHRoZSBmaW5hbCByZXNwb25zZSBvbmx5LCB3aGljaCB3b3VsZCBpbmNsdWRlIGFsbCB0aGUgb3RoZXIgaXRlbXNcbiAgICAgICAgICAgIG1pbmljYXJ0LnNob3cocmVzcG9uc2VzW3Jlc3BvbnNlcy5sZW5ndGggLSAxXSk7XG4gICAgICAgIH0pO1xuICAgIGlmICh0eXBlb2YgZGF0YUxheWVyICE9PSBcInVuZGVmaW5lZFwiKSB7dmFyIHByb2R1Y3REYXRhID0gJCgnLnByb2R1Y3QtdmFyaWF0aW9ucycpO1xuXHQgICAgdmFyIHRyYW5zYWN0aW9uUHJvZHVjdHMgPSBbXTtcblx0ICAgIHZhciBwaWRBdHRyLCBkbFNrdSwgZGxQaWQsIHByb2R1Y3QsIGZvcm0sIGRsUHJvZHVjdE5hbWUsIGRsQ2F0ZWdvcnlJRCwgZGxQcmljZSwgZGxRdWFudGl0eTtcblx0ICAgIGZvcihpPTA7aTxwcm9kdWN0RGF0YS5sZW5ndGg7aSsrKXtcblx0ICAgIFx0cGlkQXR0ciA9IHByb2R1Y3REYXRhLmVxKGkpO1xuXHRcdCAgICBkbFNrdSA9IHBpZEF0dHIuYXR0cignZGF0YS12aWQnKTtcblx0XHQgICAgZGxQaWQgPSBwaWRBdHRyLmF0dHIoJ2RhdGEtbWFzdGVyJyk7XG5cdFx0ICAgIHByb2R1Y3QgPSBwaWRBdHRyLmNsb3Nlc3QoJy5wcm9kdWN0LXNldC1pdGVtJyk7XG5cdFx0ICAgIGZvcm0gPSBwaWRBdHRyLmNsb3Nlc3QoJ2Zvcm0nKTtcblx0XHQgICAgZGxQcm9kdWN0TmFtZSA9ICQudHJpbShwcm9kdWN0LmZpbmQoJy5pdGVtLW5hbWUnKS50ZXh0KCkpO1xuXHRcdCAgICBkbENhdGVnb3J5SUQgPSBmb3JtLmZpbmQoJ2lucHV0W25hbWU9XCJjZ2lkXCJdJykudmFsKCk7XG5cdFx0ICAgIGRsUHJpY2UgPSAoJC50cmltKHByb2R1Y3QuZmluZCgnLnByaWNlLXNhbGVzJykuaHRtbCgpKS5yZXBsYWNlKFwiJFwiLCBcIlwiKSk7XG5cdFx0ICAgIGRsUXVhbnRpdHkgPSBwYXJzZUludChmb3JtLmZpbmQoJy5xdWFudGl0eS1kcm9wZG93biAuc2VsZWN0Ym94aXQnKS5maW5kKCc6c2VsZWN0ZWQnKS50ZXh0KCkpO1xuXHRcdCAgICBkbFF1YW50aXR5ID0gZGxRdWFudGl0eSA+IDAgPyBkbFF1YW50aXR5IDogMTtcblx0XHQgICAgdHJhbnNhY3Rpb25Qcm9kdWN0cy5wdXNoKHsgXCJza3VcIiA6IGRsU2t1LCBcImlkXCIgOiBkbFBpZCwgXCJuYW1lXCIgOiBkbFByb2R1Y3ROYW1lLCBcImNhdGVnb3J5XCIgOiBkbENhdGVnb3J5SUQsIFwicHJpY2VcIiA6IGRsUHJpY2UsIFwicXVhbnRpdHlcIiA6ZGxRdWFudGl0eX0pO1xuXHQgICAgfVxuXHRcdGRhdGFMYXllci5wdXNoKGFwcC5kYXRhbGF5ZXIuZ2V0RXZlbnQoXCJldmVudFwiLFwiZWNvbUFkZFwiLCBcImVjb21tZXJjZVwiLCBcIiBcIiwgXCJhZGRcIiwgdHJhbnNhY3Rpb25Qcm9kdWN0cykpO1xuICAgIH1cbn07XG5cbi8qXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvbiBTaW5jZSB0aGVyZSBhcmUgbXVsdGlwbGUgZWxlbWVudHMgd2l0aCB0aGUgYWRkLXRvLWNhcnQgSUQgb24gdGhlIHBhZ2UsXG4gKiAgd2UgbmVlZCB0byBoYW5kbGUgZWFjaCBvZiB0aGVtIGluZGl2aWR1YWxseSBzbyB0aGF0IGFsbCBvZiB0aGUgLmF2YWlsYWJpbGl0eS1tc2dcbiAqICBlbGVtZW50J3MgdGV4dHMgYXJlbid0IGNvbmNhdGVuYXRlZC5cbiAqL1xuZnVuY3Rpb24gc2V0QWRkVG9DYXJ0VGl0bGUoKSB7XG4gICAgJCgnYnV0dG9uI2FkZC10by1jYXJ0JykuZWFjaCggZnVuY3Rpb24oaSwgZSkge1xuICAgICAgICB2YXIgdGV4dCA9ICQoZSkucGFyZW50cygnLnByb2R1Y3QtYWRkLXRvLWNhcnQnKS5maW5kKCcuYXZhaWxhYmlsaXR5LW1zZycpLnRleHQoKS50cmltKCk7XG4gICAgICAgICQoZSkuYXR0cigndGl0bGUnLCB0ZXh0KTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvbiBCaW5kcyB0aGUgY2xpY2sgZXZlbnQgdG8gYSBnaXZlbiB0YXJnZXQgZm9yIHRoZSBhZGQtdG8tY2FydCBoYW5kbGluZ1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZXRBZGRUb0NhcnRUaXRsZSgpO1xuICAgICQoJ2JvZHknKS5vZmYoJ2NsaWNrJywnLmFkZC10by1jYXJ0Jykub24oJ2NsaWNrJywgJy5hZGQtdG8tY2FydCcsIGFkZFRvQ2FydCk7XG4gICAgJCgnI2FkZC1hbGwtdG8tY2FydCcpLm9uKCdjbGljaycsIGFkZEFsbFRvQ2FydCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWpheCA9ICByZXF1aXJlKCcuLi8uLi9hamF4JyksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcblxudmFyIHVwZGF0ZUNvbnRhaW5lciA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cdHZhciAkY29udGFpbmVyID0gdHlwZW9mIGRhdGEuaXRlbUlEICE9ICd1bmRlZmluZWQnID8gJCgnIycgKyBkYXRhLml0ZW1JRCkgOiAkKCcjcGRwTWFpbicpLFxuXHRcdCRhdmFpbGFiaWxpdHlDb250YWluZXIgPSAkY29udGFpbmVyLmZpbmQoJy5hdmFpbGFiaWxpdHknKSxcblx0XHQkYXZhaWxhYmlsaXR5TXNnID0gJGF2YWlsYWJpbGl0eUNvbnRhaW5lci5maW5kKCcuYXZhaWxhYmlsaXR5LW1zZycpLFxuXHRcdCRhZGRUb0NhcnQgPSAkY29udGFpbmVyLmZpbmQoJy5wZHBGb3JtICNhZGQtdG8tY2FydCcpLFxuXHRcdCRhZGRBbGxUb0NhcnQgPSAkKCcjYWRkLWFsbC10by1jYXJ0JyksXG5cdFx0aXNRdWlja1ZpZXcgPSAkKCcjUXVpY2tWaWV3RGlhbG9nJykubGVuZ3RoLFxuXHRcdGlzRWRpdEl0ZW0gPSAkKCcudWktZGlhbG9nX3VwZGF0ZS1pdGVtJykubGVuZ3RoLFxuXHRcdG1lc3NhZ2U7IC8vIHRoaXMgc2hvdWxkIGJlIGxleGljYWxseSBzY29wZWQsIHdoZW4gYGxldGAgaXMgc3VwcG9ydGVkIChFUzYpXG5cbiAgICBpZiAoISRhdmFpbGFiaWxpdHlNc2cubGVuZ3RoKSB7XG4gICAgXHQkYXZhaWxhYmlsaXR5TXNnID0gJChcIjxkaXY+XCIsIHtcImNsYXNzXCI6IFwiYXZhaWxhYmlsaXR5LW1zZ1wifSk7XG4gICAgXHQkYXZhaWxhYmlsaXR5Q29udGFpbmVyLmFwcGVuZCgkYXZhaWxhYmlsaXR5TXNnKTtcbiAgICB9XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICRhdmFpbGFiaWxpdHlNc2cuaHRtbChSZXNvdXJjZXMuSVRFTV9TVEFUVVNfTk9UQVZBSUxBQkxFKTtcbiAgICAgICAgJGFkZFRvQ2FydC5hdHRyKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgICAgICAkY29udGFpbmVyLmZpbmQoJyNwZHBRdHlTZWxlY3RTZWxlY3RCb3hJdCAuc2VsZWN0Ym94aXQtdGV4dCcpLnRleHQoJzAnKTtcbiAgICAgICAgJGNvbnRhaW5lci5maW5kKCcjcGRwUXR5U2VsZWN0U2VsZWN0Qm94SXRPcHRpb25zJykucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgJGF2YWlsYWJpbGl0eU1zZy5lbXB0eSgpO1xuICAgIC8vIExvb2sgdGhyb3VnaCBsZXZlbHMgLi4uIGlmIG1zZyBpcyBub3QgZW1wdHksIHRoZW4gY3JlYXRlIHNwYW4gZWxcbiAgICBpZiAoZGF0YS5sZXZlbHMuSU5fU1RPQ0sgPiAwKSB7XG4gICAgICAgIGlmIChkYXRhLmxldmVscy5QUkVPUkRFUiA9PT0gMCAmJiBkYXRhLmxldmVscy5CQUNLT1JERVIgPT09IDAgJiYgZGF0YS5sZXZlbHMuTk9UX0FWQUlMQUJMRSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gSnVzdCBpbiBzdG9ja1xuICAgICAgICAgICAgbWVzc2FnZSA9IFJlc291cmNlcy5JTl9TVE9DSztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEluIHN0b2NrIHdpdGggY29uZGl0aW9ucyAuLi5cbiAgICAgICAgICAgIG1lc3NhZ2UgPSBkYXRhLmluU3RvY2tNc2c7XG4gICAgICAgIH1cbiAgICAgICAgJGF2YWlsYWJpbGl0eU1zZy5hcHBlbmQoJzxwIGNsYXNzPVwiaW4tc3RvY2stbXNnXCI+JyArIG1lc3NhZ2UgKyAnPC9wPicpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5sZXZlbHMuUFJFT1JERVIgPiAwKSB7XG4gICAgICAgIGlmIChkYXRhLmxldmVscy5JTl9TVE9DSyA9PT0gMCAmJiBkYXRhLmxldmVscy5CQUNLT1JERVIgPT09IDAgJiYgZGF0YS5sZXZlbHMuTk9UX0FWQUlMQUJMRSA9PT0gMCkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFJlc291cmNlcy5QUkVPUkRFUjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBkYXRhLnByZU9yZGVyTXNnO1xuICAgICAgICB9XG4gICAgICAgICRhdmFpbGFiaWxpdHlNc2cuYXBwZW5kKCc8cCBjbGFzcz1cInByZW9yZGVyLW1zZ1wiPicgKyBtZXNzYWdlICsgJzwvcD4nKTtcbiAgICB9XG4gICAgaWYgKGRhdGEubGV2ZWxzLkJBQ0tPUkRFUiA+IDApIHtcbiAgICAgICAgaWYgKGRhdGEubGV2ZWxzLklOX1NUT0NLID09PSAwICYmIGRhdGEubGV2ZWxzLlBSRU9SREVSID09PSAwICYmIGRhdGEubGV2ZWxzLk5PVF9BVkFJTEFCTEUgPT09IDApIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBSZXNvdXJjZXMuQkFDS09SREVSO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGRhdGEuYmFja09yZGVyTXNnO1xuICAgICAgICB9XG4gICAgICAgICRhdmFpbGFiaWxpdHlNc2cuYXBwZW5kKCc8cCBjbGFzcz1cImJhY2tvcmRlci1tc2dcIj4nICsgbWVzc2FnZSArICc8L3A+Jyk7XG4gICAgfVxuICAgIGlmIChkYXRhLmluU3RvY2tEYXRlICE9PSAnJykge1xuICAgICAgICAkYXZhaWxhYmlsaXR5TXNnLmFwcGVuZCgnPHAgY2xhc3M9XCJpbi1zdG9jay1kYXRlLW1zZ1wiPicgKyBTdHJpbmcuZm9ybWF0KFJlc291cmNlcy5JTl9TVE9DS19EQVRFLCBkYXRhLmluU3RvY2tEYXRlKSArICc8L3A+Jyk7XG4gICAgfVxuICAgIGlmIChkYXRhLmxldmVscy5OT1RfQVZBSUxBQkxFID4gMCkge1xuICAgICAgICBpZiAoZGF0YS5sZXZlbHMuUFJFT1JERVIgPT09IDAgJiYgZGF0YS5sZXZlbHMuQkFDS09SREVSID09PSAwICYmIGRhdGEubGV2ZWxzLklOX1NUT0NLID09PSAwKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gUmVzb3VyY2VzLk5PVF9BVkFJTEFCTEU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gUmVzb3VyY2VzLlJFTUFJTl9OT1RfQVZBSUxBQkxFO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmNhcnRNYXhRdWFudGl0eS5RdWFudGl0eUxlZnQgPT0gMCkge1xuICAgICAgICBcdCRhdmFpbGFiaWxpdHlNc2cuYXBwZW5kKCc8cCBjbGFzcz1cIm5vdC1hdmFpbGFibGUtbXNnXCI+JyArIG1lc3NhZ2UgKyAnPC9wPicpO1xuICAgICAgICBcdCRhZGRUb0NhcnQuYXR0cignZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgXHQkY29udGFpbmVyLmZpbmQoJyNwZHBRdHlTZWxlY3RTZWxlY3RCb3hJdCAuc2VsZWN0Ym94aXQtdGV4dCcpLnRleHQoJzAnKTtcbiAgICAgICAgXHQkY29udGFpbmVyLmZpbmQoJyNwZHBRdHlTZWxlY3RTZWxlY3RCb3hJdE9wdGlvbnMnKS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzRWRpdEl0ZW0gJiYgdHlwZW9mIGRhdGEuZXJyb3IgIT0gJ3VuZGVmaW5lZCcgJiYgZGF0YS5lcnJvciA9PSAnb3V0X29mX3N0b2NrJyAmJiBkYXRhLmNhcnRNYXhRdWFudGl0eS5RdWFudGl0eUxlZnQgPT0gMCkge1xuICAgIFx0ICBtZXNzYWdlID0gUmVzb3VyY2VzLlBEUF9OT1RfQVZBSUxBQkxFO1xuICAgIFx0ICAkYXZhaWxhYmlsaXR5TXNnLmFwcGVuZCgnPHAgY2xhc3M9XCJub3QtYXZhaWxhYmxlLW1zZ1wiPicgKyBtZXNzYWdlICsgJzwvcD4nKTtcbiAgICBcdCAgJGFkZFRvQ2FydC5hdHRyKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgIFx0ICAkY29udGFpbmVyLmZpbmQoJyNwZHBRdHlTZWxlY3RTZWxlY3RCb3hJdCAuc2VsZWN0Ym94aXQtdGV4dCcpLnRleHQoJzAnKTtcbiAgICAgICAgICAkY29udGFpbmVyLmZpbmQoJyNwZHBRdHlTZWxlY3RTZWxlY3RCb3hJdE9wdGlvbnMnKS5yZW1vdmUoKTtcbiAgICB9XG4gICAgLy8gUlItNDY3IC0gSWYgdGhlIHVzZXIgaXMgYXBwcm9hY2hpbmcgdGhlIHF1YW50aXR5IGxpbWl0LFxuICAgIC8vIGxpbWl0IHRoZW0gdG8gdGhlIG1heCBhbW91bnQgdGhhdCBjYW4gYmUgYWRkZWQuXG4gICAgLy8gSWYgdGhlIHVzZXIgaXMgZWRpdGluZyBhbiBpdGVtIGFscmVhZHkgaW4gY2FydCwgd2UgZG9uJ3QgbmVlZCB0byBlbmZvcmNlIHRoZSBtYXggcXVhbnRpdHkgcnVsZS5cbiAgICBpZiAoIWlzRWRpdEl0ZW0gJiYgdHlwZW9mIGRhdGEuY2FydE1heFF1YW50aXR5ICE9ICd1bmRlZmluZWQnKSB7XG5cdFx0aWYgKGRhdGEuY2FydE1heFF1YW50aXR5Lk92ZXJRdWFudGl0eUxpbWl0ICYmIGRhdGEuY2FydE1heFF1YW50aXR5LlF1YW50aXR5TGVmdCA+IDAgJiYgZGF0YS5jYXJ0TWF4UXVhbnRpdHkuUXVhbnRpdHlMZWZ0IDwgJGNvbnRhaW5lci5maW5kKCdzZWxlY3RbbmFtZT1cIlF1YW50aXR5XCJdJykudmFsKCkpIHtcblx0XHRcdCRhdmFpbGFiaWxpdHlNc2cuYXBwZW5kKCc8cCBjbGFzcz1cIm1heC1jYXJ0LXF1YW50aXR5LW1zZ1wiPicgKyBkYXRhLmNhcnRNYXhRdWFudGl0eS5xdWFudGl0eU1lc3NhZ2VBdmFpbGFibGUgKyAnPC9wPicpO1xuXHRcdH0gZWxzZSBpZiAoZGF0YS5jYXJ0TWF4UXVhbnRpdHkuT3ZlclF1YW50aXR5TGltaXQgJiYgZGF0YS5jYXJ0TWF4UXVhbnRpdHkuUXVhbnRpdHlMZWZ0ID09IDAgJiYgISghaXNFZGl0SXRlbSAmJiB0eXBlb2YgZGF0YS5lcnJvciAhPSAndW5kZWZpbmVkJyAmJiBkYXRhLmVycm9yID09ICdvdXRfb2Zfc3RvY2snICYmIGRhdGEuY2FydE1heFF1YW50aXR5LlF1YW50aXR5TGVmdCA9PSAwKSkge1xuXHRcdFx0JGF2YWlsYWJpbGl0eU1zZy5hcHBlbmQoJzxwIGNsYXNzPVwibWF4LWNhcnQtcXVhbnRpdHktbXNnXCI+JyArIGRhdGEuY2FydE1heFF1YW50aXR5LnF1YW50aXR5TWVzc2FnZU1heCArICc8L3A+Jyk7XG5cdFx0XHQkY29udGFpbmVyLmZpbmQoJyNwZHBRdHlTZWxlY3RTZWxlY3RCb3hJdCAuc2VsZWN0Ym94aXQtdGV4dCcpLnRleHQoJzAnKTtcblx0ICAgICAgICAkY29udGFpbmVyLmZpbmQoJyNwZHBRdHlTZWxlY3RTZWxlY3RCb3hJdE9wdGlvbnMnKS5yZW1vdmUoKTtcblx0ICAgICAgICAkYWRkVG9DYXJ0LmF0dHIoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG5cdCAgICB9XG4gICAgfVxuICAgIC8vIEVuc3VyZSB0aGF0IFBEUCBhZGQgYWxsIGJ1dHRvbiBpcyBkaXNhYmxlZCBpZiBvbmUgaXRlbSBpcyBub3QgYXZhaWxhYmxlXG4gICAgaWYgKCRhZGRBbGxUb0NhcnQubGVuZ3RoKSB7XG4gICAgXHRpZiAoISQoJy5wZHBGb3JtICNhZGQtdG8tY2FydDpkaXNhYmxlZCcpLmxlbmd0aCkge1xuICAgIFx0XHQkYWRkQWxsVG9DYXJ0LnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xuICAgIFx0fSBlbHNlIHtcbiAgICBcdFx0JGFkZEFsbFRvQ2FydC5wcm9wKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgIFx0fVxuICAgIH1cbiAgICBpZiAoZGF0YS5zdGF0dXMgPT0gXCJOT1RfQVZBSUxBQkxFXCIpIHtcbiAgICBcdG1lc3NhZ2UgPSAnb3V0IG9mIHN0b2NrJztcbiAgXHQgIFx0JGF2YWlsYWJpbGl0eU1zZy5hcHBlbmQoJzxwIGNsYXNzPVwibm90LWF2YWlsYWJsZS1tc2dcIj4nICsgbWVzc2FnZSArICc8L3A+Jyk7XG4gICAgfVxufTtcblxudmFyIGdldEF2YWlsYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gRG9uJ3QgbmVlZCB0byBjaGVjayBxdWFudGl0eSB3aGVuIGFkZGluZyB0byBjYXJ0LlxuXHRpZiAoJCgnLnVpLWRpYWxvZ191cGRhdGUtaXRlbScpLmxlbmd0aCkge1xuXHRcdHJldHVybjtcblx0fVxuXHR2YXIgJHRoaXMgPSAkKHRoaXMpO1xuXHR2YXIgJHBzcENvbnRhaW5lciA9ICR0aGlzLnBhcmVudHMoJy5wcm9kdWN0LXNldC1pdGVtJyk7XG5cdHZhciBpdGVtSUQgPSAnJztcblx0dmFyIHBpZCA9ICQoJyNwaWQnKTtcblx0aWYgKCRwc3BDb250YWluZXIubGVuZ3RoKSB7XG5cdFx0aXRlbUlEID0gJHBzcENvbnRhaW5lci5hdHRyKCdpZCcpO1xuXHRcdHBpZCA9ICRwc3BDb250YWluZXIuZmluZCgnI3BpZCcpO1xuXHR9XG4gICAgYWpheC5nZXRKc29uKHtcbiAgICAgICAgdXJsOiB1dGlsLmFwcGVuZFBhcmFtc1RvVXJsKFVybHMuZ2V0QXZhaWxhYmlsaXR5LCB7XG4gICAgICAgICAgICBwaWQ6IHBpZC5maXJzdCgpLnZhbCgpLFxuICAgICAgICAgICAgUXVhbnRpdHk6ICR0aGlzLnZhbCgpLFxuICAgICAgICAgICAgaXRlbUlEOiBpdGVtSURcbiAgICAgICAgfSksXG4gICAgICAgIGNhbGxiYWNrOiB1cGRhdGVDb250YWluZXJcbiAgICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdFx0JCgnI3BkcE1haW4nKS5vbignY2hhbmdlJywgJ3NlbGVjdFtuYW1lPVwiUXVhbnRpdHlcIl0nLCBnZXRBdmFpbGFiaWxpdHkpO1xuXHR9LFxuXHR1cGRhdGVDb250YWluZXI6IHVwZGF0ZUNvbnRhaW5lclxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBkaWFsb2cgPSByZXF1aXJlKCcuLi8uLi9kaWFsb2cnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xudmFyIHFzID0gcmVxdWlyZSgncXMnKTtcbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbnZhciB6b29tTWVkaWFRdWVyeSA9IG1hdGNoTWVkaWEoJyhtaW4td2lkdGg6IDk2MHB4KScpO1xudmFyICRjYWNoZSA9IHt9O1xuXHQkY2FjaGUucGRwTWFpbiA9ICQoJyNwZHBNYWluJyk7XG5cdCRjYWNoZS5wcm9kdWN0VGh1bWJuYWlsVGlsZXMgPSAkY2FjaGUucGRwTWFpbi5maW5kKCcjdGh1bWJuYWlscyAudGh1bWInKTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gRW5hYmxlcyB0aGUgem9vbSB2aWV3ZXIgb24gdGhlIHByb2R1Y3QgZGV0YWlsIHBhZ2VcbiAqIEBwYXJhbSB6bXEge01lZGlhIFF1ZXJ5IExpc3R9XG4gKi9cbmZ1bmN0aW9uIGxvYWRab29tICh6bXEpIHtcbiAgICB2YXIgJGltZ1pvb20gPSAkKCcjcGRwTWFpbiAubWFpbi1pbWFnZScpLFxuICAgICAgICBoaXJlc1VybDtcbiAgICBpZiAoIXptcSkge1xuICAgICAgICB6bXEgPSB6b29tTWVkaWFRdWVyeTtcbiAgICB9XG4gICAgaWYgKCRpbWdab29tLmxlbmd0aCA9PT0gMCB8fCBkaWFsb2cuaXNBY3RpdmUoKSB8fCB1dGlsLmlzTW9iaWxlKCkgfHwgIXpvb21NZWRpYVF1ZXJ5Lm1hdGNoZXMpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHpvb21cbiAgICAgICAgJGltZ1pvb20udHJpZ2dlcignem9vbS5kZXN0cm95Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGlyZXNVcmwgPSAkaW1nWm9vbS5hdHRyKCdocmVmJyk7XG5cbiAgICBpZiAoaGlyZXNVcmwgJiYgaGlyZXNVcmwgIT09ICdudWxsJyAmJiBoaXJlc1VybC5pbmRleE9mKCdub2ltYWdlbGFyZ2UnKSA9PT0gLTEgJiYgem9vbU1lZGlhUXVlcnkubWF0Y2hlcykge1xuICAgICAgICAkaW1nWm9vbS56b29tKHtcbiAgICAgICAgICAgIHVybDogaGlyZXNVcmxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG56b29tTWVkaWFRdWVyeS5hZGRMaXN0ZW5lcihsb2FkWm9vbSk7XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFNldHMgdGhlIG1haW4gaW1hZ2UgYXR0cmlidXRlcyBhbmQgdGhlIGhyZWYgZm9yIHRoZSBzdXJyb3VuZGluZyA8YT4gdGFnXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cyBPYmplY3Qgd2l0aCB1cmwsIGFsdCwgdGl0bGUgYW5kIGhpcmVzIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gc2V0TWFpbkltYWdlIChhdHRzLCBlKSB7XG4gICAgdmFyICR0aGlzID0gJChlLnRhcmdldCkuY2xvc2VzdCgnLnRodW1iJyk7XG4gICAgLy8gR2V0IHNlbGVjdGVkIGltYWdlIHNyY1xuICAgIHZhciBzcmMgPSAkdGhpcy5maW5kKCdpbWcnKS5hdHRyKCdzcmMnKTtcblxuICAgIGlmICghZGlhbG9nLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgJCgnLnRodW1iJykucmVtb3ZlQ2xhc3MoJ3NlbGVjdGVkJyk7XG4gICAgICAgICR0aGlzLmFkZENsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgICBpZiAoJCgnLnByb2R1Y3QtY29sLTEnKS5oYXNDbGFzcygncHJvZHVjdC1zZXQnKSkge1xuICAgICAgICAgICAgJCgnLnByb2R1Y3QtY29sLTEgLnByaW1hcnktaW1hZ2UnKS5hdHRyKCdzcmMnLCBhdHRzLnVybCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQ2xvdWRab29tXG4gICAgICAgICAgICB2YXIgY3ogPSAkKCcuY2xvdWR6b29tJykuZGF0YSgnQ2xvdWRab29tJyk7XG4gICAgICAgICAgICAvLyBMb2FkIGEgbmV3IHNtYWxsIGltYWdlIGFuZCB6b29tIGltYWdlIGludG8gaXQ6XG4gICAgICAgICAgICB2YXIgc21hbGxJbWcgPSBzcmMucmVwbGFjZSgnJHByb2R1Y3RUaHVtYm5haWwkJywgJyRsYXJnZSQnKTtcbiAgICAgICAgICAgIHZhciB6b29tSW1nID0gc21hbGxJbWcucmVwbGFjZSgnJGxhcmdlJCcsICckZnVsbHNpemUkJyk7XG4gICAgICAgICAgICAvLyBMb2FkIG5ldyBpbWFnZXMgaW50byBDbG91ZFpvb20gaW5zdGFuY2VcbiAgICAgICAgICAgIGN6LmxvYWRJbWFnZShzbWFsbEltZywgem9vbUltZyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2VsZWN0ZWRJbWdTcmMgPSBzcmMucmVwbGFjZSgnJHByb2R1Y3RUaHVtYm5haWwkJywgJyRsYXJnZSQnKTtcbiAgICAgICAgdmFyICRwcm9kdWN0UHJpbWFyeUltZyA9ICQoJyNwZHBNYWluIC5wcm9kdWN0LXByaW1hcnktaW1hZ2UgaW1nLnByaW1hcnktaW1hZ2UnKTtcbiAgICAgICAgJHByb2R1Y3RQcmltYXJ5SW1nLmF0dHIoJ3NyYycsIHNlbGVjdGVkSW1nU3JjKTtcbiAgICAgICAgJCgnI3BkcE1haW4gI3RodW1ibmFpbHMgLnRodW1iJykucmVtb3ZlQ2xhc3MoJ3NlbGVjdGVkJyk7XG4gICAgICAgICR0aGlzLmFkZENsYXNzKCdzZWxlY3RlZCcpO1xuICAgIH1cblxuICAgIHVwZGF0ZVBpbkJ1dHRvbihhdHRzLnVybCk7XG4gICAgaWYgKCFkaWFsb2cuaXNBY3RpdmUoKSAmJiAhdXRpbC5pc01vYmlsZSgpKSB7XG4gICAgICAgICQoJyNwZHBNYWluIC5tYWluLWltYWdlJykuYXR0cignaHJlZicsIGF0dHMuaGlyZXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRodW1ibmFpbENhcm91c2VsKGFsaWdtZW50KSB7XG4gICAgJCgnLnRodW1ibmFpbC1vdmVybGF5JykuamNhcm91c2VsKHtcbiAgICAgICAgYXV0bzogMCxcbiAgICAgICAgdmVydGljYWw6IGFsaWdtZW50LFxuICAgICAgICBzY3JvbGw6MVxuICAgIH0pO1xuICAgICQoJy5qY2Fyb3VzZWwtY29udHJvbC1wcmV2JylcbiAgICAub24oJ2pjYXJvdXNlbGNvbnRyb2w6YWN0aXZlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoJ2luYWN0aXZlJyk7XG4gICAgfSlcbiAgICAub24oJ2pjYXJvdXNlbGNvbnRyb2w6aW5hY3RpdmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgJCh0aGlzKS5hZGRDbGFzcygnaW5hY3RpdmUnKTtcbiAgICB9KVxuICAgIC5qY2Fyb3VzZWxDb250cm9sKHtcbiAgICAgICAgdGFyZ2V0OiAnKz0xJ1xuICAgIH0pO1xuXG4gICAgJCgnLmpjYXJvdXNlbC1jb250cm9sLW5leHQnKVxuICAgIC5vbignamNhcm91c2VsY29udHJvbDphY3RpdmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgJCh0aGlzKS5yZW1vdmVDbGFzcygnaW5hY3RpdmUnKTtcbiAgICB9KVxuICAgIC5vbignamNhcm91c2VsY29udHJvbDppbmFjdGl2ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAkKHRoaXMpLmFkZENsYXNzKCdpbmFjdGl2ZScpO1xuICAgIH0pXG4gICAgLmpjYXJvdXNlbENvbnRyb2woe1xuICAgICAgICB0YXJnZXQ6ICctPTEnXG4gICAgfSk7XG59XG5mdW5jdGlvbiB0aHVtYm5haWxDYXJvdXNlbFJlbG9hZCgpIHtcbiAgICB2YXIgaXNWZXJ0aWNhbENhcm91c2VsID0gdHJ1ZTtcbiAgICBpZiAodXRpbC5nZXRWaWV3cG9ydCgpIDwgOTYwIHx8IGRpYWxvZy5pc0FjdGl2ZSgpKSB7XG4gICAgICAgIGlzVmVydGljYWxDYXJvdXNlbCA9IGZhbHNlO1xuICAgIH1cbiAgICAkKCcudGh1bWJuYWlsLW92ZXJsYXknKS5qY2Fyb3VzZWwoJ3JlbG9hZCcsIHtcbiAgICAgICAgYXV0bzogMCxcbiAgICAgICAgdmVydGljYWw6IGlzVmVydGljYWxDYXJvdXNlbCxcbiAgICAgICAgc2Nyb2xsOjFcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGpjYXJvdXNlbEV2ZW50cygpIHtcbiAgICAvL2NsaWNrIGZ1bmN0aW9ucyB0byBtYW51YWxseSBjaGFuZ2UgbWFpbiBwcm9kdWN0IGltYWdlIG9uIGNhcm91c2VsIGFycm93IGNsaWNrIHNpbmNlIGFycm93cyBhcmVcbiAgICAvL21lYW50IHRvIGNvbnRyb2wgdGh1bWJuYWlsc1xuICAgICQoJy5wcm9kdWN0LXRodW1ibmFpbHMgLmpjYXJvdXNlbC1jb250cm9sLW5leHQnKS5vbignY2xpY2snLGZ1bmN0aW9uKGUpe1xuICAgICAgICBpZih1dGlsLmdldFZpZXdwb3J0KCkgPCA5NjEgJiYgdXRpbC5nZXRWaWV3cG9ydCgpID4gNDgxKXtcbiAgICAgICAgICAgIHZhciB0aHVtYnMgPSAkKCdsaS50aHVtYicpO1xuICAgICAgICAgICAgdmFyIGFjdGl2ZVRodW1iID0gdGh1bWJzLmZpbHRlcignLnNlbGVjdGVkJykuaW5kZXgoKTtcbiAgICAgICAgICAgIGlmKGFjdGl2ZVRodW1iID09IDApe1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld0FjdGl2ZVRodW1iID0gYWN0aXZlVGh1bWIgLSAxO1xuICAgICAgICAgICAgdGh1bWJzLmVxKGFjdGl2ZVRodW1iKS5yZW1vdmVDbGFzcygnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgIHRodW1icy5lcShuZXdBY3RpdmVUaHVtYikuYWRkQ2xhc3MoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAkKCdsaS50aHVtYi5zZWxlY3RlZCcpLmNsaWNrKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAkKCcucHJvZHVjdC10aHVtYm5haWxzIC5qY2Fyb3VzZWwtY29udHJvbC1wcmV2Jykub24oJ2NsaWNrJyxmdW5jdGlvbihlKXtcbiAgICAgICAgaWYodXRpbC5nZXRWaWV3cG9ydCgpIDwgOTYxICYmIHV0aWwuZ2V0Vmlld3BvcnQoKSA+IDQ4MSl7XG4gICAgICAgICAgICB2YXIgdGh1bWJzID0gJCgnbGkudGh1bWInKTtcbiAgICAgICAgICAgIHZhciBhY3RpdmVUaHVtYiA9IHRodW1icy5maWx0ZXIoJy5zZWxlY3RlZCcpLmluZGV4KCk7XG4gICAgICAgICAgICBpZihhY3RpdmVUaHVtYiA9PSAodGh1bWJzLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmV3QWN0aXZlVGh1bWIgPSBhY3RpdmVUaHVtYiArIDE7XG4gICAgICAgICAgICB0aHVtYnMuZXEoYWN0aXZlVGh1bWIpLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgdGh1bWJzLmVxKG5ld0FjdGl2ZVRodW1iKS5hZGRDbGFzcygnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICQoJ2xpLnRodW1iLnNlbGVjdGVkJykuY2xpY2soKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlUGluQnV0dG9uIChpbWFnZVVybCkge1xuICAgIHZhciBwaW5CdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc2hhcmUtaWNvbltkYXRhLXNoYXJlPXBpbnRlcmVzdF0nKTtcbiAgICBpZiAoIXBpbkJ1dHRvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuZXdVcmwgPSBpbWFnZVVybDtcbiAgICB2YXIgcGRwUHJpbWFyeUltYWdlRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNwZHBNYWluIC5wcmltYXJ5LWltYWdlJyk7XG4gICAgaWYgKCFwZHBQcmltYXJ5SW1hZ2VFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFpbWFnZVVybCkge1xuICAgICAgICBuZXdVcmwgPSBwZHBQcmltYXJ5SW1hZ2VFbGVtZW50LmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgfVxuICAgIHZhciBocmVmID0gdXJsLnBhcnNlKHBpbkJ1dHRvbi5ocmVmKTtcbiAgICB2YXIgcXVlcnkgPSBxcy5wYXJzZShocmVmLnF1ZXJ5KTtcbiAgICBxdWVyeS5tZWRpYSA9IHVybC5yZXNvbHZlKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBuZXdVcmwpO1xuICAgIHF1ZXJ5LnVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgIHZhciBuZXdIcmVmID0gdXJsLmZvcm1hdChfLmV4dGVuZCh7fSwgaHJlZiwge1xuICAgICAgICBxdWVyeTogcXVlcnksIC8vIHF1ZXJ5IGlzIG9ubHkgdXNlZCBpZiBzZWFyY2ggaXMgYWJzZW50XG4gICAgICAgIHNlYXJjaDogcXMuc3RyaW5naWZ5KHF1ZXJ5KVxuICAgIH0pKTtcbiAgICBwaW5CdXR0b24uaHJlZiA9IG5ld0hyZWY7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFJlcGxhY2VzIHRoZSBpbWFnZXMgaW4gdGhlIGltYWdlIGNvbnRhaW5lciwgZm9yIGVnLiB3aGVuIGEgZGlmZmVyZW50IGNvbG9yIHdhcyBjbGlja2VkLlxuICovXG5mdW5jdGlvbiByZXBsYWNlSW1hZ2VzICgpIHtcbiAgICB2YXIgJG5ld01haW5JbWFnZSA9ICQoJyN1cGRhdGUtaW1hZ2VzIC5wcm9kdWN0LWltYWdlcnktY29udGFpbmVyJyksXG4gICAgICAgICRuZXdUaHVtYm5haWxzID0gJCgnI3VwZGF0ZS1pbWFnZXMgI3RodW1ibmFpbHMnKSxcbiAgICAgICAgJG1haW5JbWFnZSA9ICQoJyNwZHBNYWluIC5wcm9kdWN0LWltYWdlcnktY29udGFpbmVyJyksXG4gICAgICAgICR0aHVtYm5haWxzID0gJCgnI3BkcE1haW4gI3RodW1ibmFpbHMnKTtcbiAgICBpZiAoJG5ld01haW5JbWFnZS5sZW5ndGggPT09IDAgfHwgJG5ld1RodW1ibmFpbHMubGVuZ3RoID09PSAwKSB7IHJldHVybjsgfVxuXG4gICAgJG1haW5JbWFnZS5odG1sKCRuZXdNYWluSW1hZ2UuaHRtbCgpKTtcbiAgICAkdGh1bWJuYWlscy5odG1sKCRuZXdUaHVtYm5haWxzLmh0bWwoKSk7XG4gICAgJG5ld01haW5JbWFnZS5yZW1vdmUoKTtcbiAgICAkbmV3VGh1bWJuYWlscy5yZW1vdmUoKTtcbiAgICBsb2FkWm9vbSgpO1xuICAgIHZhciBpc1ZlcnRpY2FsQ2Fyb3VzZWwgPSB0cnVlO1xuICAgIGlmICh1dGlsLmdldFZpZXdwb3J0KCkgPCA5NjAgfHwgZGlhbG9nLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgaXNWZXJ0aWNhbENhcm91c2VsID0gZmFsc2U7XG4gICAgfVxuICAgIHRodW1ibmFpbENhcm91c2VsKGlzVmVydGljYWxDYXJvdXNlbCk7XG59XG5cbi8qIEBtb2R1bGUgaW1hZ2VcbiAqIEBkZXNjcmlwdGlvbiB0aGlzIG1vZHVsZSBoYW5kbGVzIHRoZSBwcmltYXJ5IGltYWdlIHZpZXdlciBvbiBQRFBcbiAqKi9cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gYnkgZGVmYXVsdCwgdGhpcyBmdW5jdGlvbiBzZXRzIHVwIHpvb20gYW5kIGV2ZW50IGhhbmRsZXIgZm9yIHRodW1ibmFpbCBjbGlja1xuICoqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGRpYWxvZy5pc0FjdGl2ZSgpIHx8IHV0aWwuaXNNb2JpbGUoKSkge1xuICAgICAgICAkKCcjcGRwTWFpbiAubWFpbi1pbWFnZScpLnJlbW92ZUF0dHIoJ2hyZWYnKTtcbiAgICB9XG4gICAgdXBkYXRlUGluQnV0dG9uKCk7XG4gICAgLy9sb2FkWm9vbSgpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBDbG91ZFpvb21cbiAgICBpZiAoIWRpYWxvZy5pc0FjdGl2ZSgpKSB7XG4gICAgICAgIC8vQ2xvdWRab29tLnF1aWNrU3RhcnQoKTtcbiAgICB9XG4gICAgLy8gaGFuZGxlIHByb2R1Y3QgdGh1bWJuYWlsIGNsaWNrIGV2ZW50XG4gICAgJCgnI3BkcE1haW4nKS5vbignY2xpY2snLCAnLnRodW1iJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgLy8gc3dpdGNoIGluZGljYXRvclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHNldE1haW5JbWFnZSgkKHRoaXMpLmZpbmQoJy5wcm9kdWN0dGh1bWJuYWlsJykuZGF0YSgnbGdpbWcnKSwgZSk7XG4gICAgfSk7XG5cbiAgICBqY2Fyb3VzZWxFdmVudHMoKTtcblxufTtcbm1vZHVsZS5leHBvcnRzLmxvYWRab29tID0gbG9hZFpvb207XG5tb2R1bGUuZXhwb3J0cy5qY2Fyb3VzZWxFdmVudHMgPSBqY2Fyb3VzZWxFdmVudHM7XG5tb2R1bGUuZXhwb3J0cy5zZXRNYWluSW1hZ2UgPSBzZXRNYWluSW1hZ2U7XG5tb2R1bGUuZXhwb3J0cy5yZXBsYWNlSW1hZ2VzID0gcmVwbGFjZUltYWdlcztcbm1vZHVsZS5leHBvcnRzLnRodW1ibmFpbENhcm91c2VsID0gdGh1bWJuYWlsQ2Fyb3VzZWw7XG5tb2R1bGUuZXhwb3J0cy50aHVtYm5haWxDYXJvdXNlbFJlbG9hZCA9IHRodW1ibmFpbENhcm91c2VsUmVsb2FkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGlhbG9nID0gcmVxdWlyZSgnLi4vLi4vZGlhbG9nJyksXG5cdGdpZnRjYXJkID0gcmVxdWlyZSgnLi4vLi4vZ2lmdGNhcmQnKSxcbiAgICBwcm9kdWN0U3RvcmVJbnZlbnRvcnkgPSByZXF1aXJlKCcuLi8uLi9zdG9yZWludmVudG9yeS9wcm9kdWN0JyksXG4gICAgdG9vbHRpcCA9IHJlcXVpcmUoJy4uLy4uL3Rvb2x0aXAnKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpLFxuICAgIGFkZFRvQ2FydCA9IHJlcXVpcmUoJy4vYWRkVG9DYXJ0JyksXG4gICAgYXZhaWxhYmlsaXR5ID0gcmVxdWlyZSgnLi9hdmFpbGFiaWxpdHknKSxcbiAgICBpbWFnZSA9IHJlcXVpcmUoJy4vaW1hZ2UnKSxcbiAgICBwcm9kdWN0U2V0ID0gcmVxdWlyZSgnLi9wcm9kdWN0U2V0JyksXG4gICAgcmVjb21tZW5kYXRpb25zID0gcmVxdWlyZSgnLi9yZWNvbW1lbmRhdGlvbnMnKSxcbiAgICBzZWxlY3RCb3hJdCA9IHJlcXVpcmUoJy4uLy4uL3NlbGVjdGJveGl0JyksXG4gICAgdmFyaWFudCA9IHJlcXVpcmUoJy4vdmFyaWFudCcpO1xuXG52YXIgJGNhY2hlID0ge1xuICAgIHByb2R1Y3RUaHVtYm5haWxUaWxlczogJCgnI3BkcE1haW4nKS5maW5kKCcjdGh1bWJuYWlscyAudGh1bWInKSxcbiAgICBwZHBNYWluOiAkKCcjcGRwTWFpbicpXG59O1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gSW5pdGlhbGl6ZSBwcm9kdWN0IGRldGFpbCBwYWdlIHdpdGggcmV2aWV3cywgcmVjb21tZW5kYXRpb24gYW5kIHByb2R1Y3QgbmF2aWdhdGlvbi5cbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZURvbSgpIHtcbiAgICByZWNvbW1lbmRhdGlvbnMoKTtcbiAgICB0b29sdGlwLmluaXQoKTtcbiAgICB2YXIgaXNWZXJ0aWNhbENhcm91c2VsID0gdHJ1ZTtcbiAgICBpZiAodXRpbC5nZXRWaWV3cG9ydCgpIDwgOTYwIHx8IGRpYWxvZy5pc0FjdGl2ZSgpKSB7XG4gICAgICAgIGlzVmVydGljYWxDYXJvdXNlbCA9IGZhbHNlO1xuICAgIH1cbiAgICBpbWFnZS50aHVtYm5haWxDYXJvdXNlbChpc1ZlcnRpY2FsQ2Fyb3VzZWwpO1xufVxuZnVuY3Rpb24gY2hhbmdlVHVtYigpIHtcblx0dmFyIGF0dHJVcmwgPSAnJztcblx0dmFyIHJlcyA9ICcnO1xuXHR2YXIgaW1nO1xuXHQkKCcjdGh1bWJuYWlsLWNhcm91c2VsIC50aHVtYicpLmVhY2goZnVuY3Rpb24oKXtcblx0XHRpbWcgPSAkKHRoaXMpLmZpbmQoJ2ltZycpO1xuXHRcdGF0dHJVcmwgPSBpbWcuYXR0cignc3JjJyk7XG5cdFx0cmVzID0gYXR0clVybC5yZXBsYWNlKCdwcm9kdWN0VGh1bWJuYWlsJywgJ2xhcmdlJyk7XG5cdFx0aW1nLmF0dHIoJ3NyYycscmVzKTtcblx0fSlcblx0JCgnI3RodW1ibmFpbC1jYXJvdXNlbCcpLnNsaWNrKHtcbiAgICBcdGRvdHM6IHRydWUsXG5cdFx0aW5maW5pdGU6IHRydWUsXG5cdFx0Y2VudGVyTW9kZTogdHJ1ZSxcbiAgICAgICAgY2VudGVyUGFkZGluZzogJzQwcHgnLFxuXHRcdHNwZWVkOiAzMDAsXG5cdFx0c2xpZGVzVG9TaG93OiAxLFxuXHRcdGFycm93czogZmFsc2Vcblx0fSk7XG59XG5cbmZ1bmN0aW9uIHByb2R1Y3RUaHVtYm5haWxDbGljayhlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICghJCgnLnByb2R1Y3QtY29sLTEnKS5oYXNDbGFzcygncHJvZHVjdC1zZXQnKSkge1xuICAgICAgICAkY2FjaGUucHJvZHVjdFRodW1ibmFpbFRpbGVzLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xuXG4gICAgICAgIHZhciAkdGhpcyA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJy50aHVtYicpO1xuXG4gICAgICAgICR0aGlzLmFkZENsYXNzKCdzZWxlY3RlZCcpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBDbG91ZFpvb21cbiAgICAgICAgdmFyIGN6ID0gJChcIi5jbG91ZHpvb21cIikuZGF0YShcIkNsb3VkWm9vbVwiKTtcblxuICAgICAgICAvLyBHZXQgc2VsZWN0ZWQgaW1hZ2Ugc3JjXG4gICAgICAgIHZhciBzcmMgPSAkdGhpcy5maW5kKCdpbWcnKS5hdHRyKCdzcmMnKTtcblxuICAgICAgICAvLyBMb2FkIGEgbmV3IHNtYWxsIGltYWdlIGFuZCB6b29tIGltYWdlIGludG8gaXQ6XG4gICAgICAgIHZhciBzbWFsbEltZyA9IHNyYy5yZXBsYWNlKFwiJHByb2R1Y3RUaHVtYm5haWwkXCIsIFwiJGxhcmdlJFwiKTtcbiAgICAgICAgdmFyIHpvb21JbWcgPSBzbWFsbEltZy5yZXBsYWNlKFwiJGxhcmdlJFwiLCBcIiRmdWxsc2l6ZSRcIik7XG5cbiAgICAgICAgLy8gTG9hZCBuZXcgaW1hZ2VzIGludG8gQ2xvdWRab29tIGluc3RhbmNlXG4gICAgICAgIGN6LmxvYWRJbWFnZShzbWFsbEltZywgem9vbUltZyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBJbml0aWFsaXplIGV2ZW50IGhhbmRsZXJzIG9uIHByb2R1Y3QgZGV0YWlsIHBhZ2VcbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZUV2ZW50cygpIHtcblxuICAgIGFkZFRvQ2FydCgpO1xuICAgIGF2YWlsYWJpbGl0eS5pbml0KCk7XG4gICAgdmFyaWFudCgpO1xuICAgIGltYWdlKCk7XG4gICAgcHJvZHVjdFNldCgpO1xuICAgIGdpZnRjYXJkLmluaXQoKTtcbiAgICB1dGlsLnNtYXJ0UmVzaXplKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW1hZ2UudGh1bWJuYWlsQ2Fyb3VzZWxSZWxvYWQoKVxuICAgIH0pO1xuXG4gICAgaWYgKFNpdGVQcmVmZXJlbmNlcy5TVE9SRV9QSUNLVVApIHtcbiAgICAgICAgcHJvZHVjdFN0b3JlSW52ZW50b3J5LmluaXQoKTtcbiAgICB9XG4gICAgJGNhY2hlLnBkcE1haW4ub24oJ2NsaWNrJywgJy5zaXplZ3VpZGVsaW5rJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgd2lkdGggPSAod2luZG93LmlubmVyV2lkdGggPCA0ODApID8gKHdpbmRvdy5pbm5lcldpZHRoIC0gNDApLnRvU3RyaW5nKCkgOiAnNDUwJztcbiAgICAgICAgZGlhbG9nLm9wZW4oe1xuICAgICAgICAgICAgdXJsOiB0aGlzLmhyZWYsXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBcdCd3aWR0aCc6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGRpYWxvZ0NsYXNzOiBcInNpemVndWlkZS1tb2RhbFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgfSk7XG4gICAgLy8gQWRkIHRvIFdpc2hsaXN0IGFuZCBBZGQgdG8gR2lmdCBSZWdpc3RyeSBsaW5rcyBiZWhhdmlvcnNcbiAgICAkY2FjaGUucGRwTWFpbi5vbignY2xpY2snLCAnW2RhdGEtYWN0aW9uPVwid2lzaGxpc3RcIl0sIFtkYXRhLWFjdGlvbj1cImdpZnQtcmVnaXN0cnlcIl0nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdXRpbC5nZXRRdWVyeVN0cmluZ1BhcmFtcygkKCcucGRwRm9ybScpLnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgaWYgKGRhdGEuY2FydEFjdGlvbikge1xuICAgICAgICAgICAgZGVsZXRlIGRhdGEuY2FydEFjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXJsID0gdXRpbC5hcHBlbmRQYXJhbXNUb1VybCh0aGlzLmhyZWYsIGRhdGEpO1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnaHJlZicsIHVybCk7XG4gICAgfSk7XG5cbiAgICAvKlByb2R1Y3QgVGFibGV0IFNoYXJlIGJ1dHRvbiovXG4gICAgJGNhY2hlLnBkcE1haW4ub24gKCdjbGljaycsICcuc3ViLWhlYWRlcicsIGZ1bmN0aW9uKGUpe1xuICAgIFx0JCh0aGlzKS50b2dnbGVDbGFzcygnYWN0aXZlJyk7XG4gICAgfSk7XG4gICAgLy8gcHJvZHVjdCBvcHRpb25zXG4gICAgJGNhY2hlLnBkcE1haW4ub24oJ2NoYW5nZScsICcucHJvZHVjdC1vcHRpb25zIHNlbGVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNhbGVzUHJpY2UgPSAkY2FjaGUucGRwTWFpbi5maW5kKCcucHJvZHVjdC1hZGQtdG8tY2FydCAucHJpY2Utc2FsZXMnKTtcbiAgICAgICAgdmFyIHNlbGVjdGVkSXRlbSA9ICQodGhpcykuY2hpbGRyZW4oKS5maWx0ZXIoJzpzZWxlY3RlZCcpLmZpcnN0KCk7XG4gICAgICAgIHNhbGVzUHJpY2UudGV4dChzZWxlY3RlZEl0ZW0uZGF0YSgnY29tYmluZWQnKSk7XG4gICAgfSk7XG5cbiAgICAkY2FjaGUucGRwTWFpbi5vbignY2xpY2snLCAnLnNlbGVjdC1xdWFudGl0eScsIGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2koUGhvbmV8UGFkKS9pKSkge1xuICAgICAgICAgICAgJCgnLnNlbGVjdGJveGl0LW9wdGlvbnMuZHJvcGRvd24tbWVudScpLmhpZGUoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gcHJldmVudCBkZWZhdWx0IGJlaGF2aW9yIG9mIHRodW1ibmFpbCBsaW5rIGFuZCBhZGQgdGhpcyBCdXR0b25cbiAgICAkY2FjaGUucGRwTWFpbi5vbignY2xpY2snLCAnLnRodW1ibmFpbC1saW5rJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuXG4gICAgJGNhY2hlLnBkcE1haW4ub24oJ2NsaWNrJywgJy51bnNlbGVjdGFibGUtb3ZlcmxheScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgJCh0aGlzKS5jbG9zZXN0KCdsaScpLmZpbmQoJ2EnKS5jbGljaygpO1xuICAgIH0pO1xuXG4gICAgJCgnLnNpemUtY2hhcnQtbGluayBhJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkaWFsb2cub3Blbih7XG4gICAgICAgICAgICB1cmw6ICQoZS50YXJnZXQpLmF0dHIoJ2hyZWYnKVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgICRjYWNoZS5wZHBNYWluLm9uKFwiY2xpY2tcIiwgXCIuZmFjZWJvb2stc2hhcmVcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBGQi51aSh7XG4gICAgICAgICAgICBtZXRob2Q6ICdzaGFyZScsXG4gICAgICAgICAgICBocmVmOiAkKGUudGFyZ2V0KS5hdHRyKCdkYXRhLXVybCcpLFxuICAgICAgICB9LCBmdW5jdGlvbihyZXNwb25zZSl7fSk7XG4gICAgfSk7XG4gICAgJGNhY2hlLnBkcE1haW4ub24oXCJjbGlja1wiLCBcIi50d2l0dGVyLXNoYXJlIGFcIiwgZnVuY3Rpb24oZSkge1xuICAgIFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIFx0d2luZG93Lm9wZW4odGhpcy5ocmVmLCBcIlR3aXR0ZXIgc2hhcmVcIiwgXCJ3aWR0aD04MDAsIGhlaWdodD0yNTVcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcblxuICAgICQoJ2JvZHknKS5vbignY2xpY2snLCcjZnVsbHNjcmVlbi16b29tLWhvcHVwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHQvLyBDcmVhdGUgRGlhbG9nXG4gICAgICAgIHZhciBwYXJhbXMgPSB7fTtcblxuXG5cdFx0Ly9Qb3RlbnRpYWxseSBhZGQgbW9ub2dyYW1taW5nIG9wdGlvbiBwYXJhbWV0ZXJzXG5cdFx0Lyp2YXIgJG1vbm9ncmFtbWluZ0NvbnRhaW5lciA9IHBkcE1haW4uZmluZCgnLm1vbm9ncmFtLWNvbnRhaW5lcicpO1xuXG5cdFx0aWYoJG1vbm9ncmFtbWluZ0NvbnRhaW5lci5sZW5ndGgpe1xuXG5cdFx0XHR2YXIgaW1nT3B0aW9ucyA9ICRtb25vZ3JhbW1pbmdDb250YWluZXIuZGF0YSgnaW1hZ2VPcHRpb25zJyksXG5cdFx0XHRcdHBlcnNvbmFsaXphdGlvblR5cGUgPSAkbW9ub2dyYW1taW5nQ29udGFpbmVyLmZpbmQoJ3VsLm1vbm9ncmFtLXN0eWxlcyBsaS5tb25vZ3JhbS1zdHlsZS10aWxlLnNlbGVjdGVkJykuZGF0YSgnc3R5bGUtY29uZmlnJykucGVyc29uYWxpemF0aW9uVHlwZTtcblxuXHRcdFx0dmFyIHZhbGlkID0gKGltZ09wdGlvbnNbJyRmdHlwZSddICE9IG51bGwgJiZcblx0XHRcdFx0aW1nT3B0aW9uc1snJGZzdHlsZSddICE9ICBudWxsICYmXG5cdFx0XHRcdGltZ09wdGlvbnNbJyRkb3RzJ10gIT0gbnVsbCAmJlxuXHRcdFx0XHQoaW1nT3B0aW9uc1snJGNocjEnXSAhPSBudWxsIHx8IGltZ09wdGlvbnNbJyRjaHIyJ10gIT0gbnVsbCB8fCBpbWdPcHRpb25zWyckY2hyMyddICE9IG51bGwpKTtcblxuXHRcdFx0aWYoJG1vbm9ncmFtbWluZ0NvbnRhaW5lci5maW5kKCdsaS5tb25vZ3JhbS1jb2xvci1zd2F0Y2gnKS5sZW5ndGgpe1xuXHRcdFx0XHR2YWxpZCA9IHZhbGlkICYmIGltZ09wdGlvbnNbJyRjb2xvciddICE9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmKHZhbGlkKXtcblxuXHRcdFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKGltZ09wdGlvbnMpLFxuXHRcdFx0XHRcdG5ld0ltZ09wdGlvbnMgPSB7fTtcblxuXHRcdFx0XHQvL2FkZCB0aGUgcHJlZml4IHRvIG1ha2UgaXQgZWFzeSBvbiB0aGUgc2VydmVyc2lkZSB0byBncmFiIGFsbCBvZiB0aGUgcmlnaHQgcGFyYW1ldGVyc1xuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7aSsrKXtcblx0XHRcdFx0XHR2YXIga2V5ID0gXCJpbWdPcHRpb25fXCIra2V5c1tpXTtcblxuXHRcdFx0XHRcdG5ld0ltZ09wdGlvbnNba2V5XSA9IGltZ09wdGlvbnNba2V5c1tpXV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRuZXdJbWdPcHRpb25zW1wicGVyc29uYWxpemF0aW9uVHlwZVwiXSA9IHBlcnNvbmFsaXphdGlvblR5cGU7XG5cblx0XHRcdFx0cGFyYW1zID0gbmV3SW1nT3B0aW9ucztcblx0XHRcdH1cblx0XHR9Ki9cblxuXG4gICAgICAgIHZhciB1cmwgPSB1dGlsLmFwcGVuZFBhcmFtc1RvVXJsKCQodGhpcykuYXR0cignaHJlZicpLHBhcmFtcyk7XG4gICAgICAgIGRpYWxvZy5vcGVuKHtcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA4OTUsXG4gICAgICAgICAgICAgICAgZGlhbG9nQ2xhc3M6ICdmdWxsU2NyZWVuJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZGlhbG9nQ29udGFpbmVyID0gJCgnI2RpYWxvZy1jb250YWluZXInKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvZHVjdEltYWdlID0gZGlhbG9nQ29udGFpbmVyLmZpbmQoJCgnLnByb2R1Y3QtcHJpbWFyeS1pbWFnZSBpbWcnKSk7XG4gICAgICAgICAgICAgICAgdmFyIGRvd25sb2FkTGluayA9ICQoJyNmdWxsc2NyZWVuLWRvd25sb2FkIGEnKTtcbiAgICAgICAgICAgICAgICBkaWFsb2dDb250YWluZXIuZmluZCgkKCcudWktZGlhbG9nLXRpdGxlYmFyLWNsb3NlJykuYWRkQ2xhc3MoJ2Z1bGxzY3JlZW4tem9vbS1jbG9zZScpKTtcblxuICAgICAgICAgICAgICAgIHZhciByZXBsYWNlU3RyID0gJyRzN2Z1bGxzaXplJCc7XG5cdFx0XHRcdC8qaWYoJG1vbm9ncmFtbWluZ0NvbnRhaW5lci5sZW5ndGgpe1xuXHRcdFx0XHRcdHJlcGxhY2VTdHIgPSBcIiRwcm9kdWN0VGh1bWJuYWlsJFwiO1xuXHRcdFx0XHR9Ki9cblxuICAgICAgICAgICAgICAgICQoJy50aHVtYiBhJykuY2xpY2soZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZVNyYyA9ICQodGhpcykuYXR0cignaHJlZicpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBmdWxsU2NyZWVuSW1nID0gaW1hZ2VTcmMucmVwbGFjZShyZXBsYWNlU3RyLCAnJGZ1bGxzY3JlZW4kJyk7XG4gICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJbWFnZS5hdHRyKCdzcmMnLCBmdWxsU2NyZWVuSW1nKTtcblxuXHRcdFx0XHRcdC8vIEFwcGVuZCBTY2VuZTcgcGFyYW0gZm9yY2UgZG93bmxvYWRcbiAgICAgICAgICAgICAgICAgICAgZnVsbFNjcmVlbkltZyArPSAnJmRvd25sb2FkJztcbiAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRMaW5rLmF0dHIoJ2hyZWYnLCBmdWxsU2NyZWVuSW1nKTtcbiAgICAgICAgICAgICAgICAgICAgJChlLnRhcmdldCkuY2xvc2VzdCgnbGknKS5hZGRDbGFzcygnc2VsZWN0ZWQnKS5zaWJsaW5ncygpLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmKCQoJyNkaWFsb2ctY29udGFpbmVyICN0aHVtYm5haWwtY2Fyb3VzZWwgbGkudGh1bWInKS5sZW5ndGggPiA0KXtcblx0ICAgICAgICAgICAgICAgICQoJyNkaWFsb2ctY29udGFpbmVyICN0aHVtYm5haWwtY2Fyb3VzZWwnKS5zbGljayh7XG5cdCAgICAgICAgICAgICAgICBcdGRvdHM6IGZhbHNlLFxuXHQgICAgICAgICAgICBcdFx0aW5maW5pdGU6IGZhbHNlLFxuXHQgICAgICAgICAgICBcdFx0c3BlZWQ6IDMwMCxcblx0ICAgICAgICAgICAgXHRcdHNsaWRlc1RvU2hvdzogNCxcblx0ICAgICAgICAgICAgXHRcdGFycm93czogdHJ1ZSxcblx0ICAgICAgICAgICAgXHRcdHZlcnRpY2FsOiB0cnVlXG5cdCAgICAgICAgICAgIFx0fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciAkbGlzdCA9IGRpYWxvZ0NvbnRhaW5lci5maW5kKCcudGh1bWJuYWlsLW92ZXJsYXknKTtcblxuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gZGlhbG9nQ29udGFpbmVyLmZpbmQoJyNuZXh0Jyk7XG4gICAgICAgICAgICAgICAgdmFyIHByZXYgPSBkaWFsb2dDb250YWluZXIuZmluZCgnI3ByZXYnKTtcblxuXG4gICAgICAgICAgICAgICAgdmFyICRmaXJzdCA9ICQoJ2xpOmZpcnN0JywgJGxpc3QpLFxuICAgICAgICAgICAgICAgICAgICAkbGFzdCA9ICQoJ2xpOmxhc3QnLCAkbGlzdCk7XG5cbiAgICAgICAgICAgICAgICBuZXh0LmNsaWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyICRuZXh0LCAkc2VsZWN0ZWQgPSBkaWFsb2dDb250YWluZXIuZmluZCgoJy5zZWxlY3RlZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgJG5leHQgPSAkc2VsZWN0ZWQubmV4dCgnbGknKS5sZW5ndGggPyAkc2VsZWN0ZWQubmV4dCgnbGknKSA6ICRmaXJzdDtcbiAgICAgICAgICAgICAgICAgICAgJHNlbGVjdGVkLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAkbmV4dC5hZGRDbGFzcygnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9ICRuZXh0LmZpbmQoJ2EnKS5hdHRyKCdocmVmJyk7XG4gICAgICAgICAgICAgICAgICAgIC8qaWYgKCRtb25vZ3JhbW1pbmdDb250YWluZXIubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKHJlcGxhY2VTdHIsJyRmdWxsc2NyZWVuJCcpO1xuICAgICAgICAgICAgICAgICAgICB9Ki9cblxuICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SW1hZ2UuYXR0cignc3JjJywgdXJsKTtcbiAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRMaW5rLmF0dHIoJ2hyZWYnLCB1cmwpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgkbGFzdC5oYXNDbGFzcygnc2VsZWN0ZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgnLmpjYXJvdXNlbC1uZXh0JykudHJpZ2dlcignY2xpY2snKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcHJldi5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAkcHJldiwgJHNlbGVjdGVkID0gZGlhbG9nQ29udGFpbmVyLmZpbmQoKCcuc2VsZWN0ZWQnKSk7XG4gICAgICAgICAgICAgICAgICAgICRwcmV2ID0gJHNlbGVjdGVkLnByZXYoJ2xpJykubGVuZ3RoID8gJHNlbGVjdGVkLnByZXYoJ2xpJykgOiAkbGFzdDtcbiAgICAgICAgICAgICAgICAgICAgJHNlbGVjdGVkLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAkcHJldi5hZGRDbGFzcygnc2VsZWN0ZWQnKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gJHByZXYuZmluZCgnYScpLmF0dHIoJ2hyZWYnKTtcblxuICAgICAgICAgICAgICAgICAgICAvKmlmICgkbW9ub2dyYW1taW5nQ29udGFpbmVyLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShyZXBsYWNlU3RyLCckZnVsbHNjcmVlbiQnKTtcbiAgICAgICAgICAgICAgICAgICAgfSovXG5cbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjdEltYWdlLmF0dHIoJ3NyYycsIHVybCk7XG4gICAgICAgICAgICAgICAgICAgIGRvd25sb2FkTGluay5hdHRyKCdocmVmJywgdXJsKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoJGZpcnN0Lmhhc0NsYXNzKCdzZWxlY3RlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKCcuamNhcm91c2VsLXByZXYnKS50cmlnZ2VyKCdjbGljaycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBjbGVhciBkaWFsb2cgb24gY2xvc2VcbiAgICAgICAgICAgICAgICAkKCcudWktZGlhbG9nLmZ1bGxTY3JlZW4gLnVpLWljb24tY2xvc2V0aGljaycpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgJCgnLnVpLWRpYWxvZy5mdWxsU2NyZWVuIC5kaWFsb2ctY29udGVudCcpLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcGRwTWFpbkNhcm91c2VsID0gJCgnI3BkcE1haW4gI3RodW1ibmFpbC1jYXJvdXNlbCAuc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICBpZiAocGRwTWFpbkNhcm91c2VsLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRJbmRleCA9IHBkcE1haW5DYXJvdXNlbC5pbmRleCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29ycmVzcG9uZGluZ0ZTWm9vbUltYWdlID0gJGxpc3QuZmluZCgnbGknKS5lcShzZWxlY3RlZEluZGV4KS5maW5kKCdhJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3JyZXNwb25kaW5nRlNab29tSW1hZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kaW5nRlNab29tSW1hZ2UuY2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgJCh3aW5kb3cpLnJlc2l6ZShmdW5jdGlvbigpe1xuICAgIFx0JCgnI2xhc3QtdmlzaXRlZCAuc2xpY2stc2xpZGVyJykuc2xpY2soJ3JlZnJlc2gnKTtcbiAgICAgICAgJCgnLnBkcC1yZWNvbW1lbmRhdGlvbnMgLnByb2R1Y3QtbGlzdGluZyAuc2xpY2stc2xpZGVyJykuc2xpY2soJ3JlZnJlc2gnKTtcbiAgICB9KTtcblxuICAgIGlmICh1dGlsLmdldFZpZXdwb3J0KCkgPCA0ODEpe1xuICAgIFx0Y2hhbmdlVHVtYigpO1xuXHQgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNhcm91c2VsID0gJCgnI3RodW1ibmFpbC1jYXJvdXNlbCcpO1xuICAgICAgICBpZiAoY2Fyb3VzZWwuaGFzQ2xhc3MoJ3NsaWNrLWluaXRpYWxpemUnKSkge1xuICAgICAgICAgICAgY2Fyb3VzZWwuc2xpY2soJ3Vuc2xpY2snKTtcbiAgICAgICAgfVxuXHQgfVxuXG4gICAgJCh3aW5kb3cpLnJlc2l6ZShmdW5jdGlvbigpe1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh1dGlsLmdldFZpZXdwb3J0KCkgPCA0ODEpIHtcbiAgICAgICAgICAgIFx0Y2hhbmdlVHVtYigpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjYXJvdXNlbCA9ICQoJyN0aHVtYm5haWwtY2Fyb3VzZWwnKTtcbiAgICAgICAgICAgICAgICBpZiAoY2Fyb3VzZWwuaGFzQ2xhc3MoJ3NsaWNrLWluaXRpYWxpemUnKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXJvdXNlbC5zbGljaygndW5zbGljaycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMTAwKTtcbiAgICB9KTtcblxuICAgIC8vVHJ1ZSBGaXRcbiAgICBpZiAodHlwZW9mIHRmYyAhPT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICB0ZmMuZXZlbnQoJ3RmYy1maXRyZWMtcHJvZHVjdCcsICdzdWNjZXNzJywgZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgZml0cmVjX3NlbGVjdHNpemUoY29udGV4dC5maXRSZWNvbW1lbmRhdGlvbi5zaXplLCBjb250ZXh0LmZpdFJlY29tbWVuZGF0aW9uLnNjb3JlLCBmYWxzZSwgY29udGV4dC5maXRSZWNvbW1lbmRhdGlvbi5pZCk7XG4gICAgICAgICAgICAkKCcucmVnaXN0cnksIC53aXNobGlzdCcpLnJlbW92ZUNsYXNzKCdibG9ja2VkJykuYWRkQ2xhc3MoJ3dsLWFjdGlvbicpO1xuICAgICAgICAgICAgaWYoJChcIi5pdGVtLVwiICsgY29udGV4dC5maXRSZWNvbW1lbmRhdGlvbi5pZCArIFwiICN2YS1zaXplXCIpLnZhbCgpICE9ICcnKXtcbiAgICAgICAgICAgICAgICAkKCcjYWRkLXRvLWNhcnQnKS5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaXRyZWNfc2VsZWN0c2l6ZShzaXplLCBzY29yZSwgdXNlc0Ryb3BEb3duLCBwcm9kdWN0SUQpe1xuICAgICAgICAvL1RydWUgZml0IHNpemUgdXBkYXRlXG4gICAgICAgIGlmKCQoXCIjaXRlbS1cIiArIHByb2R1Y3RJRCkubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICAvL0Ryb3AgRG93biBmb3Igc2l6ZVxuICAgICAgICAgICAgaWYoISQoXCIjaXRlbS1cIiArIHByb2R1Y3RJRCkuaGFzQ2xhc3MoXCJ0Zi1zaXplLWF1dG8tc2VsZWN0ZWRcIikpe1xuICAgICAgICAgICAgICAgICQoXCIjaXRlbS1cIiArIHByb2R1Y3RJRCArIFwiICN2YS1zaXplIG9wdGlvbjpzZWxlY3RlZFwiKS5yZW1vdmVBdHRyKFwic2VsZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgJChcIiNpdGVtLVwiICsgcHJvZHVjdElEICsgXCIgI3ZhLXNpemUgb3B0aW9uW3ZhbHVlKj0nc2l6ZT1cIiArIHNpemUgKyBcIiddXCIpLmF0dHIoJ3NlbGVjdGVkJywgJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgLy9BZGQgY2xhc3Mgc28gdXNlciBjYW4gb3ZlcndyaXRlIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICQoXCIjaXRlbS1cIiArIHByb2R1Y3RJRCkuYWRkQ2xhc3MoXCJ0Zi1zaXplLWF1dG8tc2VsZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgLy9SZWZyZXNoIHNlbGVjdEJveEl0XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdEJveCA9ICQoXCIjaXRlbS1cIiArIHByb2R1Y3RJRCArIFwiICN2YS1zaXplXCIpLnNlbGVjdEJveEl0KCkuZGF0YShcInNlbGVjdEJveEl0XCIpO1xuICAgICAgICAgICAgICAgIHNlbGVjdEJveC5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgJChcIiNpdGVtLVwiICsgcHJvZHVjdElEICsgXCIgI3ZhLXNpemVcIikudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIC8vTGlua3MgZm9yIHNpemVcbiAgICAgICAgICAgIGlmKCQoJy5wcm9kdWN0LXZhcmlhdGlvbnMgLnNpemUgLnNlbGVjdGVkJykubGVuZ3RoIDwgMSl7XG4gICAgICAgICAgICAgICAgJCgnLnNpemUtbGluay0nICsgc2l6ZSkuY2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGluaXRpYWxpemUgZUdDIGltYWdlIGhpZGRlbiBhdHRyaWJ1dGVzIChvbmx5IHJlcXVpcmVkIG9uIHBhZ2UgbG9hZClcbiAgICB2YXIgZUdDSW1hZ2VFbGVtZW50ID0gJCgnaW5wdXQjZ2NJbWFnZScpO1xuICAgIHZhciBlR0NTdG9yZWZyb250SW1hZ2VFbGVtZW50ID0gJCgnaW5wdXQjZ2NTdG9yZWZyb250SW1hZ2UnKTtcbiAgICB2YXIgc2VsZWN0ZWRDb2xvciA9ICQoJ3VsLnN3YXRjaGVzLkNvbG9yIGxpLnNlbGVjdGVkIGEnKTtcbiAgICBpZiAoZUdDSW1hZ2VFbGVtZW50Lmxlbmd0aCAmJiBzZWxlY3RlZENvbG9yLmxlbmd0aCl7XG4gICAgXHRlR0NJbWFnZUVsZW1lbnQudmFsKHNlbGVjdGVkQ29sb3IuZGF0YSgnc3JjJykpO1xuICAgIH1cbiAgICBpZiAoZUdDU3RvcmVmcm9udEltYWdlRWxlbWVudC5sZW5ndGggJiYgc2VsZWN0ZWRDb2xvci5sZW5ndGgpIHtcbiAgICBcdGVHQ1N0b3JlZnJvbnRJbWFnZUVsZW1lbnQudmFsKHNlbGVjdGVkQ29sb3IuYXR0cignaHJlZicpKTtcbiAgICB9XG5cbiAgICAvLyBpbml0IFNsaWNrIHNsaWRlciB3aGVuIHBkcC1yZWNvbW1lbmRhdGlvbiBoYXMgYmVlbiBsb2FkZWQgaW50byBwYWdlXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncGRwUmVjb21tZW5kYXRpb25PbkxvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaW5pdGlhbGl6ZVNsaWNrKCQoJy5wZHAtcmVjb21tZW5kYXRpb25zIC5wcm9kdWN0LWxpc3RpbmcnKSk7XG4gICAgfSk7XG5cbiAgICAkY2FjaGUucHJvZHVjdFRodW1ibmFpbFRpbGVzLmNsaWNrKHByb2R1Y3RUaHVtYm5haWxDbGljayk7XG59XG5cbmZ1bmN0aW9uIGFkZFRvQ2Fyb3VzZWwocGFyZW50RGl2KXtcblx0Ly8gUGFzcyBwYXJlbnQgZWxlbWVudFxuICAgIHZhciBjYXJvdXNlbEl0ZW0gPSBwYXJlbnREaXYuZmluZCgndWwnKTtcbiAgICB2YXIgdGh1bWJDb3VudCA9IGNhcm91c2VsSXRlbS5maW5kKCQoJ2xpJykpO1xuXG5cdC8vIFNoaWZ0IHRodW1icyB0byBmaXQgY29udGFpbmVyIDQgdGh1bWJzXG4gICAgaWYgKHRodW1iQ291bnQubGVuZ3RoID09IDQpe1xuICAgICAgICB0aHVtYkNvdW50LmFkZENsYXNzKCdzaGlmdC1sZWZ0Jyk7XG4gICAgfVxuXG5cdC8vIElmIHdlIGhhdmUgNCBvciBtb3JlIHRodW1icyBpbml0IGNhcm91c2VsXG4gICAgaWYgKGNhcm91c2VsSXRlbS5sZW5ndGggJiYgdGh1bWJDb3VudC5sZW5ndGggPj0gNCkge1xuICAgIFx0Y2Fyb3VzZWxJdGVtLmpjYXJvdXNlbCh7XG4gICAgICAgICAgICBzY3JvbGw6MSxcbiAgICAgICAgICAgIGl0ZW1GYWxsYmFja0RpbWVuc2lvbjogMTAwXG4gICAgICAgIH0pO1xuXG5cdFx0Ly8gU3dpcGUgZnVuY3Rpb25hbGl0eVxuICAgICAgICBjYXJvdXNlbEl0ZW0udG91Y2h3aXBlKHtcbiAgICAgICAgICAgIHdpcGVMZWZ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjYXJvdXNlbEl0ZW0uamNhcm91c2VsKCduZXh0Jyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2lwZVJpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjYXJvdXNlbEl0ZW0uamNhcm91c2VsKCdwcmV2Jyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJldmVudERlZmF1bHRFdmVudHM6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZVNsaWNrKHBhcmVudERpdil7XG4gICAgLy8gUGFzcyBwYXJlbnQgZWxlbWVudFxuICAgIHZhciBjYXJvdXNlbEl0ZW0gPSBwYXJlbnREaXYuZmluZCgndWwnKTtcbiAgICB2YXIgdGh1bWJDb3VudCA9IGNhcm91c2VsSXRlbS5maW5kKCQoJ2xpJykpO1xuXG4gICAgaWYoY2Fyb3VzZWxJdGVtLmhhc0NsYXNzKCdzbGljay1zbGlkZXInKSl7XG4gICAgICAgIGNhcm91c2VsSXRlbS5zbGljaygndW5zbGljaycpO1xuICAgIH1cblxuICAgIGNhcm91c2VsSXRlbS5zbGljayh7XG4gICAgICAgIGluZmluaXRlOiB0cnVlLFxuICAgICAgICBkb3RzOiBmYWxzZSxcbiAgICAgICAgc2xpZGU6ICdsaScsXG4gICAgICAgIHJlc3BvbnNpdmU6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBicmVha3BvaW50OiA5OTk5OSxcbiAgICAgICAgICAgICAgICBzZXR0aW5nczogdGh1bWJDb3VudC5sZW5ndGggPCA0ID8gXCJ1bnNsaWNrXCIgOiB7c2xpZGVzVG9TaG93OiA0fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBicmVha3BvaW50OiA0ODAsXG4gICAgICAgICAgICAgICAgc2V0dGluZ3M6IHRodW1iQ291bnQubGVuZ3RoIDw9IDIgPyBcInVuc2xpY2tcIiA6IHtzbGlkZXNUb1Nob3c6IDJ9XG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9KTtcblxufVxuXG4vLyBVSVMgLSBDaGVjayBwcm9kdWN0IGludmVudG9yeVxuZnVuY3Rpb24gaW5pdGlhbGl6ZVVJUyAoKSB7XG4gICAgdmFyIHBpZCA9ICQoJ2lucHV0I3Vpc1Byb2R1Y3RJRCcpLnZhbCgpO1xuICAgIHZhciB1cmwgPSBhcHAudXRpbC5hcHBlbmRQYXJhbXNUb1VybCggVXJscy51aXNQcm9kdWN0SW5jbHVkZSwgeyBwcm9kdWN0SUQ6IHBpZCB9ICk7XG4gICAgJC5nZXQoIHVybCwgbnVsbCApO1xufVxuXG52YXIgcHJvZHVjdCA9IHtcbiAgICBpbml0aWFsaXplRXZlbnRzOiBpbml0aWFsaXplRXZlbnRzLFxuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5pdGlhbGl6ZURvbSgpO1xuICAgICAgICBpbml0aWFsaXplRXZlbnRzKCk7XG4gICAgICAgIGluaXRpYWxpemVVSVMoKTtcbiAgICAgICAgc2VsZWN0Qm94SXQuc2VsZWN0Qm94SXQoJCgnLnNlbGVjdC1xdWFudGl0eScpKTtcbiAgICAgICAgc2VsZWN0Qm94SXQuc2VsZWN0Qm94SXQoJCgnI2djQW1vdW50c2VsZWN0JykpO1xuICAgICAgICAvLyBJbml0IFJlY29tbWVuZGF0aW9ucyBDYXJvdXNlbFxuICAgICAgICBhZGRUb0Nhcm91c2VsKCQoJyNyZWNvbW1lbmRhdGlvbnMnKSk7XG4gICAgICAgIC8vIEluaXQgXCJNb3JlIGluXCIgQ2Fyb3VzZWxcbiAgICAgICAgYWRkVG9DYXJvdXNlbCgkKCcjbW9yZUluQ2F0JykpO1xuICAgICAgICAvLyBJbml0IExhc3QgVmlzaXRlZCBDYXJvdXNlbFxuICAgICAgICBpbml0aWFsaXplU2xpY2soJCgnI2xhc3QtdmlzaXRlZCcpKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHByb2R1Y3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhamF4ID0gcmVxdWlyZSgnLi4vLi4vYWpheCcpLFxuICAgIHRvb2x0aXAgPSByZXF1aXJlKCcuLi8uLi90b29sdGlwJyksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKSxcbiAgICBzZWxlY3RCb3hJdCA9IHJlcXVpcmUoJy4uLy4uL3NlbGVjdGJveGl0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkYWRkVG9DYXJ0ID0gJCgnI2FkZC10by1jYXJ0JyksXG4gICAgICAgICRhZGRBbGxUb0NhcnQgPSAkKCcjYWRkLWFsbC10by1jYXJ0JyksXG4gICAgICAgICRwcm9kdWN0U2V0TGlzdCA9ICQoJyNwcm9kdWN0LXNldC1saXN0Jyk7XG5cbiAgICB2YXIgdXBkYXRlQWRkVG9DYXJ0QnV0dG9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCRwcm9kdWN0U2V0TGlzdC5maW5kKCcuYWRkLXRvLWNhcnRbZGlzYWJsZWRdJykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgJGFkZEFsbFRvQ2FydC5hdHRyKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgLy8gcHJvZHVjdCBzZXQgZG9lcyBub3QgaGF2ZSBhbiBhZGQtdG8tY2FydCBidXR0b24sIGJ1dCBwcm9kdWN0IGJ1bmRsZSBkb2VzLlxuICAgICAgICAgICAgLy8gaWYgdGhlIGJ1dHRvbiBpcyBhbHJlYWR5IGRpc2FibGVkLCBubyBuZWVkIHRvIGRpc2FibGUgYWxsIGJ1dHRvbnMgb24gdGhlIHBhZ2UuXG4gICAgICAgICAgICAvLyRhZGRUb0NhcnQuYXR0cignZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRhZGRBbGxUb0NhcnQucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICRhZGRUb0NhcnQucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoJHByb2R1Y3RTZXRMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdXBkYXRlQWRkVG9DYXJ0QnV0dG9ucygpO1xuICAgIH1cbiAgICAvLyBjbGljayBvbiBzd2F0Y2ggZm9yIHByb2R1Y3Qgc2V0XG4gICAgJHByb2R1Y3RTZXRMaXN0Lm9uKCdjbGljaycsICcucHJvZHVjdC1zZXQtaXRlbSAuc3dhdGNoYW5jaG9yJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHZhciAkc3dhdGNoTGlFbGVtZW50ID0gJCh0aGlzKS5wYXJlbnRzKCdsaScpO1xuICAgICAgICBpZiAoJHN3YXRjaExpRWxlbWVudC5oYXNDbGFzcygndW5zZWxlY3RhYmxlJykgfHwgJHN3YXRjaExpRWxlbWVudC5oYXNDbGFzcygnc2VsZWN0ZWQnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVybCA9IFVybHMuZ2V0U2V0SXRlbSArIHRoaXMuc2VhcmNoO1xuICAgICAgICB2YXIgJGNvbnRhaW5lciA9ICQodGhpcykuY2xvc2VzdCgnLnByb2R1Y3Qtc2V0LWl0ZW0nKTtcbiAgICAgICAgdmFyIHF0eSA9ICRjb250YWluZXIuZmluZCgnZm9ybSBzZWxlY3RbbmFtZT1cIlF1YW50aXR5XCJdJykuZmlyc3QoKS52YWwoKTtcblxuICAgICAgICBhamF4LmxvYWQoe1xuICAgICAgICAgICAgdXJsOiB1dGlsLmFwcGVuZFBhcmFtVG9VUkwodXJsLCAnUXVhbnRpdHknLCBpc05hTihxdHkpID8gJzEnIDogcXR5KSxcbiAgICAgICAgICAgIHRhcmdldDogJGNvbnRhaW5lcixcbiAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlQWRkVG9DYXJ0QnV0dG9ucygpO1xuICAgICAgICAgICAgICAgIHRvb2x0aXAuaW5pdCgpO1xuICAgICAgICAgICAgICAgIHNlbGVjdEJveEl0LnNlbGVjdEJveEl0KCQoJ3NlbGVjdCcpKTtcbiAgICAgICAgICAgICAgICAvL1RydWUgRml0XG4gICAgICAgICAgICAgICAgaWYgKHRmYyAhPT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICAgICAgICAgICAgICB0ZmMuY2FsY3VsYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgcHJvZHVjdCByZWNvbW1lbmRhdGlvbiBjYXJvdXNlbCB1c2luZyBqUXVlcnkgamNhcm91c2VsIHBsdWdpblxuICoqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICRjYXJvdXNlbCA9ICQoJyNjYXJvdXNlbC1yZWNvbW1lbmRhdGlvbnMnKTtcbiAgICBpZiAoISRjYXJvdXNlbCB8fCAkY2Fyb3VzZWwubGVuZ3RoID09PSAwIHx8ICRjYXJvdXNlbC5jaGlsZHJlbigpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgICRjYXJvdXNlbC5qY2Fyb3VzZWwoKTtcbiAgICAkKCcjY2Fyb3VzZWwtcmVjb21tZW5kYXRpb25zIC5qY2Fyb3VzZWwtcHJldicpXG4gICAgICAgIC5vbignamNhcm91c2VsY29udHJvbDphY3RpdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkKHRoaXMpLnJlbW92ZUNsYXNzKCdpbmFjdGl2ZScpO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2pjYXJvdXNlbGNvbnRyb2w6aW5hY3RpdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKCdpbmFjdGl2ZScpO1xuICAgICAgICB9KVxuICAgICAgICAuamNhcm91c2VsQ29udHJvbCh7XG4gICAgICAgICAgICB0YXJnZXQ6ICctPTEnXG4gICAgICAgIH0pO1xuXG4gICAgJCgnI2Nhcm91c2VsLXJlY29tbWVuZGF0aW9ucyAuamNhcm91c2VsLW5leHQnKVxuICAgICAgICAub24oJ2pjYXJvdXNlbGNvbnRyb2w6YWN0aXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmVDbGFzcygnaW5hY3RpdmUnKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdqY2Fyb3VzZWxjb250cm9sOmluYWN0aXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcygnaW5hY3RpdmUnKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmpjYXJvdXNlbENvbnRyb2woe1xuICAgICAgICAgICAgdGFyZ2V0OiAnKz0xJ1xuICAgICAgICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhamF4ID0gcmVxdWlyZSgnLi4vLi4vYWpheCcpLFxuICAgIGltYWdlID0gcmVxdWlyZSgnLi9pbWFnZScpLFxuICAgIHByb2dyZXNzID0gcmVxdWlyZSgnLi4vLi4vcHJvZ3Jlc3MnKSxcbiAgICBwcm9kdWN0U3RvcmVJbnZlbnRvcnkgPSByZXF1aXJlKCcuLi8uLi9zdG9yZWludmVudG9yeS9wcm9kdWN0JyksXG4gICAgdG9vbHRpcCA9IHJlcXVpcmUoJy4uLy4uL3Rvb2x0aXAnKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpLFxuICAgIGRpYWxvZyA9IHJlcXVpcmUoJy4uLy4uL2RpYWxvZycpLFxuICAgIHNlbGVjdEJveEl0ID0gcmVxdWlyZSgnLi4vLi4vc2VsZWN0Ym94aXQnKSxcbiAgICBmdWxsU2NyZWVuSW1hZ2UgPSByZXF1aXJlKCcuLi8uLi9zdG9yZWludmVudG9yeS9wcm9kdWN0JykuZnVsbFNjcmVlbkltYWdlO1xuXG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIHVwZGF0ZSBwcm9kdWN0IGNvbnRlbnQgd2l0aCBuZXcgdmFyaWFudCBmcm9tIGhyZWYsIGxvYWQgbmV3IGNvbnRlbnQgdG8gI3Byb2R1Y3QtY29udGVudCBwYW5lbFxuICogQHBhcmFtIHtTdHJpbmd9IGhyZWYgLSB1cmwgb2YgdGhlIG5ldyBwcm9kdWN0IHZhcmlhbnRcbiAqKi9cbmZ1bmN0aW9uIGNoYW5nZVR1bWIoKSB7XG5cdHZhciBhdHRyVXJsID0gJyc7XG5cdHZhciByZXMgPSAnJztcblx0dmFyIGltZztcblx0JCgnI3RodW1ibmFpbC1jYXJvdXNlbCAudGh1bWInKS5lYWNoKGZ1bmN0aW9uKCl7XG5cdFx0aW1nID0gJCh0aGlzKS5maW5kKCdpbWcnKTtcblx0XHRhdHRyVXJsID0gaW1nLmF0dHIoJ3NyYycpO1xuXHRcdHJlcyA9IGF0dHJVcmwucmVwbGFjZSgncHJvZHVjdFRodW1ibmFpbCcsICdsYXJnZScpO1xuXHRcdGltZy5hdHRyKCdzcmMnLHJlcyk7XG5cdH0pXG5cdC8vaWYgc2xpY2sgaXMgYWxyZWFkeSBpbml0aWFsaXplZCwgd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZywgc28gd2UgY2hlY2sgZm9yIGNsYXNzICdzbGljay1zbGlkZXInXG5cdGlmKCEkKCcjdGh1bWJuYWlsLWNhcm91c2VsJykuaGFzQ2xhc3MoJ3NsaWNrLXNsaWRlcicpKXtcblxuXHRcdCQoJyN0aHVtYm5haWwtY2Fyb3VzZWwnKS5zbGljayh7XG5cdCAgICBcdGRvdHM6IHRydWUsXG5cdFx0XHRpbmZpbml0ZTogdHJ1ZSxcblx0XHRcdHNwZWVkOiAzMDAsXG5cdFx0XHRzbGlkZXNUb1Nob3c6IDEsXG5cdFx0XHRhcnJvd3M6IGZhbHNlXG5cdFx0fSk7XG5cdH1cbn1cbnZhciB1cGRhdGVDb250ZW50ID0gZnVuY3Rpb24gKGhyZWYpIHtcbiAgICB2YXIgJHBkcEZvcm0gPSAkKCcucGRwRm9ybScpO1xuICAgIHZhciBxdHkgPSAkcGRwRm9ybS5maW5kKCdzZWxlY3RbbmFtZT1cIlF1YW50aXR5XCJdJykuZmlyc3QoKS52YWwoKTtcbiAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICBRdWFudGl0eTogaXNOYU4ocXR5KSA/ICcxJyA6IHF0eSxcbiAgICAgICAgZm9ybWF0OiAnYWpheCdcbiAgICB9O1xuXG4gICAgdmFyIHNlbGVjdGVkQ29sb3IgPSAkKCcjcGRwTWFpbicpLmZpbmQoJy5Db2xvciAuc2VsZWN0ZWQtdmFsdWUnKS5maXJzdCgpO1xuICAgIGlmKHNlbGVjdGVkQ29sb3IubGVuZ3RoKXtcbiAgICAgICAgdmFyIGNvbG9yTmFtZSA9IHNlbGVjdGVkQ29sb3IuYXR0cignZGF0YS1uYW1lJykudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIGNvbG9yVmFsdWUgPSBzZWxlY3RlZENvbG9yLmF0dHIoJ2RhdGEtdmFsdWUnKS50b1N0cmluZygpO1xuICAgICAgICBpZihjb2xvck5hbWUgJiYgY29sb3JWYWx1ZSAmJiAhcGFyYW1zW2NvbG9yTmFtZV0gJiYgaHJlZi5pbmRleE9mKGNvbG9yTmFtZSkgPT0gLTEpe1xuICAgICAgICAgICAgLy8gZm9yY2UgdGhlIGF1dG8tc2VsZWN0ZWQgY29sb3IgaW50byB0aGUgYWpheCBjYWxsXG4gICAgICAgICAgICBwYXJhbXNbY29sb3JOYW1lXSA9IGNvbG9yVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9ncmVzcy5zaG93KCQoJyNwZHBNYWluJykpO1xuICAgIGFqYXgubG9hZCh7XG4gICAgICAgIHVybDogdXRpbC5hcHBlbmRQYXJhbXNUb1VybChocmVmLCBwYXJhbXMpLFxuICAgICAgICB0YXJnZXQ6ICQoJyNwcm9kdWN0LWNvbnRlbnQnKSxcbiAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIEFjY291bnQgUHJvdGVjdGVkIExpbmtzXG4gICAgICAgIFx0JCgnLnByb3RlY3RlZCcpLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgJCgnI3RvcC1iYW5uZXItaW50ZXJpb3IgLmFjY291bnQtbGluay1sb2dpbiBhLnVzZXItbG9naW4taG9wdXAnKS5jbGljaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIFx0aWYgKFNpdGVQcmVmZXJlbmNlcy5TVE9SRV9QSUNLVVApIHtcbiAgICAgICAgICAgICAgICBwcm9kdWN0U3RvcmVJbnZlbnRvcnkuaW5pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW1hZ2UucmVwbGFjZUltYWdlcygpO1xuICAgICAgICAgICAgZnVsbFNjcmVlbkltYWdlKCk7XG4gICAgICAgICAgICB0b29sdGlwLmluaXQoKTtcbiAgICAgICAgICAgIGlmICh1dGlsLmdldFZpZXdwb3J0KCkgPCA0ODEpe1xuICAgICAgICBcdFx0Y2hhbmdlVHVtYigpO1xuXHQgICAgXHR9XG4gICAgICAgICAgICAvLyByZWxvYWQgdGhlIGJhemFhciB2b2ljZSByYXRpbmdzIHBhbmVcblx0XHRcdGlmICgkKCcjQlZDdXN0b21lclJhdGluZ3MnKS5sZW5ndGggPiAwICYmIHR5cGVvZiAkQlYgIT0gXCJ1bmRlZmluZWRcIiAmJiBcInVpXCIgaW4gJEJWKSB7XG5cdFx0XHRcdCRCVi51aShcInJyXCIsIFwic2hvd19yZXZpZXdzXCIsIGNvbmZpZ0RhdGEpO1xuXHRcdFx0fVxuICAgICAgICAgICAgaWYgKGRpYWxvZy5pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgLy8gaGlkZS9zaG93IHRodW1ibmFpbCBhcnJvd3MgYmFzZWQgb24gc3dhdGNoIGxpc3QgbGVuZ3RoXG4gICAgICAgICAgICAgICAgdmFyICR0aHVtYm5haWxzID0gJCgnI3RodW1ibmFpbHMnKTtcbiAgICAgICAgICAgICAgICB2YXIgdGh1bWJzV2lkdGggPSAwO1xuICAgICAgICAgICAgICAgIHZhciAkdGh1bWJzUHJldkFycm93ID0gJCgnLmpjYXJvdXNlbC1jb250cm9sLXByZXYnKTtcbiAgICAgICAgICAgICAgICB2YXIgJHRodW1ic05leHRBcnJvdyA9ICQoJy5qY2Fyb3VzZWwtY29udHJvbC1uZXh0Jyk7XG4gICAgICAgICAgICAgICAgJCgnLnRodW1iJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGh1bWJzV2lkdGggKz0gJCh0aGlzKS53aWR0aCgpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgaWYgKHRodW1ic1dpZHRoIDw9ICQoJyN0aHVtYm5haWxzJykud2lkdGgoKSkge1xuICAgICAgICAgICAgICAgICAgICAkdGh1bWJzUHJldkFycm93LmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgJHRodW1ic05leHRBcnJvdy5oaWRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGltYWdlLmpjYXJvdXNlbEV2ZW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9UcnVlIEZpdFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZmMgIT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgICAgICAgICB0ZmMuY2FsY3VsYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0Qm94SXQuc2VsZWN0Qm94SXQoJCgnc2VsZWN0LnNlbGVjdC1xdWFudGl0eScpKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgLy8gaW4gY2FzZSBvZiBhc3luY2hyb25vdXMgd2FpdCB0aW1lcyBvdmVycmlkaW5nIGZpcnN0IGNoYW5nZVxuICAgICAgICAgICAgc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdEJveEl0LnNlbGVjdEJveEl0KCQoJ3NlbGVjdC5zZWxlY3QtcXVhbnRpdHknKSk7XG4gICAgICAgICAgICB9LCAyNTApO1xuICAgICAgICAgICAgc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdEJveEl0LnNlbGVjdEJveEl0KCQoJ3NlbGVjdC5zZWxlY3QtcXVhbnRpdHknKSk7XG4gICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xudmFyIGNoYW5nZUF2YWlsYWJpbGl0eVBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gIGlmICgkKCcucHJvZHVjdC1zZXQtaXRlbScpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHZhciB3aW5kb3dXaWR0aCA9ICQod2luZG93KS53aWR0aCgpLFxuICAgICAgICAgICAgYXZhaWxhYmlsaXR5Q29udGFpbmVyID0gJCgnLnByb2R1Y3QtYWRkLXRvLWNhcnQnKS5maW5kKCcuYXZhaWxhYmlsaXR5Jyk7XG4gICAgICBpZih3aW5kb3dXaWR0aCA8PSA3NjggJiYgIWF2YWlsYWJpbGl0eUNvbnRhaW5lci5oYXNDbGFzcygndGFibGV0LW1vdmVkJykpIHtcbiAgICAgICAgICAkKGF2YWlsYWJpbGl0eUNvbnRhaW5lcikuYWRkQ2xhc3MoJ3RhYmxldC1tb3ZlZCcpLmluc2VydEFmdGVyKCcuYTJjLWJ0bi1jb250YWluZXInKTtcbiAgICAgIH1cbiAgICAgIGlmKHdpbmRvd1dpZHRoID4gNzY5ICYmIGF2YWlsYWJpbGl0eUNvbnRhaW5lci5oYXNDbGFzcygndGFibGV0LW1vdmVkJykpIHtcbiAgICAgICAgICAkKGF2YWlsYWJpbGl0eUNvbnRhaW5lcikucmVtb3ZlQ2xhc3MoJ3RhYmxldC1tb3ZlZCcpLmluc2VydEFmdGVyKCcuaW52ZW50b3J5Jyk7XG4gICAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICRwZHBNYWluID0gJCgnI3BkcE1haW46bm90KFtjbGFzcyo9XCJnaWZ0LWNhcmRcIl0pJyk7XG4gICAgLy8gaG92ZXIgb24gc3dhdGNoIC0gc2hvdWxkIHVwZGF0ZSBtYWluIGltYWdlIHdpdGggc3dhdGNoIGltYWdlXG4gICAgJHBkcE1haW4ub24oJ21vdXNlZW50ZXIgbW91c2VsZWF2ZScsICcuc3dhdGNoYW5jaG9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGFyZ2VJbWcgPSAkKHRoaXMpLmRhdGEoJ2xnaW1nJyksXG4gICAgICAgICAgICAkaW1nWm9vbSA9ICRwZHBNYWluLmZpbmQoJy5tYWluLWltYWdlJyksXG4gICAgICAgICAgICAkbWFpbkltYWdlID0gJHBkcE1haW4uZmluZCgnLnByaW1hcnktaW1hZ2UnKTtcblxuICAgICAgICBpZiAoIWxhcmdlSW1nKSB7IHJldHVybjsgfVxuICAgICAgICAvLyBzdG9yZSB0aGUgb2xkIGRhdGEgZnJvbSBtYWluIGltYWdlIGZvciBtb3VzZWxlYXZlIGhhbmRsZXJcbiAgICAgICAgJCh0aGlzKS5kYXRhKCdsZ2ltZycsIHtcbiAgICAgICAgICAgIGhpcmVzOiAkaW1nWm9vbS5hdHRyKCdocmVmJyksXG4gICAgICAgICAgICB1cmw6ICRtYWluSW1hZ2UuYXR0cignc3JjJyksXG4gICAgICAgICAgICBhbHQ6ICRtYWluSW1hZ2UuYXR0cignYWx0JyksXG4gICAgICAgICAgICB0aXRsZTogJG1haW5JbWFnZS5hdHRyKCd0aXRsZScpXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBzZXQgdGhlIG1haW4gaW1hZ2VcbiAgICAgICAgaW1hZ2Uuc2V0TWFpbkltYWdlKGxhcmdlSW1nKTtcbiAgICB9KTtcbiAgICAgICAkcGRwTWFpbi5vbignbW91c2VlbnRlcicsICcuc3dhdGNoZXMuc2l6ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQoJy5ieC1jcmVhdGl2ZScpLnNob3coKTtcbiAgICAgICAgfSkub24oJ21vdXNlbGVhdmUnLCAnLnN3YXRjaGVzLnNpemUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkKCcuYngtY3JlYXRpdmUnKS5oaWRlKCk7XG4gICAgICAgIH0pO1xuXG5cbiAgICAvLyBjbGljayBvbiBzd2F0Y2ggLSBzaG91bGQgcmVwbGFjZSBwcm9kdWN0IGNvbnRlbnQgd2l0aCBuZXcgdmFyaWFudFxuICAgICRwZHBNYWluLm9uKCdjbGljaycsICcucHJvZHVjdC1kZXRhaWwgLnN3YXRjaGFuY2hvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyICRsaUVsZW1lbnQgPSAkKHRoaXMpLnBhcmVudHMoJ2xpJyk7XG4gICAgICAgIGlmICgkbGlFbGVtZW50Lmhhc0NsYXNzKCdzZWxlY3RlZCcpKSB7IHJldHVybjsgfVxuICAgICAgICB1cGRhdGVDb250ZW50KHRoaXMuaHJlZik7XG4gICAgfSk7XG5cbiAgICAvLyBjaGFuZ2UgZHJvcCBkb3duIHZhcmlhdGlvbiBhdHRyaWJ1dGUgLSBzaG91bGQgcmVwbGFjZSBwcm9kdWN0IGNvbnRlbnQgd2l0aCBuZXcgdmFyaWFudFxuICAgICRwZHBNYWluLm9uKCdjaGFuZ2UnLCAnLnZhcmlhdGlvbi1zZWxlY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgkKHRoaXMpLnZhbCgpLmxlbmd0aCA9PT0gMCkgeyByZXR1cm47IH1cbiAgICAgICAgdXBkYXRlQ29udGVudCgkKHRoaXMpLnZhbCgpKTtcbiAgICB9KTtcbiAgICAkKCcjcGRwTWFpbi5naWZ0LWNhcmQnKS5vbignY2xpY2snLCAnLnByb2R1Y3QtZGV0YWlsIC5zd2F0Y2hhbmNob3InLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSk7XG4gICAgY2hhbmdlQXZhaWxhYmlsaXR5UG9zaXRpb24oKTtcbiAgICB1dGlsLnNtYXJ0UmVzaXplKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2hhbmdlQXZhaWxhYmlsaXR5UG9zaXRpb24oKTtcbiAgICB9KTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWRkUHJvZHVjdFRvQ2FydCA9IHJlcXVpcmUoJy4vcHJvZHVjdC9hZGRUb0NhcnQnKSxcbiAgICBhamF4ID0gcmVxdWlyZSgnLi4vYWpheCcpLFxuICAgIGxvZ2luID0gcmVxdWlyZSgnLi4vbG9naW4nKSxcbiAgICBxdWlja3ZpZXcgPSByZXF1aXJlKCcuLi9xdWlja3ZpZXcnKSxcbiAgICB2YWxpZGF0b3IgPSByZXF1aXJlKCcuLi92YWxpZGF0b3InKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICAgIHNlbGVjdEJveEl0ID0gcmVxdWlyZSgnLi4vc2VsZWN0Ym94aXQnKSxcbiAgICBmbG9hdGxhYmVscyA9IHJlcXVpcmUoJy4uL2Zsb2F0LWxhYmVscycpO1xuXG5mdW5jdGlvbiBtYXNrRGF0ZUZpZWxkKCkge1xuXHQkKCcjZHdmcm1fZ2lmdHJlZ2lzdHJ5X2V2ZW50X2RhdGUnKS5tYXNrKFwiMDAgLyAwMCAvIDAwXCIsIHsgd2F0Y2hJbnB1dHM6IHRydWUgfSk7XG5cdHZhciAkZGF0ZUZpZWxkID0gJCgnI2R3ZnJtX2dpZnRyZWdpc3RyeV9ldmVudF9kYXRlbm90aGlkZGVuJyk7XG5cdHZhciBkYXRlRmllbGRWYWwgPSAkZGF0ZUZpZWxkLnZhbCgpO1xuXHRpZiAoZGF0ZUZpZWxkVmFsICYmIGRhdGVGaWVsZFZhbC5sZW5ndGggPT0gMTIpIHtcblx0XHR2YXIgeWVhclZhbCA9IGRhdGVGaWVsZFZhbC5zdWJzdHJpbmcoMTAsIGRhdGVGaWVsZFZhbC5sZW5ndGgpO1xuXHRcdGlmIChwYXJzZUludCh5ZWFyVmFsKSA+IDIwMDApIHtcblx0XHRcdHZhciBuZXdWYWwgPSBkYXRlRmllbGRWYWwuc3Vic3RyaW5nKDAsIDEwKSArIHllYXJWYWwuc3Vic3RyaW5nKDIsIHllYXJWYWwubGVuZ3RoKTtcblx0XHRcdCRkYXRlRmllbGQudmFsKG5ld1ZhbCk7XG5cdFx0fVxuXHR9XG5cdCRkYXRlRmllbGQubWFzayhcIjAwIC8gMDAgLyAwMFwiLCB7IHdhdGNoSW5wdXRzOiB0cnVlIH0pO1xufVxuXG5mdW5jdGlvbiBoaWRlU3RlcElmRWRpdCgpIHtcblxuXHRpZighJCgnLnRhYnMnKS5pcygnOnZpc2libGUnKSkge1xuXHRcdCQoJy5keW5hbWljJykuaGlkZSgpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIG1pZ3JhdGVQcmVUb1Bvc3RGaWVsZHMoKSB7XG5cdHZhciAkZm9ybUJlZm9yZSA9ICQoJ2ZpZWxkc2V0W25hbWU9YWRkcmVzcy1iZWZvcmVdJyk7XG5cdHZhciAkZm9ybUFmdGVyID0gJCgnZmllbGRzZXRbbmFtZT1hZGRyZXNzLWFmdGVyXScpO1xuXG5cdCRmb3JtQWZ0ZXIuZmluZCgnW25hbWUkPVwiX2FkZHJlc3NpZFwiXScpLnZhbCgkZm9ybUJlZm9yZS5maW5kKCdbbmFtZSQ9XCJfYWRkcmVzc2lkXCJdJykudmFsKCkpLmJsdXIoKTtcblx0JGZvcm1BZnRlci5maW5kKCdbbmFtZSQ9XCJfZmlyc3RuYW1lXCJdJykudmFsKCRmb3JtQmVmb3JlLmZpbmQoJ1tuYW1lJD1cIl9maXJzdG5hbWVcIl0nKS52YWwoKSkuYmx1cigpO1xuXHQkZm9ybUFmdGVyLmZpbmQoJ1tuYW1lJD1cIl9sYXN0bmFtZVwiXScpLnZhbCgkZm9ybUJlZm9yZS5maW5kKCdbbmFtZSQ9XCJfbGFzdG5hbWVcIl0nKS52YWwoKSkuYmx1cigpO1xuXHQkZm9ybUFmdGVyLmZpbmQoJ1tuYW1lJD1cIl9hZGRyZXNzMVwiXScpLnZhbCgkZm9ybUJlZm9yZS5maW5kKCdbbmFtZSQ9XCJfYWRkcmVzczFcIl0nKS52YWwoKSkuYmx1cigpO1xuXHQkZm9ybUFmdGVyLmZpbmQoJ1tuYW1lJD1cIl9hZGRyZXNzMlwiXScpLnZhbCgkZm9ybUJlZm9yZS5maW5kKCdbbmFtZSQ9XCJfYWRkcmVzczJcIl0nKS52YWwoKSkuYmx1cigpO1xuXHQkZm9ybUFmdGVyLmZpbmQoJ1tuYW1lJD1cIl9jaXR5XCJdJykudmFsKCRmb3JtQmVmb3JlLmZpbmQoJ1tuYW1lJD1cIl9jaXR5XCJdJykudmFsKCkpLmJsdXIoKTtcblx0JGZvcm1BZnRlci5maW5kKCdbbmFtZSQ9XCJfY291bnRyeVwiXScpLnZhbCgkZm9ybUJlZm9yZS5maW5kKCdbbmFtZSQ9XCJfY291bnRyeVwiXScpLnZhbCgpKS5ibHVyKCk7XG5cdCRmb3JtQWZ0ZXIuZmluZCgnW25hbWUkPVwiX3Bvc3RhbFwiXScpLnZhbCgkZm9ybUJlZm9yZS5maW5kKCdbbmFtZSQ9XCJfcG9zdGFsXCJdJykudmFsKCkpLmJsdXIoKTtcblx0JGZvcm1BZnRlci5maW5kKCdbbmFtZSQ9XCJfc3RhdGVcIl0nKS52YWwoJGZvcm1CZWZvcmUuZmluZCgnW25hbWUkPVwiX3N0YXRlXCJdJykudmFsKCkpLmJsdXIoKTtcblx0JGZvcm1BZnRlci5maW5kKCdbbmFtZSQ9XCJfcGhvbmVcIl0nKS52YWwoJGZvcm1CZWZvcmUuZmluZCgnW25hbWUkPVwiX3Bob25lXCJdJykudmFsKCkpLmJsdXIoKTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvbiBMb2FkcyBhZGRyZXNzIGRldGFpbHMgdG8gYSBnaXZlbiBhZGRyZXNzIGFuZCBmaWxscyB0aGUgYWRkcmVzcyBmb3JtXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc0lEIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byB3aGljaCBkYXRhIHdpbGwgYmUgbG9hZGVkXG4gKi9cbmZ1bmN0aW9uIHBvcHVsYXRlRm9ybShhZGRyZXNzSUQsICRmb3JtKSB7XG4gICAgLy8gbG9hZCBhZGRyZXNzIGRldGFpbHNcbiAgICB2YXIgdXJsID0gVXJscy5naWZ0UmVnQWRkICsgYWRkcmVzc0lEO1xuICAgIGFqYXguZ2V0SnNvbih7XG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmFsZXJ0KFJlc291cmNlcy5SRUdfQUREUl9FUlJPUik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmlsbCB0aGUgZm9ybVxuICAgICAgICAgICAgJGZvcm0uZmluZCgnW25hbWUkPVwiX2FkZHJlc3NpZFwiXScpLnZhbChkYXRhLmFkZHJlc3MuSUQpLmJsdXIoKTtcbiAgICAgICAgICAgICRmb3JtLmZpbmQoJ1tuYW1lJD1cIl9maXJzdG5hbWVcIl0nKS52YWwoZGF0YS5hZGRyZXNzLmZpcnN0TmFtZSkuYmx1cigpO1xuICAgICAgICAgICAgJGZvcm0uZmluZCgnW25hbWUkPVwiX2xhc3RuYW1lXCJdJykudmFsKGRhdGEuYWRkcmVzcy5sYXN0TmFtZSkuYmx1cigpO1xuICAgICAgICAgICAgJGZvcm0uZmluZCgnW25hbWUkPVwiX2FkZHJlc3MxXCJdJykudmFsKGRhdGEuYWRkcmVzcy5hZGRyZXNzMSkuYmx1cigpO1xuICAgICAgICAgICAgJGZvcm0uZmluZCgnW25hbWUkPVwiX2NpdHlcIl0nKS52YWwoZGF0YS5hZGRyZXNzLmNpdHkpLmJsdXIoKTtcbiAgICAgICAgICAgICRmb3JtLmZpbmQoJ1tuYW1lJD1cIl9jb3VudHJ5XCJdJykudmFsKGRhdGEuYWRkcmVzcy5jb3VudHJ5Q29kZS50b1VwcGVyQ2FzZSgpKS5ibHVyKCk7XG4gICAgICAgICAgICAkZm9ybS5maW5kKCdbbmFtZSQ9XCJfcG9zdGFsXCJdJykudmFsKGRhdGEuYWRkcmVzcy5wb3N0YWxDb2RlKS5ibHVyKCk7XG4gICAgICAgICAgICBpZihkYXRhLmFkZHJlc3MuY291bnRyeUNvZGUgPT0gJ1VTJyl7XG4gICAgICAgICAgICAgICAgJCgkZm9ybS5maW5kKCdbbmFtZSQ9XCJfc3RhdGVcIl0nKSkucnVsZXMoJ2FkZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAkZm9ybS5maW5kKCdbbmFtZSQ9XCJfc3RhdGVcIl0nKS52YWwoZGF0YS5hZGRyZXNzLnN0YXRlQ29kZS50b1VwcGVyQ2FzZSgpKS5ibHVyKCk7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAkKCRmb3JtLmZpbmQoJ1tuYW1lJD1cIl9zdGF0ZVwiXScpKS5ydWxlcygnYWRkJywge1xuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAkZm9ybS5maW5kKCdbbmFtZSQ9XCJfc3RhdGVcIl0nKS52YWwoJycpLmJsdXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRmb3JtLmZpbmQoJ1tuYW1lJD1cIl9waG9uZVwiXScpLnZhbChkYXRhLmFkZHJlc3MucGhvbmUpLmJsdXIoKTtcblxuICAgICAgICAgICAgLy8gQWRkcmVzcyAyIG1heSBiZSBlbXB0eSAtIG5lZWQgdG8gZGVjaWRlIHdoZXRoZXIgdG8gYmx1ciB0aGUgZmllbGQgb3Igbm90LlxuICAgICAgICAgICAgaWYgKCRmb3JtLmZpbmQoJ1tuYW1lJD1cIl9hZGRyZXNzMlwiXScpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIFx0JGZvcm0uZmluZCgnW25hbWUkPVwiX2FkZHJlc3MyXCJdJykudmFsKGRhdGEuYWRkcmVzcy5hZGRyZXNzMikuYmx1cigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFx0JGZvcm0uZmluZCgnW25hbWUkPVwiX2FkZHJlc3MyXCJdJykudmFsKGRhdGEuYWRkcmVzcy5hZGRyZXNzMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3Byb3ZpZGUgbWFzayBmb3Igc2F2ZWQgYWRkcmVzc1xuICAgICAgICAgICAgJGZvcm0uZmluZCgnW25hbWUkPVwiX3Bob25lXCJdJykudW5tYXNrKCkubWFzayhcIigwMDApIDAwMC0wMDAwXCIpLmJsdXIoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvbiBJbml0aWFsaXplcyBldmVudHMgZm9yIHRoZSBnaWZ0IHJlZ2lzdHJhdGlvblxuICovXG5mdW5jdGlvbiBpbml0aWFsaXplRXZlbnRzKCkge1xuICAgIHZhciAkZXZlbnRBZGRyZXNzRm9ybSA9ICQoJ2Zvcm1bbmFtZSQ9XCJfZ2lmdHJlZ2lzdHJ5XCJdJyksXG4gICAgICAgICRiZWZvcmVBZGRyZXNzID0gJGV2ZW50QWRkcmVzc0Zvcm0uZmluZCgnZmllbGRzZXRbbmFtZT1cImFkZHJlc3MtYmVmb3JlXCJdJyksXG4gICAgICAgICRhZnRlckFkZHJlc3MgPSAkZXZlbnRBZGRyZXNzRm9ybS5maW5kKCdmaWVsZHNldFtuYW1lPVwiYWRkcmVzcy1hZnRlclwiXScpO1xuICAgIFx0dmFyICRwdWJsaWNDaGVja0JveCA9ICQoJy5wdWJsaWMtY2hlY2tib3gnKS5maW5kKCcuaW5wdXQtY2hlY2tib3gnKTtcbiAgICBcdHZhciAkaGlkZGVuUHVibGljQ2hlY2tCb3ggPSAkKCcucHVibGljLWNoZWNrYm94LWhpZGRlbicpLmZpbmQoJy5pbnB1dC1jaGVja2JveCcpO1xuICAgIFx0dmFyICRxdWFudGl0eURlc2lyZWQgPSAkKCcub3B0aW9uLXF1YW50aXR5LWRlc2lyZWQnKS5maW5kKCcuaW5wdXQtdGV4dCcpO1xuXG4gICAgXHQkcHVibGljQ2hlY2tCb3guY2hhbmdlKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIGlmKCQodGhpcykuaXMoXCI6Y2hlY2tlZFwiKSkge1xuXHQgICAgICAgIFx0JCh0aGlzKS5wYXJlbnQoKS5wYXJlbnQoKS5wYXJlbnQoKS5wYXJlbnQoKS5wYXJlbnQoKS5wYXJlbnQoKS5maW5kKCcuZm9yLWRldGFpbHMnKS5maW5kKCcucHVibGljLWNoZWNrYm94LWhpZGRlbicpLmZpbmQoJy5pbnB1dC1jaGVja2JveCcpLnByb3AoJ2NoZWNrZWQnLCB0cnVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgXHQkKHRoaXMpLnBhcmVudCgpLnBhcmVudCgpLnBhcmVudCgpLnBhcmVudCgpLnBhcmVudCgpLnBhcmVudCgpLmZpbmQoJy5mb3ItZGV0YWlscycpLmZpbmQoJy5wdWJsaWMtY2hlY2tib3gtaGlkZGVuJykuZmluZCgnLmlucHV0LWNoZWNrYm94JykucHJvcCgnY2hlY2tlZCcsIGZhbHNlKTtcblx0ICAgICAgICB9XG4gICAgXHR9KTtcblxuICAgIFx0JHF1YW50aXR5RGVzaXJlZC5jaGFuZ2UoZnVuY3Rpb24oKSB7XG4gICAgXHRcdCQodGhpcykucGFyZW50KCkucGFyZW50KCkucGFyZW50KCkucGFyZW50KCkucGFyZW50KCkuZmluZCgnLmZvci1kZXRhaWxzJykuZmluZCgnLm9wdGlvbi1xdWFudGl0eS1kZXNpcmVkLWhpZGRlbicpLmZpbmQoJy5pbnB1dC10ZXh0JykudmFsKCQodGhpcykudmFsKCkpO1xuICAgIFx0fSk7XG5cblxuICAgICQoJy51c2VwcmVldmVudCcpLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZmlsdGVyIG91dCBzdG9yZWZyb250IHRvb2xraXRcbiAgICAgICAgJCgnOmlucHV0JywgJGJlZm9yZUFkZHJlc3MpLm5vdCgnW2lkXj1cImV4dFwiXScpLm5vdCgnc2VsZWN0W25hbWUkPVwiX2FkZHJlc3NCZWZvcmVMaXN0XCJdJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZmllbGROYW1lID0gJCh0aGlzKS5hdHRyKCduYW1lJyksXG4gICAgICAgICAgICAgICAgJGFmdGVyRmllbGQgPSAkYWZ0ZXJBZGRyZXNzLmZpbmQoJ1tuYW1lPVwiJyArIGZpZWxkTmFtZS5yZXBsYWNlKCdCZWZvcmUnLCAnQWZ0ZXInKSArICdcIl0nKTtcbiAgICAgICAgICAgICRhZnRlckZpZWxkLnZhbCgkKHRoaXMpLnZhbCgpKS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgJGV2ZW50QWRkcmVzc0Zvcm0ub24oJ2NoYW5nZScsICdzZWxlY3RbbmFtZSQ9XCJfYWRkcmVzc0JlZm9yZUxpc3RcIl0nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhZGRyZXNzSUQgPSAkKHRoaXMpLnZhbCgpO1xuICAgICAgICBpZiAoYWRkcmVzc0lELmxlbmd0aCA9PT0gMCkgeyByZXR1cm47IH1cbiAgICAgICAgcG9wdWxhdGVGb3JtKGFkZHJlc3NJRCwgJGJlZm9yZUFkZHJlc3MpO1xuICAgIH0pXG4gICAgLm9uKCdjaGFuZ2UnLCAnc2VsZWN0W25hbWUkPVwiX2FkZHJlc3NBZnRlckxpc3RcIl0nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhZGRyZXNzSUQgPSAkKHRoaXMpLnZhbCgpO1xuICAgICAgICBpZiAoYWRkcmVzc0lELmxlbmd0aCA9PT0gMCkgeyByZXR1cm47IH1cbiAgICAgICAgcG9wdWxhdGVGb3JtKGFkZHJlc3NJRCwgJGFmdGVyQWRkcmVzcyk7XG4gICAgfSk7XG5cbiAgICAkKCcuaXRlbS1lZGl0LWRldGFpbHMnKS5jbGljayhmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBwcm9kdWN0TGlzdElEID0gJCgnaW5wdXRbbmFtZT1wcm9kdWN0TGlzdElEXScpLnZhbCgpO1xuICAgICAgICAvL1Zlcnkgc3BlY2lmaWMgY2FzZSBmb3IgbWFraW5nIGlucHV0cyBvdXRzaWRlIG9mIGRpYWxvZyBhdmFpbGFibGVcbiAgICAgICAgJC53aWRnZXQoIFwidWkuZGlhbG9nXCIsICQudWkuZGlhbG9nLCB7XG4gICAgICAgICAgICBfYWxsb3dJbnRlcmFjdGlvbjogZnVuY3Rpb24oIGV2ZW50ICkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhISQoIGV2ZW50LnRhcmdldCApLmlzKCBcImlucHV0XCIgKSB8fCB0aGlzLl9zdXBlciggZXZlbnQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHF1aWNrdmlldy5zaG93KHtcbiAgICAgICAgICAgIHVybDogZS50YXJnZXQuaHJlZixcbiAgICAgICAgICAgIHNvdXJjZTogJ2dpZnRyZWdpc3RyeScsXG4gICAgICAgICAgICBwcm9kdWN0bGlzdGlkOiBwcm9kdWN0TGlzdElEXG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG5cdC8vIGdpZnQgcmVnaXN0cnkgYWR2YW5jZWQgb3B0aW9ucyBvbiBsb2dpbiBpbnRlcmNlcHQgcGFnZVxuXHQkKCcuZ2lmdC1yZWdpc3RyeS1hZHZhbmNlZCAudG9nZ2xlJykub24oJ2NsaWNrJywgZnVuY3Rpb24oKXtcblx0XHQkKCcuZ2lmdC1yZWdpc3RyeS1hZHZhbmNlZCAudG9nZ2xlLWNvbnRlbnQnKS5zbGlkZVRvZ2dsZShmdW5jdGlvbigpe1xuXHRcdFx0c2VsZWN0Qm94SXQuc2VsZWN0Qm94SXQoJCgnLmdpZnQtcmVnaXN0cnktYWR2YW5jZWQgLnNlbGVjdC1maWVsZDp2aXNpYmxlJykpO1xuXHRcdH0pO1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSk7XG5cbiAgICAkKFwiI2R3ZnJtX2dpZnRyZWdpc3RyeV9jb3B5QWRkcmVzc1wiKS5jaGFuZ2UoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKHRoaXMuY2hlY2tlZCkge1xuICAgICAgICBcdG1pZ3JhdGVQcmVUb1Bvc3RGaWVsZHMoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJChcIiNzZWxlY3QtcXVhbnRpdHktZGVzaXJlZCBzZWxlY3RcIikuY2hhbmdlKGZ1bmN0aW9uKCkge1xuICAgIFx0dmFyIGN1cnJWYWx1ZSA9IHBhcnNlSW50KCQodGhpcykudmFsKCkpO1xuICAgIFx0dmFyIGF0dHJOYW1lID0gJCh0aGlzKS5hdHRyKCduYW1lJyk7XG4gICAgXHQkKCdpbnB1dFtuYW1lPVwiJythdHRyTmFtZSsnXCJdJykuZWFjaChmdW5jdGlvbihpbmQsIGVsKSB7XG4gICAgXHRcdCQoZWwpLnZhbChjdXJyVmFsdWUpO1xuICAgIFx0XHQkKGVsKS5hdHRyKCd2YWx1ZScsIGN1cnJWYWx1ZSk7XG4gICAgXHR9KTtcbiAgICB9KTtcblxuICAgIC8vIGdpZnQgcmVnaXN0cnkgYWR2YW5jZWQgb3B0aW9ucyB0b2dnbGVcbiAgICAkKCcuc2VhcmNoLWdpZnRyZWdpc3RyeS10b2dnbGUtYnV0dG9uJykub24oJ2NsaWNrJywgZnVuY3Rpb24oZSl7XG4gICAgXHRlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgXHQkKHRoaXMpLnRvZ2dsZUNsYXNzKCdleHBhbmRlZCcpO1xuICAgIFx0JCgnLmdpZnQtcmVnaXN0cnktYWR2YW5jZWQtb3B0aW9ucycpLnRvZ2dsZSgpO1xuICAgIH0pO1xuXG4gICAgdmFyICRmb3JtID0gJCgnI2R3ZnJtX2dpZnRyZWdpc3RyeV9zZWFyY2gnKTtcbiAgICAkZm9ybS5maW5kKCcuZm9ybS1yb3cgc2VsZWN0JykuYWZ0ZXIoXCI8c3BhbiBjbGFzcz0nc2VsZWN0LWFycm93Jz48L3NwYW4+XCIpO1xuXG5cdCQoJ2J1dHRvbi5wcmV2aW91cycpLmNsaWNrKGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gUmVtb3ZlIHRoZSByZXF1aXJlZCBjbGFzcyBzbyB2YWxpZGF0aW9uXG5cdFx0Ly8gZG9lcyBub3Qgb2NjdXIgb24gdGhlIGZvcm0gZmllbGRzXG5cdFx0Ly8gc2luY2UgdGhpcyBpcyB0aGUgcHJldmlvdXMgYnV0dG9uLCBhbmQgdmFsaWRhdGlvbiBpcyBub3QgbmVlZGVkLlxuXHRcdCQoJ2Zvcm0nKS5maW5kKCdpbnB1dCcpLnJlbW92ZUNsYXNzKCdyZXF1aXJlZCcpO1xuXHRcdCQoJ2Zvcm0nKS5maW5kKCdzZWxlY3QnKS5yZW1vdmVDbGFzcygncmVxdWlyZWQnKTtcblx0fSk7XG5cdFxuXHQvL2VuYWJsZSBtYXNrIGZvciBudW1iZXIgZmllbGRcbiAgICAkKCcjZHdmcm1fZ2lmdHJlZ2lzdHJ5JykuZmluZCgnLmlucHV0LXRleHQucGhvbmUnKS5tYXNrKFwiKDAwMCkgMDAwLTAwMDBcIik7XG59XG5cbmZ1bmN0aW9uIHNldEZsb2F0TGFiZWxzT25TZWxlY3RFbGVtZW50cyAoKSB7XG5cdCQoJy5wdF9naWZ0LXJlZ2lzdHJ5JykuZmluZCgnc2VsZWN0JykucGFyZW50KCkuYWRkQ2xhc3MoJ2hhcy1mbG9hdC1sYWJlbCcpO1xuXHQkKCcucHRfZ2lmdC1yZWdpc3RyeScpLmZpbmQoJ3NlbGVjdCcpLnBhcmVudCgpLmZpbmQoJy50ZXh0LWlucHV0LWxhYmVsJykuYWRkQ2xhc3MoJ2Zsb2F0Jyk7XG59XG5cbmZ1bmN0aW9uIGluaXRFdmVudEl0ZW1zKCkge1xuXHQkKCcuZ2lmdC1yZWdpc3RyeS1pdGVtLXJvdycpLmVhY2goZnVuY3Rpb24oKXtcblx0XHR2YXIgJHN0eWxlID0gJCh0aGlzKS5maW5kKCcuc2t1JykuZGV0YWNoKCk7XG5cdFx0JHN0eWxlLmZpbmQoXCIubGFiZWxcIikudGV4dChcIlN0eWxlICM6XCIpO1xuXHRcdCQodGhpcykuZmluZCgnLnByb2R1Y3QtbGlzdC1pdGVtJykuYXBwZW5kKCRzdHlsZSk7XG5cblx0XHR2YXIgJHByaWNlID0gJCh0aGlzKS5maW5kKCcucHJpY2UnKS5kZXRhY2goKTtcblx0XHR2YXIgJHByaWNlQ29sdW1uID0gJCh0aGlzKS5maW5kKCcuZ2lmdC1yZWdpc3RyeS1pdGVtLXJvdy1wcmljZScpO1xuXHRcdCRwcmljZUNvbHVtbi5hcHBlbmQoJHByaWNlKTtcblx0XHRpZighKCRwcmljZUNvbHVtbi5maW5kKCcucHJpY2Utc3RhbmRhcmQnKS5sZW5ndGggJiYgJHByaWNlQ29sdW1uLmZpbmQoJy5wcmljZS1zYWxlcycpLmxlbmd0aCkpe1xuXHRcdFx0JHByaWNlQ29sdW1uLmZpbmQoJy5wcmljZSAudmFsdWUgLnByaWNlLXN0YW5kYXJkJykucmVtb3ZlQ2xhc3MoJ3ByaWNlLXN0YW5kYXJkJyk7XG5cdFx0XHQkcHJpY2VDb2x1bW4uZmluZCgnLnByaWNlIC52YWx1ZSAucHJpY2Utc2FsZXMnKS5yZW1vdmVDbGFzcygncHJpY2Utc2FsZXMnKTtcblx0XHR9XG5cblx0XHR2YXIgJHByaW9yaXR5ID0gJCh0aGlzKS5maW5kKCcub3B0aW9uLXByaW9yaXR5IC52YWx1ZScpO1xuXHRcdHZhciBwcmlvcml0eVRleHQgPSAkcHJpb3JpdHkudGV4dCgpO1xuXHRcdCRwcmlvcml0eS50ZXh0KHByaW9yaXR5VGV4dC5zdWJzdHIoOSwgcHJpb3JpdHlUZXh0Lmxlbmd0aCkpO1xuXG5cdFx0dmFyICRxdWFudGl0eVNlbGVjdCA9ICQodGhpcykuZmluZCgnLnF1YW50aXR5LXNlbGVjdCcpO1xuXHRcdCRxdWFudGl0eVNlbGVjdC5hZnRlcihcIjxzcGFuIGNsYXNzPSdzZWxlY3QtYXJyb3cnPjwvc3Bhbj5cIik7XG5cdFx0dmFyICRmb3JtID0gJCh0aGlzKS5maW5kKFwiI2R3ZnJtX3Byb2R1Y3RfYWRkdG9jYXJ0LCAjZ2lmdC1jZXJ0LXB1cmNoYXNlXCIpO1xuXHRcdCRxdWFudGl0eVNlbGVjdC5vbihcImNoYW5nZVwiLCBmdW5jdGlvbigpe1xuXHRcdFx0JGZvcm0uZmluZCgnLmhpZGRlbi1xdWFudGl0eScpLnZhbCgkKHRoaXMpLnZhbCgpKTtcblx0XHR9KTtcblx0fSk7XG5cdCQoJy5tb2JpbGUtcmVnaXN0cnktaXRlbS1jb250YWluZXInKS5lYWNoKGZ1bmN0aW9uKCl7XG5cdFx0dmFyICRzdHlsZSA9ICQodGhpcykuZmluZCgnLnNrdScpLmRldGFjaCgpO1xuXHRcdCRzdHlsZS5maW5kKFwiLmxhYmVsXCIpLnRleHQoXCJTdHlsZSAjOlwiKTtcblx0XHQkKHRoaXMpLmZpbmQoJy5wcm9kdWN0LWxpc3QtaXRlbScpLmFwcGVuZCgkc3R5bGUpO1xuXG5cdFx0dmFyICRwcmljZSA9ICQodGhpcykuZmluZCgnLnByaWNlJykuZGV0YWNoKCk7XG5cdFx0dmFyICRwcmljZVNwYW4gPSAkKHRoaXMpLmZpbmQoJy5yZWdpc3RyeS1pdGVtLXByaWNlJyk7XG5cdFx0JHByaWNlU3Bhbi5hcHBlbmQoJHByaWNlKTtcblx0XHRpZighKCRwcmljZVNwYW4uZmluZCgnLnByaWNlLXN0YW5kYXJkJykubGVuZ3RoICYmICRwcmljZVNwYW4uZmluZCgnLnByaWNlLXNhbGVzJykubGVuZ3RoKSl7XG5cdFx0XHQkcHJpY2VTcGFuLmZpbmQoJy5wcmljZSAudmFsdWUgLnByaWNlLXN0YW5kYXJkJykucmVtb3ZlQ2xhc3MoJ3ByaWNlLXN0YW5kYXJkJyk7XG5cdFx0XHQkcHJpY2VTcGFuLmZpbmQoJy5wcmljZSAudmFsdWUgLnByaWNlLXNhbGVzJykucmVtb3ZlQ2xhc3MoJ3ByaWNlLXNhbGVzJyk7XG5cdFx0fVxuXG5cdFx0dmFyICRwcmlvcml0eSA9ICQodGhpcykuZmluZCgnLm9wdGlvbi1wcmlvcml0eSAudmFsdWUnKTtcblx0XHR2YXIgcHJpb3JpdHlUZXh0ID0gJHByaW9yaXR5LnRleHQoKTtcblx0XHQkcHJpb3JpdHkudGV4dChwcmlvcml0eVRleHQuc3Vic3RyKDksIHByaW9yaXR5VGV4dC5sZW5ndGgpKTtcblxuXHRcdHZhciAkcXVhbnRpdHlTZWxlY3QgPSAkKHRoaXMpLmZpbmQoJy5yZWdpc3RyeS1pdGVtLXF1YW50aXR5IHNlbGVjdCcpO1xuXHRcdCRxdWFudGl0eVNlbGVjdC5hZnRlcihcIjxzcGFuIGNsYXNzPSdzZWxlY3QtYXJyb3cnPjwvc3Bhbj5cIik7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBjaGVja1BvcHVsYXRlZEZpZWxkcygpIHtcbiAgICAkKCcjZHdmcm1fZ2lmdHJlZ2lzdHJ5X2V2ZW50IGlucHV0JykuZWFjaChmdW5jdGlvbiAoaW5kZXgsIGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCQoZWxlbWVudCkudmFsKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgJChlbGVtZW50KS5ibHVyKCk7XG4gICAgICAgIH1cbiAgICB9KVxufVxuXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0RmxvYXRMYWJlbHNPblNlbGVjdEVsZW1lbnRzKCk7XG4gICAgaW5pdGlhbGl6ZUV2ZW50cygpO1xuICAgIGFkZFByb2R1Y3RUb0NhcnQoKTtcbiAgICBoaWRlU3RlcElmRWRpdCgpO1xuICAgIG1hc2tEYXRlRmllbGQoKTtcbiAgICBsb2dpbi5pbml0KCk7XG4gICAgdXRpbC5zZXREZWxldGVDb25maXJtYXRpb24oJy5pdGVtLWxpc3QnLCBTdHJpbmcuZm9ybWF0KFJlc291cmNlcy5DT05GSVJNX0RFTEVURSwgUmVzb3VyY2VzLlRJVExFX0dJRlRSRUdJU1RSWSkpO1xuICAgIGluaXRFdmVudEl0ZW1zKCk7XG4gICAgY2hlY2tQb3B1bGF0ZWRGaWVsZHMoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb21wYXJlV2lkZ2V0ID0gcmVxdWlyZSgnLi4vY29tcGFyZS13aWRnZXQnKSxcbiAgICBnaWZ0Y2FyZCA9IHJlcXVpcmUoJy4uL2dpZnRjYXJkJyksXG4gICAgaW1hZ2VzTG9hZGVkID0gcmVxdWlyZSgnaW1hZ2VzbG9hZGVkJyksXG4gICAgcHJvZHVjdFRpbGUgPSByZXF1aXJlKCcuLi9wcm9kdWN0LXRpbGUnKSxcbiAgICBwcm9ncmVzcyA9IHJlcXVpcmUoJy4uL3Byb2dyZXNzJyksXG4gICAgc21hcnRSZXNpemUgPSByZXF1aXJlKCcuLi9zbWFydHJlc2l6ZScpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gICAgaW1hZ2VtYXByZXNpemVyID0gcmVxdWlyZSgnLi4vaW1hZ2VtYXByZXNpemVyJyksXG4gICAgaW50ZXJhY3QgPSByZXF1aXJlKCcuLi9pbnRlcmFjdCcpLFxuICAgIG1lZGl1bUJyZWFrcG9pbnQgPSA0ODAsXG4gICAgbGFyZ2VCcmVha3BvaW50ID0gOTYwLFxuICAgICRjYWNoZSA9IHt9O1xuXG52YXIgd2luZG93V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcblxuZnVuY3Rpb24gaW5maW5pdGVTY3JvbGwoKSB7XG4gICAgLy8gZ2V0dGluZyB0aGUgaGlkZGVuIGRpdiwgd2hpY2ggaXMgdGhlIHBsYWNlaG9sZGVyIGZvciB0aGUgbmV4dCBwYWdlXG4gICAgdmFyIGxvYWRpbmdQbGFjZUhvbGRlciA9ICQoJy5pbmZpbml0ZS1zY3JvbGwtcGxhY2Vob2xkZXJbZGF0YS1sb2FkaW5nLXN0YXRlPVwidW5sb2FkZWRcIl0nKTtcbiAgICAvLyBnZXQgdXJsIGhpZGRlbiBpbiBET01cbiAgICB2YXIgZ3JpZFVybCA9IGxvYWRpbmdQbGFjZUhvbGRlci5hdHRyKCdkYXRhLWdyaWQtdXJsJyk7XG5cbiAgICBpZiAobG9hZGluZ1BsYWNlSG9sZGVyLmxlbmd0aCA9PT0gMSAmJiB1dGlsLmVsZW1lbnRJblZpZXdwb3J0KGxvYWRpbmdQbGFjZUhvbGRlci5nZXQoMCksIDI1MCkpIHtcbiAgICAgICAgLy8gc3dpdGNoIHN0YXRlIHRvICdsb2FkaW5nJ1xuICAgICAgICAvLyAtIHN3aXRjaGVzIHN0YXRlLCBzbyB0aGUgYWJvdmUgc2VsZWN0b3IgaXMgb25seSBtYXRjaGluZyBvbmNlXG4gICAgICAgIC8vIC0gc2hvd3MgbG9hZGluZyBpbmRpY2F0b3JcbiAgICAgICAgbG9hZGluZ1BsYWNlSG9sZGVyLmF0dHIoJ2RhdGEtbG9hZGluZy1zdGF0ZScsICdsb2FkaW5nJyk7XG4gICAgICAgIGxvYWRpbmdQbGFjZUhvbGRlci5hZGRDbGFzcygnaW5maW5pdGUtc2Nyb2xsLWxvYWRpbmcnKTtcblxuXG4gICAgICAgIC8vIG5hbWVkIHdyYXBwZXIgZnVuY3Rpb24sIHdoaWNoIGNhbiBlaXRoZXIgYmUgY2FsbGVkLCBpZiBjYWNoZSBpcyBoaXQsIG9yIGFqYXggcmVwc29uc2UgaXMgcmVjZWl2ZWRcbiAgICAgICAgdmFyIGZpbGxFbmRsZXNzU2Nyb2xsQ2h1bmsgPSBmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICAgICAgbG9hZGluZ1BsYWNlSG9sZGVyLnJlbW92ZUNsYXNzKCdpbmZpbml0ZS1zY3JvbGwtbG9hZGluZycpO1xuICAgICAgICAgICAgbG9hZGluZ1BsYWNlSG9sZGVyLmF0dHIoJ2RhdGEtbG9hZGluZy1zdGF0ZScsICdsb2FkZWQnKTtcbiAgICAgICAgICAgICQoJ2Rpdi5zZWFyY2gtcmVzdWx0LWNvbnRlbnQnKS5hcHBlbmQoaHRtbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gb2xkIGNvbmRpdGlvbiBmb3IgY2FjaGluZyB3YXMgYCdzZXNzaW9uU3RvcmFnZScgaW4gd2luZG93ICYmIHNlc3Npb25TdG9yYWdlW1wic2Nyb2xsLWNhY2hlX1wiICsgZ3JpZFVybF1gXG4gICAgICAgIC8vIGl0IHdhcyByZW1vdmVkIHRvIHRlbXBvcmFyaWx5IGFkZHJlc3MgUkFQLTI2NDlcblxuICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgdHlwZTogJ0dFVCcsXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2h0bWwnLFxuICAgICAgICAgICAgdXJsOiBncmlkVXJsLFxuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgLy8gcHV0IHJlc3BvbnNlIGludG8gY2FjaGVcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZVsnc2Nyb2xsLWNhY2hlXycgKyBncmlkVXJsXSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90aGluZyB0byBjYXRjaCBpbiBjYXNlIG9mIG91dCBvZiBtZW1vcnkgb2Ygc2Vzc2lvbiBzdG9yYWdlXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IHdpbGwgZmFsbCBiYWNrIHRvIGxvYWQgdmlhIGFqYXhcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIFVJXG4gICAgICAgICAgICAgICAgZmlsbEVuZGxlc3NTY3JvbGxDaHVuayhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcHJvZHVjdFRpbGUuaW5pdCgpO1xuICAgICAgICAgICAgICAgIC8vIGluaXQgc3dhdGNoIGNvbG9yIHZpZXdcbiAgICAgICAgICAgICAgICBzaG93TW9yZVN3YXRjaGVzKCk7XG4gICAgICAgICAgICAgICAgLy8gc3luYyBoZWlnaHRcbiAgICAgICAgICAgICAgICB0aWxlU3luYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhTGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgXHR2YXIgZGF0YUxheWVyID0gd2luZG93LmRhdGFMYXllciA9IHdpbmRvdy5kYXRhTGF5ZXIgfHwgW107XG4gICAgICAgIFx0ZGF0YUxheWVyLnB1c2goYXBwLmRhdGFsYXllci5nZXRFdmVudChcImV2ZW50XCIsIFwiYmF0Y2hlZEVjb21Qcm9kSW1wcmVzc2lvblwiKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvbiByZXBsYWNlcyBicmVhZGNydW1icywgbGVmdGhhbmQgbmF2IGFuZCBwcm9kdWN0IGxpc3Rpbmcgd2l0aCBhamF4IGFuZCBwdXRzIGEgbG9hZGluZyBpbmRpY2F0b3Igb3ZlciB0aGUgcHJvZHVjdCBsaXN0aW5nXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVByb2R1Y3RMaXN0aW5nKGlzSGFzaENoYW5nZSkge1xuICAgIHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uLmhhc2g7XG4gICAgXG4gICAgaWYoaGFzaD09PScjcmVzdWx0cy1jb250ZW50JyB8fCBoYXNoPT09JyNyZXN1bHRzLXByb2R1Y3RzJykgeyByZXR1cm47IH1cbiAgICBcbiAgICB2YXIgcmVmaW5lVXJsID0gbnVsbCxcbiAgICBcdGVuY29kZWRIYXNoID0gXCJcIixcbiAgICBcdHNlYXJjaFN0cmluZyA9IFwiXCIsXG4gICAgXHRzZWFyY2hVcmwgPSBcIlwiO1xuICAgIFxuICAgIGlmIChoYXNoLmxlbmd0aCA+IDApIHtcbiAgICBcdHNlYXJjaFN0cmluZyA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggfHwgXCI/XCI7XG4gICAgXHRlbmNvZGVkSGFzaCA9ICcmJyArIGhhc2guc3Vic3RyKDEpLnJlcGxhY2UoL1xccy9nLCclMjAnKTsgLy9SZXF1aXJlZDogRmlyZWZveCBhbGxvd3Mgd2hpdGVzcGFjZSBpbiBVUkwsIHdoaWNoIGJyZWFrcyByZWZpbmVtZW50cyAoS1MtMTUxNSwgS1MtMTEzMSlcbiAgICAgICAgcmVmaW5lVXJsID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgc2VhcmNoU3RyaW5nICsgZW5jb2RlZEhhc2g7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzSGFzaENoYW5nZSkge1xuICAgICAgICByZWZpbmVVcmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICB9XG5cbiAgICBpZiAoIXJlZmluZVVybCkgeyByZXR1cm47IH1cblxuICAgIHNlYXJjaFVybCA9IHV0aWwuYXBwZW5kUGFyYW1Ub1VSTChyZWZpbmVVcmwsIFwiZm9ybWF0XCIsIFwiYWpheFwiKTtcblxuICAgIHByb2dyZXNzLnNob3coJGNhY2hlLmNvbnRlbnQpO1xuICAgICQuYWpheCh7XG4gICAgICAgIHR5cGU6ICdHRVQnLFxuICAgICAgICBkYXRhVHlwZTogJ2h0bWwnLFxuICAgICAgICB1cmw6IHNlYXJjaFVybCxcblx0ICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICRjYWNoZS5jb250ZW50ID0gJGNhY2hlLm1haW4uZmluZChcIi5zZWFyY2gtcmVzdWx0LWNvbnRlbnRcIik7XG5cdCAgICAgICAgJGNhY2hlLmZpbHRlcnMgPSAkY2FjaGUubWFpbi5maW5kKFwiI2ZpbHRlci1jb250YWluZXJcIik7XG5cdCAgICAgICAgJGNhY2hlLmNvdW50ID0gJGNhY2hlLm1haW4uZmluZChcIi5zZWFyY2gtcmVzdWx0LWNvdW50XCIpO1xuXHQgICAgICAgICRjYWNoZS5jb3VudFNlYXJjaCA9ICRjYWNoZS5tYWluLmZpbmQoXCIuaGVhZGVyLWl0ZW0tcmVzdWx0XCIpO1xuXHQgICAgICAgIHZhciBuZXdQcm9kdWN0cyA9ICQocmVzcG9uc2UpLmZpbmQoJy5zZWFyY2gtcmVzdWx0LWNvbnRlbnQnKTtcblx0ICAgICAgICB2YXIgbmV3RmlsdGVycyA9ICQocmVzcG9uc2UpLmZpbmQoJyNmaWx0ZXItY29udGFpbmVyJyk7XG5cdCAgICAgICAgdmFyIG5ld0NvdW50ID0gJChyZXNwb25zZSkuZmluZCgnLnNlYXJjaC1yZXN1bHQtY291bnQnKTtcblx0ICAgICAgICB2YXIgbmV3Q291bnRTZWFyY2ggPSAkKHJlc3BvbnNlKS5maW5kKCcuaGVhZGVyLWl0ZW0tcmVzdWx0Jyk7XG5cdCAgICAgICAgJGNhY2hlLmNvbnRlbnQucmVwbGFjZVdpdGgobmV3UHJvZHVjdHMpO1xuXHQgICAgICAgIC8vaWYgZmlsdGVyIGlzIG9wZW5lZCBub3cgd2Ugc2hvdWxkIHJlcGxhY2UgaXQgd2l0aCBvcGVuZWQgZmlsdGVyIHRvb1xuXHQgICAgICAgIGlmICghJGNhY2hlLmZpbHRlcnMuZmluZCgnLmZpbHRlci1jb250ZW50JykuaGFzQ2xhc3MoJ2hpZGUnKSkge1xuXHQgICAgICAgICAgICBuZXdGaWx0ZXJzLmZpbmQoJy5maWx0ZXItY29udGVudCcpLnJlbW92ZUNsYXNzKCdoaWRlJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgICRjYWNoZS5maWx0ZXJzLnJlcGxhY2VXaXRoKG5ld0ZpbHRlcnMpO1xuXHQgICAgICAgICRjYWNoZS5jb3VudC5yZXBsYWNlV2l0aChuZXdDb3VudCk7XG5cdCAgICAgICAgJGNhY2hlLmNvdW50U2VhcmNoLnJlcGxhY2VXaXRoKG5ld0NvdW50U2VhcmNoKTtcblx0ICAgICAgICBwcm9kdWN0VGlsZS5pbml0KCk7XG5cdCAgICAgICAgcHJvZ3Jlc3MuaGlkZSgpO1xuXHQgICAgICAgIHRpbGVTeW5jKCk7XG4gICAgICAgIC8vY2xvc2UgY2F0ZWdvcnkgbmF2IGluIG1vYmlsZS90YWJsZXRcbiAgICAgICAgaWYgKHdpbmRvd1dpZHRoIDw9IGxhcmdlQnJlYWtwb2ludCkge1xuICAgICAgICAgICAgJCgnLnJlZmluZW1lbnQuU2hvcC5ieS5DYXRlZ29yeS5kaXNwbGF5bmFtZScpLmFkZENsYXNzKCdjb2xsYXBzZWQnKS5maW5kKCd1bCcpLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2luZG93V2lkdGggPiBtZWRpdW1CcmVha3BvaW50ICYmIHdpbmRvd1dpZHRoIDw9IGxhcmdlQnJlYWtwb2ludCkge1xuICAgICAgICAgICAgJCgnLmZpbHRlci1jb250YWluZXInKS5jc3MoJ2JvcmRlci10b3AnLCAnMXB4IHNvbGlkICMwMDAnKTtcbiAgICAgICAgfVxuXG5cdCAgICAgICAgLy9SZWhpZGUgc3ViIGNhdGVnb3JpZXMgd2l0aCB0b2dnbGVzXG5cdCAgICAgICAgc3ViVG9nZ2xlSW5pdCgpO1xuXG5cdCAgICAgICAgLy9DaGFuZ2UgUGFnZSBUaXRsZVxuXHQgICAgICAgIHZhciB0aXRsZVBhcnRzID0gZG9jdW1lbnQudGl0bGUuc3BsaXQoJ3wnKTtcblx0ICAgICAgICBkb2N1bWVudC50aXRsZSA9ICQoJy5zZWFyY2gtcmVzdWx0LWNvdW50IGgxJykudGV4dCgpLnJlcGxhY2UoL14oLil8XFxzKC4pL2csIGZ1bmN0aW9uKCQxKXsgcmV0dXJuICQxLnRvVXBwZXJDYXNlKCApOyB9KSArICcgfCAnICsgdGl0bGVQYXJ0c1sxXTtcblxuXHQgICAgICAgIC8vIHRyaWdnZXIgc2Nyb2xsIHRvIHNldCB0aGUgaGVhZGVyXG5cdCAgICAgICAgJCh3aW5kb3cpLnRyaWdnZXIoJ3Njcm9sbCcpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbi8vc3luY2hyb25pemVzIGhlaWdodHMgb2YgdGlsZXMgb24gY2F0IGJyb3dzZSBwYWdlc1xuZnVuY3Rpb24gdGlsZVN5bmMoKSB7XG4gICAgaW1hZ2VzTG9hZGVkKCcuc2VhcmNoLXJlc3VsdC1jb250ZW50Jykub24oJ2Fsd2F5cycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJCgnLnNlYXJjaC1yZXN1bHQtY29udGVudCAucHJvZHVjdC10aWxlJykuc3luY0hlaWdodCgpO1xuICAgIH0pO1xufVxuXG4vL3NhdmUgY3VycmVudCByZWZpbmVtZW50IHRhYnNcbmZ1bmN0aW9uIHNldFJlZmluZW1lbnRDb29raWVzKCkge1xuICAgICRjYWNoZS5tYWluLmZpbmQoJy5yZWZpbmVtZW50IC50b2dnbGUgc3BhbicpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAkLmNvb2tpZSgkLnRyaW0oJCh0aGlzKS50ZXh0KCkpLCAkKHRoaXMpLnBhcmVudHMoJy5yZWZpbmVtZW50JykuaGFzQ2xhc3MoJ2NvbGxhcHNlZCcpKTtcbiAgICB9KTtcbn1cbi8vSGlkZSBsaXN0cyBmb3Igc3ViLXRvZ2dsZVxuZnVuY3Rpb24gc3ViVG9nZ2xlSW5pdCgpIHtcbiAgICBpZigkKFwiLnJlZmluZW1lbnRcIikubGVuZ3RoICYmICQoXCIucmVmaW5lbWVudCAuZXhwYW5kYWJsZVwiKS5sZW5ndGgpe1xuICAgICAgICBpZigkKFwiLmV4cGFuZGFibGUuYWN0aXZlIC5wbHVzX21pbnVzXCIpLmh0bWwoKT09XCIrXCIpIHtcbiAgICAgICAgICAgICQoXCIuZXhwYW5kYWJsZS5hY3RpdmUgLnBsdXNfbWludXNcIikuaHRtbChcIiYjODIxMTtcIik7XG4gICAgICAgIH1cblxuICAgICAgICAkKFwiLmV4cGFuZGFibGVcIikuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZighJCh0aGlzKS5oYXNDbGFzcygnYWN0aXZlJykpe1xuICAgICAgICAgICAgICAgICQodGhpcykucGFyZW50KCkuZmluZChcInVsOm5vdCguYWN0aXZlKVwiKS5jc3MoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cblxuICAgIH1cbn1cblxuLy9TY2FsZSBkaXZpZGVycyBoZWlnaHQvd2lkdGggZm9yIGNhdGVnb3J5IGxhbmRpbmcgY29udGVudCBiYXNlZCBvbiBzY3JlZW4gd2lkdGhcbmZ1bmN0aW9uIHNjYWxlRGl2aWRlcnMoKSB7XG4gICAgaWYgKCQoJy5jYXQtbGFuZGluZy1zbG90JykubGVuZ3RoICYmICQoJ3RkJykubGVuZ3RoKSB7XG4gICAgICAgIGltYWdlc0xvYWRlZCgnLmNhdC1sYW5kaW5nLXNsb3QnKS5vbignYWx3YXlzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGltZ3MgPSAkKCcuY2F0LWxhbmRpbmctc2xvdCcpLmZpbmQoJ2ltZycpO1xuICAgICAgICAgICAgdmFyIG1heFdpZHRoID0gMDtcbiAgICAgICAgICAgIHZhciBtYXhXaWR0aEltZztcbiAgICAgICAgICAgIGpRdWVyeS5lYWNoKGltZ3MsIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCQodGhpcykud2lkdGgoKSA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heFdpZHRoID0gJCh0aGlzKS53aWR0aCgpO1xuICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aEltZyA9ICQodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICB2YXIgc2NhbGVSYXRpbyA9IG1heFdpZHRoIC8gbWF4V2lkdGhJbWdbJzAnXS5uYXR1cmFsV2lkdGg7XG5cbiAgICAgICAgICAgIHZhciBpdGVtcyA9ICQoJy5jYXQtbGFuZGluZy1zbG90JykuZmluZCgndGQnKTtcbiAgICAgICAgICAgIGpRdWVyeS5lYWNoKGl0ZW1zLCAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICgkKHRoaXMpLmNoaWxkcmVuKCkubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCd3aWR0aCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLndpZHRoKE1hdGgucm91bmQodGhpcy53aWR0aCAqIHNjYWxlUmF0aW8pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnaGVpZ2h0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykuaGVpZ2h0KE1hdGgucm91bmQodGhpcy5oZWlnaHQgKiBzY2FsZVJhdGlvKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcGVyc29uYWxpemF0aW9uU2xpZGVyKCkge1xuXG4gICAgdmFyIGJlZm9yZSA9ICQoJy5zbGlkZXItYmVmJyk7XG4gICAgdmFyIGFmdGVyID0gJCgnLnNsaWRlci1hZnQnKTtcbiAgICB2YXIgaGFuZGxlID0gJCgnLmhhbmRsZS13cmFwcGVyJyk7XG4gICAgdmFyIHNsaWRlciA9ICQoJy5BQi1zbGlkZWJhcicpO1xuICAgIHZhciB0b29sdGlwID0gJCgnLnNsaWRlci10aXAnKTtcblxuICAgICQoJy5zbGlkZXItYmVmJykuZmluZCgnaW1nJykuY3NzKCdtYXgtd2lkdGgnLCAkKCcuc2xpZGVyLWFmdCcpLndpZHRoKCkpO1xuICAgICQoJy5oYW5kbGUtd3JhcHBlcicpLmNzcygnaGVpZ2h0JywgJCgnLnNsaWRlci1hZnQnKS5oZWlnaHQoKSk7XG5cbiAgICB2YXIgY3VycmVudFdpZHRoID0gJChiZWZvcmUpLndpZHRoKCk7IC8vZ2V0IGN1cnJlbnQgd2lkdGggb2YgdG9wIGltYWdlXG4gICAgdmFyIG5ld1RvcFdpZHRoID0gY3VycmVudFdpZHRoICogMi8zOyAvL2NhbGN1bGF0ZSBuZXcgdG9wIHdpZHRoIC0+IDIvMyBvZiBjdXJyZW50IHdpZHRoXG5cblxuICAgIGJlZm9yZS53aWR0aChuZXdUb3BXaWR0aCk7IC8vc2V0IHRvcCBpbWFnZSB3aXRoIG5ldyB3aWR0aFxuICAgIGhhbmRsZS5jc3MoJ2xlZnQnLCBuZXdUb3BXaWR0aCk7IC8vc2V0IGxlZnQgbWFyZ2luIGZvciBiYXJcblxuXG5cbiAgICBmdW5jdGlvbiBzbGlkZUJhcihlKSB7XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV3V2lkdGggPSBwYXJzZUludCgkKGhhbmRsZSkuY3NzKCdsZWZ0JykpO1xuICAgICAgICAgICAgLy8gc2V0IHdpZHRoIG9mIGJlZm9yZSBpbWcgZGl2XG4gICAgICAgICAgICBiZWZvcmUud2lkdGgobmV3V2lkdGgpO1xuICAgICAgICB9LCAzMCk7XG5cbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzbGlkZUJhck1vYmlsZShlKSB7XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV3V2lkdGggPSBwYXJzZUZsb2F0KCQoaGFuZGxlKS5jc3MoJ2xlZnQnKSkgKyBlLmR4O1xuICAgICAgICAgICAgLy8gc2V0IHdpZHRoIG9mIGJlZm9yZSBpbWcgZGl2XG4gICAgICAgICAgICBiZWZvcmUud2lkdGgobmV3V2lkdGgpO1xuICAgICAgICAgICAgaGFuZGxlLmNzcygnbGVmdCcsIG5ld1dpZHRoICsgJ3B4Jyk7XG4gICAgICAgIH0sIDMwKTtcblxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuXG4gICAgaGFuZGxlLmRyYWdnYWJsZSh7XG4gICAgICAgIGNvbnRhaW5tZW50OiBzbGlkZXIsXG4gICAgICAgIGF4aXM6ICd4J1xuICAgIH0pO1xuXG4gICAgc2xpZGVyLmJpbmQoJ2RyYWcnLCBzbGlkZUJhcikuYmluZCgnbW91c2Vkb3duIHRvdWNoc3RhcnQnLCBmdW5jdGlvbigpe1xuICAgICAgICB0b29sdGlwLmZhZGVPdXQoMTApO1xuICAgIH0pO1xuXG4gICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoIDw9IGxhcmdlQnJlYWtwb2ludCkge1xuICAgICAgICBpbnRlcmFjdC5pbnRlcmFjdCgnLmRyYWdnYWJsZScpXG4gICAgICAgIC5kcmFnZ2FibGUoe1xuICAgICAgICAgICAgb25tb3ZlOiBzbGlkZUJhck1vYmlsZVxuICAgICAgICB9KTtcbiAgICB9XG5cbn1cbmZ1bmN0aW9uIG9hc1RpbGVzKCkge1xuICAgIC8vIHByZXZlbnQgYWRkaW5nIG9hc1RpbGVzIGFmdGVyIHNlYXJjaCByZWZpbmVtZW50XG4gICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5oYXNoLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgICQoJy50aWxlcy1jb250YWluZXIgLmdyaWQtdGlsZScpLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoJCh0aGlzKS5oYXNDbGFzcygnb2FzRG91YmxlJykgfHwgJCh0aGlzKS5oYXNDbGFzcygnYmxhbmstdGlsZScpIHx8ICQodGhpcykuaGFzQ2xhc3MoJ29hcy10aWxlJykpIHtcbiAgICAgICAgICAgICQodGhpcykucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9KVxuICAgIHZhciAkcHJvZHVjdFRpbGVzID0gJCgnLnRpbGVzLWNvbnRhaW5lciAucHJvZHVjdC10aWxlJyk7XG4gICAgdmFyICRncmlkVGlsZXMgPSAkKCcudGlsZXMtY29udGFpbmVyIC5ncmlkLXRpbGUnKTtcbiAgICB2YXIgcHJvZHVjdFRpbGVzTmV3ID0gJCgnI3NlYXJjaC1yZXN1bHQtaXRlbXMgbGkuZ3JpZC10aWxlJyk7XG4gICAgLy8gc2V0dXAgT0FTIHNsb3RzIGlmIHRoZXkgZXhpc3RcbiAgICAkKCcjb2FzVGlsZXMnKS5maXJzdCgpLmZpbmQoJ2xpJykuZWFjaCggZnVuY3Rpb24oaW5kZXgsIGVsKSB7XG5cbiAgICAgICAgdmFyIHRpbGVQb3NpdGlvbiA9ICQoZWwpLmF0dHIoXCJ0aWxlUG9zaXRpb25cIik7XG4gICAgICAgIHZhciBibGFua1RpbGUgPSAkKCc8bGkgY2xhc3M9XCJncmlkLXRpbGUgYmxhbmstdGlsZVwiPicpO1xuICAgICAgICAvLyBjb25maWd1cmUgdGlsZSBwb3NpdGlvblxuICAgICAgICBpZiAodGlsZVBvc2l0aW9uID4gcHJvZHVjdFRpbGVzTmV3Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGlsZVBvc2l0aW9uID0gcHJvZHVjdFRpbGVzTmV3Lmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICAqICAgc2V0dXAgdGlsZSBwb3NpdGlvbiAtIG1vdmVzIHRoZSB0aWxlIHRvIHRoZSBwb3NpdGlvbiBpbiB0aGVcbiAgICAgICAgICogICBsaXN0IChtaW51cyBvbmUgYmVjYXVzZSB6ZXJvIGJhc2VkIGFycmF5KSBtaW51cyBvbmUgYWxzbyBtYWtlc1xuICAgICAgICAgKiAgIGl0IHNvIGEgdGlsZSBpcyBuZXZlciBsYXN0IGluIHRoZSBsaXN0XG4gICAgICAgICAqICAgICAgICAgICAqXG4gICAgICAgICAqICAgYWxzbyBhY2NvdW50aW5nIGZvciBjYXNlIHdoZXJlIG9hcyBkb3VibGUgdGlsZSBpcyBiZXR3ZWVuIHR3byByb3dzIG9uIG1vYmlsZVxuICAgICAgICAgKi9cblxuICAgICAgICBpZiAoJCgnLm9hc0RvdWJsZScpLmxlbmd0aCAmJiB3aW5kb3dXaWR0aCA8PSBtZWRpdW1CcmVha3BvaW50ICYmIHRpbGVQb3NpdGlvbiAlIDIgPT0gMCApIHtcbiAgICAgICAgICAgIHRpbGVQb3NpdGlvbiAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgJChlbCkuY2xvbmUoKS5pbnNlcnRCZWZvcmUocHJvZHVjdFRpbGVzTmV3W3RpbGVQb3NpdGlvbiAtMV0pO1xuICAgICAgICBpZiAoJCh0aGlzKS5oYXNDbGFzcygnb2FzRG91YmxlJykpIHtcbiAgICAgICAgICAgICQocHJvZHVjdFRpbGVzTmV3W3RpbGVQb3NpdGlvbiAtMV0pLmJlZm9yZShibGFua1RpbGUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuICAgIC8vIFJSLTY3NjkgZG8gbm90IHN5bmMgcHJvZHVjdCBuYW1lIGhlaWdodFxuXG4gICAgLy8gRG8gbm90IHVzZSBjYWNoZWQgY29udGFpbmVycyBoZXJlIGJlY2F1c2UgdGhlIGFtb3VudCBvZiB0aWxlcyBpbiB0aGUgZ3JpZCBtYXkgYmUgY2hhbmdlZCBieSBKUyBjb2RlIGFib3ZlXG5cbiAgICAvLyBpZiAoJHByb2R1Y3RUaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgLy8gICAgIHZhciBjb2xDb3VudCA9IChtYXRjaE1lZGlhKCcobWF4LXdpZHRoOiAnICsgbWVkaXVtQnJlYWtwb2ludCArICdweCknKS5tYXRjaGVzKSA/IDIgOiAzO1xuICAgIC8vXG4gICAgICAgIC8vIFN5bmNocm9uaXplIGhlaWdodHMgb2YgcHJvZHVjdCBuYW1lcyBpbiBhIHJvd1xuICAgICAgICAvLyBmb3IgKHZhciBpID0gMDsgaSA8ICRncmlkVGlsZXMubGVuZ3RoOyBpICs9IGNvbENvdW50KSB7XG4gICAgICAgIC8vICAgICB2YXIgcm93VGlsZXMgPSBbXTtcbiAgICAgICAgLy8gICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sQ291bnQ7IGorKykge1xuICAgICAgICAvLyAgICAgICAgIHZhciBncmlkVGlsZSA9ICRncmlkVGlsZXNbaSArIGpdO1xuICAgICAgICAvLyAgICAgICAgIGlmIChncmlkVGlsZSkge1xuICAgICAgICAvLyAgICAgICAgICAgICByb3dUaWxlcy5wdXNoKGdyaWRUaWxlKTtcbiAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICAkKHJvd1RpbGVzKS5maW5kKCcucHJvZHVjdC1uYW1lJykuc3luY0hlaWdodCgpO1xuICAgICAgICAvLyB9XG4gICAgLy8gfVxufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBhZGQgYWJpbGl0eSB0byBzaG93IG1vcmUgdGhhbiAzIHN3YXRjaGVzIG9uIHRoZSBwcm9kdWN0IHRpbGVcbiAqL1xuZnVuY3Rpb24gc2hvd01vcmVTd2F0Y2hlcygpIHtcbiAgICB2YXIgcHJvZHVjdFRpbGVzID0gJCgnI3NlYXJjaC1yZXN1bHQtaXRlbXMgbGkuZ3JpZC10aWxlJyk7O1xuICAgIGlmIChwcm9kdWN0VGlsZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICBwcm9kdWN0VGlsZXMuZmluZCgnLnByb2R1Y3QtdGlsZScpLmVhY2goZnVuY3Rpb24oKXtcblxuICAgICAgICB2YXIgJHRpbGUgPSBqUXVlcnkodGhpcyk7XG4gICAgICAgIHZhciAkbGlzdCA9ICR0aWxlLmZpbmQoJy5zd2F0Y2gtbGlzdCcpO1xuICAgICAgICB2YXIgJHN3YXRjaGVzID0gJGxpc3QuZmluZCgnbGknKTtcblxuICAgICAgICBpZiAoICRzd2F0Y2hlcy5sZW5ndGggPiAkbGlzdC5kYXRhKCdtYXgnKSAmJiAkbGlzdC5maW5kKCcubW9yZScpLmxlbmd0aCA9PSAwKXtcblxuICAgICAgICAgICAgdmFyIG92ZXJsYXlzd2F0Y2ggPSBqUXVlcnkoJzxkaXYvPicpLmFkZENsYXNzKCdzdy1vdmVybGF5Jyk7XG4gICAgICAgICAgICAkdGlsZS5hcHBlbmQob3ZlcmxheXN3YXRjaClcbiAgICAgICAgICAgICRsaXN0LmNsb25lKCkuYXBwZW5kVG8ob3ZlcmxheXN3YXRjaCk7XG5cbiAgICAgICAgICAgIHZhciB0b2dnbGUgPSAkKCc8c3Bhbi8+JykuYWRkQ2xhc3MoJ21vcmUnKS50ZXh0KCcoKycgKyAoJHN3YXRjaGVzLmxlbmd0aCAtICRsaXN0LmRhdGEoJ21heCcpKSArICcpJyk7XG4gICAgICAgICAgICAkbGlzdC5wcmVwZW5kKHRvZ2dsZSk7XG4gICAgICAgICAgICB0b2dnbGUub24oJ2NsaWNrJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBvdmVybGF5c3dhdGNoLnNob3coKTtcbiAgICAgICAgICAgICAgICAkdGlsZS5maW5kKCcucHJvZHVjdC1zd2F0Y2hlcywgLnByb2R1Y3QtbmFtZSwgLnByb2R1Y3QtcHJpY2luZywgLnByb2R1Y3QtcHJvbW8nKS5oaWRlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgb3ZlcmxheXN3YXRjaC5vbignbW91c2VsZWF2ZScsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgdmFyICRvdmVybGF5c3dhdGNoID0gJCh0aGlzKTtcbiAgICAgICAgICAgICAgICB2YXIgdGltZW91dElEID0gJG92ZXJsYXlzd2F0Y2guZGF0YSgndGltZW91dGlkJyk7XG4gICAgICAgICAgICAgICAgaWYodGltZW91dElEKXtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpbWVvdXRJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgJG92ZXJsYXlzd2F0Y2guZGF0YSgndGltZW91dGlkJywgJycpO1xuICAgICAgICAgICAgICAgICAgICAkb3ZlcmxheXN3YXRjaC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICR0aWxlLmZpbmQoJy5wcm9kdWN0LXN3YXRjaGVzLCAucHJvZHVjdC1uYW1lLCAucHJvZHVjdC1wcmljaW5nLCAucHJvZHVjdC1wcm9tbycpLnNob3coKTtcbiAgICAgICAgICAgICAgICB9LDIwMDApO1xuICAgICAgICAgICAgICAgICRvdmVybGF5c3dhdGNoLmRhdGEoJ3RpbWVvdXRpZCcsIHRpbWVvdXRJRCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG92ZXJsYXlzd2F0Y2gub24oJ21vdXNlZW50ZXInLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHZhciAkb3ZlcmxheXN3YXRjaCA9ICQodGhpcyk7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVvdXRJRCA9ICRvdmVybGF5c3dhdGNoLmRhdGEoJ3RpbWVvdXRpZCcpO1xuICAgICAgICAgICAgICAgIGlmKHRpbWVvdXRJRCl7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJChkb2N1bWVudCkub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN3Y29udGFpbmVyID0gJCgnLnN3LW92ZXJsYXknKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN3Y29udGFpbmVyLmlzKGUudGFyZ2V0KSAmJiBzd2NvbnRhaW5lci5oYXMoZS50YXJnZXQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzd2NvbnRhaW5lci5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICR0aWxlLmZpbmQoJy5wcm9kdWN0LXN3YXRjaGVzLCAucHJvZHVjdC1uYW1lLCAucHJvZHVjdC1wcmljaW5nLCAucHJvZHVjdC1wcm9tbycpLnNob3coKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvbiBJbml0aWFsaXplcyBldmVudHMgZm9yIHRoZSBmb2xsb3dpbmcgZWxlbWVudHM6PGJyLz5cbiAqIDxwPnJlZmluZW1lbnQgYmxvY2tzPC9wPlxuICogPHA+dXBkYXRpbmcgZ3JpZDogcmVmaW5lbWVudHMsIHBhZ2luYXRpb24sIGJyZWFkY3J1bWI8L3A+XG4gKiA8cD5pdGVtIGNsaWNrPC9wPlxuICogPHA+c29ydGluZyBjaGFuZ2VzPC9wPlxuICovXG5mdW5jdGlvbiBpbml0aWFsaXplRXZlbnRzKCkge1xuXG4gICAgLy8gc2Nyb2xsIGZvciBzdGlja3kgaGVhZGVyL3JlZmluZW1lbnRzXG4gICAgJCh3aW5kb3cpLnNjcm9sbChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNjcm9sbEZpbHRlckNvbnN0YW50ID0gMTIwLFxuICAgICAgICBoZWFkZXJIZWlnaHQgPSAkKCcudG9wLWJhbm5lcicpLm91dGVySGVpZ2h0KCksXG4gICAgICAgIG5hdkhlaWdodCA9IDAsXG4gICAgICAgIGNhdFNsb3RIZWlnaHQgPSAkKCcuY2F0ZWdvcnktdG9wLXNsb3QnKS5vdXRlckhlaWdodCgpLFxuICAgICAgICBzY3JvbGxUb3AgPSAkKHRoaXMpLnNjcm9sbFRvcCgpLFxuICAgICAgICBmaWx0ZXJzID0gJCgnI2ZpbHRlcnMnKSxcbiAgICAgICAgc2VsZWN0ZWRGaWx0ZXJzID0gZmlsdGVycy5maW5kKCcjZmlsdGVycy1zZWxlY3RlZCcpLFxuICAgICAgICBoYXNGaWx0ZXJzID0gc2VsZWN0ZWRGaWx0ZXJzLmxlbmd0aCA+IDAgJiYgc2VsZWN0ZWRGaWx0ZXJzLmZpbmQoJy5yZWZpbmVtZW50LWxpc3QnKS5sZW5ndGggPiAwLFxuICAgICAgICBpc1NlYXJjaFBhZ2UgPSAkKCcucHRfcHJvZHVjdC1zZWFyY2gtcmVzdWx0JykubGVuZ3RoID4gMDtcbiAgICAgICAgaWYgKHdpbmRvd1dpZHRoIDw9IGxhcmdlQnJlYWtwb2ludCkge1xuICAgICAgICAgICAgbmF2SGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIHNjcm9sbEZpbHRlckNvbnN0YW50ID0gMTUwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmF2SGVpZ2h0ID0gJCgnI25hdmlnYXRpb24nKS5vdXRlckhlaWdodCgpO1xuICAgICAgICAgICAgc2Nyb2xsRmlsdGVyQ29uc3RhbnQgPSAxMjA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpbHRlckFjdGl2ZSA9ICQoJy5maWx0ZXItdG9nZ2xlJykuaGFzQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICBpZiAodXRpbC5pc01vYmlsZSgpKSB7XG5cdCAgICAgICAgaWYgKGlzU2VhcmNoUGFnZSAmJiBoYXNGaWx0ZXJzKXtcblx0XHQgICAgICAgIGlmIChzY3JvbGxUb3AgPiAwKSB7XG5cdFx0ICAgICAgICBcdCQoJyNzaXRlLXRhYi1iYXInKS5jc3MoJ3Bvc2l0aW9uJywgJ3N0YXRpYycpO1xuXHRcdCAgICAgICAgfSBlbHNlIHtcblx0XHQgICAgICAgIFx0JCgnI3NpdGUtdGFiLWJhcicpLmNzcygncG9zaXRpb24nLCAnZml4ZWQnKTtcblx0XHQgICAgICAgIH1cblx0ICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU2VhcmNoUGFnZSAmJiBoYXNGaWx0ZXJzICYmICFmaWx0ZXJBY3RpdmUgJiYgIXV0aWwuaXNNb2JpbGUoKSkge1xuICAgICAgICAgICAgaWYgKHNjcm9sbFRvcCA+IGhlYWRlckhlaWdodCArIG5hdkhlaWdodCArIGNhdFNsb3RIZWlnaHQgKyBzY3JvbGxGaWx0ZXJDb25zdGFudCkge1xuICAgICAgICAgICAgICAgICQoJy5maWx0ZXItY29udGFpbmVyJykuY3NzKCdib3JkZXItYm90dG9tJywgJzAnKTtcbiAgICAgICAgICAgICAgICAkKCcjcHJpbWFyeScpLmNzcygnbWFyZ2luVG9wJywgJzIxNXB4Jyk7XG4gICAgICAgICAgICAgICAgJCgnLmxvd2VyJykuY3NzKCdtYXJnaW5Ub3AnLCAnMjE1cHgnKTtcbiAgICAgICAgICAgICAgICBmaWx0ZXJzLmFkZENsYXNzKCdzdGlja3knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICQoJy5maWx0ZXItY29udGFpbmVyJykuY3NzKCdib3JkZXItYm90dG9tJywgJzFweCBzb2xpZCAjMDAwJyk7XG4gICAgICAgICAgICAgICAgJCgnI3ByaW1hcnknKS5jc3MoJ21hcmdpblRvcCcsICcwJyk7XG4gICAgICAgICAgICAgICAgJCgnLmxvd2VyJykuY3NzKCdtYXJnaW5Ub3AnLCAnMCcpO1xuICAgICAgICAgICAgICAgIGZpbHRlcnMucmVtb3ZlQ2xhc3MoJ3N0aWNreScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyB0cmlnZ2VyIHNjcm9sbCB0byBzZXQgdGhlIGhlYWRlciBvbiBwYWdlIGxvYWRcbiAgICAkKHdpbmRvdykudHJpZ2dlcignc2Nyb2xsJyk7XG5cbiAgICB2YXIgcHJvZHVjdFRpbGVzID0galF1ZXJ5KCcjc2VhcmNoLXJlc3VsdC1pdGVtcyBsaS5ncmlkLXRpbGUnKTtcbiAgICAvL2FkZCBzcGVjaWZpYyBjbGFzcyBmb3IgcHJvZHVjdCBzZXQgdGlsZXNcbiAgICAkKCcucHJvZHVjdC10aWxlJykuaGFzKCQoJy5wcm9kdWN0LXNldC1wcmljZScpKS5hZGRDbGFzcygncHJvZHVjdC1zZXQtdGlsZScpO1xuXG4gICAgaWYgKHR5cGVvZiAkY2FjaGUuY2hlY2tnaWZ0Y2FyZEJhbGFuY2UgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgJGNhY2hlLmNoZWNrZ2lmdGNhcmRCYWxhbmNlID0gJCgnI0NoZWNrQmFsYW5jZUJ1dHRvbicpO1xuICAgICAgICAkY2FjaGUuZ2lmdGNhcmRjb2RlPSAkKCcuZ2lmdGNhcmRjb2RlJyk7XG4gICAgICAgICRjYWNoZS5naWZ0Y2FyZHBpbj0gJCgnLmdpZnRjYXJkcGluJyk7XG4gICAgICAgICRjYWNoZS5naWZ0Y2FyZGJhbGFuY2U9ICQoJy5iYWxhbmNlJyk7XG4gICAgICAgICRjYWNoZS5naWZ0Y2FyZGZvcm09ICQoJyNnYy1jaGVja2JhbGFuY2UnKTtcbiAgICB9XG4gICAgJGNhY2hlLmNoZWNrZ2lmdGNhcmRCYWxhbmNlLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAkY2FjaGUuZ2lmdGNhcmRjb2RlID0gJGNhY2hlLmdpZnRjYXJkY29kZTtcbiAgICAgICAgJGNhY2hlLmdpZnRjYXJkcGluID0gJGNhY2hlLmdpZnRjYXJkcGluO1xuICAgICAgICAkY2FjaGUuZ2lmdGNhcmRiYWxhbmNlID0gJGNhY2hlLmdpZnRjYXJkYmFsYW5jZTtcblxuICAgICAgICAkY2FjaGUuZ2lmdGNhcmRiYWxhbmNlLnRleHQoJycpO1xuXG4gICAgICAgIGlmICgkY2FjaGUuZ2lmdGNhcmRjb2RlLmxlbmd0aD09PTAgfHwgJGNhY2hlLmdpZnRjYXJkY29kZS52YWwoKS5sZW5ndGg9PT0wIHx8ICRjYWNoZS5naWZ0Y2FyZGNvZGUudmFsKCkgPT09ICdHaWZ0IENhcmQgTnVtYmVyJykge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gJGNhY2hlLmdpZnRjYXJkZm9ybS5maW5kKFwic3Bhbi5lcnJvclwiKTtcbiAgICAgICAgICAgIGlmIChlcnJvci5sZW5ndGg9PT0wKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAkKFwiPHNwYW4+XCIpLmFkZENsYXNzKFwiZXJyb3JcIikuYXBwZW5kVG8oJGNhY2hlLmdpZnRjYXJkZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvci5odG1sKFJlc291cmNlcy5HSUZUX0NFUlRfTUlTU0lORyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRjYWNoZS5naWZ0Y2FyZHBpbi5sZW5ndGg9PT0wIHx8ICRjYWNoZS5naWZ0Y2FyZHBpbi52YWwoKS5sZW5ndGg9PT0wIHx8ICRjYWNoZS5naWZ0Y2FyZHBpbi52YWwoKSA9PT0gJ1BJTicpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9ICRjYWNoZS5naWZ0Y2FyZGZvcm0uZmluZChcInNwYW4uZXJyb3JcIik7XG4gICAgICAgICAgICBpZiAoZXJyb3IubGVuZ3RoPT09MCkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gJChcIjxzcGFuPlwiKS5hZGRDbGFzcyhcImVycm9yXCIpLmFwcGVuZFRvKCRjYWNoZS5naWZ0Y2FyZGZvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IuaHRtbChcIlBsZWFzZSBlbnRlciB0aGUgcGluIG51bWJlclwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBDUlNQQURFUy0yMzogZGlzcGxheSB0aGUgcHJvZ3Jlc3Mgb3ZlcmxheVxuICAgICAgICBwcm9ncmVzcy5zaG93KCk7XG4gICAgICAgIGdpZnRjYXJkLmNoZWNrQmFsYW5jZSgkY2FjaGUuZ2lmdGNhcmRjb2RlLnZhbCgpLCAkY2FjaGUuZ2lmdGNhcmRwaW4udmFsKCksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIHByb2dyZXNzIG92ZXJsYXlcbiAgICAgICAgICAgIHByb2dyZXNzLmhpZGUoKTtcbiAgICAgICAgICAgIC8vIGVhY2ggY2FsbCByZW1vdmUgcHJldiBiYWxhbmNlXG4gICAgICAgICAgICAkY2FjaGUuZ2lmdGNhcmRmb3JtLmZpbmQoXCJzcGFuLmdjYmFsYW5jZVwiKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgaWYoIWRhdGEgfHwgIWRhdGEuZ2lmdENlcnRpZmljYXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gZXJyb3JcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkY2FjaGUuZ2lmdGNhcmRmb3JtLmZpbmQoXCJzcGFuLmVycm9yXCIpO1xuICAgICAgICAgICAgICAgICRjYWNoZS5naWZ0Y2FyZGZvcm0uZmluZChcInNwYW4uZ2NiYWxhbmNlXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmxlbmd0aD09PTApIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSAkKFwiPHNwYW4+XCIpLmFkZENsYXNzKFwiZXJyb3JcIikuYXBwZW5kVG8oJGNhY2hlLmdpZnRjYXJkZm9ybSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVycm9yLmh0bWwoUmVzb3VyY2VzLkdJRlRfQ0VSVF9JTlZBTElEKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkaXNwbGF5IGRldGFpbHMgaW4gVUlcbiAgICAgICAgICAgICRjYWNoZS5naWZ0Y2FyZGZvcm0uZmluZChcInNwYW4uZXJyb3JcIikucmVtb3ZlKCk7XG4gICAgICAgICAgICB2YXIgYmFsYW5jZSA9IGRhdGEuZ2lmdENlcnRpZmljYXRlLmJhbGFuY2U7XG4gICAgICAgICAgICB2YXIgZ2NiYWxhbmNlID0gJChcIjxzcGFuPlwiKS5hZGRDbGFzcyhcImdjYmFsYW5jZVwiKS5hcHBlbmRUbygkY2FjaGUuZ2lmdGNhcmRmb3JtKTtcbiAgICAgICAgICAgIGdjYmFsYW5jZS5odG1sKFJlc291cmNlcy5HSUZUX0NFUlRfQkFMQU5DRStcIiBcIitiYWxhbmNlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgJG1haW4gPSAkKCcjbWFpbicpO1xuICAgIC8vIGNvbXBhcmUgY2hlY2tlZFxuICAgICRjYWNoZS5tYWluLm9uKCdjbGljaycsICdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0uY29tcGFyZS1jaGVjaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNiID0gJCh0aGlzKTtcbiAgICAgICAgdmFyIHRpbGUgPSBjYi5jbG9zZXN0KCcucHJvZHVjdC10aWxlJyk7XG5cbiAgICAgICAgdmFyIGZ1bmMgPSB0aGlzLmNoZWNrZWQgPyBjb21wYXJlV2lkZ2V0LmFkZFByb2R1Y3QgOiBjb21wYXJlV2lkZ2V0LnJlbW92ZVByb2R1Y3Q7XG4gICAgICAgIHZhciBpdGVtSW1nID0gdGlsZS5maW5kKCcucHJvZHVjdC1pbWFnZSBhIGltZycpLmZpcnN0KCk7XG4gICAgICAgIGZ1bmMoe1xuICAgICAgICAgICAgaXRlbWlkOiB0aWxlLmRhdGEoJ2l0ZW1pZCcpLFxuICAgICAgICAgICAgdXVpZDogdGlsZVswXS5pZCxcbiAgICAgICAgICAgIGltZzogaXRlbUltZyxcbiAgICAgICAgICAgIGNiOiBjYlxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAkY2FjaGUubWFpbi5vbignY2xpY2snLCAnLml0ZW0tY291bnQgYScsIGZ1bmN0aW9uIChlKSB7XG4gICAgXHRlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgXHR2YXIgaXRlbSA9JCh0aGlzKS5wYXJlbnQoJ2xpJylcbiAgICBcdGl0ZW0udG9nZ2xlQ2xhc3MoJ29wZW4nKS5wYXJlbnQoJ3VsJykudG9nZ2xlQ2xhc3MoJ29wZW4tdWwnKS5maW5kKCdsaS5oaWRlJykudG9nZ2xlQ2xhc3MoJ29wZW4nKTtcbiAgICB9KTtcblxuICAgIHZhciBwZXJzb25hbGl6YXRpb25QYWdlO1xuICAgIC8vIGNoZWNrIGlmIGNhdGVnb3J5IGxhbmRpbmcgcGFnZSB0byBoaWRlIGJyZWFkY3J1bWIvZmlsdGVycywgc2NhbGUgZGl2aWRlcnMgYW5kIGltYWdlc1xuICAgIGlmICgkKCcuY2F0LWxhbmRpbmctc2xvdCcpLmxlbmd0aCApIHtcbiAgICBcdGlmKHBlcnNvbmFsaXphdGlvblBhZ2Upe1xuICAgIFx0XHRhZGRCYWNrZ3JvdW5kQ292ZXIoKTtcbiAgICBcdH1cbiAgICAgICAgaWYgKCQoJy5BQi1zbGlkZWJhcicpLmxlbmd0aCl7XG4gICAgICAgICAgICBwZXJzb25hbGl6YXRpb25TbGlkZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNjYWxlcyBkaXZpZGVyIHRkJ3MgZm9yIGNhdGVnb3J5IGxhbmRpbmcgcGFnZSBjb250ZW50XG4gICAgICAgIHNjYWxlRGl2aWRlcnMoKTtcbiAgICB9IGVsc2Uge1xuICAgIFx0JCgnLmZpbHRlci1jb250YWluZXInKS5zaG93KCk7XG4gICAgICAgICQoJy5maWx0ZXItYnV0dG9ucycpLnNob3coKTtcbiAgICB9XG4gICAgXG4gIC8vY2F0IGxhbmRpbmcgcGFnZSBzbGlkZXJzXG4gICAgaWYgKCQoJy5jYXQtbGFuZGluZy1zbG90JykpIHtcbiAgICBcdGlmICgkKCcuc2xpZGVyJykubGVuZ3RoKSB7XG4gICAgXHRcdChmdW5jdGlvbihlLHQsbixyKXtlLmZuLnNzcz1mdW5jdGlvbihyKXt2YXIgaT1lLmV4dGVuZCh7c2xpZGVTaG93OnRydWUsc3RhcnRPbjowLHNwZWVkOjEwMDAwMDAwMDAwMDAwLHRyYW5zaXRpb246MCxhcnJvd3M6dHJ1ZX0scik7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe2Z1bmN0aW9uIHkoZSl7cmV0dXJuIHMuZXEoZSkuaGVpZ2h0KCkvby53aWR0aCgpKjEwMCtcIiVcIn1mdW5jdGlvbiBiKGUpe2lmKCFjKXtjPXRydWU7dmFyIHQ9cy5lcShlKTt0LmZhZGVJbihhKTtzLm5vdCh0KS5mYWRlT3V0KGEpO28uYW5pbWF0ZSh7cGFkZGluZ0JvdHRvbTp5KGUpfSxhLGZ1bmN0aW9uKCl7Yz1mYWxzZX0pO2coKX19ZnVuY3Rpb24gdygpe2w9bD09PXUtMT8wOmwrMTtiKGwpfWZ1bmN0aW9uIEUoKXtsPWw9PT0wP3UtMTpsLTE7YihsKX12YXIgcj1lKHRoaXMpLHM9ci5jaGlsZHJlbigpLndyYXBBbGwoJzxkaXYgY2xhc3M9XCJzc3NcIi8+JykuYWRkQ2xhc3MoXCJzc3NsaWRlXCIpLG89ci5maW5kKFwiLnNzc1wiKSx1PXMubGVuZ3RoLGE9aS50cmFuc2l0aW9uLGY9aS5zdGFydE9uLGw9Zj51LTE/MDpmLGM9ZmFsc2UsaCxwLGQsdixtLGc9aS5zbGlkZVNob3c/ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQocCk7cD1zZXRUaW1lb3V0KHcsaS5zcGVlZCl9OmUubm9vcDtpZihpLmFycm93cyl7by5hcHBlbmQoJzxkaXYgY2xhc3M9XCJzc3NwcmV2XCIvPicsJzxkaXYgY2xhc3M9XCJzc3NuZXh0XCIvPicpfW09by5maW5kKFwiLnNzc25leHRcIiksdj1vLmZpbmQoXCIuc3NzcHJldlwiKTtlKHQpLmxvYWQoZnVuY3Rpb24oKXtvLmNzcyh7cGFkZGluZ0JvdHRvbTp5KGwpfSkuY2xpY2soZnVuY3Rpb24odCl7aD1lKHQudGFyZ2V0KTtpZihoLmlzKG0pKXt3KCl9ZWxzZSBpZihoLmlzKHYpKXtFKCl9fSk7YihsKTtlKG4pLmtleWRvd24oZnVuY3Rpb24oZSl7ZD1lLmtleUNvZGU7aWYoZD09PTM5KXt3KCl9ZWxzZSBpZihkPT09Mzcpe0UoKX19KX0pfSl9fSkoalF1ZXJ5LHdpbmRvdyxkb2N1bWVudCk7XG4gICAgICAgIFx0JChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICBcdCAgJCgnLnNsaWRlcicpLnNzcygpO1xuICAgICAgICBcdH0pO1xuICAgIFx0fVxuICAgIH1cbiAgICBcbiAgICAkKCcuYnJlYWRjcnVtYicpLnNob3coKTtcblxuICAgIC8vIGFjY291bnRzIGZvciBpc3N1ZSB3aGVyZSBzb3J0LWJ5IHRleHQgd291bGQgb3RoZXJ3aXNlIG92ZXJmbG93IGluIG1vYmlsZVxuICAgICRjYWNoZS5tYWluLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAod2luZG93V2lkdGggPD0gMzcwICYmICQoJy5zb3J0LWJ5LXRleHQnKVswXS5maXJzdENoaWxkLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgICAgICAkKCcuc29ydC10b2dnbGUnKS5jc3MoJ3BhZGRpbmcnLCAnMTZweCA4cHgnKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICAvLyBpZiBtb2JpbGUvdGFibGV0IHRoZW4gbWFrZSBjYXRlZ29yeWxhbmRpbmcgaW1wb3NzaWJsZSB0byBnZXQgdG8gZnJvbSBuYXYgYW5kIGNvbGxhcHNlIGNhdGVnb3J5IGxpc3QgYXQgc21hbGxlciB2aWV3cG9ydHNcbiAgICBpZiAod2luZG93V2lkdGggPD0gbGFyZ2VCcmVha3BvaW50KSB7XG4gICAgICAgIHZhciBpdGVtcyA9ICQoJy5tZW51LWNhdGVnb3J5LmxldmVsLTEgPiBsaScpO1xuICAgICAgICBqUXVlcnkuZWFjaChpdGVtcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoJCh0aGlzKS5hdHRyKCdkYXRhLXRlbXBsYXRlJykpe1xuICAgICAgICAgICAgICAgIHZhciBzdHJpbmcgPSAkKHRoaXMpLmRhdGEoJ3RlbXBsYXRlJyk7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnN0cmluZyA9IHN0cmluZy5zdWJzdHIoc3RyaW5nLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgJCgnLnJlZmluZW1lbnQuU2hvcC5ieS5DYXRlZ29yeS5kaXNwbGF5bmFtZScpLmFkZENsYXNzKCdjb2xsYXBzZWQnKS5maW5kKCd1bCcpLmhpZGUoKTtcbiAgICB9XG5cbiAgICAvL0hhbmRsZXMgUmVzaXppbmcgb2YgV2luZG93XG4gICAgc21hcnRSZXNpemUoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh3aW5kb3dXaWR0aCAhPSB3aW5kb3cuaW5uZXJXaWR0aCkge1xuICAgICAgICAgICAgLy9zZXQgbmV3IHdpbmRvd1dpZHRoXG4gICAgICAgICAgICB3aW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuXG4gICAgICAgICAgICAvLyBoYW5kbGUgY29sbGFwc2luZy9leHBhbmRpbmcgb2YgcmVmaW5lbWVudCBzZWN0aW9ucyBkZXBlbmRpbmcgb24gdmlld3BvcnRcbiAgICAgICAgICAgIGlmICh3aW5kb3dXaWR0aCA8PSBsYXJnZUJyZWFrcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAkKCcucmVmaW5lbWVudC5TaG9wLmJ5LkNhdGVnb3J5LmRpc3BsYXluYW1lJykuYWRkQ2xhc3MoJ2NvbGxhcHNlZCcpLmZpbmQoJ3VsJykuaGlkZSgpO1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3dXaWR0aCA8PSBtZWRpdW1CcmVha3BvaW50IHx8ICEoJCgnI2ZpbHRlcnMtc2VsZWN0ZWQnKS5jaGlsZHJlbigpLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICQoJy5maWx0ZXItY29udGFpbmVyJykuY3NzKCdib3JkZXItdG9wJywgJzAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICQoJy5maWx0ZXItY29udGFpbmVyJykuY3NzKCdib3JkZXItdG9wJywgJzFweCBzb2xpZCAjMDAwJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgJCgnLmZpbHRlci1jb250YWluZXInKS5jc3MoJ2JvcmRlci10b3AnLCAnMXB4IHNvbGlkICMwMDAnKTtcbiAgICAgICAgICAgICAgICAkKCcucmVmaW5lbWVudC5TaG9wLmJ5LkNhdGVnb3J5LmRpc3BsYXluYW1lJykucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNlZCcpLmZpbmQoJ3VsJykuc2hvdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlcyByZW1vdmFsIG9mIHByb2R1Y3QtdGlsZSBoZWlnaHQgZm9yIHJlLXN5bmNocm9uaXphdGlvbiB3aGVuIHJlc2l6aW5nIG9uIGNhdCBicm93c2UgcGFnZVxuICAgICAgICAkKCcuc2VhcmNoLXJlc3VsdC1jb250ZW50IC5wcm9kdWN0LXRpbGUnKS5yZW1vdmVBdHRyKCdzdHlsZScpO1xuICAgICAgICB0aWxlU3luYygpO1xuXG4gICAgICAgIC8vIHNjYWxlcyBkaXZpZGVycyBvbiBjYXRlZ29yeSBsYW5kaW5nIHBhZ2VzIGlmIHRoZXkgZXhpc3QgYW5kIGNhbGxzIGZ1bmN0aW9uIHRvIHNjYWxlIGNvb3JkaW5hdGVzIG9uIG1hcHNcbiAgICAgICAgaWYgKCQoJy5jYXQtbGFuZGluZy1zbG90JykubGVuZ3RoICkge1xuICAgICAgICAgICAgc2NhbGVEaXZpZGVycygpO1xuICAgICAgICAgICAgJCgnbWFwJykuaW1hZ2VNYXBSZXNpemUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNjYWxlcyBpbWFnZXMgb24gcGVyc29uYWxpemF0aW9uIHNob3AgbGFuZGluZyBwYWdlXG4gICAgICAgICQoJy5zbGlkZXItYmVmJykuZmluZCgnaW1nJykuY3NzKCdtYXgtd2lkdGgnLCAkKCcuc2xpZGVyLWFmdCcpLndpZHRoKCkpO1xuICAgICAgICAkKCcuaGFuZGxlLXdyYXBwZXInKS5jc3MoJ2hlaWdodCcsICQoJy5zbGlkZXItYWZ0JykuaGVpZ2h0KCkpO1xuXG4gICAgICAgIGlmICgkKCcuc2xpZGVyLWJlZicpLndpZHRoKCkgPj0gJCgnLkFCLXNsaWRlYmFyJykud2lkdGgoKSkge1xuICAgICAgICAgICAgLy8kKCcuaGFuZGxlLXdyYXBwZXInKS5jc3MoJ2xlZnQnLCAkKCcuQUItc2xpZGViYXInKS53aWR0aCgpKTtcbiAgICAgICAgICAgIHBlcnNvbmFsaXphdGlvblNsaWRlcigpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvL1NlY29uZGFyeSBOYXZpZ2F0aW9uIFRvZ2dsZVxuICAgICRjYWNoZS5tYWluLm9uKCdjbGljaycsICcucmVmaW5lbWVudCAudG9nZ2xlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgJCh0aGlzKS5wYXJlbnRzKCcucmVmaW5lbWVudCcpLnRvZ2dsZUNsYXNzKCdjb2xsYXBzZWQnKS5maW5kKCcjY2F0ZWdvcnktbGV2ZWwtMScpLnRvZ2dsZSgpO1xuICAgICAgICAkKHRoaXMpLnBhcmVudHMoJy5yZWZpbmVtZW50JykuZmluZCgnLmNsZWFyLXJlZmluZW1lbnQnKS50b2dnbGUoKTtcbiAgICB9KTtcblxuICAgIC8vIEZpbHRlciBUb2dnbGVcbiAgICAkbWFpbi5vbignY2xpY2snLCAnLmZpbHRlci10b2dnbGUnLCBmdW5jdGlvbiAoZSl7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcbiAgICAgICAgLy9SZW1vdmUgU29ydCBib3hcbiAgICAgICAgJCgnLnNvcnQtYnktY29udGFpbmVyJykuYWRkQ2xhc3MoJ2hpZGUnKTtcbiAgICAgICAgJCgnLnNvcnQtYm94IC5ib3R0b20tYm9yZGVyLWJveCcpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgJCgnLnNvcnQtYm94IC5ib3R0b20tYm9yZGVyLWJveCAuc29ydC10b2dnbGUnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgIC8vXG4gICAgICAgIGlmICgkdGhpcy5oYXNDbGFzcygnYWN0aXZlJykpe1xuICAgICAgICAgICAgLy9Db2xsYXBzZSBmaWx0ZXIgcGFuZWxcbiAgICAgICAgICAgICR0aGlzLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICR0aGlzLmZpbmQoJy5maWx0ZXItc2hvdycpLnJlbW92ZUNsYXNzKCdoaWRlJyk7XG4gICAgICAgICAgICAkdGhpcy5maW5kKCcuZmlsdGVyLWhpZGUnKS5hZGRDbGFzcygnaGlkZScpO1xuICAgICAgICAgICAgJCgnLmZpbHRlci1jb250ZW50JykuYWRkQ2xhc3MoJ2hpZGUnKTtcbiAgICAgICAgICAgIGlmICgkKCcjZmlsdGVycy1zZWxlY3RlZCcpLmNoaWxkcmVuKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICQoJy5maWx0ZXItY29udGFpbmVyJykuY3NzKCdib3JkZXItYm90dG9tJywgJzFweCBzb2xpZCAjMDAwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJCgnI2ZpbHRlcnMnKS5oYXNDbGFzcygnc3RpY2t5Jykpe1xuICAgICAgICAgICAgICAgICQoJy5maWx0ZXItY29udGFpbmVyJykuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJCgnI2ZpbHRlcnMtc2VsZWN0ZWQnKS5yZW1vdmVDbGFzcygnaGlkZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9TaG93IGZpbHRlciBwYW5lbFxuICAgICAgICAgICAgJHRoaXMuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgJHRoaXMuZmluZCgnLmZpbHRlci1zaG93JykuYWRkQ2xhc3MoJ2hpZGUnKTtcbiAgICAgICAgICAgICR0aGlzLmZpbmQoJy5maWx0ZXItaGlkZScpLnJlbW92ZUNsYXNzKCdoaWRlJyk7XG4gICAgICAgICAgICAkKCcuZmlsdGVyLWNvbnRlbnQnKS5yZW1vdmVDbGFzcygnaGlkZScpO1xuICAgICAgICAgICAgJCgnLmZpbHRlci1jb250YWluZXInKS5jc3MoJ2Rpc3BsYXknLCAnYmxvY2snKTtcbiAgICAgICAgICAgIGlmICgkKCcjZmlsdGVycy1zZWxlY3RlZCcpLmNoaWxkcmVuKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICQoJy5maWx0ZXItY29udGFpbmVyJykuY3NzKCdib3JkZXItYm90dG9tJywgJzFweCBzb2xpZCAjMDAwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkKCcjZmlsdGVycy1zZWxlY3RlZCcpLmFkZENsYXNzKCdoaWRlJyk7XG4gICAgICAgICAgICAkKCcubUN1c3RvbVNjcm9sbGJhcicpLm1DdXN0b21TY3JvbGxiYXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyaWdnZXIgc2Nyb2xsIHRvIHNldCB0aGUgaGVhZGVyXG4gICAgICAgICQod2luZG93KS50cmlnZ2VyKCdzY3JvbGwnKTtcbiAgICB9KTtcblxuICAgIC8vIFNvcnQgVG9nZ2xlXG4gICAgJGNhY2hlLm1haW4ub24oXCJjbGlja1wiLCBcIi5zb3J0LXRvZ2dsZVwiLCBmdW5jdGlvbiAoZSl7XG4gICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAgIC8vUmVtb3ZlIEZpbHRlciBib3hcbiAgICAgICAgdmFyICRmaWx0ZXJUb2dnbGUgPSAkKCcuZmlsdGVycy1iYXIgLmZpbHRlci10b2dnbGUnKTtcbiAgICAgICAgaWYgKCRmaWx0ZXJUb2dnbGUubGVuZ3RoICYmICRmaWx0ZXJUb2dnbGUuaGFzQ2xhc3MoJ2FjdGl2ZScpKSB7XG4gICAgICAgICAgICAkZmlsdGVyVG9nZ2xlLnRyaWdnZXIoJ2NsaWNrJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyokKCcuc29ydC1ib3ggLmJvdHRvbS1ib3JkZXItYm94JykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpOyovXG4gICAgICAgICQoJy5ib3R0b20tYm9yZGVyLWJveC5maWx0ZXIgLmZpbHRlci10b2dnbGUnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgIGlmKCR0aGlzLmhhc0NsYXNzKCdhY3RpdmUnKSl7XG4gICAgICAgICAgICAvL0Nsb3NlIE1lbnVcbiAgICAgICAgICAgICR0aGlzLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICR0aGlzLnBhcmVudCgpLnBhcmVudCgpLnBhcmVudCgpLmZpbmQoJy5zb3J0LWJ5LWNvbnRhaW5lcicpLmFkZENsYXNzKCdoaWRlJyk7XG4gICAgICAgICAgICAkdGhpcy5wYXJlbnQoKS5wYXJlbnQoKS5maW5kKCcuYm90dG9tLWJvcmRlci1ib3guc29ydCcpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAvL1Nob3cgbWVudVxuICAgICAgICAgICAgJHRoaXMuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgJHRoaXMucGFyZW50KCkucGFyZW50KCkucGFyZW50KCkuZmluZCgnLnNvcnQtYnktY29udGFpbmVyJykucmVtb3ZlQ2xhc3MoJ2hpZGUnKTtcbiAgICAgICAgICAgICR0aGlzLnBhcmVudCgpLnBhcmVudCgpLmZpbmQoJy5ib3R0b20tYm9yZGVyLWJveC5zb3J0JykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBDbG9zZSBGaWx0ZXIgYW5kIFNvcnQgb24gY2xpY2tpbmcgb3V0c2lkZSB0aGUgZmlsdGVyc1xuICAgICQoJ2JvZHksIGh0bWwnKS5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgJHRhcmdldCA9ICQoZS50YXJnZXQpO1xuICAgICAgICBpZiAoJHRhcmdldC5jbG9zZXN0KCcuZmlsdGVycy1iYXIgLmZpbHRlci1jb250ZW50JykubGVuZ3RoIHx8XG4gICAgICAgICAgICAkdGFyZ2V0LmNsb3Nlc3QoJy5maWx0ZXJzLWJhciAuZmlsdGVyLXRvZ2dsZScpLmxlbmd0aCB8fFxuICAgICAgICAgICAgJHRhcmdldC5jbG9zZXN0KCcuZmlsdGVycy1iYXIgLnNvcnQtYm94JykubGVuZ3RoIHx8IFxuICAgICAgICAgICAgJHRhcmdldC5jbG9zZXN0KCcuZmlsdGVycy1iYXIgLmNsZWFyLWZpbHRlcnMtdGV4dCcpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xvc2UgRmlsdGVyXG4gICAgICAgIHZhciAkZmlsdGVyVG9nZ2xlID0gJCgnLmZpbHRlcnMtYmFyIC5maWx0ZXItdG9nZ2xlJyk7XG4gICAgICAgIGlmICgkZmlsdGVyVG9nZ2xlLmxlbmd0aCAmJiAkZmlsdGVyVG9nZ2xlLmhhc0NsYXNzKCdhY3RpdmUnKSkge1xuICAgICAgICAgICAgJGZpbHRlclRvZ2dsZS50cmlnZ2VyKCdjbGljaycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xvc2UgU29ydFxuICAgICAgICB2YXIgJHNvcnRUb2dnbGUgPSAkKCcuZmlsdGVycy1iYXIgLnNvcnQtdG9nZ2xlJyk7XG4gICAgICAgIGlmICgkc29ydFRvZ2dsZS5sZW5ndGggJiYgJHNvcnRUb2dnbGUuaGFzQ2xhc3MoJ2FjdGl2ZScpKSB7XG4gICAgICAgICAgICAkc29ydFRvZ2dsZS50cmlnZ2VyKCdjbGljaycpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkY2FjaGUubWFpbi5vbihcImNsaWNrXCIsIFwiLnJlZmluZW1lbnRzLXZpZXctY29udHJvbHNcIiwgZnVuY3Rpb24gKGUpe1xuICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLFxuICAgICAgICAgICAgJHZpZXdNb3JlUmVmaW5lID0gJHRoaXMuZmluZCgnLnJlZmluZW1lbnRzLXZpZXdtb3JlJyksXG4gICAgICAgICAgICAkdmlld0xlc3NSZWZpbmUgPSAkdGhpcy5maW5kKCcucmVmaW5lbWVudHMtdmlld2xlc3MnKSxcbiAgICAgICAgICAgICRzaG93SXRlbXMgPSAkdGhpcy5wYXJlbnQoKS5maW5kKCd1bCcpLmRhdGEoJ3Nob3cnKSxcbiAgICAgICAgXHQkc2hvd0l0ZW1zVGFibGV0ID0gJHRoaXMucGFyZW50KCkuZmluZCgndWwnKS5kYXRhKCdzaG93dGFibGV0Jyk7XG4gICAgICAgIGlmKCR2aWV3TW9yZVJlZmluZS5oYXNDbGFzcygnaGlkZScpKXtcbiAgICAgICAgICAgIC8vQ2xvc2UgTWVudVxuICAgICAgICAgICAgJHZpZXdMZXNzUmVmaW5lLmFkZENsYXNzKCdoaWRlJyk7XG4gICAgICAgICAgICAkdmlld01vcmVSZWZpbmUucmVtb3ZlQ2xhc3MoJ2hpZGUnKTtcbiAgICAgICAgICAgIHZhciAkaXQgPSAxO1xuICAgICAgICAgICAgJHRoaXMucGFyZW50KCkuZmluZCgnLnJlZmluZW1lbnQtbGlzdCBsaScpLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBpZigkaXQgPiAkc2hvd0l0ZW1zKXtcbiAgICAgICAgICAgICAgICAgICAgJCggdGhpcyApLmFkZENsYXNzKCdoaWRlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRpdCsrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgLy9TaG93IG1lbnVcbiAgICAgICAgICAgICR2aWV3TGVzc1JlZmluZS5yZW1vdmVDbGFzcygnaGlkZScpO1xuICAgICAgICAgICAgJHZpZXdNb3JlUmVmaW5lLmFkZENsYXNzKCdoaWRlJyk7XG4gICAgICAgICAgICAkdGhpcy5wYXJlbnQoKS5maW5kKCdsaS5oaWRlJykuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICQoIHRoaXMgKS5yZW1vdmVDbGFzcygnaGlkZScpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoJHZpZXdNb3JlUmVmaW5lLmhhc0NsYXNzKCdoaWRlVGFibGV0Jykpe1xuICAgICAgICAgICAgLy9DbG9zZSBNZW51XG4gICAgICAgICAgICAkdmlld0xlc3NSZWZpbmUuYWRkQ2xhc3MoJ2hpZGVUYWJsZXQnKTtcbiAgICAgICAgICAgICR2aWV3TW9yZVJlZmluZS5yZW1vdmVDbGFzcygnaGlkZVRhYmxldCcpO1xuICAgICAgICAgICAgdmFyICRpdCA9IDE7XG4gICAgICAgICAgICAkdGhpcy5wYXJlbnQoKS5maW5kKCcucmVmaW5lbWVudC1saXN0IGxpJykuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIGlmKCRpdCA+ICRzaG93SXRlbXNUYWJsZXQpe1xuICAgICAgICAgICAgICAgICAgICAkKCB0aGlzICkuYWRkQ2xhc3MoJ2hpZGVUYWJsZXQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJGl0Kys7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAvL1Nob3cgbWVudVxuICAgICAgICAgICAgJHZpZXdMZXNzUmVmaW5lLnJlbW92ZUNsYXNzKCdoaWRlVGFibGV0Jyk7XG4gICAgICAgICAgICAkdmlld01vcmVSZWZpbmUuYWRkQ2xhc3MoJ2hpZGVUYWJsZXQnKTtcbiAgICAgICAgICAgICR0aGlzLnBhcmVudCgpLmZpbmQoJ2xpLmhpZGVUYWJsZXQnKS5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgJCggdGhpcyApLnJlbW92ZUNsYXNzKCdoaWRlVGFibGV0Jyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gaGFuZGxlIHRvZ2dsZSByZWZpbmVtZW50IGJsb2Nrc1xuICAgICRjYWNoZS5tYWluLm9uKFwiY2xpY2tcIiwgXCIucmVmaW5lbWVudC13cmFwcGVyIGEsIC5wYWdpbmF0aW9uIGEsIC5icmVhZGNydW1iLXJlZmluZW1lbnQtdmFsdWUgYVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZigkKHRoaXMpLnBhcmVudCgpLmhhc0NsYXNzKFwidW5zZWxlY3RhYmxlXCIpKSB7IHJldHVybjsgfVxuICAgICAgICB2YXIgY2F0cGFyZW50ID0gJCh0aGlzKS5wYXJlbnRzKCcuY2F0ZWdvcnktcmVmaW5lbWVudCcpO1xuICAgICAgICBpZihjYXRwYXJlbnQubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciB1cmkgPSB1dGlsLmdldFVyaSh0aGlzKTtcblxuICAgICAgICBpZigkKHRoaXMpLmNsb3Nlc3QoJy5yZWZpbmVtZW50LkNhdGVnb3J5JykubGVuZ3RoID4gMCB8fCB1cmkuaGFzaC5zdWJzdHJpbmcoMSkgPT0gJycpIHtcbiAgICAgICAgICAgIC8vIEZvciB3aGVuIGEgY2F0ZWdvcnkgcmVmaW5lbWVudCBpcyBjbGlja2VkIG9yIHdoZW4gYSBjb2xvci9zaXplL2V0Yy4gcmVmaW5lbWVudCBpcyBjbGVhcmVkXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGVuY29kZVVSSShkZWNvZGVVUklDb21wb25lbnQodGhpcy5ocmVmKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3Igd2hlbiBhIGNvbG9yL3NpemUvZXRjLiByZWZpbmVtZW50IGlzIGNsaWNrZWRcbiAgICAgICAgICAgIHNldFJlZmluZW1lbnRDb29raWVzKCk7XG4gICAgICAgICAgICB2YXIgcmVmaW5lVXJsID0gdXJpLmhhc2guc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBlbmNvZGVVUkkoZGVjb2RlVVJJQ29tcG9uZW50KHJlZmluZVVybCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcblxuICAgICRjYWNoZS5tYWluLm9uKCdjbGljaycsICcuZ2MtY2hlY2stYmFsYW5jZS1oZWFkZXInLCBmdW5jdGlvbiAoZSkge1xuICAgIFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIFx0JCh0aGlzKS50b2dnbGVDbGFzcygnZXhwYW5kZWQnKTtcbiAgICB9KTtcbiAgICAvL1N1YiBUb2dnbGVcbiAgICAkY2FjaGUubWFpbi5vbihcImNsaWNrXCIsIFwiLmV4cGFuZGFibGUgLnN1Yi10b2dnbGVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpO1xuICAgICAgICB2YXIgbWluaUxpc3QgPSAkdGhpcy5wYXJlbnQoKS5uZXh0KCk7XG4gICAgICAgIGlmKG1pbmlMaXN0Lmxlbmd0aCA+IDAgJiYgKG1pbmlMaXN0LmNzcygnZGlzcGxheScpID09ICdub25lJykpe1xuICAgICAgICAgICAgbWluaUxpc3QuY3NzKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuICAgICAgICAgICAgJHRoaXMuZmluZChcIi5wbHVzX21pbnVzXCIpLmh0bWwoXCImIzgyMTE7XCIpO1xuICAgICAgICAgICAgaWYoJHRoaXMucGFyZW50KCkuaGFzQ2xhc3MoXCJjbGljay1jb2xsYXBzZWRcIikpe1xuICAgICAgICAgICAgICAgICR0aGlzLnBhcmVudCgpLnJlbW92ZUNsYXNzKFwiY2xpY2stY29sbGFwc2VkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoISR0aGlzLnBhcmVudCgpLmhhc0NsYXNzKFwiY2xpY2stZXhwYW5kZWRcIikpe1xuICAgICAgICAgICAgICAgICR0aGlzLnBhcmVudCgpLmFkZENsYXNzKFwiY2xpY2stZXhwYW5kZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgbWluaUxpc3QuY3NzKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG4gICAgICAgICAgICAkdGhpcy5maW5kKFwiLnBsdXNfbWludXNcIikuaHRtbChcIitcIik7XG4gICAgICAgICAgICBpZighJHRoaXMucGFyZW50KCkuaGFzQ2xhc3MoXCJjbGljay1jb2xsYXBzZWRcIikpe1xuICAgICAgICAgICAgICAgICR0aGlzLnBhcmVudCgpLmFkZENsYXNzKFwiY2xpY2stY29sbGFwc2VkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoJHRoaXMucGFyZW50KCkuaGFzQ2xhc3MoXCJjbGljay1leHBhbmRlZFwiKSl7XG4gICAgICAgICAgICAgICAgJHRoaXMucGFyZW50KCkucmVtb3ZlQ2xhc3MoXCJjbGljay1leHBhbmRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICQodGhpcykudG9nZ2xlQ2xhc3MoJ2V4cGFuZGVkJyk7XG5cbiAgICB9KTtcbiAgICBzdWJUb2dnbGVJbml0KCk7XG5cbiAgICAvL1NvcnQgRHJvcCBkb3duXG4gICAgJGNhY2hlLm1haW4ub24oXCJjbGlja1wiLCBcIi5zb3J0LWJ5LWxpc3QgLnNvcnQtaXRlbVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpO1xuICAgICAgICB2YXIgY3VycmVudEhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaDtcbiAgICAgICAgdmFyIG5ld1NvcnRVcmwgPSB1dGlsLmdldFVyaSgkdGhpcy5kYXRhKFwidXJsXCIpKTsgXG4gICAgICAgICAgICAvLyBJZiBuZXdTb3J0VXJsIGNvbnRhaW5zIGhhc2hcbiAgICAgICAgaWYobmV3U29ydFVybC5oYXNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXBlcmF0ZSB0aGUgaGFzaCBwYXJhbXNcbiAgICAgICAgICAgIHZhciBoYXNoTG9vcCA9IG5ld1NvcnRVcmwuaGFzaC5zdWJzdHIoMSkuc3BsaXQoXCImXCIpO1xuICAgICAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBoYXNoIHBhcmFtc1xuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGkgPD0gaGFzaExvb3AubGVuZ3RoLTE7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNwbGl0IGhhc2ggcGFyYW0gXG4gICAgICAgICAgICAgICAgdmFyIHFzVmFsID0gaGFzaExvb3BbaV0uc3BsaXQoJz0nKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgcXMgaXMgaW4gY3VycmVudCBxdWVyeSBzdHJpbmdcbiAgICAgICAgICAgICAgICBpZihjdXJyZW50SGFzaC5pbmRleE9mKHFzVmFsWzBdKSAhPT0gLTEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSB2YWx1ZSBpbiBxdWVyeXN0cmluZyB3aXRoIG5ldyBzb3J0IHBhcmFtXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAocXNWYWxbMF0gKyc9W15cXCZdKycsICdnJyk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRIYXNoID0gY3VycmVudEhhc2gucmVwbGFjZShyZWdleCwgaGFzaExvb3BbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgYWRkIHNvcnQgcXVlcnlzdHJpbmcgcGFyYW0gdG8gaGFzaFxuICAgICAgICAgICAgICAgICAgICAgY3VycmVudEhhc2ggKz0gXCImXCIraGFzaExvb3BbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBjdXJyZW50SGFzaFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBuZXdTb3J0VXJsO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYoJChcIi5zb3J0LWJ5LWxpc3QgLnNvcnQtaXRlbS5zb3J0ZWQtYnlcIikubGVuZ3RoID4gMCl7XG4gICAgICAgIHZhciBzZWxlY3RlZFRleHQgPSAkKFwiLnNvcnQtYnktbGlzdCAuc29ydGVkLWJ5IHNwYW5cIikuaHRtbCgpO1xuICAgICAgICAkKFwiLmZpbHRlci1idXR0b25zIC5zb3J0LXRvZ2dsZSBzcGFuLnNvcnQtYnktdGV4dFwiKS5odG1sKHNlbGVjdGVkVGV4dCk7XG4gICAgfVxuXG4gICAgLy9VcGRhdGluZyBHcmlkIGZvciBGYXZvcml0ZXNcbiAgICAkKFwiI3BkcE1haW4sICNwZHBRdWlja1wiKS5vbihcImNsaWNrXCIsIFwiLmZhdm91cml0ZXMtdG9nZ2xlIGEsIC5mYXZvcml0ZXMtbm8tc2Vzc2lvblwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgdmFyIHVyaSA9IHV0aWwuZ2V0VXJpKHRoaXMpO1xuICAgICAgICB2YXIgcmVmaW5lVXJsID0gdXJpLmhhc2gubGVuZ3RoID4gMSA/IHVyaS5oYXNoLnN1YnN0cigxKSA6IFwiXCI7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gcmVmaW5lVXJsO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICAkY2FjaGUubWFpbi5vbihcImNsaWNrXCIsIFwiYS5yZWZpbmVtZW50LWxpbmtcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgdXJpID0gdXRpbC5nZXRVcmkoJCh0aGlzKS5hdHRyKCdkYXRhLWhyZWZsaW5rJykpO1xuICAgICAgICB2YXIgcmVmaW5lVXJsID0gdXJpLmhhc2gubGVuZ3RoID4gMSA/IHVyaS5oYXNoLnN1YnN0cigxKSA6IFwiXCI7XG4gICAgICAgIGlmIChyZWZpbmVVcmwgIT0gJycpe1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSByZWZpbmVVcmw7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSAkKHRoaXMpLmF0dHIoJ2RhdGEtaHJlZmxpbmsnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICAvLyBoYW5kbGUgZXZlbnRzIGl0ZW0gY2xpY2suIGFwcGVuZCBwYXJhbXMuXG4gICAgJGNhY2hlLm1haW4ub24oXCJjbGlja1wiLCBcIiNzZWFyY2gtcmVzdWx0LWl0ZW1zIC5wcm9kdWN0LXRpbGUgYS50aHVtYi1saW5rLCAjc2VhcmNoLXJlc3VsdC1pdGVtcyAucHJvZHVjdC10aWxlIGEubmFtZS1saW5rXCIsIGZ1bmN0aW9uIChlKSB7XG5cbiAgICAgICAgdmFyIGEgPSAkKHRoaXMpO1xuICAgICAgICAvLyBnZXQgY3VycmVudCBwYWdlIHJlZmluZW1lbnQgdmFsdWVzXG4gICAgICAgIHZhciB3bCA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICAgICAgdmFyIHFzUGFyYW1zID0gKHdsLnNlYXJjaC5sZW5ndGggPiAxKSA/IHV0aWwuZ2V0UXVlcnlTdHJpbmdQYXJhbXMod2wuc2VhcmNoLnN1YnN0cigxKSkgOiB7fTtcbiAgICAgICAgdmFyIGhhc2hQYXJhbXMgPSAod2wuaGFzaC5sZW5ndGggPiAxKSA/IHV0aWwuZ2V0UXVlcnlTdHJpbmdQYXJhbXMod2wuaGFzaC5zdWJzdHIoMSkpIDoge307XG4gICAgICAgIC8vIG1lcmdlIGhhc2ggcGFyYW1zIHdpdGggcXVlcnlzdHJpbmcgcGFyYW1zXG4gICAgICAgIHZhciBwYXJhbXMgPSAkLmV4dGVuZChoYXNoUGFyYW1zLCBxc1BhcmFtcyk7XG4gICAgICAgIGlmICghcGFyYW1zLnN0YXJ0KSB7XG4gICAgICAgICAgICBwYXJhbXMuc3RhcnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCB0aGUgaW5kZXggb2YgdGhlIHNlbGVjdGVkIGl0ZW0gYW5kIHNhdmUgYXMgc3RhcnQgcGFyYW1ldGVyXG4gICAgICAgIHZhciB0aWxlID0gYS5jbG9zZXN0KFwiLnByb2R1Y3QtdGlsZVwiKTtcbiAgICAgICAgdmFyIGlkeCA9IHRpbGUuZGF0YShcImlkeFwiKSA/ICt0aWxlLmRhdGEoXCJpZHhcIikgOiAwO1xuICAgICAgICAvLyBjb252ZXJ0IHBhcmFtcy5zdGFydCB0byBpbnRlZ2VyIGFuZCBhZGQgaW5kZXhcbiAgICAgICAgcGFyYW1zLnN0YXJ0PSgrcGFyYW1zLnN0YXJ0KSsoaWR4KzEpO1xuICAgICAgICB2YXIgY2dpZCA9IHRpbGUuZGF0YShcImNnaWRcIikgPyB0aWxlLmRhdGEoXCJjZ2lkXCIpIDogJyc7XG4gICAgICAgIGlmKGNnaWQgIT0gJycpe1xuICAgICAgICAgICAgcGFyYW1zLmNnaWQ9Y2dpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHR5cGVvZiBrYXRlc3BhZGUgIT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICAgICAgLy8gb25seSBpbmNsdWRlIGhhc2ggZm9yIEthdGVTcGFkZVxuICAgICAgICAgICAgYVswXS5oYXNoID0gJC5wYXJhbShwYXJhbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXNlIHRoZSBmdWxsIHVybFxuICAgICAgICB2YXIgZnVsbFVybCA9IGEuYXR0cignZGF0YS1mdWxsLXVybCcpO1xuICAgICAgICBpZihmdWxsVXJsKXtcbiAgICAgICAgICAgIGZ1bGxVcmwgKz0gYVswXS5oYXNoO1xuICAgICAgICAgICAgYS5hdHRyKCdkYXRhLWZ1bGwtdXJsJywgZnVsbFVybCk7XG4gICAgICAgICAgICBpZigkLmJyb3dzZXIubXNpZSAmJiAkLmJyb3dzZXIudmVyc2lvbiA8IDEwKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uID0gZnVsbFVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIGhhbmRsZSBzb3J0aW5nIGNoYW5nZSAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAkY2FjaGUubWFpbi5vbihcImNoYW5nZVwiLCBcIi5zb3J0LWJ5IHNlbGVjdFwiLCBmdW5jdGlvbiAoZSkge1xuXG4gICAgICAgIHZhciByZWZpbmVVcmwgPSAkKHRoaXMpLmZpbmQoJ29wdGlvbjpzZWxlY3RlZCcpLnZhbCgpO1xuICAgICAgICB2YXIgdXJpID0gdXRpbC5nZXRVcmkocmVmaW5lVXJsKTtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSB1cmkucXVlcnkuc3Vic3RyKDEpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSlcbiAgICAub24oXCJjaGFuZ2VcIiwgXCIuaXRlbXMtcGVyLXBhZ2Ugc2VsZWN0XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciByZWZpbmVVcmwgPSAkKHRoaXMpLmZpbmQoJ29wdGlvbjpzZWxlY3RlZCcpLnZhbCgpO1xuICAgICAgICB2YXIgdXJpID0gdXRpbC5nZXRVcmkocmVmaW5lVXJsKTtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSB1cmkucXVlcnkuc3Vic3RyKDEpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgLy8gaGFuZGxlIGhhc2ggY2hhbmdlXG4gICAgJCh3aW5kb3cpLm9uKCdoYXNoY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHVwZGF0ZVByb2R1Y3RMaXN0aW5nKHRydWUpO1xuICAgIH0pO1xuXG4gICAgLy8gcHJvZHVjdCBncmlkIHN3YXRjaGVzXG4gICAgalF1ZXJ5KFwiLnByb2R1Y3Qtc3dhdGNoZXMgYS5tb3JlXCIpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCl7XG4gICAgICAgIC8valF1ZXJ5KHRoaXMpLnBhcmVudCgpLmZpbmQoJy5oaWRkZW4tc3dhdGNoJykuc2xpZGVUb2dnbGUoKTtcbiAgICAgICAgalF1ZXJ5KHRoaXMpLmNsb3Nlc3QoJy5wcm9kdWN0LXN3YXRjaGVzJylcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzaG93YWxsJyk7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH0pO1xuICAgIGpRdWVyeSgnLnByb2R1Y3Qtc3dhdGNoZXMgaW1nLmNsb3NlLXN3YXRjaGVzLXBhbmUnKS5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgalF1ZXJ5KHRoaXMpLmNsb3Nlc3QoJy5wcm9kdWN0LXN3YXRjaGVzJylcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdzaG93YWxsJyk7XG4gICAgfSk7XG5cblxuXG4gICAgLy8gUHJvZHVjdCBUaWxlIC0gc2hvdyBtb3JlIHN3YXRjaGVzXG4gICAgc2hvd01vcmVTd2F0Y2hlcygpO1xuXG5cbiAgICAvLyBoYW5kbGUgZXZlbnRzIGZvciB1cGRhdGluZyBncmlkXG4gICAgJG1haW4ub24oJ2NsaWNrJywgJy5yZWZpbmVtZW50cyBhLCAucGFnaW5hdGlvbiBhLCAuYnJlYWRjcnVtYi1yZWZpbmVtZW50LXZhbHVlIGEsIC5maWx0ZXItY2xlYXItYWxsIC5jbGVhci1maWx0ZXJzLXRleHQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyBkb24ndCBpbnRlcmNlcHQgZm9yIGNhdGVnb3J5IGFuZCBmb2xkZXIgcmVmaW5lbWVudHMsIGFzIHdlbGwgYXMgdW5zZWxlY3RhYmxlXG4gICAgICAgIGlmICgkKHRoaXMpLnBhcmVudHMoJy5jYXRlZ29yeS1yZWZpbmVtZW50JykubGVuZ3RoID4gMCB8fCAkKHRoaXMpLnBhcmVudHMoJy5mb2xkZXItcmVmaW5lbWVudCcpLmxlbmd0aCA+IDAgfHwgJCh0aGlzKS5wYXJlbnQoKS5oYXNDbGFzcygndW5zZWxlY3RhYmxlJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvL1JlbW92ZSBVUkwgaGFzaCBpZiB1c2VyIGNsaWNrcyBvbiBjbGVhciBhbGwgZmlsdGVyc1xuICAgICAgICBpZiAoJCh0aGlzKS5oYXNDbGFzcygnY2xlYXItZmlsdGVycy10ZXh0JykpIHtcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSh7fSwgd2luZG93LmRvY3VtZW50LnRpdGxlLCB0aGlzLmhyZWYpO1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHVwZGF0ZVByb2R1Y3RMaXN0aW5nKHRoaXMuaHJlZik7XG4gICAgfSk7XG5cbiAgICAvLyBoYW5kbGUgZXZlbnRzIGl0ZW0gY2xpY2suIGFwcGVuZCBwYXJhbXMuXG4gICAgJG1haW4ub24oJ2NsaWNrJywgJy5wcm9kdWN0LXRpbGUgYTpub3QoXCIjcXVpY2t2aWV3YnV0dG9uXCIpJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9ICQodGhpcyk7XG4gICAgICAgIC8vIGdldCBjdXJyZW50IHBhZ2UgcmVmaW5lbWVudCB2YWx1ZXNcbiAgICAgICAgdmFyIHdsID0gd2luZG93LmxvY2F0aW9uO1xuXG4gICAgICAgIHZhciBxc1BhcmFtcyA9ICh3bC5zZWFyY2gubGVuZ3RoID4gMSkgPyB1dGlsLmdldFF1ZXJ5U3RyaW5nUGFyYW1zKHdsLnNlYXJjaC5zdWJzdHIoMSkpIDoge307XG4gICAgICAgIHZhciBoYXNoUGFyYW1zID0gKHdsLmhhc2gubGVuZ3RoID4gMSkgPyB1dGlsLmdldFF1ZXJ5U3RyaW5nUGFyYW1zKHdsLmhhc2guc3Vic3RyKDEpKSA6IHt9O1xuXG4gICAgICAgIC8vIG1lcmdlIGhhc2ggcGFyYW1zIHdpdGggcXVlcnlzdHJpbmcgcGFyYW1zXG4gICAgICAgIHZhciBwYXJhbXMgPSAkLmV4dGVuZChoYXNoUGFyYW1zLCBxc1BhcmFtcyk7XG4gICAgICAgIGlmICghcGFyYW1zLnN0YXJ0KSB7XG4gICAgICAgICAgICBwYXJhbXMuc3RhcnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCB0aGUgaW5kZXggb2YgdGhlIHNlbGVjdGVkIGl0ZW0gYW5kIHNhdmUgYXMgc3RhcnQgcGFyYW1ldGVyXG4gICAgICAgIHZhciB0aWxlID0gYS5jbG9zZXN0KCcucHJvZHVjdC10aWxlJyk7XG4gICAgICAgIHZhciBpZHggPSB0aWxlLmRhdGEoJ2lkeCcpID8gKyB0aWxlLmRhdGEoJ2lkeCcpIDogMDtcblxuICAgICAgICAvLyBjb252ZXJ0IHBhcmFtcy5zdGFydCB0byBpbnRlZ2VyIGFuZCBhZGQgaW5kZXhcbiAgICAgICAgcGFyYW1zLnN0YXJ0ID0gKCtwYXJhbXMuc3RhcnQpICsgKGlkeCArIDEpO1xuICAgICAgICAvLyBzZXQgdGhlIGhhc2ggYW5kIGFsbG93IG5vcm1hbCBhY3Rpb24gdG8gY29udGludWVcbiAgICAgICAgYVswXS5oYXNoID0gJC5wYXJhbShwYXJhbXMpO1xuICAgIH0pO1xuXG4gICAgLy8gaGFuZGxlIHNvcnRpbmcgY2hhbmdlXG4gICAgJG1haW4ub24oJ2NoYW5nZScsICcuc29ydC1ieSBzZWxlY3QnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHVwZGF0ZVByb2R1Y3RMaXN0aW5nKCQodGhpcykuZmluZCgnb3B0aW9uOnNlbGVjdGVkJykudmFsKCkpO1xuICAgIH0pXG4gICAgLm9uKCdjaGFuZ2UnLCAnLml0ZW1zLXBlci1wYWdlIHNlbGVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlZmluZVVybCA9ICQodGhpcykuZmluZCgnb3B0aW9uOnNlbGVjdGVkJykudmFsKCk7XG4gICAgICAgIGlmIChyZWZpbmVVcmwgPT09ICdJTkZJTklURV9TQ1JPTEwnKSB7XG4gICAgICAgICAgICAkKCdodG1sJykuYWRkQ2xhc3MoJ2luZmluaXRlLXNjcm9sbCcpLnJlbW92ZUNsYXNzKCdkaXNhYmxlLWluZmluaXRlLXNjcm9sbCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJCgnaHRtbCcpLmFkZENsYXNzKCdkaXNhYmxlLWluZmluaXRlLXNjcm9sbCcpLnJlbW92ZUNsYXNzKCdpbmZpbml0ZS1zY3JvbGwnKTtcbiAgICAgICAgICAgIHVwZGF0ZVByb2R1Y3RMaXN0aW5nKHJlZmluZVVybCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciAkcHJvZHVjdFRpbGVzID0gJCgnLnRpbGVzLWNvbnRhaW5lciAucHJvZHVjdC10aWxlJyk7XG4gICAgdmFyICRncmlkVGlsZXMgPSAkKCcudGlsZXMtY29udGFpbmVyIC5ncmlkLXRpbGUnKTtcbiAgICBpZiAoJHByb2R1Y3RUaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGltYWdlc0xvYWRlZCgnLnRpbGVzLWNvbnRhaW5lcicpLm9uKCdhbHdheXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBTeW5jaHJvbml6ZSBoZWlnaHQgb2YgcHJvZHVjdCB0aWxlc1xuICAgICAgICAgICAgJHByb2R1Y3RUaWxlcy5zeW5jSGVpZ2h0KClcbiAgICAgICAgICAgICAgICAuZWFjaChmdW5jdGlvbihpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5kYXRhKCdpZHgnLCBpZHgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vL3B1c2ggcHJvZHVjdCB0aWxlIGNsaWNrIHRvIGRhdGFMYXllclxuJChcIi5wcm9kdWN0LXRpbGVcIikuY2xpY2soZnVuY3Rpb24oKXtcblx0dmFyIHByb2R1Y3RJRCA9ICQudHJpbSgkKHRoaXMpLmF0dHIoJ2RhdGEtaXRlbWlkJykpO1xuXHRpZiAoZGF0YUxheWVyKSB7XG5cdFx0dmFyIGVjb21tZXJjZSA9IG51bGw7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhTGF5ZXIubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICgnZWNvbW1lcmNlJyBpbiBkYXRhTGF5ZXJbaV0pIHtcblx0XHRcdFx0dmFyIGVjb21tZXJjZSA9IGRhdGFMYXllcltpXS5lY29tbWVyY2U7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoZWNvbW1lcmNlICE9IHVuZGVmaW5lZCAmJiAnaW1wcmVzc2lvbnMnIGluIGVjb21tZXJjZSkge1xuXHRcdFx0dmFyIHA7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVjb21tZXJjZS5pbXByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRwID0gZWNvbW1lcmNlLmltcHJlc3Npb25zW2ldO1xuXHRcdFx0XHRpZiAocC5pZCA9PSBwcm9kdWN0SUQpe1xuXHRcdFx0XHRcdGRhdGFMYXllci5wdXNoKGFwcC5kYXRhbGF5ZXIuZ2V0RXZlbnQoXCJldmVudFwiLCBcImVjb21Qcm9kdWN0SW1wcmVzc2lvbkNsaWNrXCIsIFwiZWNvbW1lcmNlXCIsIFwiIFwiLCBcImNsaWNrXCIsIHAsIHAuY2F0ZWdvcnkpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbmZ1bmN0aW9uIGFkZEJhY2tncm91bmRDb3ZlcigpIHtcblx0JCgnLnRvcC1iYW5uZXInKS5iZWZvcmUoXCI8ZGl2IGlkPSdiYWNrZ3JvdW5kLWNvdmVyJz48L2Rpdj5cIik7XG59XG5cbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoU2l0ZVByZWZlcmVuY2VzLkxJU1RJTkdfSU5GSU5JVEVfU0NST0xMKSB7XG4gICAgICAgICQod2luZG93KS5vbignc2Nyb2xsJywgaW5maW5pdGVTY3JvbGwpO1xuICAgIH1cbiAgICAkY2FjaGUgPSB7XG4gICAgICAgIG1haW4gOiAkKFwiI21haW5cIiksXG4gICAgICAgIGl0ZW1zIDogJChcIiNzZWFyY2gtcmVzdWx0LWl0ZW1zXCIpXG4gICAgfTtcbiAgICAkY2FjaGUuY29udGVudCA9ICRjYWNoZS5tYWluLmZpbmQoXCIuc2VhcmNoLXJlc3VsdC1jb250ZW50XCIpO1xuICAgIGNvbXBhcmVXaWRnZXQuaW5pdCgpO1xuICAgIGlmIChTaXRlUHJlZmVyZW5jZXMuTElTVElOR19JTkZJTklURV9TQ1JPTEwpIHtcbiAgICAgICAgJCh3aW5kb3cpLm9uKCdzY3JvbGwnLCBpbmZpbml0ZVNjcm9sbCk7XG4gICAgfVxuICAgIHVwZGF0ZVByb2R1Y3RMaXN0aW5nKGZhbHNlKTtcbiAgICBwcm9kdWN0VGlsZS5pbml0KCk7XG4gICAgaW5pdGlhbGl6ZUV2ZW50cygpO1xuICAgIHRpbGVTeW5jKCk7XG4gICAgb2FzVGlsZXMoKTtcbiAgICBzbWFydFJlc2l6ZShvYXNUaWxlcyk7XG4gICAgJCgnbWFwJykuaW1hZ2VNYXBSZXNpemUoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgJCgnI2hvbWVwYWdlLXNsaWRlcicpXG4gICAgICAgIC8vIHJlc3BvbnNpdmUgc2xpZGVzXG4gICAgICAgIC5vbignamNhcm91c2VsOmNyZWF0ZSBqY2Fyb3VzZWw6cmVsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSAkKHRoaXMpLFxuICAgICAgICAgICAgICAgIHdpZHRoID0gZWxlbWVudC5pbm5lcldpZHRoKCk7XG4gICAgICAgICAgICBlbGVtZW50LmpjYXJvdXNlbCgnaXRlbXMnKS5jc3MoJ3dpZHRoJywgd2lkdGggKyAncHgnKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmpjYXJvdXNlbCh7XG4gICAgICAgICAgICB3cmFwOiAnY2lyY3VsYXInXG4gICAgICAgIH0pXG4gICAgICAgIC5qY2Fyb3VzZWxBdXRvc2Nyb2xsKHtcbiAgICAgICAgICAgIGludGVydmFsOiA1MDAwXG4gICAgICAgIH0pO1xuICAgICQoJyNob21lcGFnZS1zbGlkZXIgLmpjYXJvdXNlbC1jb250cm9sJylcbiAgICAgICAgLm9uKCdqY2Fyb3VzZWxwYWdpbmF0aW9uOmFjdGl2ZScsICdhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignamNhcm91c2VscGFnaW5hdGlvbjppbmFjdGl2ZScsICdhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5qY2Fyb3VzZWxQYWdpbmF0aW9uKHtcbiAgICAgICAgICAgIGl0ZW06IGZ1bmN0aW9uIChwYWdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICc8YSBocmVmPVwiIycgKyBwYWdlICsgJ1wiPicgKyBwYWdlICsgJzwvYT4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICQoJyN2ZXJ0aWNhbC1jYXJvdXNlbCcpXG4gICAgICAgIC5qY2Fyb3VzZWwoe1xuICAgICAgICAgICAgdmVydGljYWw6IHRydWVcbiAgICAgICAgfSlcbiAgICAgICAgLmpjYXJvdXNlbEF1dG9zY3JvbGwoe1xuICAgICAgICAgICAgaW50ZXJ2YWw6IDUwMDBcbiAgICAgICAgfSk7XG4gICAgJCgnI3ZlcnRpY2FsLWNhcm91c2VsIC5qY2Fyb3VzZWwtcHJldicpXG4gICAgICAgIC5vbignamNhcm91c2VsY29udHJvbDphY3RpdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkKHRoaXMpLnJlbW92ZUNsYXNzKCdpbmFjdGl2ZScpO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2pjYXJvdXNlbGNvbnRyb2w6aW5hY3RpdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKCdpbmFjdGl2ZScpO1xuICAgICAgICB9KVxuICAgICAgICAuamNhcm91c2VsQ29udHJvbCh7XG4gICAgICAgICAgICB0YXJnZXQ6ICctPTEnXG4gICAgICAgIH0pO1xuXG4gICAgJCgnI3ZlcnRpY2FsLWNhcm91c2VsIC5qY2Fyb3VzZWwtbmV4dCcpXG4gICAgICAgIC5vbignamNhcm91c2VsY29udHJvbDphY3RpdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkKHRoaXMpLnJlbW92ZUNsYXNzKCdpbmFjdGl2ZScpO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2pjYXJvdXNlbGNvbnRyb2w6aW5hY3RpdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKCdpbmFjdGl2ZScpO1xuICAgICAgICB9KVxuICAgICAgICAuamNhcm91c2VsQ29udHJvbCh7XG4gICAgICAgICAgICB0YXJnZXQ6ICcrPTEnXG4gICAgICAgIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBkaWFsb2cgPSByZXF1aXJlKCcuLi9kaWFsb2cnKSxcbiAgICBzZWxlY3RCb3hJdCA9IHJlcXVpcmUoJy4uL3NlbGVjdGJveGl0Jyk7XG5cbi8vU0dcbi8vICQoJy5zdG9yZS1kZXRhaWxzLWxpbmsnKS5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuLy8gICAgIGUucHJldmVudERlZmF1bHQoKTtcbi8vICAgICBkaWFsb2cub3Blbih7XG4vLyAgICAgICAgIHVybDogJChlLnRhcmdldCkuYXR0cignaHJlZicpXG4vLyAgICAgfSk7XG4vLyB9KTtcblxuLy8gU3RvcmUgZG9tIGNvbGxlY3Rpb25zXG52YXIgJGNhY2hlID0ge307XG4vLyBDcmVhdGUgdGhlIHRvb2x0aXAgYW5kIGl0cyB0ZXh0XG52YXIgaW5mb1dpbmRvdztcblxuLy8gQ3JlYXRlIHRoZSBsYXJnZSBtYXAgdGhhdCBpcyBvbiB0aGUgZmluZCBhbmQgcmVzdWx0cyBwYWdlXG5mdW5jdGlvbiBsYXJnZU1hcCgpe1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgZ29vZ2xlIGFwaSBoYXMgbG9hZGVkXG4gICAgaWYodHlwZW9mIGdvb2dsZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcbiAgICAvLyBDYWxsIHRvIGdvb2dsZVxuICAgIGluZm9XaW5kb3cgPSBuZXcgZ29vZ2xlLm1hcHMuSW5mb1dpbmRvdygpO1xuICAgIC8vIENlbnRlciBvZiBVU0EgLSB7bGF0IDogMzcuMDkwMjQwLCBsbmcgOiAtOTUuNzEyODkxfTtcbiAgICAkY2FjaGUuZGVmYXVsdENlbnRlciA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmcoMzcuMDkwMjQwLCAtOTUuNzEyODkxKTtcblxuICAgIC8vIExvYWQgbWFwIHdpdGggdGhlIHVzZXJMb2NhdGlvblxuICAgICRjYWNoZS5tYXBMYXJnZSA9IG5ldyBnb29nbGUubWFwcy5NYXAoICQoJy53aWRlLW1hcCcpWzBdLCB7XG4gICAgICAgIGNlbnRlciA6ICRjYWNoZS5kZWZhdWx0Q2VudGVyLFxuICAgICAgICBtYXBUeXBlSWQgOiBnb29nbGUubWFwcy5NYXBUeXBlSWQuUk9BRE1BUCxcbiAgICAgICAgem9vbSA6IDgsXG4gICAgICAgIG1pblpvb20gOiAyLFxuICAgICAgICBzdHJlZXRWaWV3Q29udHJvbCA6IGZhbHNlfSk7XG5cbiAgICAkY2FjaGUuYm91bmRzTGFyZ2UgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzKCk7XG4gICAgLy8gVGVzdCB0byBzZWUgaWYgd2UgaGF2ZSBhIGxpc3Qgb2Ygc3RvcmVzIGFuZCBpZiBzbywgYWRkIG1hcmtlcnNcblxuICAgIHZhciBwb3N0YWxDb2RlID0gJCgnaW5wdXRbbmFtZT1cInBvc3RhbENvZGVcIl0nKTtcblxuICAgIGlmICgkY2FjaGUuc3RvcmVzLmxlbmd0aCkge1xuICAgICAgICBhZGRNYXJrZXJzKCk7XG4gICAgfSBlbHNlIGlmIChwb3N0YWxDb2RlLmxlbmd0aCkge1xuICAgICAgICB2YXIgcG9zdGFsID0gcG9zdGFsQ29kZS52YWwoKTtcbiAgICAgICAgdmFyIGdlb2NvZGVyID0gbmV3IGdvb2dsZS5tYXBzLkdlb2NvZGVyKCk7XG4gICAgICAgIGdlb2NvZGVyLmdlb2NvZGUoeydhZGRyZXNzJzpwb3N0YWx9LGZ1bmN0aW9uKHJlc3VsdHMsc3RhdHVzKXtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT0gZ29vZ2xlLm1hcHMuR2VvY29kZXJTdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICAkY2FjaGUubWFwTGFyZ2Uuc2V0Q2VudGVyKHJlc3VsdHNbMF0uZ2VvbWV0cnkubG9jYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8vIEFkZCBtYXJrZXJzIHRvXG5mdW5jdGlvbiBhZGRNYXJrZXJzKCl7XG4gICAgLy8gTG9vcCB0aGUgc3RvcmVzIGFuZCBhZGQgdGhlIG1hcmtlcnNcbiAgICAkY2FjaGUuc3RvcmVzLmVhY2goZnVuY3Rpb24oaW5kZXgpe1xuICAgICAgICB2YXIgc3RvcmUgPSAkKHRoaXMpO1xuICAgICAgICAvLyBJZiB0aGUgc3RvcmUgZG9lc24ndCBoYXZlIGNvcnJlY3QgbGF0L2xuZyBkYXRhLCB3ZSByZXR1cm4gb3V0IG9mIHRoZSBmdW5jdGlvbiBhbmQgZG9uJ3QgYWRkIGl0IHRvIHRoZSBtYXAuXG4gICAgICAgIC8vIFJldHVybmluZyB0cnVlIGFsbG93cyB0aGUgbG9vcCB0byBjb250aW51ZVxuICAgICAgICBpZihzdG9yZS5kYXRhKCdpc3ZhbGlkJykudG9TdHJpbmcoKSAhPSAndHJ1ZScpIHJldHVybiB0cnVlO1xuICAgICAgICB2YXIgcG9pbnQgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKCBwYXJzZUZsb2F0KHN0b3JlLmRhdGEoJ2xhdCcpKSwgcGFyc2VGbG9hdChzdG9yZS5kYXRhKCdsbmcnKSkgKTtcbiAgICAgICAgdmFyIGljb24gPSBhcHAucmVzb3VyY2VzWydHT09HTEVfUElOXycgKyBzdG9yZS5kYXRhKCdzdG9yZWJyYW5kJykudG9VcHBlckNhc2UoKV07XG4gICAgICAgIHZhciBtYXJrZXIgPSBuZXcgZ29vZ2xlLm1hcHMuTWFya2VyKHtwb3NpdGlvbiA6IHBvaW50LCBtYXAgOiAkY2FjaGUubWFwTGFyZ2UsIGljb24gOiBpY29ufSk7XG5cbiAgICAgICAgdmFyIGh0bWw9ICc8ZGl2IGNsYXNzPVwiZ29vZ2xlLWxvY2F0aW9uLWhvcHVwXCI+JyArIHN0b3JlLmZpbmQoJy5zdG9yZS1pbmZvcm1hdGlvbicpLmh0bWwoKSArIHN0b3JlLmZpbmQoJy5zdG9yZS1hZGRyZXNzJykuaHRtbCgpICsgJzxhIGhyZWY9XCInICsgc3RvcmUuZGF0YSgnZGlyZWN0aW9ucycpICsgJ1wiIHRhcmdldD1cIl9ibGFua1wiPicgKyBhcHAucmVzb3VyY2VzWydHT09HTEVfRElSRUNUSU9OJ10gKyAnPC9hPjwvZGl2Pic7XG5cbiAgICAgICAgLy8gQWRkIGEgbGlzdGVuZXIgdG8gb3BlbiB0aGUgdG9vbHRpcCB3aGVuIGEgdXNlciBjbGlja3Mgb24gb25lIG9mIHRoZSBtYXJrZXJzXG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ2NsaWNrJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGluZm9XaW5kb3cuc2V0Q29udGVudChodG1sKTtcbiAgICAgICAgICAgIGluZm9XaW5kb3cub3BlbigkY2FjaGUubWFwTGFyZ2UsIG1hcmtlcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNldCBib3VuZHMgb2YgbWFwXG4gICAgICAgICRjYWNoZS5ib3VuZHNMYXJnZS5leHRlbmQocG9pbnQpO1xuICAgIH0pO1xuXG4gICAgLy8gS2VlcCBtYXAgaW4gYm91bmRzXG4gICAgJGNhY2hlLm1hcExhcmdlLmZpdEJvdW5kcygkY2FjaGUuYm91bmRzTGFyZ2UpO1xuICAgIHZhciBsaXN0ZW5lciA9IGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKCRjYWNoZS5tYXBMYXJnZSwgXCJpZGxlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZigkY2FjaGUubWFwTGFyZ2UuZ2V0Wm9vbSgpID4gMTIpICRjYWNoZS5tYXBMYXJnZS5zZXRab29tKDEyKTtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIH0pO1xufVxuXG4vLyBBbGxvdyBzb3J0aW5nIG9mIHNlYXJjaCByZXN1bHRzXG5mdW5jdGlvbiBzb3J0VGFicygpe1xuICAgIC8vIERldGVybWluZSBzZWxlY3RlZCB0YWIgYmFzZWQgb24gc2l0ZSBJRCBhbmQgc2V0dXAgZnVuY3Rpb25hbGl0eVxuICAgICQoJy5zdG9yZS10YWJzLW1lbnUgbGknKS5lYWNoKGZ1bmN0aW9uKGluZGV4KXtcbiAgICAgICAgdmFyIGxpID0gJCh0aGlzKTtcblxuICAgICAgICAvLyBsaSBjbGljayBmdW5jdGlvbmFsaXR5XG4gICAgICAgIGxpLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgLy8gT25seSBhbGxvdyBjbGljayBpZiBub3Qgc2VsZWN0ZWQsIG90aGVyd2lzZSBzZWxlY3QgaXQgYXMgYWN0aXZlIHRhYlxuICAgICAgICAgICAgaWYobGkuaGFzQ2xhc3MoJ2N1cnJlbnQnKSkgcmV0dXJuO1xuICAgICAgICAgICAgLy8gUmVsZWFzZSBwcmV2aW91cyBsaVxuICAgICAgICAgICAgJGNhY2hlLnRhYk5hdi5maW5kKCcuY3VycmVudCcpLnRvZ2dsZUNsYXNzKCdjdXJyZW50Jyk7XG4gICAgICAgICAgICAvLyBIb2xkL2RlYWN0aXZhdGUgY3VycmVudCBsaVxuICAgICAgICAgICAgbGkudG9nZ2xlQ2xhc3MoJ2N1cnJlbnQnKTtcblxuICAgICAgICAgICAgLy8gRmFkZSBvdXQgcHJldmlvdXMgcmVzdWx0c1xuICAgICAgICAgICAgJGNhY2hlLnNlYXJjaENvbnRlbnQuZmluZCgnLnRhYi1jb250ZW50LmN1cnJlbnQnKS50b2dnbGVDbGFzcygnY3VycmVudCcpLnN0b3AodHJ1ZSwgdHJ1ZSkuZmFkZU91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIC8vIEZhZGUgaW4gbmV3IHJlc3VsdHNcbiAgICAgICAgICAgICAgICAkKCdkaXYjJyArIGxpLmF0dHIoJ2lkJykgKyAnU2VjdGlvbicpLnRvZ2dsZUNsYXNzKCdjdXJyZW50Jykuc3RvcCh0cnVlLCB0cnVlKS5mYWRlSW4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuLy8gRklMVEVSIEtBVEUgU1BBREUgUkVTVUxUUyAtIFNQRUNJRklDIE9OTFkgVE8gVEhFIEtBVEUgU1BBREUgVEFCXG5mdW5jdGlvbiBzb3J0S2F0ZVJlc3VsdHMoKXtcbiAgICAkKCcuc2VhcmNoLXNvcnQgYScpLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHRcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgbGluayA9ICQodGhpcyk7XG5cbiAgICAgICAgLy8gSWYgY3VycmVudCBsaW5rIGlzbid0IGFjdGl2ZVxuICAgICAgICBpZihsaW5rLmF0dHIoJ2NsYXNzJykgIT0gJ2FjdGl2ZScpe1xuICAgICAgICAgICAgLy8gUmVsZWFzZSBwcmV2aW91c2x5IGFjdGl2ZSBhbmQgbWFrZSB0aGlzIGFjdGl2ZVxuICAgICAgICAgICAgJCgnLnNlYXJjaC1zb3J0IGEuYWN0aXZlJykudG9nZ2xlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgbGluay50b2dnbGVDbGFzcygnYWN0aXZlJyk7XG5cbiAgICAgICAgICAgIC8vIFNvcnQgc3RvcmVzXG4gICAgICAgICAgICAvLyBUZXN0IHRvIHNlZSBpZiB3ZSBoYXZlIGFueSBzdG9yZXMgdG8gZGlzcGxheSBhdCB0aGUgZW5kIG9mIHRoZSBmaWx0ZXIsIG90aGVyd2lzZSBkaXNwbGF5IHRoZSBubyBzZWFyY2ggcmVzdWx0cyBhbGVydFxuICAgICAgICAgICAgdmFyIHNob3dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBzb3J0ID0gbGluay5hdHRyKCdocmVmJyk7XG4gICAgICAgICAgICAvLyBIaWRlIHN0b3Jlc1xuICAgICAgICAgICAgJGNhY2hlLmthdGVTdG9yZXMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9ICQodGhpcyk7XG4gICAgICAgICAgICAgICAgLy8gSGlkZSBpdCBmcm9tIHRoZSBzdGFydFxuICAgICAgICAgICAgICAgIHN0b3JlLmNzcygnZGlzcGxheScsICdub25lJyk7XG4gICAgICAgICAgICAgICAgLy8gU2hvdyBpdCBpZiBtYXRjaGVzIHNvcnQgY3JpdGVyaWFcbiAgICAgICAgICAgICAgICBpZihzb3J0ID09IFwiYWxsXCIgfHwgc3RvcmUuaGFzQ2xhc3Moc29ydCkpe1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5jc3MoJ2Rpc3BsYXknLCAnYmxvY2snKTtcbiAgICAgICAgICAgICAgICAgICAgc2hvd2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIG5vIHN0b3JlcyB0byBzaG93LCB3ZSBkaXNwbGF5IHRoZSBhbGVydFxuICAgICAgICAgICAgaWYoIXNob3dpbmcpICRjYWNoZS5maWx0ZXIuc2hvdygpO1xuICAgICAgICAgICAgZWxzZSAkY2FjaGUuZmlsdGVyLmhpZGUoKTtcblxuICAgICAgICAgICAgLy8gSGlkZS9TaG93IHN0YXRlc1xuICAgICAgICAgICAgJGNhY2hlLnN0YXRlcy5lYWNoKGZ1bmN0aW9uKGluZGV4KXtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSAkKHRoaXMpO1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZVNob3cgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHN0YXRlLmZpbmQoJy5zdG9yZScpLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoJCh0aGlzKS5jc3MoJ2Rpc3BsYXknKSA9PSBcImJsb2NrXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVTaG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBzdG9yZXMgdG8gZGlzcGxheSwgd2Ugc2hvdyB0aGUgc3RhdGUsIG90aGVyd2lzZSB3ZSBoaWRlIGl0XG4gICAgICAgICAgICAgICAgaWYoc3RhdGVTaG93KXtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgc3RhdGUgaXMgaW5hY3RpdmUsIHNob3cgaXRcbiAgICAgICAgICAgICAgICAgICAgaWYoc3RhdGUuaGFzQ2xhc3MoJ2luYWN0aXZlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnRvZ2dsZUNsYXNzKCdpbmFjdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuZmluZCgnaDEuc3RhdGVIZWFkZXInKS50b2dnbGVDbGFzcygnaW5hY3RpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmZpbmQoJy5zdG9yZXMnKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRGlzcGxheSBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zaG93KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHN0YXRlLmhpZGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gSGlkZS9TaG93IGNvdW50cmllc1xuICAgICAgICAgICAgJGNhY2hlLmNvdW50cmllcy5lYWNoKGZ1bmN0aW9uKGluZGV4KXtcbiAgICAgICAgICAgICAgICB2YXIgY291bnRyeSA9ICQodGhpcyk7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50cnlTaG93ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBjb3VudHJ5LmZpbmQoJy5zdG9yZScpLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoJCh0aGlzKS5jc3MoJ2Rpc3BsYXknKSA9PSBcImJsb2NrXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRyeVNob3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIHN0b3JlcyB0byBkaXNwbGF5LCB3ZSBzaG93IHRoZSBzdGF0ZSwgb3RoZXJ3aXNlIHdlIGhpZGUgaXRcbiAgICAgICAgICAgICAgICBpZihjb3VudHJ5U2hvdyl7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHN0YXRlIGlzIGluYWN0aXZlLCBzaG93IGl0XG4gICAgICAgICAgICAgICAgICAgIGlmKGNvdW50cnkuaGFzQ2xhc3MoJ2luYWN0aXZlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50cnkudG9nZ2xlQ2xhc3MoJ2luYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudHJ5LmZpbmQoJ2gxLnN0YXRlSGVhZGVyJykudG9nZ2xlQ2xhc3MoJ2luYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudHJ5LmZpbmQoJy5zdG9yZXMnKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRGlzcGxheSBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICBjb3VudHJ5LnNob3coKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgY291bnRyeS5oaWRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIFRPR0dMRSBTVEFURSBIRUFERVJTXG4gICAgJCgnLnN0YXRlSGVhZGVyJykuZWFjaChmdW5jdGlvbihpbmRleCl7XG4gICAgICAgIHZhciBoZWFkZXIgPSAkKHRoaXMpO1xuICAgICAgICBoZWFkZXIub24oJ2NsaWNrJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGhlYWRlci5wYXJlbnQoKS50b2dnbGVDbGFzcygnaW5hY3RpdmUnKTtcbiAgICAgICAgICAgIGhlYWRlci50b2dnbGVDbGFzcygnaW5hY3RpdmUnKTtcbiAgICAgICAgICAgIGhlYWRlci5wYXJlbnQoKS5maW5kKCcuc3RvcmUnKS50b2dnbGUoJ2Zhc3QnKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbi8vIElFOCBGSVggRk9SIEZPUk0gRk9DVVM6IEtTLTQ3M1xuZnVuY3Rpb24gaW50ZXJuZXRFeHBsb3JlclppcEZvY3VzKCl7XG4gICAgdmFyIGZvcm0gPSAkKCdmb3JtLnppcCcpO1xuICAgIHZhciBidG4gPSBmb3JtLmZpbmQoJ2J1dHRvblt0eXBlPVwic3VibWl0XCJdJyk7XG5cbiAgICBmb3JtLm9uKCdzdWJtaXQnLGZ1bmN0aW9uKGUpe1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gQ29sbGVjdCB0aGUgcmVxdWlyZWQgZm9ybSBmaWVsZHNcbiAgICAgICAgdmFyIGRhdGEgPSBcIj9cIiArIGZvcm0uc2VyaWFsaXplKCk7XG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgd2hhdCB0eXBlIG9mIGNhbGwgdGhpcyBpcyAoZnJvbSB0aGUgYnV0dG9uKVxuICAgICAgICBkYXRhICs9IFwiJlwiICsgYnRuLmF0dHIoXCJuYW1lXCIpICsgXCI9XCIgKyBidG4uYXR0cihcInZhbHVlXCIpO1xuICAgICAgICAvLyBBZGQgdGhlIHNlcmlhbGl6ZSBkYXRhIHRvIHRoZSBmb3JtIHN1Ym1pdFxuICAgICAgICB2YXIgdXJsID0gZm9ybS5hdHRyKCdhY3Rpb24nKSArIGRhdGE7XG5cbiAgICAgICAgLy8gUmVkaXJlY3QgdG8gdGhlIGNvcnJlY3QgVVJMXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IHVybDtcbiAgICB9KTtcbn1cblxuLy8gSW5zdGFudGlhdGUgdGhlIHN0b3JlbG9jYXRvclxudmFyIHN0b3JlbG9jYXRvciA9IHtcbiAgICBpbml0IDogZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gQ2FjaGUgdG9wIGxldmVsIGVsZW1lbnRzXG4gICAgICAgICRjYWNoZS50YWJOYXYgPSAkKCcuc3RvcmUtdGFicy1tZW51Jyk7XG4gICAgICAgICRjYWNoZS5zZWFyY2hDb250ZW50ID0gJCgnLnNlYXJjaC1jb250ZW50Jyk7XG4gICAgICAgIC8vIENhY2hlIGRvbVxuICAgICAgICAkY2FjaGUucmVzdWx0c0Jsb2NrID0gJCgnI2thdGVzcGFkZUNvbnRlbnRTZWN0aW9uIC5yZXN1bHRzQmxvY2snKTtcbiAgICAgICAgJGNhY2hlLmZpbHRlciA9ICQoJyNrYXRlc3BhZGVDb250ZW50U2VjdGlvbiAuZmlsdGVyLW5vLXJlc3VsdHMnKTtcbiAgICAgICAgJGNhY2hlLmNvdW50cmllcyA9ICRjYWNoZS5yZXN1bHRzQmxvY2suZmluZCgnLmNvdW50cnknKTtcbiAgICAgICAgJGNhY2hlLnN0YXRlcyA9ICRjYWNoZS5yZXN1bHRzQmxvY2suZmluZCgnLnN0YXRlJyk7XG4gICAgICAgICRjYWNoZS5zdG9yZXMgPSAkY2FjaGUuc2VhcmNoQ29udGVudC5maW5kKCcuc3RvcmUnKTtcbiAgICAgICAgJGNhY2hlLmthdGVTdG9yZXMgPSAkY2FjaGUucmVzdWx0c0Jsb2NrLmZpbmQoJy5zdG9yZScpO1xuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBzb3J0aW5nL2ZpbHRlcmluZyBmdW5jdGlvbmFsaXR5IG9mIHRoZSBrYXRlIHRhYlxuICAgICAgICBzb3J0S2F0ZVJlc3VsdHMoKTtcbiAgICAgICAgLy8gRmFkZSBpbiBjdXJyZW50IGNvbnRlbnRcbiAgICAgICAgJGNhY2hlLnNlYXJjaENvbnRlbnQuZmluZCgnLnRhYi1jb250ZW50LmN1cnJlbnQnKS5zdG9wKHRydWUsIHRydWUpLmZhZGVJbigpO1xuICAgICAgICAvLyBBbGxvdyB0YWIgbWVudSB0byBvcHBlcmF0ZVxuICAgICAgICBzb3J0VGFicygpO1xuXG4gICAgICAgIC8vIFNJVEUgU1BFQ0lGSUMgRlVOQ1RJT05BTElUWVxuICAgICAgICAvLyBJZiBvbiBrYXRlc3BhZGUuY29tLCB3ZSBjb2xsZWN0IGluZm9ybWF0aW9uIGZvciB0aGUgbGFyZ2UgbWFwXG4gICAgICAgIGxhcmdlTWFwKCk7XG5cbiAgICAgICAgLy8gQWxsb3cgcG9wdXAgb2Ygc21hbGwgbWFwIChhbHNvIHVzZWQgZm9yIGFjY291bnQtbmVhcmVzdCBzdG9yZXMpXG4gICAgICAgIHRoaXMuZGV0YWlsc0hvcHVwKCk7XG5cbiAgICAgICAgc2VsZWN0Qm94SXQuc2VsZWN0Qm94SXQoJCgnLnNlbGVjdEJveGVkIHNlbGVjdCcpKTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHppcCBjb2RlIHNlYXJjaCBmb3JtIHdvcmtzIGNvcnJlY3RseSBvbiBJRTg6IEtTLTQ3M1xuICAgICAgICBpZigkKCdodG1sJykuaGFzQ2xhc3MoJ2llOCcpKSBpbnRlcm5ldEV4cGxvcmVyWmlwRm9jdXMoKTtcbiAgICB9LFxuICAgIC8vIFNNQUxMIE1BUCBIT1BVUCBGVU5DVElPTkFMSVRZXG4gICAgZGV0YWlsc0hvcHVwIDogZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gQ2FjaGUgRG9tXG4gICAgICAgICRjYWNoZS5zdG9yZURldGFpbHMgPSAkKCcjc3RvcmUtZGV0YWlscy1ob3B1cCcpO1xuICAgICAgICAkY2FjaGUuc3RvcmVJbmZvID0gJGNhY2hlLnN0b3JlRGV0YWlscy5maW5kKCcuc3RvcmUtaW5mb3JtYXRpb24nKTtcbiAgICAgICAgJGNhY2hlLnN0b3JlRGV0YWlsc01hcCA9ICRjYWNoZS5zdG9yZURldGFpbHMuZmluZCgnLmRldGFpbHMtbWFwJyk7XG4gICAgICAgICRjYWNoZS5wb3B1cE92ZXJsYXkgPSAkKCcucG9wdXAtb3ZlcmxheScpXG5cbiAgICAgICAgLy8gSG9vayBmb3IgdGhlICdtYXAnIGxpbmtcbiAgICAgICAgJCgnLmdvb2dsZS1tYXAnKS5vbignY2xpY2snLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIC8vIElmIGdvb2dsZSBpc24ndCBsb2FkZWQgeWV0LCByZXR1cm5cbiAgICAgICAgICAgIGlmKHR5cGVvZiBnb29nbGUgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHZhciBsaW5rID0gJCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBpZCA9IGxpbmsuYXR0cignaHJlZicpO1xuICAgICAgICAgICAgdmFyIHN0b3JlID0gJCgnIycgKyBpZCk7XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKHBhcnNlRmxvYXQoc3RvcmUuZGF0YShcImxhdFwiKSksIHBhcnNlRmxvYXQoc3RvcmUuZGF0YSgnbG5nJykpKTtcbiAgICAgICAgICAgIHZhciBpY29uID0gYXBwLnJlc291cmNlc1snR09PR0xFX1BJTl8nICsgc3RvcmUuZGF0YSgnc3RvcmVicmFuZCcpLnRvVXBwZXJDYXNlKCldO1xuICAgICAgICAgICAgLy8gSGlkZSBhbnkgcHJldmlvdXMgc3RvcmUgaW5mb1xuICAgICAgICAgICAgJGNhY2hlLnN0b3JlSW5mby5jaGlsZHJlbigpLmhpZGUoKTtcbiAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGNyZWF0ZWQgdGhlIHN0b3JlIGluZm8sIG90aGVyd2lzZSwgcG9wdWxhdGUgdGhlIHN0b3JlIGluZm9cbiAgICAgICAgICAgIGlmKCEkY2FjaGVbaWRdKSB7XG4gICAgICAgICAgICAgICAgJGNhY2hlLnN0b3JlSW5mby5hcHBlbmQoJzxkaXYgaWQ9XCJkZXRhaWxzLScgKyBpZCArICdcIj48L2Rpdj4nKTtcbiAgICAgICAgICAgICAgICAkY2FjaGVbaWRdID0gJCgnI2RldGFpbHMtJyArIGlkKTtcbiAgICAgICAgICAgICAgICBzdG9yZS5maW5kKCcuc3RvcmUtbmFtZScpLmNsb25lKCkuYXBwZW5kVG8oJGNhY2hlW2lkXSk7XG4gICAgICAgICAgICAgICAgc3RvcmUuZmluZCgnLnN0b3JlLWFkZHJlc3MnKS5jbG9uZSgpLmFwcGVuZFRvKCRjYWNoZVtpZF0pO1xuICAgICAgICAgICAgICAgIHN0b3JlLmZpbmQoJy5zdG9yZS1ob3VycycpLmNsb25lKCkuYXBwZW5kVG8oJGNhY2hlW2lkXSk7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGRpcmVjdGlvbnMgbGlua1xuICAgICAgICAgICAgICAgICRjYWNoZVtpZF0uYXBwZW5kKCc8YSBjbGFzcz1cImRpcmVjdGlvbnMtbGlua1wiIHRhcmdldD1cIl9ibGFua1wiIGhyZWY9XCInICsgc3RvcmUuZGF0YSgnZGlyZWN0aW9ucycpICsgJ1wiPkRpcmVjdGlvbnM8L2E+Jyk7XG4gICAgICAgICAgICAgICAgJGNhY2hlW2lkXS5hZGRDbGFzcyhzdG9yZS5kYXRhKCdzdG9yZWJyYW5kJykgKyAnSW5mbycpO1xuICAgICAgICAgICAgfSBlbHNlICRjYWNoZVtpZF0uc2hvdygpO1xuXG4gICAgICAgICAgICAvLyBBZGQgaXQgdG8gdGhlIGRpYWxvZyBob3B1cFxuICAgICAgICAgICAgJGNhY2hlLnN0b3JlRGV0YWlscy5kaWFsb2coe3dpZHRoOiAnYXV0bycsIGhlaWdodDogJ2F1dG8nLCBkaWFsb2dDbGFzcyA6ICdzdG9yZS1kZXRhaWxzLWhvcHVwJywgbW9kYWw6IHRydWUgfSk7XG4gICAgICAgICAgICAvLyBpZiBkaWFsb2cgaXMgb3BlbiwgcmV0dXJuXG4gICAgICAgICAgICBpZighJGNhY2hlLnN0b3JlRGV0YWlscy5kaWFsb2coXCJpc09wZW5cIikpICRjYWNoZS5zdG9yZURldGFpbHMuZGlhbG9nKCdvcGVuJyk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgbWFwIGlmIG5lZWRlZFxuICAgICAgICAgICAgaWYoISRjYWNoZS5tYXBTbWFsbCkge1xuICAgICAgICAgICAgICAgICRjYWNoZS5tYXBTbWFsbCA9IG5ldyBnb29nbGUubWFwcy5NYXAoJGNhY2hlLnN0b3JlRGV0YWlsc01hcFswXSwge2NlbnRlciA6IHBvaW50LCBtYXBUeXBlSWQgOiBnb29nbGUubWFwcy5NYXBUeXBlSWQuUk9BRE1BUCwgem9vbSA6IDYsIHN0cmVldFZpZXdDb250cm9sIDogZmFsc2V9KTtcbiAgICAgICAgICAgICAgICAkY2FjaGUuYm91bmRzU21hbGwgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBwcmV2aW91cyBtYXJrZXIsIHJlbW92ZSBpdFxuICAgICAgICAgICAgaWYoJGNhY2hlLm1hcmtlclNtYWxsKSAkY2FjaGUubWFya2VyU21hbGwuc2V0TWFwKG51bGwpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyBtYXJrZXJcbiAgICAgICAgICAgICRjYWNoZS5tYXJrZXJTbWFsbCA9IG5ldyBnb29nbGUubWFwcy5NYXJrZXIoe3Bvc2l0aW9uIDogcG9pbnQsIG1hcCA6ICRjYWNoZS5tYXBTbWFsbCwgaWNvbiA6IGljb259KTtcbiAgICAgICAgICAgIC8vIE1ha2UgbWFya2VyIGJvdW5jZVxuICAgICAgICAgICAgJGNhY2hlLm1hcmtlclNtYWxsLnNldEFuaW1hdGlvbihnb29nbGUubWFwcy5BbmltYXRpb24uRFJPUCk7XG4gICAgICAgICAgICAvLyBOZWVkZWQgc28gdGhhdCBnb29nbGUgd2lsbCByZWRyYXcgcmVnaW9ucyBvZiB0aGUgbWFwIG9uY2UgaXQgaXMgaW4gdGhlIGhvcHVwIGFuZCBub3QgaGlkZGVuLCB3aGljaCBnYXZlIGl0IGEgMCBoZWlnaHRcbiAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIoJGNhY2hlLm1hcFNtYWxsLCBcInJlc2l6ZVwiKTtcbiAgICAgICAgICAgICRjYWNoZS5tYXBTbWFsbC5zZXRab29tKDYpO1xuICAgICAgICAgICAgLy8gU2V0IGJvdW5kcyBvZiBtYXBcbiAgICAgICAgICAgICRjYWNoZS5tYXBTbWFsbC5zZXRDZW50ZXIocG9pbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0b3JlbG9jYXRvcjtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWRkUHJvZHVjdFRvQ2FydCA9IHJlcXVpcmUoJy4vcHJvZHVjdC9hZGRUb0NhcnQnKSxcbiAgICBwYWdlID0gcmVxdWlyZSgnLi4vcGFnZScpLFxuICAgIGxvZ2luID0gcmVxdWlyZSgnLi4vbG9naW4nKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgYWRkUHJvZHVjdFRvQ2FydCgpO1xuICAgICQoJyNlZGl0QWRkcmVzcycpLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBhZ2UucmVkaXJlY3QodXRpbC5hcHBlbmRQYXJhbVRvVVJMKFVybHMud2lzaGxpc3RBZGRyZXNzLCAnQWRkcmVzc0lEJywgJCh0aGlzKS52YWwoKSkpO1xuICAgIH0pO1xuXG4gICAgLy9hZGQganMgbG9naWMgdG8gcmVtb3ZlIHRoZSAsIGZyb20gdGhlIHF0eSBmZWlsZCB0byBwYXNzIHJlZ2V4IGV4cHJlc3Npb24gb24gY2xpZW50IHNpZGVcbiAgICAkKCcub3B0aW9uLXF1YW50aXR5LWRlc2lyZWQgaW5wdXQnKS5vbignZm9jdXNvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICQodGhpcykudmFsKCQodGhpcykudmFsKCkucmVwbGFjZSgnLCcsICcnKSk7XG4gICAgfSk7XG5cbiAgICBsb2dpbi5pbml0KCk7XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBpbWFnZXNMb2FkZWQgPSByZXF1aXJlKCdpbWFnZXNsb2FkZWQnKSxcbiAgICBxdWlja3ZpZXcgPSByZXF1aXJlKCcuL3F1aWNrdmlldycpO1xuXG52YXIgJGNhY2hlID0ge307XG5cbmZ1bmN0aW9uIGluaXRRdWlja1ZpZXdCdXR0b25zKCkge1xuICAgICQoJy50aWxlcy1jb250YWluZXIgLnByb2R1Y3QtaW1hZ2UnKS5vbignbW91c2VlbnRlcicsIGZ1bmN0aW9uICgpIHtcbiAgICBcdHZhciAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAgIHZhciAkcXZCdXR0b24gPSAkKCcjcXVpY2t2aWV3YnV0dG9uJyk7XG4gICAgICAgIGlmICgkcXZCdXR0b24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAkcXZCdXR0b24gPSAkKCc8YSBpZD1cInF1aWNrdmlld2J1dHRvblwiIGNsYXNzPVwicXVpY2t2aWV3XCI+JyArIFJlc291cmNlcy5RVUlDS19WSUVXICsgJzxpIGNsYXNzPVwiZmEgZmEtYXJyb3dzLWFsdFwiPjwvaT48L2E+Jyk7XG4gICAgICAgICAgICAkcXZCdXR0b24ub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHRpbGVUeXBlID0gJCh0aGlzKS5wYXJlbnRzKCcucHJvZHVjdC10aWxlJykuZGF0YSgndGlsZXR5cGUnKTtcbiAgICAgICAgICAgICAgICAvL1Zlcnkgc3BlY2lmaWMgY2FzZSBmb3IgbWFraW5nIGlucHV0cyBvdXRzaWRlIG9mIGRpYWxvZyBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAkLndpZGdldCggXCJ1aS5kaWFsb2dcIiwgJC51aS5kaWFsb2csIHtcbiAgICAgICAgICAgICAgICAgICAgX2FsbG93SW50ZXJhY3Rpb246IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhISQoIGV2ZW50LnRhcmdldCApLmlzKCBcImlucHV0XCIgKSB8fCB0aGlzLl9zdXBlciggZXZlbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHF1aWNrdmlldy5zaG93KHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAkKHRoaXMpLmF0dHIoJ2hyZWYnKSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiAncXVpY2t2aWV3JyxcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tQ2xhc3M6IHR5cGVvZiB0aWxlVHlwZSAhPSAndW5kZWZpbmVkJyA/IHRpbGVUeXBlIDogJydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyICRsaW5rID0gJHRoaXMuZmluZCgnLnRodW1iLWxpbmsnKTtcbiAgICAgICAgJHF2QnV0dG9uLmF0dHIoe1xuICAgICAgICAgICAgJ2hyZWYnOiAkbGluay5hdHRyKCdocmVmJyksXG4gICAgICAgICAgICAndGl0bGUnOiAkbGluay5hdHRyKCd0aXRsZScpXG4gICAgICAgIH0pLmFwcGVuZFRvKHRoaXMpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBncmlkVmlld1RvZ2dsZSgpIHtcbiAgICAkKCcudG9nZ2xlLWdyaWQnKS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICQoJy5zZWFyY2gtcmVzdWx0LWNvbnRlbnQnKS50b2dnbGVDbGFzcygnd2lkZS10aWxlcycpO1xuICAgICAgICAkKHRoaXMpLnRvZ2dsZUNsYXNzKCd3aWRlJyk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uIEluaXRpYWxpemVzIGV2ZW50cyBvbiB0aGUgcHJvZHVjdC10aWxlIGZvciB0aGUgZm9sbG93aW5nIGVsZW1lbnRzOlxuICogLSBzd2F0Y2hlc1xuICogLSB0aHVtYm5haWxzXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVFdmVudHMoKSB7XG4gICAgaW5pdFF1aWNrVmlld0J1dHRvbnMoKTtcbiAgICBncmlkVmlld1RvZ2dsZSgpO1xuICAgIFxuICAgICRjYWNoZS5jb250YWluZXIub24oJ3RvdWNoc3RhcnQgY2xpY2sgbW91c2VlbnRlcicsICcuc3dhdGNoLWxpc3QgYS5zd2F0Y2gnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyBkb24ndCBmb2xsb3cgdGhlIGxpbmsgb24gbW9iaWxlIGRldmljZXNcbiAgICAgICAgaWYgKHV0aWwuaXNNb2JpbGUoKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBjdXJyZW50IHRodW1iIGRldGFpbHNcbiAgICAgICAgdmFyIGxpbmsgPSAkKHRoaXMpO1xuICAgICAgICB2YXIgdGlsZSA9IGxpbmsuY2xvc2VzdChcIi5ncmlkLXRpbGVcIik7XG4gICAgICAgIHZhciB0aHVtYiA9IHRpbGUuZmluZChcIi5wcm9kdWN0LWltYWdlIGEudGh1bWItbGluayBpbWdcIikuZmlsdGVyKFwiOm5vdCgubGF6eSk6Zmlyc3RcIik7XG4gICAgICAgIHZhciB0aHVtYkxpbmsgPSB0aWxlLmZpbmQoXCIucHJvZHVjdC1pbWFnZSBhLnRodW1iLWxpbmtcIik7XG4gICAgICAgIHZhciBzZWNvbmRUaHVtYiA9IHRpbGUuZmluZChcIi5wcm9kdWN0LWltYWdlIGEudGh1bWItbGluayBpbWdcIikuZmlsdGVyKFwiOm5vdCgubGF6eSk6bGFzdFwiKTtcbiAgICAgICAgdmFyIHN3YXRjaEltZyA9IGxpbmsuY2hpbGRyZW4oXCJpbWdcIikuZmlsdGVyKFwiOmZpcnN0XCIpO1xuICAgICAgICB2YXIgZGF0YSA9IGxpbmsuZGF0YShcInRodW1iXCIpO1xuXG4gICAgICAgIHZhciBjdXJyZW50QXR0cyA9IHtcbiAgICAgICAgICAgIHNyYyA6IHRodW1iLmF0dHIoXCJzcmNcIiksXG4gICAgICAgICAgICBhbHQgOiB0aHVtYi5hdHRyKFwiYWx0XCIpLFxuICAgICAgICAgICAgdGl0bGUgOiB0aHVtYi5hdHRyKFwidGl0bGVcIilcbiAgICAgICAgfVxuXG4gICAgICAgIHRodW1iLmF0dHIoe1xuICAgICAgICAgICAgc3JjIDogKHRodW1iLmRhdGEoJ2FsdC1zcmMnKSA9PSBkYXRhLnNyYykgPyBkYXRhWydhbHQtc3JjJ10gOiBkYXRhLnNyYyxcbiAgICAgICAgICAgIGFsdCA6IGRlY29kZVVSSUNvbXBvbmVudChkYXRhLmFsdClcbiAgICAgICAgfSkuZGF0YSgnYWx0LXNyYycsIGRhdGFbJ2FsdC1zcmMnXSk7XG5cbiAgICAgICAgc2Vjb25kVGh1bWIuYXR0cih7XG4gICAgICAgICAgICBzcmMgOiAodGh1bWIuZGF0YSgnYWx0LXNyYycpID09IGRhdGEuc3JjKSA/IGRhdGEuc3JjIDogZGF0YVsnYWx0LXNyYyddLFxuICAgICAgICAgICAgYWx0IDogZGVjb2RlVVJJQ29tcG9uZW50KGRhdGEuYWx0KVxuICAgICAgICB9KS5kYXRhKCdhbHQtc3JjJyx0aHVtYi5hdHRyKCdzcmMnKSk7XG5cbiAgICAgICAgdGh1bWIuYXR0cignZGF0YS1hc3NldG5hbWUnLHN3YXRjaEltZy5kYXRhKCdhc3NldG5hbWUnKSk7XG4gICAgICAgIHN3YXRjaEltZy5kYXRhKFwidGh1bWJcIiwgY3VycmVudEF0dHMpO1xuICAgICAgICAvLyBSZW1vdmUgZmFpbGVkIGNsYXNzIGluIGNhc2UgdGhlIG5ldyBzd2F0Y2ggaGFzIGltYWdlcyB0aGUgcHJldmlvdXMgc3dhdGNoIGxhY2tlZFxuICAgICAgICB0aHVtYi5yZW1vdmVDbGFzcygnZmFpbGVkJyk7XG5cbiAgICAgICAgaWYgKHNlY29uZFRodW1iLmF0dHIoXCJzcmNcIikgPT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgIHNlY29uZFRodW1iLmFkZENsYXNzKCdmYWlsZWQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlY29uZFRodW1iLnJlbW92ZUNsYXNzKCdmYWlsZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gc2V0IHRodW1iIHByb2R1Y3QncyBocmVmIGVxdWFsIHRvIHN3YXRjaCdzIGhyZWZcbiAgICAgICAgdGh1bWJMaW5rLmF0dHIoJ2hyZWYnLCBsaW5rLmF0dHIoJ2hyZWYnKSk7XG4gICAgICAgIFxuICAgIH0pO1xuICAgICRjYWNoZS5jb250YWluZXIub24oJ21vdXNlbGVhdmUnLCAnLnN3YXRjaC1saXN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBSZXN0b3JlIGN1cnJlbnQgdGh1bWIgaW1hZ2VcbiAgICAgICAgdmFyICR0aWxlID0gJCh0aGlzKS5jbG9zZXN0KCcucHJvZHVjdC10aWxlJyksXG4gICAgICAgICAgICAkdGh1bWIgPSAkdGlsZS5maW5kKCcucHJvZHVjdC1pbWFnZSAudGh1bWItbGluayBpbWcnKS5lcSgxKSxcbiAgICAgICAgICAgICR0aHVtYkxpbmsgPSAkdGlsZS5maW5kKFwiLnByb2R1Y3QtaW1hZ2UgYS50aHVtYi1saW5rXCIpLFxuICAgICAgICAgICAgJHNlbGVjdGVkU3dhdGNoID0gJHRpbGUuZmluZCgnLnN3YXRjaC1saXN0IC5zd2F0Y2guc2VsZWN0ZWQnKSxcbiAgICAgICAgICAgIGJhc2V1cmwgPSAkdGh1bWIuZGF0YSgnYmFzZXVybCcpO1xuICAgICAgICAgICAgXG4gICAgICAgIC8vIHNldCB1cCBiYXNlIGltYWdlXG4gICAgICAgIGlmICgkc2VsZWN0ZWRTd2F0Y2gubGVuZ3RoICYmICRzZWxlY3RlZFN3YXRjaC5kYXRhKCd0aHVtYicpICYmICRzZWxlY3RlZFN3YXRjaC5kYXRhKCd0aHVtYicpWydzcmMnXSkge1xuICAgICAgICAgICAgJHRodW1iLmF0dHIoJ3NyYycsICRzZWxlY3RlZFN3YXRjaC5kYXRhKCd0aHVtYicpWydzcmMnXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYmFzZXVybCkge1xuICAgICAgICAgICAgJHRodW1iLmF0dHIoJ3NyYycsIGJhc2V1cmwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCB1cCBiYXNlIGhyZWZcbiAgICAgICAgaWYgKCRzZWxlY3RlZFN3YXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICAgICR0aHVtYkxpbmsuYXR0cignaHJlZicsICRzZWxlY3RlZFN3YXRjaC5hdHRyKCdocmVmJykpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0pO1xuXG59XG5cbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkY2FjaGUgPSB7XG4gICAgICAgIGNvbnRhaW5lcjogJCgnLnRpbGVzLWNvbnRhaW5lcicpXG4gICAgfTtcblxuICAgIGluaXRpYWxpemVFdmVudHMoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciAkbG9hZGVyO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uIFNob3dzIGFuIEFKQVgtbG9hZGVyIG9uIHRvcCBvZiBhIGdpdmVuIGNvbnRhaW5lclxuICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXIgVGhlIEVsZW1lbnQgb24gdG9wIG9mIHdoaWNoIHRoZSBBSkFYLUxvYWRlciB3aWxsIGJlIHNob3duXG4gKi9cbnZhciBzaG93ID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIHZhciB0YXJnZXQgPSAoIWNvbnRhaW5lciB8fCAkKGNvbnRhaW5lcikubGVuZ3RoID09PSAwKSA/ICQoJ2JvZHknKSA6ICQoY29udGFpbmVyKTtcbiAgICAkbG9hZGVyID0gJGxvYWRlciB8fCAkKCcubG9hZGVyJyk7XG5cbiAgICBpZiAoJGxvYWRlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgJGxvYWRlciA9ICQoJzxkaXYvPicpLmFkZENsYXNzKCdsb2FkZXInKVxuICAgICAgICAgICAgLmFwcGVuZCgkKCc8ZGl2Lz4nKS5hZGRDbGFzcygnbG9hZGVyLWluZGljYXRvcicpLCAkKCc8ZGl2Lz4nKS5hZGRDbGFzcygnbG9hZGVyLWJnJykpO1xuICAgIH1cbiAgICByZXR1cm4gJGxvYWRlci5hcHBlbmRUbyh0YXJnZXQpLnNob3coKTtcbn07XG4vKipcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uIEhpZGVzIGFuIEFKQVgtbG9hZGVyXG4gKi9cbnZhciBoaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICgkbG9hZGVyKSB7XG4gICAgICAgICRsb2FkZXIuaGlkZSgpO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuc2hvdyA9IHNob3c7XG5leHBvcnRzLmhpZGUgPSBoaWRlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGlhbG9nID0gcmVxdWlyZSgnLi9kaWFsb2cnKSxcbiAgICBwcm9kdWN0ID0gcmVxdWlyZSgnLi9wYWdlcy9wcm9kdWN0JyksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxuICAgIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxuXG52YXIgbWFrZVVybCA9IGZ1bmN0aW9uICh1cmwsIHNvdXJjZSwgcHJvZHVjdExpc3RJRCkge1xuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgdXJsID0gdXRpbC5hcHBlbmRQYXJhbVRvVVJMKHVybCwgJ3NvdXJjZScsIHNvdXJjZSk7XG4gICAgfVxuICAgIGlmIChwcm9kdWN0TGlzdElEKSB7XG4gICAgICAgIHVybCA9IHV0aWwuYXBwZW5kUGFyYW1Ub1VSTCh1cmwsICdwcm9kdWN0bGlzdGlkJywgcHJvZHVjdExpc3RJRCk7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgUHJvZHVjdCBVUkxcbiAqIEByZXR1cm5zIHtTdHJpbmd9IFByb2R1Y3QgVXJsIHdpdGhvdXQgc2VhcmNoIHBhcmFtZXRlcnMgaWYgaXQgd2FzIHNlby1mcmllbmRseSB1cmxcbiAqICAgICAgICAgIG9yIFByb2R1Y3QgVXJsIHdpdGggcGlkIHNlYXJjaCBwYXJhbWV0ZXIgb25seSBpZiBpdCB3YXMgbm90IHNlby1mcmllbmRseVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9kdWN0VXJsKHVybCkge1xuICAgIGlmICh1cmwuaW5kZXhPZignPycpICE9PSAtMSkge1xuICAgICAgICB2YXIgcGlkUG9zaXRpb24gPSB1cmwuaW5kZXhPZignP3BpZD0nKTtcbiAgICAgICAgaWYgKHBpZFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICAgICAgcGlkUG9zaXRpb24gPSB1cmwuaW5kZXhPZignJnBpZD0nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGlkUG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgdXJsTm9QYXJhbXMgPSB1cmwuc3Vic3RyaW5nKDAsIHVybC5pbmRleE9mKCc/JykpO1xuICAgICAgICAgICAgdmFyIHBpZFZhbHVlU3RhcnRQb3NpdGlvbiA9IHBpZFBvc2l0aW9uICsgNTtcbiAgICAgICAgICAgIHZhciBwaWRWYWx1ZUVuZFBvc2l0aW9uID0gdXJsLmluZGV4T2YoJyYnLCBwaWRWYWx1ZVN0YXJ0UG9zaXRpb24pO1xuICAgICAgICAgICAgaWYgKHBpZFZhbHVlRW5kUG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcGlkVmFsdWVFbmRQb3NpdGlvbiA9IHVybC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGlkVmFsdWUgPSB1cmwuc2xpY2UocGlkVmFsdWVTdGFydFBvc2l0aW9uLCBwaWRWYWx1ZUVuZFBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmIChwaWRWYWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsTm9QYXJhbXMgKyAnP3BpZD0nICsgcGlkVmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cmxOb1BhcmFtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1cmwuc3Vic3RyaW5nKDAsIHVybC5pbmRleE9mKCc/JykpXG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYWxsb3dPdXRPZlN0b2NrQ2xpY2soZSwgb3ZlcmxheSl7XG5cdGUucHJldmVudERlZmF1bHQoKTtcbiAgICBvdmVybGF5LmNsb3Nlc3QoJ2xpJykuZmluZCgnYScpLmNsaWNrKCk7XG59XG5cbnZhciBxdWlja3ZpZXcgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuZXhpc3RzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lciA9ICQoJzxkaXYvPicpLmF0dHIoJ2lkJywgJ1F1aWNrVmlld0RpYWxvZycpLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvZHVjdExpbmtzID0gJCgnI3NlYXJjaC1yZXN1bHQtaXRlbXMgLnByb2R1Y3QtdGlsZTpub3QoLnByb2R1Y3Qtc2V0LXRpbGUpIC50aHVtYi1saW5rJykubWFwKGZ1bmN0aW9uIChpbmRleCwgdGh1bWJMaW5rKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplUHJvZHVjdFVybCgkKHRodW1iTGluaykuYXR0cignaHJlZicpKTtcbiAgICAgICAgfSk7XG4gICAgICAgICQoXCIucHJvbW90aW9uLWNhbGxvdXQgYS50b29sdGlwXCIpLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBcdGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgIH0sXG5cbiAgICBzZXR1cDogZnVuY3Rpb24gKHF2VXJsKSB7XG5cbiAgICAgICAgLy8gaGlkZS9zaG93IHRodW1ibmFpbCBhcnJvd3MgYmFzZWQgb24gc3dhdGNoIGxpc3QgbGVuZ3RoXG4gICAgICAgIHZhciAkdGh1bWJuYWlscyA9ICQoJyN0aHVtYm5haWxzJyk7XG4gICAgICAgIHZhciB0aHVtYnNXaWR0aCA9IDA7XG4gICAgICAgIHZhciAkdGh1bWJzUHJldkFycm93ID0gJCgnLmpjYXJvdXNlbC1jb250cm9sLXByZXYnKTtcbiAgICAgICAgdmFyICR0aHVtYnNOZXh0QXJyb3cgPSAkKCcuamNhcm91c2VsLWNvbnRyb2wtbmV4dCcpO1xuICAgICAgICAkKCcudGh1bWInKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGh1bWJzV2lkdGggKz0gJCh0aGlzKS53aWR0aCgpO1xuICAgICAgICB9KVxuICAgICAgICBpZiAodGh1bWJzV2lkdGggPD0gJCgnI3RodW1ibmFpbHMnKS53aWR0aCgpKSB7XG4gICAgICAgICAgICAkdGh1bWJzUHJldkFycm93LmhpZGUoKTtcbiAgICAgICAgICAgICR0aHVtYnNOZXh0QXJyb3cuaGlkZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyICRidG5OZXh0ID0gJCgnLnF1aWNrdmlldy1uZXh0JyksXG4gICAgICAgICAgICAkYnRuUHJldiA9ICQoJy5xdWlja3ZpZXctcHJldicpO1xuXG4gICAgICAgIHByb2R1Y3QuaW5pdCgpO1xuXG4gICAgICAgIHRoaXMucHJvZHVjdExpbmtJbmRleCA9IF8odGhpcy5wcm9kdWN0TGlua3MpLmZpbmRJbmRleChmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsID09PSBub3JtYWxpemVQcm9kdWN0VXJsKHF2VXJsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaGlkZSB0aGUgYnV0dG9ucyBvbiB0aGUgY29tcGFyZSBwYWdlIG9yIHdoZW4gdGhlcmUgYXJlIG5vIG90aGVyIHByb2R1Y3RzXG4gICAgICAgIGlmICh0aGlzLnByb2R1Y3RMaW5rcy5sZW5ndGggPD0gMSB8fCAkKCcuY29tcGFyZXJlbW92ZWNlbGwnKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAkYnRuTmV4dC5oaWRlKCk7XG4gICAgICAgICAgICAkYnRuUHJldi5oaWRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wcm9kdWN0TGlua0luZGV4ID09PSB0aGlzLnByb2R1Y3RMaW5rcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAkYnRuTmV4dC5hdHRyKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb2R1Y3RMaW5rSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICRidG5QcmV2LmF0dHIoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICAkYnRuTmV4dC5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0ZVF1aWNrdmlldygxKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgJGJ0blByZXYub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGVRdWlja3ZpZXcoLTEpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHR5cGVvZiB0ZmMgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHRmYy5jYWxjdWxhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIFx0XHR0ZmMuY2FsY3VsYXRlKCk7IC8vIEFkZCBUcnVlRml0IHdpZGdldFxuICAgIFx0fVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcCAtIEhvdyBtYW55IHByb2R1Y3RzIGF3YXkgZnJvbSBjdXJyZW50IHByb2R1Y3QgdG8gbmF2aWdhdGUgdG8uIE5lZ2F0aXZlIG51bWJlciBtZWFucyBuYXZpZ2F0ZSBiYWNrd2FyZFxuICAgICAqL1xuICAgIG5hdmlnYXRlUXVpY2t2aWV3OiBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAvLyBkZWZhdWx0IHN0ZXAgdG8gMFxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMucHJvZHVjdExpbmtJbmRleCArPSAoc3RlcCA/IHN0ZXAgOiAwKTtcbiAgICAgICAgdmFyIHVybCA9IG1ha2VVcmwodGhpcy5wcm9kdWN0TGlua3NbdGhpcy5wcm9kdWN0TGlua0luZGV4XSwgJ3F1aWNrdmlldycpO1xuICAgICAgICBkaWFsb2cucmVwbGFjZSh7XG4gICAgICAgICAgICB1c2VDb250YWluZXI6IHNlbGYuJGNvbnRhaW5lcixcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHF1aWNrdmlldy5zZXR1cC5jYWxsKHF1aWNrdmlldywgdXJsKTtcbiAgICAgICAgICAgICAgICAvLyBhZGQgY2xhc3MgZm9yIGdpZnQtY2FyZCBwcm9kdWN0c1xuICAgICAgICAgICAgICAgIHZhciAkcXVpY2tWaWV3RGlhbG9nID0gJCgnLnVpLWRpYWxvZ19xdWljay12aWV3Jyk7XG4gICAgICAgICAgICAgICAgdmFyICRpc0dpZnQgPSAkcXVpY2tWaWV3RGlhbG9nLmZpbmQoJyNpc0dpZnRDYXJkJyk7XG4gICAgICAgICAgICAgICAgaWYgKCRpc0dpZnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICRxdWlja1ZpZXdEaWFsb2cuYWRkQ2xhc3MoJ2dpZnRDYXJkJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJHF1aWNrVmlld0RpYWxvZy5yZW1vdmVDbGFzcygnZ2lmdENhcmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pOyAgICAgICBcbiAgICAgICAgXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBzaG93IHF1aWNrIHZpZXcgZGlhbG9nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy51cmwgLSB1cmwgb2YgdGhlIHByb2R1Y3QgZGV0YWlsc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnNvdXJjZSAtIHNvdXJjZSBvZiB0aGUgZGlhbG9nIHRvIGJlIGFwcGVuZGVkIHRvIFVSTFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmNsYXNzIC0gY3VzdG9tIGNsYXNzIHRvIGFkZCB0byB0aGUgZGlhbG9nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMucHJvZHVjdGxpc3RpZCAtIHRvIGJlIGFwcGVuZGVkIHRvIFVSTFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuY2FsbGJhY2sgLSBjYWxsYmFjayBvbmNlIHRoZSBkaWFsb2cgaXMgb3BlbmVkXG4gICAgICovXG4gICAgc2hvdzogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHVybDtcbiAgICAgICAgaWYgKCF0aGlzLmV4aXN0cygpKSB7XG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgfVxuICAgICAgICB1cmwgPSBtYWtlVXJsKG9wdGlvbnMudXJsLCBvcHRpb25zLnNvdXJjZSwgb3B0aW9ucy5wcm9kdWN0bGlzdGlkKTtcbiAgICAgICAgdmFyIGRpYWxvZ1dpZHRoID0gd2luZG93Lm1hdGNoTWVkaWEoJyhtaW4td2lkdGg6IDk2MXB4KScpLm1hdGNoZXMgPyA4MjAgOiA3MjA7XG4gICAgICAgIGlmICgob3B0aW9ucy5zb3VyY2UgPT09ICdjYXJ0JyB8fCBvcHRpb25zLnNvdXJjZSA9PT0gJ3NmbC1hZGQnIHx8IG9wdGlvbnMuc291cmNlID09PSAnZ2lmdHJlZ2lzdHJ5JykgJiYgd2luZG93LmlubmVyV2lkdGggPD0gNzY4KSB7XG4gICAgICAgICAgICBkaWFsb2dXaWR0aCA9ICh3aW5kb3cuaW5uZXJXaWR0aCA8PSA2NjgpID8gKHdpbmRvdy5pbm5lcldpZHRoKS50b1N0cmluZygpIDogJzY2OCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCQoJy51aS1kaWFsb2dfcXVpY2stdmlldycpLmxlbmd0aCkge1xuICAgICAgICAgICAgJCgnLnVpLWRpYWxvZ19xdWljay12aWV3JykucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kY29udGFpbmVyLmVtcHR5KCk7XG5cbiAgICAgICAgZGlhbG9nLm9wZW4oe1xuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLiRjb250YWluZXIsXG4gICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogZGlhbG9nV2lkdGgsXG4gICAgICAgICAgICAgICAgdGl0bGU6IFJlc291cmNlcy5RVUlDS19WSUVXX1BPUFVQLFxuICAgICAgICAgICAgICAgIGRpYWxvZ0NsYXNzOiAndWktZGlhbG9nX3F1aWNrLXZpZXcgJyArICh0eXBlb2Ygb3B0aW9ucy5jdXN0b21DbGFzcyAhPSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuY3VzdG9tQ2xhc3MgOiAnJyksXG4gICAgICAgICAgICAgICAgb3BlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHVwKHVybCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgeyBvcHRpb25zLmNhbGxiYWNrKCk7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCQoJyNwZHBNYWluLmdpZnQtY2FyZCcpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBcdHZhciBsaW5rdXJsID0gJCgnI3BkcE1haW4uZ2lmdC1jYXJkJykuZmluZCgnLmZ1bGwtZGV0YWlscy1saW5rIGEnKS5hdHRyKCdocmVmJyk7XG4gICAgICAgICAgICAgICAgICAgIFx0aWYgKGxpbmt1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgXHRcdCQoJyNwZHBNYWluLmdpZnQtY2FyZCAuc3dhdGNoZXMuQ29sb3IgbGkgYScpLmF0dHIoJ2hyZWYnLGxpbmt1cmwpO1xuICAgICAgICAgICAgICAgICAgICBcdH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy9tdXN0IGJlIGluaXRpYWxpemUgaW4gdGhlIGRpYWxvZyBjcmVhdGlvbiBzbyBpdCBpcyBhdmFpbGFibGUgXG4gICAgICAgICQoJyNRdWlja1ZpZXdEaWFsb2cnKS5vbignY2xpY2snLCAnLnVuc2VsZWN0YWJsZS1vdmVybGF5JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGFsbG93T3V0T2ZTdG9ja0NsaWNrKGUsJCh0aGlzKSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgZXhpc3RzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRjb250YWluZXIgJiYgKHRoaXMuJGNvbnRhaW5lci5sZW5ndGggPiAwKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHF1aWNrdmlldztcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBjb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZGFya3NreWFwcC9zdHJpbmctaGFzaFxuICovXG5mdW5jdGlvbiBoYXNoRm4oc3RyKSB7XG4gICAgdmFyIGhhc2ggPSA1MzgxLFxuICAgICAgICBpID0gc3RyLmxlbmd0aDtcblxuICAgIHdoaWxlIChpKSB7XG4gICAgICAgIGhhc2ggPSAoaGFzaCAqIDMzKSBeIHN0ci5jaGFyQ29kZUF0KC0taSk7XG4gICAgfVxuICAgIC8qIEphdmFTY3JpcHQgZG9lcyBiaXR3aXNlIG9wZXJhdGlvbnMgKGxpa2UgWE9SLCBhYm92ZSkgb24gMzItYml0IHNpZ25lZFxuICAgICogaW50ZWdlcnMuIFNpbmNlIHdlIHdhbnQgdGhlIHJlc3VsdHMgdG8gYmUgYWx3YXlzIHBvc2l0aXZlLCBjb252ZXJ0IHRoZVxuICAgICogc2lnbmVkIGludCB0byBhbiB1bnNpZ25lZCBieSBkb2luZyBhbiB1bnNpZ25lZCBiaXRzaGlmdC4gKi9cbiAgICByZXR1cm4gaGFzaCA+Pj4gMDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgcmF0aW5nIGJhc2VkIG9uIGhhc2ggcmFuZ2luZyBmcm9tIDItNVxuICogQHBhcmFtIHBpZFxuICovXG5mdW5jdGlvbiBnZXRSYXRpbmcocGlkKSB7XG4gICAgcmV0dXJuIGhhc2hGbihwaWQudG9TdHJpbmcoKSkgJSAzMCAvIDEwICsgMjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAkKCcucHJvZHVjdC1yZXZpZXcnKS5lYWNoKGZ1bmN0aW9uIChpbmRleCwgcmV2aWV3KSB7XG4gICAgICAgICAgICB2YXIgcGlkID0gJChyZXZpZXcpLmRhdGEoJ3BpZCcpO1xuICAgICAgICAgICAgaWYgKCFwaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByYXRpbmcgcmFuZ2UgZnJvbSAyIC0gNVxuICAgICAgICAgICAgdmFyIHJhdGluZyA9IGdldFJhdGluZyhwaWQpO1xuICAgICAgICAgICAgdmFyIGJhc2VSYXRpbmcgPSBNYXRoLmZsb29yKHJhdGluZyk7XG4gICAgICAgICAgICB2YXIgc3RhcnNDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2VSYXRpbmc7IGkrKykge1xuICAgICAgICAgICAgICAgICQoJy5yYXRpbmcnLCByZXZpZXcpLmFwcGVuZCgnPGkgY2xhc3M9XCJmYSBmYS1zdGFyXCI+PC9pPicpO1xuICAgICAgICAgICAgICAgIHN0YXJzQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGdpdmUgaGFsZiBzdGFyIGZvciBhbnl0aGluZyBpbiBiZXR3ZWVuXG4gICAgICAgICAgICBpZiAocmF0aW5nID4gYmFzZVJhdGluZykge1xuICAgICAgICAgICAgICAgICQoJy5yYXRpbmcnLCByZXZpZXcpLmFwcGVuZCgnPGkgY2xhc3M9XCJmYSBmYS1zdGFyLWhhbGYtb1wiPjwvaT4nKTtcbiAgICAgICAgICAgICAgICBzdGFyc0NvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhcnNDb3VudCA8IDUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDUgLSBzdGFyc0NvdW50OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgJCgnLnJhdGluZycsIHJldmlldykuYXBwZW5kKCc8aSBjbGFzcz1cImZhIGZhLXN0YXItb1wiPjwvaT4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uIEJpbmRzIGV2ZW50IHRvIHRoZSBwbGFjZSBob2xkZXIgKC5ibHVyKVxuICovXG5mdW5jdGlvbiBpbml0aWFsaXplRXZlbnRzKCkge1xuLy9cdFRoaXMgY29kZSBicmVha3Mgc2VhcmNoIGZvcm0gdmFsaWRhdGlvblxuXHRcbi8vICAgICQoJyNxJykuZm9jdXMoZnVuY3Rpb24gKCkge1xuLy8gICAgICAgIHZhciBpbnB1dCA9ICQodGhpcyk7XG4vLyAgICAgICAgaWYgKGlucHV0LnZhbCgpID09PSBpbnB1dC5hdHRyKCdwbGFjZWhvbGRlcicpKSB7XG4vLyAgICAgICAgICAgIGlucHV0LnZhbCgnJyk7XG4vLyAgICAgICAgfVxuLy8gICAgfSlcbi8vICAgIC5ibHVyKGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICB2YXIgaW5wdXQgPSAkKHRoaXMpO1xuLy8gICAgICAgIGlmIChpbnB1dC52YWwoKSA9PT0gJycgfHwgaW5wdXQudmFsKCkgPT09IGlucHV0LmF0dHIoJ3BsYWNlaG9sZGVyJykpIHtcbi8vICAgICAgICAgICAgaW5wdXQudmFsKGlucHV0LmF0dHIoJ3BsYWNlaG9sZGVyJykpO1xuLy8gICAgICAgIH1cbi8vICAgIH0pXG4vLyAgICAuYmx1cigpO1xufVxuXG5leHBvcnRzLmluaXQgPSBpbml0aWFsaXplRXZlbnRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgY3VycmVudFF1ZXJ5ID0gbnVsbCxcbiAgICBsYXN0UXVlcnkgPSBudWxsLFxuICAgIHJ1bm5pbmdRdWVyeSA9IG51bGwsXG4gICAgbGlzdFRvdGFsID0gLTEsXG4gICAgbGlzdEN1cnJlbnQgPSAtMSxcbiAgICBkZWxheSA9IDMwLFxuICAgICRyZXN1bHRzQ29udGFpbmVyLFxuICAgIG1vYmlsZU1lbnVCcmVha3BvaW50ID0gOTYwO1xuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvbiBIYW5kbGVzIGtleWJvYXJkJ3MgYXJyb3cga2V5c1xuICogQHBhcmFtIGtleUNvZGUgQ29kZSBvZiBhbiBhcnJvdyBrZXkgdG8gYmUgaGFuZGxlZFxuICovXG5mdW5jdGlvbiBoYW5kbGVBcnJvd0tleXMoa2V5Q29kZSkge1xuICAgIHN3aXRjaCAoa2V5Q29kZSkge1xuICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgLy8ga2V5VXBcbiAgICAgICAgICAgIGxpc3RDdXJyZW50ID0gKGxpc3RDdXJyZW50IDw9IDApID8gKGxpc3RUb3RhbCAtIDEpIDogKGxpc3RDdXJyZW50IC0gMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICAgIC8vIGtleURvd25cbiAgICAgICAgICAgIGxpc3RDdXJyZW50ID0gKGxpc3RDdXJyZW50ID49IGxpc3RUb3RhbCAtIDEpID8gMCA6IGxpc3RDdXJyZW50ICsgMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gcmVzZXRcbiAgICAgICAgICAgIGxpc3RDdXJyZW50ID0gLTE7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgJHJlc3VsdHNDb250YWluZXIuY2hpbGRyZW4oKS5yZW1vdmVDbGFzcygnc2VsZWN0ZWQnKS5lcShsaXN0Q3VycmVudCkuYWRkQ2xhc3MoJ3NlbGVjdGVkJyk7XG4gICAgJCgnaW5wdXRbbmFtZT1cInFcIl0nKS52YWwoJHJlc3VsdHNDb250YWluZXIuZmluZCgnLnNlbGVjdGVkIC5zdWdnZXN0aW9udGVybScpLmZpcnN0KCkudGV4dCgpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLypcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uXHRUaGUgZGVmYXVsdCBwbGFjZWhvbGRlciBoYXMgcG9vciBjb250cmFzdCBvbiBtb2JpbGUsIGFuZCB3ZSB3aWxsIG5vdCBoYXZlIGEgcGxhY2Vob2xkZXIgcHNldWRvLWVsZW1lbnRcbiAqIFx0XHRcdFx0dW50aWwgQ1NTNCBpcyByZWxlYXNlZC4gVW50aWwgdGhlbiB3ZSBjYW4gaGF2ZSBhIFwiZmFrZVwiIHBsYWNlaG9sZGVyIHRoYXQgY2FuIGJlIHN0eWxlZC5cbiAqL1xuZnVuY3Rpb24gbW9iaWxlUGxhY2Vob2xkZXJDb250cmFzdCgpIHtcblx0dmFyICRtb2JpbGVTZWFyY2hGaWVsZCA9ICQoJy5oZWFkZXItc2VhcmNoLW1vYmlsZSAua2F0ZXNlYXJjaHZhbCcpO1xuXHRcblx0JG1vYmlsZVNlYXJjaEZpZWxkLm9uKCdmb2N1cycsIGZ1bmN0aW9uIChlKSB7XG4gICAgXHR2YXIgJHRoaXMgPSAkKHRoaXMpO1xuXHRcdHZhciBwbGFjZWhvbGRlclRleHQgPSAkdGhpcy5wcm9wKCdwbGFjZWhvbGRlcicpO1xuICAgIFx0aWYgKCR0aGlzLnZhbCgpID09PSBwbGFjZWhvbGRlclRleHQpIHtcbiAgICBcdFx0JHRoaXMudmFsKFwiXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgIFx0XHRyZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KS5vbignYmx1cicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAgIHZhciBwaCA9ICR0aGlzLnByb3AoJ3BsYWNlaG9sZGVyJyk7XG4gICAgICAgIGlmICgkdGhpcy52YWwoKSA9PT0gXCJcIikge1xuICAgICAgICAgICAgJHRoaXMudmFsKHBoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pLnZhbCgkbW9iaWxlU2VhcmNoRmllbGQucHJvcCgncGxhY2Vob2xkZXInKSk7XG59XG5cbnZhciBzZWFyY2hzdWdnZXN0ID0ge1xuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBDb25maWd1cmVzIHBhcmFtZXRlcnMgYW5kIHJlcXVpcmVkIG9iamVjdCBpbnN0YW5jZXNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbiAoY29udGFpbmVyLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgdmFyICRzZWFyY2hDb250YWluZXIgPSAkKGNvbnRhaW5lcik7XG4gICAgICAgIHZhciAkc2VhcmNoRm9ybSA9ICRzZWFyY2hDb250YWluZXIuZmluZCgnZm9ybVtuYW1lPVwic2ltcGxlU2VhcmNoXCJdJyk7XG4gICAgICAgIHZhciAkc2VhcmNoRmllbGQgPSAkc2VhcmNoRm9ybS5maW5kKCdpbnB1dFtuYW1lPVwicVwiXScpO1xuXG4gICAgICAgIC8vIGRpc2FibGUgYnJvd3NlciBhdXRvIGNvbXBsZXRlXG4gICAgICAgICRzZWFyY2hGaWVsZC5hdHRyKCdhdXRvY29tcGxldGUnLCAnb2ZmJyk7XG5cbiAgICAgICAgLy8gb24gZm9jdXMgbGlzdGVuZXIgKGNsZWFyIGRlZmF1bHQgdmFsdWUpXG4gICAgICAgICRzZWFyY2hGaWVsZC5mb2N1cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoISRyZXN1bHRzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIHJlc3VsdHMgY29udGFpbmVyIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgICRyZXN1bHRzQ29udGFpbmVyID0gJCgnPGRpdi8+JykuYXR0cignaWQnLCAnc2VhcmNoLXN1Z2dlc3Rpb25zJykuYXBwZW5kVG8oJHNlYXJjaENvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJHNlYXJjaEZpZWxkLnZhbCgpID09PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAkc2VhcmNoRmllbGQudmFsKCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAkKGRvY3VtZW50KS5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKCEkc2VhcmNoQ29udGFpbmVyLmlzKGUudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5jbGVhclJlc3VsdHMsIDIwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIC8vIG9uIGtleSB1cCBsaXN0ZW5lclxuICAgICAgICAkc2VhcmNoRmllbGQua2V5dXAoZnVuY3Rpb24gKGUpIHtcblxuICAgICAgICAgICAgLy8gZ2V0IGtleUNvZGUgKHdpbmRvdy5ldmVudCBpcyBmb3IgSUUpXG4gICAgICAgICAgICB2YXIga2V5Q29kZSA9IGUua2V5Q29kZSB8fCB3aW5kb3cuZXZlbnQua2V5Q29kZTtcblxuICAgICAgICAgICAgLy8gY2hlY2sgYW5kIHRyZWF0IHVwIGFuZCBkb3duIGFycm93c1xuICAgICAgICAgICAgaWYgKGhhbmRsZUFycm93S2V5cyhrZXlDb2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBhbiBFTlRFUiBvciBFU0NcbiAgICAgICAgICAgIGlmIChrZXlDb2RlID09PSAxMyB8fCBrZXlDb2RlID09PSAyNykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJSZXN1bHRzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50UXVlcnkgPSAkc2VhcmNoRmllbGQudmFsKCkudHJpbSgpO1xuXG4gICAgICAgICAgICAvLyBubyBxdWVyeSBjdXJyZW50bHkgcnVubmluZywgaW5pdCBhbiB1cGRhdGVcbiAgICAgICAgICAgIGlmICghcnVubmluZ1F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgcnVubmluZ1F1ZXJ5ID0gY3VycmVudFF1ZXJ5O1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5zdWdnZXN0LmJpbmQodGhpcyksIGRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgXG4gICAgICAgIG1vYmlsZVBsYWNlaG9sZGVyQ29udHJhc3QoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIHRyaWdnZXIgc3VnZ2VzdCBhY3Rpb25cbiAgICAgKi9cbiAgICBzdWdnZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgcXVlcnkgdG8gZXhlY3V0ZSAocnVubmluZ1F1ZXJ5KSBpcyBzdGlsbCB1cCB0byBkYXRlIGFuZCBoYWQgbm90IGNoYW5nZWQgaW4gdGhlIG1lYW53aGlsZVxuICAgICAgICAvLyAod2UgaGFkIGEgbGl0dGxlIGRlbGF5KVxuICAgICAgICBpZiAocnVubmluZ1F1ZXJ5ICE9PSBjdXJyZW50UXVlcnkpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBydW5uaW5nIHF1ZXJ5IHRvIHRoZSBtb3N0IHJlY2VudCBzZWFyY2ggcGhyYXNlXG4gICAgICAgICAgICBydW5uaW5nUXVlcnkgPSBjdXJyZW50UXVlcnk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBpdCdzIGVtcHR5IGNsZWFyIHRoZSByZXN1bHRzIGJveCBhbmQgcmV0dXJuXG4gICAgICAgIGlmIChydW5uaW5nUXVlcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyUmVzdWx0cygpO1xuICAgICAgICAgICAgcnVubmluZ1F1ZXJ5ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IHNlYXJjaCBwaHJhc2UgaXMgdGhlIHNhbWUgYXMgZm9yIHRoZSBsYXN0IHN1Z2dlc3Rpb24gY2FsbCwganVzdCByZXR1cm5cbiAgICAgICAgaWYgKGxhc3RRdWVyeSA9PT0gcnVubmluZ1F1ZXJ5KSB7XG4gICAgICAgICAgICBydW5uaW5nUXVlcnkgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYnVpbGQgdGhlIHJlcXVlc3QgdXJsXG4gICAgICAgIHZhciByZXFVcmwgPSB1dGlsLmFwcGVuZFBhcmFtVG9VUkwoVXJscy5zZWFyY2hzdWdnZXN0LCAncScsIHJ1bm5pbmdRdWVyeSk7XG5cbiAgICAgICAgLy8gZXhlY3V0ZSBzZXJ2ZXIgY2FsbFxuICAgICAgICAkLmdldChyZXFVcmwsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgc3VnZ2VzdGlvbkhUTUwgPSBkYXRhLFxuICAgICAgICAgICAgICAgIGFuc0xlbmd0aCA9IHN1Z2dlc3Rpb25IVE1MLnRyaW0oKS5sZW5ndGg7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSByZXN1bHRzIHBvcHVsYXRlIHRoZSByZXN1bHRzIGRpdlxuICAgICAgICAgICAgaWYgKGFuc0xlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJSZXN1bHRzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgcmVzdWx0cyBkaXZcbiAgICAgICAgICAgICAgICAkcmVzdWx0c0NvbnRhaW5lci5odG1sKHN1Z2dlc3Rpb25IVE1MKS5mYWRlSW4oMjAwKTtcbiAgICAgICAgICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5zZWFyY2goL3dlYmtpdC9pKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgJCgnLnN1Z2dlc3Rpb24td3JhcHBlcicpLm1DdXN0b21TY3JvbGxiYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCB0aGUgbWFpbiBuYXYgZnJvbSBhbHNvIHNjcm9sbGluZyBpbiBtb2JpbGVcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHRoZSBuYXYgdGhlIHNhbWUgaGVpZ2h0IG9mIHRoZSBzZWFyY2ggY29udGFpbmVyXG4gICAgICAgICAgICAgICAgLy8gb25seSBpZiB0aGUgY29udGFpbmVyIGlzIHRhbGxlciB0aGFuIHRoZSB2aWV3cG9ydFxuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA8IG1vYmlsZU1lbnVCcmVha3BvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWFyY2hDb250YWluZXJIZWlnaHQgPSAkKCcuaGVhZGVyLXNlYXJjaC1tb2JpbGUnKS5vdXRlckhlaWdodCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdnBIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2cEhlaWdodCA8IHNlYXJjaENvbnRhaW5lckhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgnI25hdmlnYXRpb24nKS5hZGRDbGFzcygnbm9TY3JvbGwnKS5jc3MoJ2hlaWdodCcsIHNlYXJjaENvbnRhaW5lckhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGJlY29tZXMgdGhlIHNjcm9sbGFibGUgY29udGFpbmVyIHNvIHRoZSB1c2VyIGNhbiBzZWUgYWxsIG9mIHRoZSByZXN1bHRzXG4gICAgICAgICAgICAgICAgICAgICAgICAkKCcubmF2aWdhdGlvbi10b3AnKS5maXJzdCgpLmNzcygnaGVpZ2h0JywgdnBIZWlnaHQpLmNzcygnb3ZlcmZsb3cteScsICdzY3JvbGwnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjb250YWluZXIgaXMgc2hvcnRlciB0aGFuIHRoZSB2aWV3cG9ydCBoZWlnaHQganVzdCBwcmV2ZW50IHRoZSBuYXYgZnJvbSBzY3JvbGxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJyNuYXZpZ2F0aW9uJykuYWRkQ2xhc3MoJ25vU2Nyb2xsJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlY29yZCB0aGUgcXVlcnkgdGhhdCBoYXMgYmVlbiBleGVjdXRlZFxuICAgICAgICAgICAgbGFzdFF1ZXJ5ID0gcnVubmluZ1F1ZXJ5O1xuICAgICAgICAgICAgLy8gcmVzZXQgY3VycmVudGx5IHJ1bm5pbmcgcXVlcnlcbiAgICAgICAgICAgIHJ1bm5pbmdRdWVyeSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBhbm90aGVyIHJlcXVpcmVkIHVwZGF0ZSAoaWYgY3VycmVudCBzZWFyY2ggcGhyYXNlIGlzIGRpZmZlcmVudCBmcm9tIGp1c3QgZXhlY3V0ZWQgY2FsbClcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVlcnkgIT09IGxhc3RRdWVyeSkge1xuICAgICAgICAgICAgICAgIC8vIC4uLiBhbmQgZXhlY3V0ZSBpbW1lZGlhdGVseSBpZiBzZWFyY2ggaGFzIGNoYW5nZWQgd2hpbGUgdGhpcyBzZXJ2ZXIgY2FsbCB3YXMgaW4gdHJhbnNpdFxuICAgICAgICAgICAgICAgIHJ1bm5pbmdRdWVyeSA9IGN1cnJlbnRRdWVyeTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuc3VnZ2VzdC5iaW5kKHRoaXMpLCBkZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhpZGVMZWZ0UGFuZWwoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqL1xuICAgIGNsZWFyUmVzdWx0czogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoISRyZXN1bHRzQ29udGFpbmVyKSB7IHJldHVybjsgfVxuICAgICAgICAkcmVzdWx0c0NvbnRhaW5lci5mYWRlT3V0KDIwMCwgZnVuY3Rpb24gKCkgeyRyZXN1bHRzQ29udGFpbmVyLmVtcHR5KCk7fSk7XG4gICAgICAgIC8vIGxldCB0aGUgbmF2IHNjcm9sbCBhZ2FpblxuICAgICAgICBpZiAod2luZG93LmlubmVyV2lkdGggPCBtb2JpbGVNZW51QnJlYWtwb2ludCkge1xuICAgICAgICAgICAgJCgnLnNlYXJjaC1zdWdnZXN0aW9uLXdyYXBwZXInKS5yZW1vdmVBdHRyKCdzdHlsZScpO1xuICAgICAgICAgICAgJCgnI25hdmlnYXRpb24nKS5yZW1vdmVBdHRyKCdzdHlsZScpLnJlbW92ZUNsYXNzKCdub1Njcm9sbCcpO1xuICAgICAgICAgICAgJCgnLm5hdmlnYXRpb24tdG9wJykuZmlyc3QoKS5yZW1vdmVBdHRyKCdzdHlsZScpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKi9cbiAgICBoaWRlTGVmdFBhbmVsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vaGlkZSBsZWZ0IHBhbmVsIGlmIHRoZXJlIGlzIG9ubHkgYSBtYXRjaGluZyBzdWdnZXN0ZWQgY3VzdG9tIHBocmFzZVxuICAgICAgICBpZiAoJCgnLnNlYXJjaC1zdWdnZXN0aW9uLWxlZnQtcGFuZWwtaGl0JykubGVuZ3RoID09PSAxICYmICQoJy5zZWFyY2gtcGhyYXNlLXN1Z2dlc3Rpb24gYScpLnRleHQoKS5yZXBsYWNlKC8oXltcXHNdK3xbXFxzXSskKS9nLCAnJykudG9VcHBlckNhc2UoKSA9PT0gJCgnLnNlYXJjaC1zdWdnZXN0aW9uLWxlZnQtcGFuZWwtaGl0IGEnKS50ZXh0KCkudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgJCgnLnNlYXJjaC1zdWdnZXN0aW9uLWxlZnQtcGFuZWwnKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgICAgICAgJCgnLnNlYXJjaC1zdWdnZXN0aW9uLXdyYXBwZXItZnVsbCcpLmFkZENsYXNzKCdzZWFyY2gtc3VnZ2VzdGlvbi13cmFwcGVyJyk7XG4gICAgICAgICAgICAkKCcuc2VhcmNoLXN1Z2dlc3Rpb24td3JhcHBlcicpLnJlbW92ZUNsYXNzKCdzZWFyY2gtc3VnZ2VzdGlvbi13cmFwcGVyLWZ1bGwnKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc2VhcmNoc3VnZ2VzdDsiLCIndXNlIHN0cmljdCc7XG5mdW5jdGlvbiBzZWxlY3RCb3hJdChzZWxlY3QpIHtcbiAgICB2YXIgaXRlbXMgPSBzZWxlY3QuZmlsdGVyKCdzZWxlY3QnKTtcbiAgICBpZiAoaXRlbXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGl0ZW1zLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpdGVtID0gJCh0aGlzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGl0ZW0uYWRkQ2xhc3MoJ3JlcGxhY2VkJyk7XG4gICAgICAgICAgICB2YXIgc2IgPSBpdGVtLnNlbGVjdEJveEl0KCkuZGF0YSgnc2VsZWN0Qm94SXQnKTtcbiAgICAgICAgICAgIHNiLnJlZnJlc2goKTtcbiAgICAgICAgICAgIGl0ZW1zLmJpbmQoe1xuICAgICAgICAgICAgICAgICdvcGVuJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykubmV4dCgnLnNlbGVjdGJveGl0LWNvbnRhaW5lcicpLmFkZENsYXNzKCdvcGVuJylcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdjbG9zZScgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5uZXh0KCcuc2VsZWN0Ym94aXQtY29udGFpbmVyJykucmVtb3ZlQ2xhc3MoJ29wZW4nKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2ZvY3VzaW4nIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykubmV4dCgnLnNlbGVjdGJveGl0LWNvbnRhaW5lcicpLmFkZENsYXNzKCdmb2N1cycpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2ZvY3Vzb3V0JyA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLm5leHQoJy5zZWxlY3Rib3hpdC1jb250YWluZXInKS5yZW1vdmVDbGFzcygnZm9jdXMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGFkZCBhdmFpbGFibGl0eSBtZXNzYWdlIHdpdGhpbiBkcm9wZG93blxuICAgICAgICAgICAgc2IuZHJvcGRvd25Db250YWluZXIuZmluZCgnbGlbZGF0YS10ZXh0XSBhJykuZWFjaChcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSAkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGkgPSBhLnBhcmVudCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YVRleHQgPSBsaS5kYXRhKCd0ZXh0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGh0bWwgPSBhLmh0bWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChodG1sLmluZGV4T2YoZGF0YVRleHQpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGkuYWRkQ2xhc3MoJ2F2YWlsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5odG1sKCc8c3BhbiBjbGFzcz1cInNpemVcIj4nICsgaHRtbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnPC9zcGFuPiZuYnNwOzxzcGFuIGNsYXNzPVwibXNnXCI+J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBkYXRhVGV4dCArICc8L3NwYW4+Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH0pO1xufVxubW9kdWxlLmV4cG9ydHMuc2VsZWN0Qm94SXQgPSBzZWxlY3RCb3hJdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBFeGVjdXRlIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdGhlIHVzZXIgaGFzIHN0b3BwZWQgcmVzaXppbmcgdGhlIHNjcmVlbi5cbiAqIEBwYXJhbSBjYWxsYmFjayB7RnVuY3Rpb259IFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBleGVjdXRlLlxuICovXG5cbnZhciBzbWFydHJlc2l6ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciB0aW1lb3V0O1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChjYWxsYmFjaywgMTAwKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjYWxsYmFjaztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc21hcnRyZXNpemU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTVkgQkFHIC0gRVhQQU5EIEFORCBNSU5JTUlaRSBGVU5DVElPTkFMSVRZIFZJQSBDSEVDS09VVFxuICogV0UgQVJFIFJFQklORElORyBUSEUgRVZFTlQgSEVSRSBTSU5DRSBJVCBJUyBJTkNMVURFRCBJTlNJREUgT0ZcbiAqIE1JTklTVU1NQVJZLklTTUwgV0hJQ0ggSVMgUkVUVVJORUQgVklBIEFKQVggV0hFTiBBIFVTRVIgQ0hBTkdFUyBUSEVcbiAqIFNISVBQSU5HIE1FVEhPRC5cbiAqL1xuXG52YXIgc3RpY2t5Q2FydCA9IHtcbiAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgJCgnI215LWJhZy10b2dnbGUtYnV0dG9uJykub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgLy9jb250cm9sIGhlaWdodCBvZiBleHBhbmRlZCBiYWdcbiAgICAgICAgICAgIHZhciBzdW1tYXJ5QmxvY2sgPSAgJCgnLmNhcnQtb3JkZXItdG90YWxzJyk7XG4gICAgICAgICAgICB2YXIgY29udGVudEJsb2NrID0gJCgnLmNoZWNrb3V0LW1pbmktc3VtbWFyeScpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoc3VtbWFyeUJsb2NrLmhlaWdodCgpID4gY29udGVudEJsb2NrLmhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgc3VtbWFyeUJsb2NrLmZpbmQoJy5teS1iYWctY29udGVudCcpLmFkZENsYXNzKCdzY3JvbGFibGUnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3VtbWFyeUJsb2NrLmZpbmQoJy5teS1iYWctY29udGVudCcpLnJlbW92ZUNsYXNzKCdzY3JvbGFibGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNob3cgZXhwYW5kZWQgYmFnXG4gICAgICAgICAgICAkKHRoaXMpLnRvZ2dsZUNsYXNzKCdmYS1taW51cycpXG4gICAgICAgICAgICAgICAgLnBhcmVudHMoJy5teS1iYWctY2hlY2tvdXQnKS50b2dnbGVDbGFzcygnZXhwYW5kZWQnKTtcbiAgICAgICAgICAgICQoJy5teS1iYWctY29udGVudCcpLnRvZ2dsZSgpO1xuXG4gICAgICAgICAgICAvL3JlbG9hZCBzdGlja3kgYmxvY2tcbiAgICAgICAgICAgICQoZG9jdW1lbnQuYm9keSkudHJpZ2dlcignc3RpY2t5X2tpdDpyZWNhbGMnKTtcblxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0aWNreUNhcnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbnZlbnRvcnkgPSByZXF1aXJlKCcuLycpO1xudmFyIHByb2R1Y3QgPSByZXF1aXJlKCcuLi9zdG9yZWludmVudG9yeS9wcm9kdWN0Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxudmFyIGNhcnRJbnZlbnRvcnkgPSB7XG4gICAgc2V0U2VsZWN0ZWRTdG9yZTogZnVuY3Rpb24gKHN0b3JlSWQsdXVpZCkge1xuICAgICAgICB2YXIgJHNlbGVjdGVkU3RvcmUgPSAkKCcuc3RvcmUtdGlsZS4nICsgc3RvcmVJZCArICcuc2VsZWN0ZWQnKSxcbiAgICAgICAgICAgICRsaW5lSXRlbSA9ICQoJy5jYXJ0LXJvd1tkYXRhLXV1aWQ9XCInICsgdXVpZCArICdcIl0nKSxcbiAgICAgICAgICAgIHN0b3JlQWRkcmVzcyA9ICRzZWxlY3RlZFN0b3JlLmZpbmQoJy5zdG9yZS1hZGRyZXNzJykuaHRtbCgpLFxuICAgICAgICAgICAgc3RvcmVTdGF0dXMgPSAkc2VsZWN0ZWRTdG9yZS5maW5kKCcuc3RvcmUtc3RhdHVzJykuZGF0YSgnc3RhdHVzJyksXG4gICAgICAgICAgICBzdG9yZVN0YXR1c1RleHQgPSAkc2VsZWN0ZWRTdG9yZS5maW5kKCcuc3RvcmUtc3RhdHVzJykudGV4dCgpLFxuICAgICAgICAgICAgc3RvcmVTdHIgPSBSZXNvdXJjZXMuUElDS19VUF9BVC5yZXBsYWNlKCd7MH0nLCRzZWxlY3RlZFN0b3JlLmZpbmQoJy5zdG9yZS1uYW1lJykudGV4dCgpLnRyaW0oKSksXG4gICAgICAgICAgICBzdG9yZVZhbEh0bWwgPSAnPHNwYW4gaWQ9XCJzdG9yZVZhbFwiPicrc3RvcmVTdHIrJzwvc3Bhbj4nO1xuICAgICAgICB0aGlzLnNlbGVjdGVkU3RvcmUgPSBzdG9yZUlkO1xuXG5cblxuICAgICAgICAkbGluZUl0ZW0uZmluZCgnLmluc3RvcmUtZGVsaXZlcnkgLnNlbGVjdGVkLXN0b3JlLWFkZHJlc3MnKVxuICAgICAgICAgICAgLmRhdGEoJ3N0b3JlSWQnLCBzdG9yZUlkKVxuICAgICAgICAgICAgLmF0dHIoJ2RhdGEtc3RvcmUtaWQnLCBzdG9yZUlkKVxuICAgICAgICAgICAgLmh0bWwoc3RvcmVBZGRyZXNzKTtcbiAgICAgICAgJGxpbmVJdGVtLmZpbmQoJy5pbnN0b3JlLWRlbGl2ZXJ5IC5zZWxlY3RlZC1zdG9yZS1hdmFpbGFiaWxpdHknKVxuICAgICAgICAgICAgLmRhdGEoJ3N0YXR1cycsIHN0b3JlU3RhdHVzKVxuICAgICAgICAgICAgLmF0dHIoJ2RhdGEtc3RhdHVzJywgc3RvcmVTdGF0dXMpXG4gICAgICAgICAgICAudGV4dChzdG9yZVN0YXR1c1RleHQpO1xuICAgICAgICAvLyAkbGluZUl0ZW0uZmluZCgnLmluc3RvcmUtZGVsaXZlcnkgLmRlbGl2ZXJ5LW9wdGlvbicpLnJlbW92ZUF0dHIoJ2Rpc2FibGVkJykudHJpZ2dlcignY2xpY2snKTtcblxuICAgICAgICB2YXIgaG9tZURlbENvbnRhaW5lcnMgPSAkbGluZUl0ZW0uZmluZCgnLmhvbWUtZGVsaXZlcnknKTtcblxuICAgICAgICBob21lRGVsQ29udGFpbmVycy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgc3RvcmVWYWwgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKCcjc3RvcmVWYWwnKTtcblxuICAgICAgICAgICAgaWYgKHN0b3JlVmFsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBzaXplID0gc3RvcmVWYWwubGVuZ3RoOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc3RvcmVWYWxbaV07XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbC5pbnNlcnRBZGphY2VudEhUTUwoJ2FmdGVyQmVnaW4nLHN0b3JlVmFsSHRtbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy9oaWRlIGNvdW50cnkgcmVzdHJpY3Rpb24gbWVzc2FnZSBpZiBpdCBleGlzdHNcbiAgICAgICAgdmFyIGZpbmFsU2FsZVJvdyA9ICRsaW5lSXRlbS5uZXh0KCcuZmluYWwtc2FsZS1yb3cnKTtcbiAgICAgICAgaWYgKGZpbmFsU2FsZVJvdy5sZW5ndGggJiYgZmluYWxTYWxlUm93LmZpbmQoJy5pdGVtLXJlc3RyaWN0aW9uLW1lc3NhZ2VzJykubGVuZ3RoKSB7XG4gICAgICAgICAgICBmaW5hbFNhbGVSb3cuZmluZCgnLml0ZW0tcmVzdHJpY3Rpb24tbWVzc2FnZXMnKS5hZGRDbGFzcygndmlzdWFsbHktaGlkZGVuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBVc2VyLnN0b3JlSWQgPSBzdG9yZUlkO1xuXG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICB1cmw6IFVybHMuc2V0U3RvcmVQaWNrdXAsXG4gICAgICAgICAgICB0eXBlOiAnR0VUJyxcbiAgICAgICAgICAgIGRhdGE6IHtwbGlkOiB1dWlkLCBzdG9yZWlkOiBzdG9yZUlkLCBzdG9yZXBpY2t1cDogJ3RydWUnfVxuICAgICAgICB9KTtcbiAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgIHVybDogVXJscy5zZXRQcmVmZXJyZWRTdG9yZSxcbiAgICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICAgIGRhdGE6IHtzdG9yZUlkOiBzdG9yZUlkfVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGNhcnRTZWxlY3RTdG9yZTogZnVuY3Rpb24gKHNlbGVjdGVkU3RvcmUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgaXRlbVJvdyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYXJ0LXJvd1tkYXRhLXV1aWQ9XCInK3NlbGYudXVpZCsnXCJdJyk7XG4gICAgICAgIHZhciBjb2xvckVsID0gaXRlbVJvdy5xdWVyeVNlbGVjdG9yKCdkaXZbZGF0YS1hdHRyaWJ1dGU9XCJjb2xvclwiXSAudmFsdWUnKTtcbiAgICAgICAgdmFyIHF0eUVsID0gaXRlbVJvdy5xdWVyeVNlbGVjdG9yKCcuY2FydC1xdWFudGl0eScpO1xuICAgICAgICB2YXIgcHJpY2VFbCA9IGl0ZW1Sb3cucXVlcnlTZWxlY3RvcignLnByaWNlLXRvdGFsJyk7XG4gICAgICAgIHZhciBwaWQgPSAgaXRlbVJvdy5kYXRhc2V0LnBpZDtcblxuICAgICAgICB2YXIgcHJvZHVjdENvbG9yID0gY29sb3JFbCA/IGNvbG9yRWwudGV4dENvbnRlbnQudHJpbSgpIDogJyc7XG4gICAgICAgIHZhciBwcm9kdWN0UHJpY2UgPSBwcmljZUVsID8gcHJpY2VFbC50ZXh0Q29udGVudC50cmltKCkgOiAnJztcbiAgICAgICAgdmFyIHByb2R1Y3RRdHkgPSAgcXR5RWwgPyAgcXR5RWwudmFsdWUgOiAnJztcblxuICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgZGF0YVR5cGU6ICdodG1sJyxcbiAgICAgICAgICAgIHVybDogdXRpbC5hcHBlbmRQYXJhbXNUb1VybChVcmxzLmdldFByb2R1Y3RJbmZvLCB7XG4gICAgICAgICAgICAgICAgcGlkOiBwaWQsXG4gICAgICAgICAgICAgICAgcHJvZHVjdENvbG9yOiBwcm9kdWN0Q29sb3IsXG4gICAgICAgICAgICAgICAgcHJvZHVjdFByaWNlOiBwcm9kdWN0UHJpY2UsXG4gICAgICAgICAgICAgICAgcHJvZHVjdFF0eTogcHJvZHVjdFF0eVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBVc2VyLnBpY2t1cENvbnRlbnQgPSByZXNwb25zZTtcblxuICAgICAgICAgICAgICAgIGludmVudG9yeS5zZWxlY3RTdG9yZURpYWxvZyh7XG4gICAgICAgICAgICAgICAgICAgIHBpZDogcGlkLFxuICAgICAgICAgICAgICAgICAgICBwaWNrdXBDb250ZW50OiBVc2VyLnBpY2t1cENvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlczogW10sXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkU3RvcmVJZDogc2VsZWN0ZWRTdG9yZSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRTdG9yZVRleHQ6IFJlc291cmNlcy5TRUxFQ1RFRF9TVE9SRSxcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVDYWxsYmFjazogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbURlbE9wdGlvbnMgPSAkKCcuY2FydC1yb3dbZGF0YS11dWlkPVwiJytzZWxmLnV1aWQrJ1wiXSAuaXRlbS1kZWxpdmVyeS1vcHRpb25zJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtRGVsT3B0aW9ucy5maW5kKCcuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbURlbE9wdGlvbnMuZmluZCgnLmhvbWUtZGVsaXZlcnknKS5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdFN0b3JlQ2FsbGJhY2s6IGZ1bmN0aW9uKHN0b3JlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0U2VsZWN0ZWRTdG9yZShzdG9yZUlkLHNlbGYudXVpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBzZXREZWxpdmVyeU9wdGlvbjogZnVuY3Rpb24gKHZhbHVlLCBzdG9yZUlkKSB7XG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgcGxpZDogdGhpcy51dWlkLFxuICAgICAgICAgICAgc3RvcmVwaWNrdXA6ICh2YWx1ZSA9PT0gJ3N0b3JlJyA/IHRydWUgOiBmYWxzZSlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHZhbHVlID09PSAnc3RvcmUnKSB7XG4gICAgICAgICAgICBkYXRhLnN0b3JlcGlja3VwID0gdHJ1ZTtcbiAgICAgICAgICAgIGRhdGEuc3RvcmVpZCA9IHN0b3JlSWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhLnN0b3JlcGlja3VwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgIHVybDogVXJscy5zZXRTdG9yZVBpY2t1cCxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoKSB7bG9jYXRpb24ucmVsb2FkKCk7fVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbURlbE9wdGlvbnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2FydC1yb3cgLmRvLWJ0bicpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBzaXplID0gaXRlbURlbE9wdGlvbnMubGVuZ3RoOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtRGVsT3B0aW9uc1tpXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzLnByZXZpb3VzRWxlbWVudFNpYmxpbmcsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1EZWxXcmFwcGVyID0gZWwucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IGVsLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gJ2hvbWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1EZWxXcmFwcGVyLnF1ZXJ5U2VsZWN0b3IoJy5hY3RpdmUnKS5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgLy9zaG93IGNvdW50cnkgcmVzdHJpY3Rpb24gbWVzc2FnZSBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbmFsU2FsZVJvdyA9IGpRdWVyeShpdGVtRGVsV3JhcHBlcikuY2xvc2VzdCgnLmNhcnQtcm93JykubmV4dCgnLmZpbmFsLXNhbGUtcm93Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbFNhbGVSb3cubGVuZ3RoICYmIGZpbmFsU2FsZVJvdy5maW5kKCcuaXRlbS1yZXN0cmljdGlvbi1tZXNzYWdlcycpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxTYWxlUm93LmZpbmQoJy5pdGVtLXJlc3RyaWN0aW9uLW1lc3NhZ2VzJykucmVtb3ZlQ2xhc3MoJ3Zpc3VhbGx5LWhpZGRlbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbURlbFdyYXBwZXIucXVlcnlTZWxlY3RvcignLmluc3RvcmUtZGVsaXZlcnknKSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgXHRpdGVtRGVsV3JhcHBlci5xdWVyeVNlbGVjdG9yKCcuaW5zdG9yZS1kZWxpdmVyeScpLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYodmFsID09PSAnc3RvcmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1EZWxXcmFwcGVyLnF1ZXJ5U2VsZWN0b3IoJy5zZXQtcHJlZmVycmVkLXN0b3JlJykuY2xpY2soKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyByZXNldCB0aGUgdXVpZFxuICAgICAgICAgICAgICAgIHZhciAkZWwgPSBqUXVlcnkoZWwpO1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZFN0b3JlID0gJGVsLmNsb3Nlc3QoJy5pbnN0b3JlLWRlbGl2ZXJ5JykuZmluZCgnLnNlbGVjdGVkLXN0b3JlLWFkZHJlc3MnKS5kYXRhKCdzdG9yZUlkJyk7XG4gICAgICAgICAgICAgICAgc2VsZi51dWlkID0gJGVsLmNsb3Nlc3QoJy5jYXJ0LXJvdycpLmRhdGEoJ3V1aWQnKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNldERlbGl2ZXJ5T3B0aW9uKGVsLCBzZWxlY3RlZFN0b3JlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgJCgnLmNhcnQtcm93IC5zZXQtcHJlZmVycmVkLXN0b3JlJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHNlbGYudXVpZCA9IHRoaXMuZGF0YXNldC51dWlkO1xuICAgICAgICAgICAgc2VsZi5waWQgPSB0aGlzLmRhdGFzZXQucGlkO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkU3RvcmUgPSAkKHRoaXMpLmNsb3Nlc3QoJy5pbnN0b3JlLWRlbGl2ZXJ5JykuZmluZCgnLnNlbGVjdGVkLXN0b3JlLWFkZHJlc3MnKS5kYXRhKCdzdG9yZUlkJyk7XG5cbiAgICAgICAgICAgIGlmICghVXNlci56aXApIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNhcnRTZWxlY3RTdG9yZShzZWxlY3RlZFN0b3JlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jYXJ0U2VsZWN0U3RvcmUoc2VsZWN0ZWRTdG9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY2FydEludmVudG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcbiAgICBkaWFsb2cgPSByZXF1aXJlKCcuLi9kaWFsb2cnKSxcbiAgICBUUHJvbWlzZSA9IHJlcXVpcmUoJ3Byb21pc2UnKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgbmV3TGluZSA9ICdcXG4nO1xudmFyIHN0b3JlVGVtcGxhdGUgPSBmdW5jdGlvbiAoc3RvcmUsIHNlbGVjdGVkU3RvcmVJZCwgc2VsZWN0ZWRTdG9yZVRleHQpIHtcbiAgICAvL2hhbmRsZXMgZGVwcmVjYXRpb24gYW5kIG9yZ2FuaXphdGlvbiBvZiBzdG9yZSBob3VycyBpbmZvXG5cdFxuICAgIHZhciBzdG9yZUhvdXJzU3RhY2tlZCxcbiAgICAgICAgc3RvcmVIb3Vyc0xvbmcsXG4gICAgICAgIHN0b3JlSG91cnNPbmx5ID0gc3RvcmUuc3RvcmVIb3VycztcblxuICAgIGlmIChzdG9yZUhvdXJzT25seS5pbmRleE9mKCc8YnI+PGJyPicpICE9IC0xKSB7XG4gICAgICAgIHN0b3JlSG91cnNPbmx5ID0gc3RvcmUuc3RvcmVIb3Vycy5zcGxpdCgnPGJyPjxicj4nKVswXTtcbiAgICB9XG4gICAgaWYgKHN0b3JlSG91cnNPbmx5LmluZGV4T2YoJzxiciAvPjxiciAvPicpICE9IC0xKSB7XG4gICAgICAgIHN0b3JlSG91cnNPbmx5ID0gc3RvcmUuc3RvcmVIb3Vycy5zcGxpdCgnPGJyIC8+PGJyIC8+JylbMF07XG4gICAgfVxuXG5cdHN0b3JlSG91cnNPbmx5ID0gc3RvcmVIb3Vyc09ubHkucmVwbGFjZSgnPGJyPicsICc8YnIgLz4nLCAnZycpO1xuXHRzdG9yZUhvdXJzT25seSA9IHN0b3JlSG91cnNPbmx5LnJlcGxhY2UoJzxiciA+JywgJzxiciAvPicsICdnJyk7XG5cdHN0b3JlSG91cnNTdGFja2VkID0gc3RvcmVIb3Vyc09ubHkucmVwbGFjZSgnPGJyLz4nLCAnPGJyIC8+JywgJ2cnKTtcblx0c3RvcmVIb3Vyc0xvbmcgPSBzdG9yZUhvdXJzU3RhY2tlZC5yZXBsYWNlKCc8YnIgLz4nLCAnLCBcXHUwMEEwJywgJ2cnKTtcblxuICAgIHZhciBzdG9yZVBob25lID0gJyc7ICAgICAgICBcbiAgICBpZiAoc3RvcmUucGhvbmUpIHtcbiAgICBcdHN0b3JlUGhvbmUgPSAnPGJyLz48YSBocmVmPVwidGVsOicgKyBzdG9yZS5waG9uZSArICdcIj4nICsgc3RvcmUucGhvbmUgKyAnPC9hPic7XG4gICAgfVxuXHR2YXIgcUF0dHIgPSBcIlwiO1xuXHRpZihzdG9yZS5hZGRyZXNzMSAgICAhPSBudWxsKSBxQXR0ciArPSBzdG9yZS5hZGRyZXNzMSArIFwiLCBcIjtcblx0aWYoc3RvcmUuYWRkcmVzczIgICAgIT0gbnVsbCkgcUF0dHIgKz0gc3RvcmUuYWRkcmVzczIgKyBcIiwgXCI7XG5cdGlmKHN0b3JlLmNpdHkgICAgICAgICE9IG51bGwpIHFBdHRyICs9IHN0b3JlLmNpdHkgKyBcIiwgXCI7XG5cdGlmKHN0b3JlLnBvc3RhbENvZGUgICE9IG51bGwpIHFBdHRyICs9IHN0b3JlLnBvc3RhbENvZGUgKyBcIiwgXCI7XG5cdGlmKHN0b3JlLnN0YXRlQ29kZSAgICE9IG51bGwpIHFBdHRyICs9IHN0b3JlLnN0YXRlQ29kZSArIFwiLCBcIjtcblx0aWYoc3RvcmUuY291bnRyeUNvZGUgIT0gbnVsbCkgcUF0dHIgKz0gc3RvcmUuY291bnRyeUNvZGU7XG5cdHZhciBnbGluayA9IFwiaHR0cDovL21hcHMuZ29vZ2xlLmNvbS9tYXBzP2hsPWVuJmY9cSZxPVwiICsgZW5jb2RlVVJJKHFBdHRyKTtcblxuICAgIHJldHVybiBbXG4gICAgICAgICc8bGkgY2xhc3M9XCJzdG9yZS10aWxlICcgKyBzdG9yZS5zdG9yZUlkICsgKHN0b3JlLnN0b3JlSWQgPT09IHNlbGVjdGVkU3RvcmVJZCA/ICcgc2VsZWN0ZWQnIDogJycpICsgJ1wiPicsXG4gICAgICAgICcgICAgPHNwYW4gY2xhc3M9XCJyZWNvbW1lbmRlZC1zaG9wLW1zZ1wiPicgKyAneW91ciByZWNvbW1lbmRlZCBzaG9wJyArICc8L3NwYW4+JyxcbiAgICAgICAgJyAgICA8YnV0dG9uIGNsYXNzPVwic2VsZWN0LXN0b3JlLXJhZGlvXCIgZGF0YS1zdG9yZS1pZD1cIicgKyBzdG9yZS5zdG9yZUlkICsgJ1wiJyArXG4gICAgICAgIChzdG9yZS5zdGF0dXNjbGFzcyAhPT0gJ3N0b3JlLWluLXN0b2NrJyA/ICdkaXNhYmxlZD1cImRpc2FibGVkXCInIDogJycpICsgJz4nLFxuICAgICAgICAnICAgIDwvYnV0dG9uPicsXG4gICAgICAgICcgICAgPGRpdiBjbGFzcz1cInN0b3JlLXByaW1hcnktaW5mb1wiPicsXG4gICAgICAgICcgICAgICAgIDxwIGNsYXNzPVwic3RvcmUtbmFtZVwiPicsXG4gICAgICAgICcgICAgICAgICAgICAnICsgc3RvcmUubmFtZSArICc8YnIvPicsXG4gICAgICAgICcgICAgICAgIDwvcD4nLFxuICAgICAgICAnICAgICAgICA8cCBjbGFzcz1cInN0b3JlLWFkZHJlc3NcIj4nLFxuICAgICAgICAnICAgICAgICAgICAgJyArIHN0b3JlLmFkZHJlc3MxICsgJzxici8+JyxcbiAgICAgICAgJyAgICAgICAgICAgICcgKyBzdG9yZS5jaXR5ICsgJywgJyArIHN0b3JlLnN0YXRlQ29kZSArICcgJyArIHN0b3JlLnBvc3RhbENvZGUsXG4gICAgICAgICcgICAgICAgIDwvcD4nLFxuICAgICAgICAnICAgIDwvZGl2PicsXG4gICAgICAgICcgICAgPGRpdiBjbGFzcz1cInN0b3JlLXNlY29uZGFyeS1pbmZvXCI+JyxcbiAgICAgICAgJyAgICAgICAgPHAgY2xhc3M9XCJzdG9yZS1zdGF0dXNcIiBkYXRhLXN0YXR1cz1cIicgKyBzdG9yZS5zdGF0dXNjbGFzcyArICdcIj4nICsgc3RvcmUuc3RhdHVzICsgJzwvcD4nLFxuICAgICAgICAnICAgICAgICA8cCBjbGFzcz1cInN0b3JlLWhvdXJzLXN0YWNrZWRcIj4nICsgc3RvcmVIb3Vyc1N0YWNrZWQgKyAnPC9wPicsXG4gICAgICAgICcgICAgICAgIDxwIGNsYXNzPVwic3RvcmUtaG91cnMtbG9uZ1wiPicgKyBzdG9yZUhvdXJzTG9uZyArICc8L3A+JyxcbiAgICAgICAgJyAgICA8L2Rpdj4nLFxuICAgICAgICAnICAgIDxhIGhyZWY9XCInICsgZ2xpbmsgKyAnXCIgY2xhc3M9XCJzdG9yZS1tYXAtdG9nZ2xlIGRpcmVjdGlvbnNcIiB0YXJnZXQ9XCJfYmxhbmtcIj4nICsgJ01BUCcgKyAnPC9hPicsXG4gICAgICAgICcgICAgPGRpdiBjbGFzcz1cInN0b3JlLW1hcC1jb250YWluZXJcIj4nLFxuICAgICAgICAnICAgICAgIDxkaXYgY2xhc3M9XCJzdG9yZS1tYXBcIj48L2Rpdj4nLFxuICAgICAgICAnICAgIDwvZGl2PicsXG4gICAgICAgICc8L2xpPidcbiAgICBdLmpvaW4obmV3TGluZSk7XG59O1xuXG52YXIgc3RvcmVMaXN0VGVtcGxhdGUgPSBmdW5jdGlvbiAocGlja3VwQ29udGVudCwgc3RvcmVzLCBzZWxlY3RlZFN0b3JlSWQsIHNlbGVjdGVkU3RvcmVUZXh0KSB7XG4gICAgdmFyIHRlbXBsYXRlQ29udGVudCA9ICcnO1xuICAgIGlmIChzdG9yZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBwaWNrdXBDb250ZW50LFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJzdG9yZS1saXN0LWNvbnRhaW5lclwiPicsXG4gICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJzdG9yZXMtYXZhaWxhYmlsaXR5LW1zZ1wiPmF2YWlsYWJsZSBhdCAnICsgc3RvcmVzLmxlbmd0aCArICcgc2hvcHM8L3NwYW4+JyxcbiAgICAgICAgICAgICc8dWwgY2xhc3M9XCJzdG9yZS1saXN0XCI+JyxcbiAgICAgICAgICAgIF8ubWFwKHN0b3JlcywgZnVuY3Rpb24gKHN0b3JlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlVGVtcGxhdGUoc3RvcmUsIHNlbGVjdGVkU3RvcmVJZCwgc2VsZWN0ZWRTdG9yZVRleHQpO1xuICAgICAgICAgICAgfSkuam9pbihuZXdMaW5lKSxcbiAgICAgICAgICAgICc8L3VsPicsXG4gICAgICAgICAgICAnPC9kaXY+J1xuICAgICAgICBdLmpvaW4obmV3TGluZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHBpY2t1cENvbnRlbnQsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cInN0b3JlLWxpc3QtY29udGFpbmVyXCI+JyxcbiAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInN0b3Jlcy1hdmFpbGFiaWxpdHktbXNnXCI+YXZhaWxhYmxlIGF0ICcgKyBzdG9yZXMubGVuZ3RoICsgJyBzaG9wczwvc3Bhbj4nLFxuICAgICAgICAgICAgJzwvZGl2PidcbiAgICAgICAgXS5qb2luKG5ld0xpbmUpO1xuICAgIH1cbn07XG5cbnZhciB6aXBQcm9tcHRUZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICAnPGRpdiBpZD1cInByZWZlcnJlZC1zdG9yZS1wYW5lbFwiPicsXG4gICAgICAgICcgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9XCJ1c2VyLXppcFwiIHBsYWNlaG9sZGVyPVwiJyArIFJlc291cmNlcy5FTlRFUl9aSVAgKyAnXCIgbmFtZT1cInppcENvZGVcIi8+JyxcbiAgICAgICAgJzwvZGl2PidcbiAgICBdLmpvaW4obmV3TGluZSk7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiB0ZXN0IHdoZXRoZXIgemlwY29kZSBpcyB2YWxpZCBmb3IgZWl0aGVyIFVTIG9yIENhbmFkYVxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgemlwY29kZSBpcyB2YWxpZCBmb3IgZWl0aGVyIGNvdW50cnksIGZhbHNlIGlmIGl0J3MgaW52YWxpZCBmb3IgYm90aFxuICoqL1xudmFyIHZhbGlkYXRlWmlwQ29kZSA9IGZ1bmN0aW9uICh6aXBDb2RlKSB7XG4gICAgdmFyIHJlZ2V4ZXMgPSB7XG4gICAgICAgICAgICBjYW5hZGE6IC9eW0FCQ0VHSEpLTE1OUFJTVFZYWV1cXGRbQUJDRUdISktMTU5QUlNUVldYWVpdKCApP1xcZFtBQkNFR0hKS0xNTlBSU1RWV1hZWl1cXGQkL2ksXG4gICAgICAgICAgICB1c2E6IC9eXFxkezV9KC1cXGR7NH0pPyQvXG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgaWYgKCF6aXBDb2RlKSB7IHJldHVybjsgfVxuICAgIF8uZWFjaChyZWdleGVzLCBmdW5jdGlvbiAocmUpIHtcbiAgICAgICAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAocmUpO1xuICAgICAgICB2YWxpZCA9IHJlZ2V4cC50ZXN0KHppcENvZGUpO1xuICAgIH0pO1xuICAgIHJldHVybiB2YWxpZDtcbn07XG5cbnZhciBzdG9yZWludmVudG9yeSA9IHtcbiAgICB6aXBQcm9tcHQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGRpYWxvZy5vcGVuKHtcbiAgICAgICAgICAgIGh0bWw6IHppcFByb21wdFRlbXBsYXRlKCksXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IFJlc291cmNlcy5TVE9SRV9ORUFSX1lPVSxcbiAgICAgICAgICAgICAgICB3aWR0aDogNTAwLFxuICAgICAgICAgICAgICAgIGJ1dHRvbnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IFJlc291cmNlcy5TRUFSQ0gsXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgemlwQ29kZSA9ICQoJyN1c2VyLXppcCcpLnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlWmlwQ29kZSh6aXBDb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0VXNlclppcCh6aXBDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soemlwQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgb3BlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAkKCcjdXNlci16aXAnKS5vbigna2V5cHJlc3MnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUud2hpY2ggPT09IDEzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJpZ2dlciB0aGUgc2VhcmNoIGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJy51aS1kaWFsb2ctYnV0dG9uc2V0IC51aS1idXR0b24nKS50cmlnZ2VyKCdjbGljaycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0U3RvcmVzSW52ZW50b3J5OiBmdW5jdGlvbiAocGlkKSB7XG4gICAgICAgIHJldHVybiBUUHJvbWlzZS5yZXNvbHZlKCQuYWpheCh7XG4gICAgICAgICAgICB1cmw6IHV0aWwuYXBwZW5kUGFyYW1zVG9VcmwoVXJscy5zdG9yZXNJbnZlbnRvcnksIHtcbiAgICAgICAgICAgICAgICBwaWQ6IHBpZCxcbiAgICAgICAgICAgICAgICB6aXBDb2RlOiBVc2VyLnppcCxcbiAgICAgICAgICAgICAgICBzdG9yZUlkOiBVc2VyLnN0b3JlSWRcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJ1xuICAgICAgICB9KSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gb3BlbiB0aGUgZGlhbG9nIHRvIHNlbGVjdCBzdG9yZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9wdGlvbnMuc3RvcmVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuc2VsZWN0ZWRTdG9yZUlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuc2VsZWN0ZWRTdG9yZVRleHRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLmNvbnRpbnVlQ2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNlbGVjdFN0b3JlQ2FsbGJhY2tcbiAgICAgKiovXG4gICAgc2VsZWN0U3RvcmVEaWFsb2c6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIFVzZXIuc3RvcmVzID0gb3B0aW9ucy5zdG9yZXM7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHBpZCA9IG9wdGlvbnMucGlkLFxuICAgICAgICAgICAgcGlja3VwQ29udGVudCA9IG9wdGlvbnMucGlja3VwQ29udGVudCxcbiAgICAgICAgICAgIHNlbGVjdGVkU3RvcmVJZCA9IG9wdGlvbnMuc2VsZWN0ZWRTdG9yZUlkLFxuICAgICAgICAgICAgc2VsZWN0ZWRTdG9yZVRleHQgPSBvcHRpb25zLnNlbGVjdGVkU3RvcmVUZXh0LFxuICAgICAgICAgICAgc3RvcmVMaXN0ID0gc3RvcmVMaXN0VGVtcGxhdGUocGlja3VwQ29udGVudCwgVXNlci5zdG9yZXMsIHNlbGVjdGVkU3RvcmVJZCwgc2VsZWN0ZWRTdG9yZVRleHQpLFxuICAgICAgICAgICAgZGlhbG9nV2lkdGggPSAod2luZG93LmlubmVyV2lkdGggPCA3MDgpID8gKHdpbmRvdy5pbm5lcldpZHRoKS50b1N0cmluZygpIDogJzY2OCc7XG5cbiAgICAgICAgZGlhbG9nLm9wZW4oe1xuICAgICAgICAgICAgaHRtbDogc3RvcmVMaXN0LFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIGJ1dHRvbnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IFJlc291cmNlcy5DT05USU5VRV9XSVRIX1NUT1JFLFxuICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udGludWVDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY29udGludWVDYWxsYmFjayhVc2VyLnN0b3Jlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBkaWFsb2dXaWR0aCxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogeyBteTogXCJ0b3BcIiwgYXQ6IFwidG9wKzEwMFwiLCBvZjogd2luZG93IH0sXG4gICAgICAgICAgICAgICAgZGlhbG9nQ2xhc3M6ICdzdG9yZS1waWNrdXAtZGlhbG9nJyxcbiAgICAgICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICQoJ2JvZHknKS5yZW1vdmVDbGFzcygnc3RvcmUtcGlja3VwLWRpYWxvZy1vcGVuZWQnKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBcdCQoXCIjc2hvd1N0b3Jlc0Zvcm1cIikudmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICBcdCQoJy5waWNrdXAtcHJvZHVjdC1hdHRyaWJ1dGUucFF1YW50aXR5IC52YWx1ZScpLmh0bWwoJCgnI3BkcFF0eVNlbGVjdFNlbGVjdEJveEl0VGV4dCcpLmh0bWwoKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXRTdG9yZUV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgnLnNlbGVjdC1zdG9yZS1yYWRpbycpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZUlkID0gJCh0aGlzKS5kYXRhKCdzdG9yZUlkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHN0b3JlIGlzIGFscmVhZHkgc2VsZWN0ZWQsIGRvbid0IHNlbGVjdCBhZ2FpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghJCh0aGlzKS5wYXJlbnQoKS5oYXNDbGFzcygnc2VsZWN0ZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCcuc3RvcmUtbGlzdCAuc3RvcmUtdGlsZS5zZWxlY3RlZCcpLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJy5zdG9yZS10aWxlJykuYWRkQ2xhc3MoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNlbGVjdFN0b3JlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2VsZWN0U3RvcmVDYWxsYmFjayhzdG9yZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAkKCcuc3RvcmUtbWFwLXRvZ2dsZScpLm5vdCgnLmRpcmVjdGlvbnMnKS5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFwQ29udGFpbmVyID0gJCh0aGlzKS5jbG9zZXN0KCQoJy5zdG9yZS10aWxlJykpLmZpbmQoJCgnLnN0b3JlLW1hcCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBDb250YWluZXIudG9nZ2xlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS50b2dnbGVDbGFzcygndmlzaWJsZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykuY2xvc2VzdCgkKCcuc3RvcmUtdGlsZScpKS5maW5kKCQoJy5zdG9yZS1tYXAtY29udGFpbmVyJykpLnRvZ2dsZUNsYXNzKCd2aXNpYmxlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXBDb250YWluZXIuY2hpbGRyZW4oKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcCA9IG5ldyBnb29nbGUubWFwcy5NYXAobWFwQ29udGFpbmVyWzBdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6b29tOiA4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2VvY29kZXIgPSBuZXcgZ29vZ2xlLm1hcHMuR2VvY29kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkZHJlc3MgPSAkKHRoaXMpLmNsb3Nlc3QoJCgnLnN0b3JlLXRpbGUnKSkuZmluZCgkKCcuc3RvcmUtYWRkcmVzcycpKVswXS5pbm5lclRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb2NvZGVyLmdlb2NvZGUoeydhZGRyZXNzJzogYWRkcmVzc30sIGZ1bmN0aW9uKHJlc3VsdHMsIHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ09LJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5zZXRDZW50ZXIocmVzdWx0c1swXS5nZW9tZXRyeS5sb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmtlciA9IG5ldyBnb29nbGUubWFwcy5NYXJrZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXA6IG1hcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHJlc3VsdHNbMF0uZ2VvbWV0cnkubG9jYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoJ0dlb2NvZGUgd2FzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZm9sbG93aW5nIHJlYXNvbjogJyArIHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVN0b3JlTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB6aXBDb2RlID0gJCgnLnppcC1pbnB1dCcpLnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heERpc3RhbmNlID0gJCgnLmRpc3RhbmNlLWlucHV0JykudmFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVaaXBDb2RlKHppcENvZGUpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSB3YW50IHRvIHNob3cgY3VzdG9tZXIncyBQcmVmZXJyZWQgU3RvcmUgYXQgdGhlIHRvcCBvZiB0aGUgc3RvcmVzIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBldmVuIGlmIHByZWZlcnJlZCBzdG9yZSB6aXAgY29kZSBpcyBvdXQgb2Ygc2VhcmNoIHJhbmdlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBwZXJmb3JtIHN0b3JlcyBzZWFyY2ggYnkgemlwIGFuZCBtYXggZGlzdGFuY2UgYXQgZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyB0aGUgUHJlZmVycmVkIFN0b3JlIGluIHRoZSBzZWFyY2ggcmVzdWx0cywgbm8gYWRkaXRpb25hbCByZXF1ZXN0IGlzIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgZ2V0IFByZWZlcnJlZCBTdG9yZSBkYXRhIGFuZCBhZGQgaXQgdG8gdGhlIGZpcnN0IHBvc2l0aW9uIGluIHRoZSBzZWFyY2ggcmVzdWx0c1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvbWlzZSB0byBnZXQgc3RvcmVzIG5lYXIgdGhlIHByb3ZpZGVkIHppcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZXNQcm9taXNlID0gVFByb21pc2UucmVzb2x2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHV0aWwuYXBwZW5kUGFyYW1zVG9VcmwoVXJscy5zdG9yZXNJbnZlbnRvcnksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6aXBDb2RlOiB6aXBDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heERpc3RhbmNlOiBtYXhEaXN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWQ6IHBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZUlkOiBVc2VyLnN0b3JlSWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByb21pc2UgdG8gZ2V0IHByZWZlcnJlZCBzdG9yZSBJRCBhbmQgemlwIGZvciBsb2dnZWQgaW4gY3VzdG9tZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGl0IHJlc29sdmVzIHdpdGggYW4gZW1wdHkgb2JqZWN0IGZvciBub3QgbG9nZ2VkIGluIGN1c3RvbWVycylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJlZmVycmVkU3RvcmVJZFByb21pc2UgPSBUUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogVXJscy5nZXRQcmVmZXJyZWRTdG9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUUHJvbWlzZS5hbGwoW3N0b3Jlc1Byb21pc2UsIHByZWZlcnJlZFN0b3JlSWRQcm9taXNlXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmVzID0gcmVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZWZTdG9yZUlkUmVzcG9uc2UgPSByZXNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJlZlN0b3JlUHJvbWlzZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZTdG9yZUlkUmVzcG9uc2Uuc3RvcmVJZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIFByZWZlcnJlZCBTdG9yZSBpcyBwcmVzZW50IGluIHRoZSBzdG9yZSBsaXN0IGFscmVhZHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZWZTdG9yZUlkeCA9IF8uZmluZEluZGV4KHN0b3JlcywgeyAnc3RvcmVJZCc6IHByZWZTdG9yZUlkUmVzcG9uc2Uuc3RvcmVJZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZlN0b3JlSWR4ICE9PSAtMSAmJiBwcmVmU3RvcmVJZHggIT09IDApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBzbywgZ2V0IHByZWZlcnJlZCBzdG9yZSBmcm9tIHRoZSBzdG9yZXMgbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJlZlN0b3JlID0gc3RvcmVzLnNwbGljZShwcmVmU3RvcmVJZHgsIDEpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVmU3RvcmVQcm9taXNlID0gVFByb21pc2UucmVzb2x2ZShwcmVmU3RvcmUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGdldCB0aGUgUHJlZmVycmVkIFN0b3JlIGRhdGEgZnJvbSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZlN0b3JlUHJvbWlzZSA9IFRQcm9taXNlLnJlc29sdmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1dGlsLmFwcGVuZFBhcmFtc1RvVXJsKFVybHMuc3RvcmVzSW52ZW50b3J5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHppcENvZGU6IHByZWZTdG9yZUlkUmVzcG9uc2Uuc3RvcmVaaXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heERpc3RhbmNlOiAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGlkOiBwaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKS50aGVuKGZ1bmN0aW9uKHByZWZTdG9yZXNSZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLmZpbmQocHJlZlN0b3Jlc1JlcywgeyAnc3RvcmVJZCc6IHByZWZTdG9yZUlkUmVzcG9uc2Uuc3RvcmVJZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZTdG9yZVByb21pc2UgPSBUUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVmU3RvcmVQcm9taXNlLnRoZW4oZnVuY3Rpb24ocHJlZlN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZTdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZXMudW5zaGlmdChwcmVmU3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVc2VyLnN0b3JlcyA9IHN0b3JlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCcuc3RvcmUtbGlzdC1jb250YWluZXInKS5lbXB0eSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJy5zdG9yZS1saXN0LWNvbnRhaW5lcicpLmFwcGVuZCgnPHNwYW4gY2xhc3M9XCJzdG9yZXMtYXZhaWxhYmlsaXR5LW1zZ1wiPmF2YWlsYWJsZSBhdCAnICsgc3RvcmVzLmxlbmd0aCArICcgc2hvcHM8L3NwYW4+Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3Jlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnLnN0b3JlLWxpc3QtY29udGFpbmVyJykuYXBwZW5kKCc8ZGl2IGNsYXNzPVwic3RvcmUtbGlzdFwiPjwvZGl2PicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCcuc3RvcmUtbGlzdCcpLmFwcGVuZChfLm1hcChzdG9yZXMsIGZ1bmN0aW9uIChzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlVGVtcGxhdGUoc3RvcmUsIHNlbGVjdGVkU3RvcmVJZCwgc2VsZWN0ZWRTdG9yZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5qb2luKG5ld0xpbmUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U3RvcmVFdmVudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnLnNlbGVjdC1zdG9yZS1yYWRpbycpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50RWwgPSB0aGlzLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJCh0aGlzKS5kYXRhKCdzdG9yZUlkJykgPT0gVXNlci5zdG9yZUlkIHx8IHBhcmVudEVsLmNsYXNzTGlzdC5jb250YWlucygnc2VsZWN0ZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEVsLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5jbGljaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnLnNob3ctbW9yZScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgQWxsT3RoZXIgPSBwYXJzZUludChzdG9yZXMubGVuZ3RoLTMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmVzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJy51aS1kaWFsb2ctYnV0dG9uc2V0JykuYXBwZW5kKCc8YnV0dG9uIGNsYXNzPVwic2hvdy1tb3JlIG1vcmUtYnRuXCI+dmlldyBhbGwgU0hPUFMgKCcrQWxsT3RoZXIrJykrPC9idXR0b24+Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3QgPSAkKCcuc3RvcmUtbGlzdCAuc3RvcmUtdGlsZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnVtVG9TaG93ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbiA9ICQoJy5zaG93LW1vcmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG51bUluTGlzdCA9IGxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNTaG93aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3Quc2xpY2UoMCwgbnVtVG9TaG93KS5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbkZhZGVDb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vd1Nob3dpbmcgPSBsaXN0LmZpbHRlcignOnZpc2libGUnKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihub3dTaG93aW5nID09IG51bUluTGlzdCAmJiBpc1Nob3dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1Nob3dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b24udGV4dCgndmlldyBsZXNzIFNIT1BTJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihub3dTaG93aW5nID09IG51bVRvU2hvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi50ZXh0KCd2aWV3IGFsbCBTSE9QUyAoJysgQWxsT3RoZXIrJykrJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTaG93aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b24uY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2hvd2luZyA9IGxpc3QuZmlsdGVyKCc6dmlzaWJsZScpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGlzU2hvd2luZyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5zbGljZShzaG93aW5nIC0gMSwgc2hvd2luZyArIG51bVRvU2hvdykuZmFkZUluKDEwMCxvbkZhZGVDb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3Quc2xpY2UobnVtVG9TaG93ICwgbnVtSW5MaXN0KS5mYWRlT3V0KDEwMCxvbkZhZGVDb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAkKCcjc2hvd1N0b3Jlc0Zvcm0nKS5vbignc3VibWl0JywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlU3RvcmVMaXN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICQoJy5kaXN0YW5jZS1pbnB1dCcpLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTdG9yZUxpc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJy5kaXN0YW5jZS1pbnB1dC1sYWJlbCcpWzBdLmlubmVySFRNTCA9ICdSYWRpdXM6ICcgKyAkKCcuZGlzdGFuY2UtaW5wdXQgb3B0aW9uOnNlbGVjdGVkJylbMF0udmFsdWUgKyAnIG1pbGVzJztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAkKCcuemlwLWlucHV0Jykub24oJ2NoYW5nZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVN0b3JlTGlzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgnLmRpc3RhbmNlLWlucHV0LWxhYmVsJylbMF0uaW5uZXJIVE1MID0gJ1JhZGl1czogJyArICQoJy5kaXN0YW5jZS1pbnB1dCBvcHRpb246c2VsZWN0ZWQnKVswXS52YWx1ZSArICcgbWlsZXMnO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRTdG9yZUV2ZW50cygpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2luaXRpYWxpemUgZGlzcGxheSBvZiBkaXN0YW5jZSBhbmQgemlwY29kZSB1c2VkXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICQoJy5kaXN0YW5jZS1pbnB1dC1sYWJlbCcpWzBdLmlubmVySFRNTCA9ICdSYWRpdXM6ICcgKyAkKCcuZGlzdGFuY2UtaW5wdXQgb3B0aW9uOnNlbGVjdGVkJylbMF0udmFsdWUgKyAnIG1pbGVzJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogVXJscy5nZXRaaXBDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVswXS51c2VyRGVmYXVsdFppcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnaW5wdXQuemlwLWlucHV0JykudmFsKHJlc3BvbnNlWzBdLnVzZXJEZWZhdWx0WmlwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZVswXS56aXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJ2lucHV0LnppcC1pbnB1dCcpLnZhbChyZXNwb25zZVswXS56aXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQoJ2lucHV0LnppcC1pbnB1dCcpLnZhbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCcjc2hvd1N0b3Jlc0Zvcm0nKS50cmlnZ2VyKCdzdWJtaXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpe1xuICAgICAgICAgICAgdmFyIHRvcE9mZnNldCA9ICgkKHdpbmRvdykud2lkdGgoKSA8IDcwOCkgPyA2MSA6ICgoJCh3aW5kb3cpLndpZHRoKCkgLSA3MDgpIC8gMikgKyA2MTtcbiAgICAgICAgICAgIGlmICh0b3BPZmZzZXQgPiAxMDApIHtcbiAgICAgICAgICAgICAgICB0b3BPZmZzZXQgPSAxMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b3BPZmZzZXQgPSAkKHdpbmRvdykuc2Nyb2xsVG9wKCkgKyB0b3BPZmZzZXQ7XG4gICAgICAgICAgICAkKCcudWktZGlhbG9nJykuY3NzKCd0b3AnLCB0b3BPZmZzZXQudG9TdHJpbmcoKSArICdweCcpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAkKCdib2R5JykuYWRkQ2xhc3MoJ3N0b3JlLXBpY2t1cC1kaWFsb2ctb3BlbmVkJyk7XG4gICAgICAgIH0sIDUwKTtcblxuICAgIH0sXG4gICAgc2V0VXNlclppcDogZnVuY3Rpb24gKHppcCkge1xuICAgICAgICBVc2VyLnppcCA9IHppcDtcbiAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICAgIHVybDogVXJscy5zZXRaaXBDb2RlLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHppcENvZGU6IHppcFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIHNoaXBwaW5nTG9hZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJGNoZWNrb3V0Rm9ybSA9ICQoJy5hZGRyZXNzJyk7XG4gICAgICAgICRjaGVja291dEZvcm0ub2ZmKCdjbGljaycpO1xuICAgICAgICAkY2hlY2tvdXRGb3JtLm9uKCdjbGljaycsICdpbnB1dFtuYW1lJD1cIl9zaGlwcGluZ0FkZHJlc3NfaXNHaWZ0XCJdJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5zaWJsaW5ncygnLmdpZnQtbWVzc2FnZS10ZXh0JykudG9nZ2xlQ2xhc3MoJ2hpZGRlbicsICQoJ2lucHV0W25hbWUkPVwiX3NoaXBwaW5nQWRkcmVzc19pc0dpZnRcIl06Y2hlY2tlZCcpLnZhbCgpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdG9yZWludmVudG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBkaWFsb2cgPSByZXF1aXJlKCcuLi9kaWFsb2cnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyICRjYWNoZSA9IHtcblx0cGRwTWFpbiA6ICQoJyNwZHBNYWluJyksXG5cdHBkcEZvcm0gOiAkKFwiI3BkcE1haW4gZm9ybS5wZHBGb3JtXCIpLFxuXHRwcm9kdWN0VGh1bWJuYWlsVGlsZXM6ICQoJyNwZHBNYWluJykuZmluZCgnI3RodW1ibmFpbHMgLnRodW1iJyksXG5cdGFkZEFsbFRvQ2FydCA6ICQoJyNhZGQtYWxsLXRvLWNhcnQnKSxcblx0cHJvZHVjdFNldExpc3QgOiAkKFwiLnByb2R1Y3Qtc2V0LWxpc3RcIiksXG5cblx0Ly9tb25vZ3JhbW1pbmdcblx0bW9ub2dyYW1jb250YWluZXIgOiAkKCcjcGRwTWFpbiAubW9ub2dyYW0tY29udGFpbmVyJyksXG5cdG1vbm9ncmFtZm9ybWZpZWxkcyA6ICQoJy5tb25vZ3JhbS1mb3JtLWZpZWxkcycpLFxuXG5cdC8vIG1vbm9ncmFtbWluZyBzdHlsZSBjb250YWluZXJcblx0bW9ub2dyYW1zdHlsZXMgOiAkKCcjcGRwTWFpbiAubW9ub2dyYW0tY29udGFpbmVyJykuZmluZCgndWwubW9ub2dyYW0tc3R5bGVzJyksXG5cdG1vbm9ncmFtc3R5bGV0aWxlcyA6ICQoJyNwZHBNYWluIC5tb25vZ3JhbS1jb250YWluZXInKS5maW5kKCdsaS5tb25vZ3JhbS1zdHlsZS10aWxlJyksXG5cdHNlbGVjdGVkU3R5bGVDb25maWcgOiBudWxsLFxuXG5cdC8vIG9wdGlvbnNcblx0bW9ub2dyYW1pbmdvcHRpb25zY29udGFpbmVyIDogJCgnI3BkcE1haW4gLm1vbm9ncmFtLWNvbnRhaW5lcicpLmZpbmQoJy5tb25vZ3JhbS1vcHRpb25zLWNvbnRhaW5lcicpLFxuXG5cdC8vIGZvbnRcblx0bW9ub2dyYW1mb250c2VsZWN0IDogJCgnI3BkcE1haW4gLm1vbm9ncmFtLWNvbnRhaW5lcicpLmZpbmQoJy5tb25vZ3JhbS1mb250LXNlbGVjdCcpLFxuXHRmb250dGlsZWJhc2UgOiAkKCcjcGRwTWFpbiAubW9ub2dyYW0tY29udGFpbmVyJykuZmluZCgnLm1vbm9ncmFtLWZvbnQtYmFzZS52aXN1YWxseS1oaWRkZW4nKS5jbG9uZSgpLFxuXG5cdC8vIGNoYXJhY3RlcnNcblx0bW9ub2dyYW10ZXh0aW5wdXRjb250YWluZXIgOiAkKCcjcGRwTWFpbiAubW9ub2dyYW0tY29udGFpbmVyJykuZmluZCgnLm1vbm9ncmFtLXRleHQtaW5wdXQtY29udGFpbmVyJyksXG5cdG1vbm9ncmFtdGV4dHRpdGxlIDogJCgnI3BkcE1haW4gLm1vbm9ncmFtLWNvbnRhaW5lcicpLmZpbmQoJy50ZXh0LWlucHV0LXRpdGxlJyksXG5cdG1vbm9ncmFtdGV4dGlucHV0Ym9keSA6ICQoJyNwZHBNYWluIC5tb25vZ3JhbS1jb250YWluZXInKS5maW5kKCcubW9ub2dyYW0tdGV4dC1pbnB1dC1ib2R5JyksXG5cdG1vbm9ncmFtaW5wdXRiYXNlIDogJCgnI3BkcE1haW4gLm1vbm9ncmFtLWNvbnRhaW5lcicpLmZpbmQoJy5tb25vZ3JhbS10ZXh0LWlucHV0LXdyYXBwZXInKS5jbG9uZSgpLFxuXHRmb2N1c2VkaW5wdXQgOiBudWxsLC8vIHVzZWQgYXMgYSBjb250YWluZXIgZm9yIHRoZSBjdXJyZW50bHlcblx0XHRcdFx0XHRcdFx0XHQvLyBmb2N1c2VkIGlucHV0LCB0byBhbGxvdyBzeW1ib2xzIHRvIGJlXG5cdFx0XHRcdFx0XHRcdFx0Ly8gYWRkZWQgdGhlcmVcblx0bW9ub2dyYW10ZXh0aW5wdXRjbGVhciA6ICQoJyNwZHBNYWluIC5tb25vZ3JhbS1jb250YWluZXInKS5maW5kKCcubW9ub2dyYW0tdGV4dC1pbnB1dC1jbGVhcicpLFxuXG5cdC8vIHN5bWJvbHNcblx0bW9ub2dyYW1zeW1ib2xsaXN0IDogJCgnI3BkcE1haW4gLm1vbm9ncmFtLWNvbnRhaW5lcicpLmZpbmQoJy5tb25vZ3JhbS1zeW1ib2wtbGlzdCcpLFxuXHRtb25vZ3JhbXN5bWJvbHNlbGVjdGlvbmNvbnRhaW5lciA6ICQoJyNwZHBNYWluIC5tb25vZ3JhbS1jb250YWluZXInKS5maW5kKCcubW9ub2dyYW0tc3ltYm9sLXNlbGVjdGlvbi1jb250YWluZXInKSxcblx0c3ltYm9sYmFzZSA6ICQoJyNwZHBNYWluIC5tb25vZ3JhbS1jb250YWluZXInKS5maW5kKCcubW9ub2dyYW0tc3ltYm9sLWJhc2UudmlzdWFsbHktaGlkZGVuJykuY2xvbmUoKSxcblxuXHQvLyBkb3RzXG5cdG1vbm9ncmFtZG90c2NvbnRhaW5lciA6ICQoJyNwZHBNYWluIC5tb25vZ3JhbS1jb250YWluZXInKS5maW5kKCdkaXYubW9ub2dyYW0tZG90cy1jb250YWluZXInKSxcblx0bW9ub2dyYW1kb3Rzb3B0aW9ucyA6ICQoJyNwZHBNYWluIC5tb25vZ3JhbS1jb250YWluZXInKS5maW5kKCdsaS5kb3RzLW9wdGlvbicpLFxuXG5cdC8vIGNvbG9yc1xuXHRtb25vZ3JhbWNvbG9ycyA6ICQoJyNwZHBNYWluIC5tb25vZ3JhbS1jb250YWluZXInKS5maW5kKCdsaS5tb25vZ3JhbS1jb2xvci1zd2F0Y2gnKVxuXG5cbn07XG5mdW5jdGlvbiBpbml0aWFsaXplRXZlbnRzKCl7XG5cdGlmKCRjYWNoZS5wZHBNYWluLmxlbmd0aCA+IDApe1xuXHRcdCQoXCIjcGRwTWFpbiwgI3F1aWNrLXZpZXctZGlhbG9nXCIpLm9uKFwiY2xpY2tcIiwgXCIucHJvZHVjdC10aHVtYm5haWxzIGxpIGFcIiwgZnVuY3Rpb24oZSkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHR2YXIgdmFyaWF0aW9ucyA9ICQoJy5wcm9kdWN0LXZhcmlhdGlvbnMnKTtcblxuXHRcdFx0Ly8gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIENsb3VkWm9vbVxuXHRcdFx0dmFyIGN6ID0gJChcIi5jbG91ZHpvb21cIikuZGF0YShcIkNsb3VkWm9vbVwiKTtcblxuXHRcdFx0Ly8gR2V0IHNlbGVjdGVkIGltYWdlIHNyY1xuXHRcdFx0dmFyIHNyYyA9ICQodGhpcykuZmluZCgnaW1nJykuYXR0cignc3JjJyk7XG5cdFx0XHR2YXIgcGRwSW1nID0gJCgnLnByaW1hcnktaW1hZ2UuY2xvdWR6b29tJyk7XG5cblx0XHRcdC8vIExvYWQgYSBuZXcgc21hbGwgaW1hZ2UgYW5kIHpvb20gaW1hZ2UgaW50byBpdDpcblx0XHRcdHZhciBzbWFsbEltZyA9IHNyYy5yZXBsYWNlKFwiJHByb2R1Y3RUaHVtYm5haWwkXCIsIFwiJGxhcmdlJFwiKTtcblx0ICAgICAgICB2YXIgem9vbUltZyA9IHNtYWxsSW1nLnJlcGxhY2UoXCIkbGFyZ2UkXCIsIFwiJHM3ZnVsbHNpemUkXCIpO1xuXG5cdCAgICAgICAgLy8gTG9hZCBuZXcgaW1hZ2VzIGludG8gQ2xvdWRab29tIGluc3RhbmNlXG5cdCAgICAgICAgdmFyIGlzUXVpY2tWaWV3ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciAkcXZjb250YWluZXIgPSAkKCcjcXVpY2stdmlldy1kaWFsb2cnKTtcblx0XHRcdFx0cmV0dXJuICgkcXZjb250YWluZXIubGVuZ3RoPjApO1xuXHRcdFx0fTtcblx0ICAgICAgICBpZighaXNRdWlja1ZpZXcpe1xuXHQgICAgICAgIFx0Y3oubG9hZEltYWdlKHNtYWxsSW1nLCB6b29tSW1nKTtcblx0ICAgICAgICB9XG5cdFx0fSk7XG5cblx0XHRpZiAoJGNhY2hlLnBkcE1haW4uZmluZCgnI3RodW1ibmFpbHMgbGknKS5sZW5ndGggPD0gNCkge1xuXHRcdFx0JCgnI3RodW1ibmFpbHMgLmpjYXJvdXNlbC1jb250cm9sLXByZXYnKS5oaWRlKCk7XG5cdFx0XHQkKCcjdGh1bWJuYWlscyAuamNhcm91c2VsLWNvbnRyb2wtbmV4dCcpLmhpZGUoKTtcblx0XHR9XG5cblx0XHRpZih3aW5kb3cuaW5uZXJXaWR0aCA8IDk2MCl7XG5cdFx0XHQkKCcjc29jaWFsLXByb2R1Y3Qtc2V0ICNzb2NpYWwtaGVhZGVyJykuY2xpY2soZnVuY3Rpb24oKXtcblx0XHRcdFx0JCgnI3NvY2lhbC1wcm9kdWN0LXNldCAuc29jaWFsLWljb25zJykuc2xpZGVUb2dnbGUoKTtcblx0XHRcdH0pXG5cdFx0fVxuXHR9XG5cdCQoJ2JvZHknKS5vbignY2xpY2snLCAnLnR3aXR0ZXItc2hhcmUgYScsIGZ1bmN0aW9uKGUpe1xuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0fSk7XG4gICAgJGNhY2hlLnBkcE1haW4ub2ZmKFwiY2xpY2suc3dhdGNoZXNcIilcblx0Lm9uKFwiY2xpY2suc3dhdGNoZXNcIiwgXCJkaXYucHJvZHVjdC1kZXRhaWwgYS5zd2F0Y2hhbmNob3IsIGRpdi5wcm9kdWN0LXNldC1kZXRhaWxzIGEuc3dhdGNoYW5jaG9yXCIsIGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gRklYTUU6IGV2ZXJ5IHRpbWUgdGhlIHZhcmlhdGlvbiBjaGFuZ2VzLCBhbiBhZGRpdGlvbmFsIGxpc3RlbmVyIGlzIGFkZGVkLlxuXHRcdC8vIFRoaXMgaXMgZHVlIHRvIHRoZSB2YXJpYXRpb24uanMgYWxzbyBhcHBseWluZyBsaWtlIGV2ZW50cy5cblx0XHQvLyBUaGUgZnVuY3Rpb25hbGl0eSBmcm9tIHRoaXMgZmlsZSBzaG91bGQgYmUgbW92ZWQgaW50byB2YXJpYW50LmpzLCBvciBvdGhlciBzcGVjaWZpYyBzdWItbmFtZXNwYWNlIChnaWZ0Y2FyZC5qcywgcHJvZHVjdHNldC5qcywgYW5kIHRoZSBsaWtlKS5cblx0XHQvLyBwcm9kdWN0LmpzIHNob3VsZCBiZSBTdG9yZSBJbnZlbnRvcnkgc3BlY2lmaWMhXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0dmFyIGFuY2hvciA9ICQodGhpcyksXG5cdFx0XHRwYXJlbnRMaXN0ID0gYW5jaG9yLnBhcmVudChcImxpXCIpLFxuXHRcdFx0cXR5ID0gJCgnLnBkcEZvcm0gc2VsZWN0W25hbWU9XCJRdWFudGl0eVwiXScpLmZpcnN0KCkudmFsKCksXG5cdFx0XHRwcm9kdWN0U2V0ID0gJChhbmNob3IpLmNsb3Nlc3QoJy5wcm9kdWN0LXNldC1pdGVtJyksXG5cdFx0XHRpc1Byb2R1Y3RTZXQgPSBwcm9kdWN0U2V0Lmxlbmd0aCA+IDAsXG5cdFx0XHRwYXJhbXMgPSB7XG5cdFx0XHRcdFF1YW50aXR5IDogaXNOYU4ocXR5KSA/IFwiMVwiIDogcXR5XG5cdFx0XHR9LFxuXHRcdFx0cGFyZW50ID0gYW5jaG9yLmNsb3Nlc3QoXCJ1bC5zd2F0Y2hlc1wiKSxcblx0XHRcdGF0dHJpYnV0ZUNvbnRhaW5lciA9IHBhcmVudC5jbG9zZXN0KCdsaScpLFxuXHRcdFx0aXNDb2xvciA9IHBhcmVudC5oYXNDbGFzcyhcIkNvbG9yXCIpLFxuXHRcdFx0Y29udGFpbmVyID0gcGFyZW50LmNsb3Nlc3QoJy5wcm9kdWN0LXZhcmlhdGlvbnMnKSxcblx0XHRcdGlucHV0SWQgPSBjb250YWluZXIuZmluZCgnaW5wdXRbbmFtZT1waWRdJyk7XG5cblx0XHRpZiAoaXNQcm9kdWN0U2V0KSB7XG5cdFx0XHQvLyB1cGRhdGVQcm9kdWN0U2V0KGFuY2hvcik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gcGF1c2UgYW5kIHJlcG9zaXRpb24gZmxvd3BsYXllciBpZiBjdXJyZW50bHkgYWN0aXZlXG5cdFx0dHJ5e1xuXHRcdFx0aWYoZmxvd3BsYXllciAmJiBmbG93cGxheWVyKCkpe1xuXHRcdFx0XHR2YXIgdmlkZW9QbGF5ZXIgPSAkKCcuZmxvd3BsYXllci1jb250YWluZXInKTtcblx0XHRcdFx0aWYodmlkZW9QbGF5ZXIuY2hpbGRyZW4oKS5sZW5ndGggIT0gMCl7XG5cdFx0XHRcdFx0dmlkZW9QbGF5ZXIuY3NzKCd0b3AnLCctOTk5cHgnKS5jc3MoJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGNhdGNoKGUpIHtcblxuXHRcdH1cblxuXG5cdFx0Ly8gRG9uJ3QgYWxsb3cgcHJlc2VsZWN0aW9uIG9mIGEgbW9ub2dyYW0gY29sb3IgdW5sZXNzIHRleHQgaXMgc3VibWl0dGVkXG5cdFx0aWYocGFyZW50Lmhhc0NsYXNzKCdtb25vZ3JhbScpICYmICQoJ2lucHV0W25hbWU9ZHdmcm1fY3VzdG9taXplcl9tb25vZ3JhbV90ZXh0XScpLnZhbCgpID09ICcnICYmICEkY2FjaGUubW9ub1Jlc2V0KSByZXR1cm4gZmFsc2U7XG5cblxuXHRcdGlmIChwYXJlbnRMaXN0Lmhhc0NsYXNzKFwic2VsZWN0ZWRcIikpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IGVsc2UgaWYgKHBhcmVudExpc3QubGVuZ3RoID4gMCkge1xuXG5cdFx0XHRwYXJlbnRMaXN0LnBhcmVudCgndWwnKS5maW5kKCdsaScpLmVhY2goZnVuY3Rpb24oZSl7XG5cdFx0XHRcdCQodGhpcykucmVtb3ZlQ2xhc3MoXCJzZWxlY3RlZFwiKTtcblxuXHRcdFx0XHQvLyBTZXQgcHJldmlvdXNseSB1biBzZWxlY3RhYmxlIGVsZW1lbnQgYmFjayB0byBpbml0aWFsIHN0YXRlXG5cdFx0XHRcdGlmKCQodGhpcykuaGFzQ2xhc3MoJ3ByZXYtdW5zZWxlY3RhYmxlJykpe1xuXHRcdFx0XHRcdCQodGhpcykuYWRkQ2xhc3MoXCJ1bnNlbGVjdGFibGVcIik7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBzZXQgY2xhc3Mgb2YgcHJldmlvdXNseSB1biBzZWxlY3RhYmxlIGxpXG5cdFx0XHRpZihwYXJlbnRMaXN0Lmhhc0NsYXNzKCd1bnNlbGVjdGFibGUnKSl7XG5cdFx0XHRcdHBhcmVudExpc3QucmVtb3ZlQ2xhc3MoXCJ1bnNlbGVjdGFibGVcIik7XG5cdFx0XHRcdHBhcmVudExpc3QuYWRkQ2xhc3MoXCJwcmV2LXVuc2VsZWN0YWJsZVwiKTtcblx0XHRcdH1cblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHQgICAgcGFyZW50TGlzdC5hZGRDbGFzcyhcInNlbGVjdGVkXCIpO1xuXHRcdFx0fSwgMCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuaHJlZikge1xuXHRcdFx0cmV0dXJuOyAvLyBpZiBubyBocmVmLCB0aGVuIHJldHVyblxuXHRcdH1cblxuXHRcdC8vIGtlZXAgdGhlIGdpZnQgY2FyZCBpbmZvIGludGFjdCB3aGVuIGNoYW5naW5nIHRoZSBnaWZ0IGNhcmQgYW1vdW50XG5cblx0XHR2YXIgZWdpZnRjYXJkID0gJCgnLnBkcEZvcm0gaW5wdXRbbmFtZT1cImVnaWZ0Y2FyZFwiXScpO1xuXHRcdHZhciBnaWZ0Y2FyZCA9ICQoJy5wZHBGb3JtIGlucHV0W25hbWU9XCJnaWZ0Y2FyZFwiXScpO1xuXG5cdFx0ZWdpZnRjYXJkID0gZWdpZnRjYXJkLmxlbmd0aCAmJiBlZ2lmdGNhcmQuZmlyc3QoKS52YWwoKSA9PSAndHJ1ZScgPyB0cnVlIDogZmFsc2U7XG5cdFx0Z2lmdGNhcmQgPSBnaWZ0Y2FyZC5sZW5ndGggJiYgZ2lmdGNhcmQuZmlyc3QoKS52YWwoKSA9PSAndHJ1ZScgPyB0cnVlIDogZmFsc2U7XG5cblx0XHRpZihnaWZ0Y2FyZCB8fCBlZ2lmdGNhcmQpe1xuXG5cdFx0XHR2YXIgZ2NBbW91bnQgPSAkKCcjZ2NBbW91bnQnKS5maXJzdCgpLnZhbCgpO1xuXHRcdFx0aWYoZ2NBbW91bnQpe1xuXHRcdFx0XHRwYXJhbXNbJ2djQW1vdW50J10gPSBnY0Ftb3VudDtcblx0XHRcdH1cblxuXHRcdFx0aWYoZWdpZnRjYXJkKXtcblxuXHRcdFx0XHR2YXIgdmdjUmVjaXBpZW50TmFtZSA9ICQoJy5wZHBGb3JtIGlucHV0W25hbWU9XCJ2Z2NSZWNpcGllbnROYW1lXCJdJykuZmlyc3QoKS52YWwoKTtcblx0XHRcdFx0dmFyIHZnY1JlY2lwaWVudEVtYWlsID0gJCgnLnBkcEZvcm0gaW5wdXRbbmFtZT1cInZnY1JlY2lwaWVudEVtYWlsXCJdJykuZmlyc3QoKS52YWwoKTtcblx0XHRcdFx0dmFyIHZnY0Zyb21OYW1lID0gJCgnLnBkcEZvcm0gaW5wdXRbbmFtZT1cInZnY0Zyb21OYW1lXCJdJykuZmlyc3QoKS52YWwoKTtcblx0XHRcdFx0dmFyIHZnY0Zyb21FbWFpbCA9ICQoJy5wZHBGb3JtIGlucHV0W25hbWU9XCJ2Z2NGcm9tRW1haWxcIl0nKS5maXJzdCgpLnZhbCgpO1xuXHRcdFx0XHR2YXIgdmdjR2lmdENhcmRNZXNzYWdlID0gJCgnLnBkcEZvcm0gdGV4dGFyZWFbbmFtZT1cInZnY0dpZnRDYXJkTWVzc2FnZVwiXScpLmZpcnN0KCkudmFsKCk7XG5cblx0XHRcdFx0aWYodmdjUmVjaXBpZW50TmFtZSl7XG5cdFx0XHRcdFx0cGFyYW1zWyd2Z2NSZWNpcGllbnROYW1lJ10gPSB2Z2NSZWNpcGllbnROYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHZnY1JlY2lwaWVudEVtYWlsKXtcblx0XHRcdFx0XHRwYXJhbXNbJ3ZnY1JlY2lwaWVudEVtYWlsJ10gPSB2Z2NSZWNpcGllbnRFbWFpbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZih2Z2NGcm9tTmFtZSl7XG5cdFx0XHRcdFx0cGFyYW1zWyd2Z2NGcm9tTmFtZSddID0gdmdjRnJvbU5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYodmdjRnJvbUVtYWlsKXtcblx0XHRcdFx0XHRwYXJhbXNbJ3ZnY0Zyb21FbWFpbCddID0gdmdjRnJvbUVtYWlsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHZnY0dpZnRDYXJkTWVzc2FnZSl7XG5cdFx0XHRcdFx0cGFyYW1zWyd2Z2NHaWZ0Q2FyZE1lc3NhZ2UnXSA9IHZnY0dpZnRDYXJkTWVzc2FnZTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBrZWVwIHRoZSBwcm9kdWN0IGxpc3QgaWQgZm9yIHVzZSB3aXRoIHRoZSBnaWZ0IHJlZ2lzdHJ5IHF1aWNrIGVkaXRcblx0XHR2YXIgcHJvZHVjdGxpc3RpZCA9ICQoJy5wZHBGb3JtIGlucHV0W25hbWU9XCJwcm9kdWN0bGlzdGlkXCJdJyk7XG5cdFx0aWYocHJvZHVjdGxpc3RpZC5sZW5ndGgpe1xuXHRcdFx0cGFyYW1zWydwcm9kdWN0bGlzdGlkJ10gPSBwcm9kdWN0bGlzdGlkLmZpcnN0KCkudmFsKCk7XG5cdFx0fVxuXG5cdFx0cGFyYW1zWydwYWdlc291cmNlJ10gPSAkKCcucGRwRm9ybSBpbnB1dFtuYW1lPVwicGFnZXNvdXJjZVwiXScpLmZpcnN0KCkudmFsKCk7XG5cblx0XHR2YXIgdGFyZ2V0ID0gKHByb2R1Y3RTZXQubGVuZ3RoID4gMCAmJiBwcm9kdWN0U2V0LmNoaWxkcmVuLmxlbmd0aCA+IDApID8gcHJvZHVjdFNldCA6IGFuY2hvci5jbG9zZXN0KCcucHJvZHVjdC1kZXRhaWwnKS5maW5kKCcjcHJvZHVjdC1jb250ZW50Jyk7XG5cdFx0dmFyIHRhcmdldGRldGFpbCA9KHByb2R1Y3RTZXQubGVuZ3RoID4gMCAmJiBwcm9kdWN0U2V0LmNoaWxkcmVuLmxlbmd0aCA+IDApID8gcHJvZHVjdFNldCA6IGFuY2hvci5jbG9zZXN0KCcucHJvZHVjdC1zaG9ydC1kZXNjcmlwdGlvbicpLmZpbmQoJyNzaG9ydC1kZXNjcmlwdGlvbicpO1xuXHRcdHZhciBuZXdIcmVmID0gdGhpcy5ocmVmO1xuXG5cdFx0dmFyIHNlbGVjdGVkQ29sb3IgPSBjb250YWluZXIuZmluZCgnLkNvbG9yIC5zZWxlY3RlZC12YWx1ZScpLmZpcnN0KCk7XG5cdFx0aWYoc2VsZWN0ZWRDb2xvci5sZW5ndGgpe1xuXHRcdFx0dmFyIGNvbG9yTmFtZSA9IHNlbGVjdGVkQ29sb3IuYXR0cignZGF0YS1uYW1lJykudG9TdHJpbmcoKTtcblx0XHRcdHZhciBjb2xvclZhbHVlID0gc2VsZWN0ZWRDb2xvci5hdHRyKCdkYXRhLXZhbHVlJykudG9TdHJpbmcoKTtcblx0XHRcdGlmKGNvbG9yTmFtZSAmJiBjb2xvclZhbHVlICYmICFwYXJhbXNbY29sb3JOYW1lXSAmJiBuZXdIcmVmLmluZGV4T2YoY29sb3JOYW1lKSA9PSAtMSl7XG5cdFx0XHRcdC8vIGZvcmNlIHRoZSBhdXRvLXNlbGVjdGVkIGNvbG9yIGludG8gdGhlIGFqYXggY2FsbFxuXHRcdFx0XHRwYXJhbXNbY29sb3JOYW1lXSA9IGNvbG9yVmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vQWRkIGRyb3BzaGlwIG1vbm9ncmFtIHRleHQgaWYgc2V0LlxuXHRcdGlmKCQoJ2lucHV0W25hbWU9XCJtdFwiXScpLmxlbmd0aCA+IDApe1xuXHRcdFx0aWYoJCgnaW5wdXRbbmFtZT1cIm10XCJdJykudmFsKCkubGVuZ3RoID49IDEpe1xuXHRcdFx0XHRwYXJhbXNbJ210J10gPSAkKCdpbnB1dFtuYW1lPVwibXRcIl0nKS52YWwoKTtcblx0XHRcdFx0cGFyYW1zWydtYyddID0gJCgnaW5wdXRbbmFtZT1cIm1jXCJdJykudmFsKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIHVybCA9IGFwcC51dGlsLmFwcGVuZFBhcmFtc1RvVXJsKG5ld0hyZWYsIHBhcmFtcyk7XG5cblx0XHRpZigkKCcjcHJvZHVjdC1zZXQtbGlzdCcpLmxlbmd0aCA+IDApe1xuXHRcdFx0cGFyYW1zWydwcm9kdWN0c2V0J10gPSB0cnVlO1xuXHRcdFx0dXJsID0gYXBwLnV0aWwuYXBwZW5kUGFyYW1zVG9VcmwodXJsLCBwYXJhbXMpO1xuXHRcdH1cblxuXHRcdGFwcC5hamF4LmxvYWQoe1xuXHRcdFx0dXJsOiBkZWNvZGVVUklDb21wb25lbnQodXJsKSxcblx0XHRcdGNhbGxiYWNrIDogZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRcdFx0dmFyIHJlc2V0U2l6ZSA9IGZhbHNlO1xuXG5cdFx0XHRcdHZhciBwZHBNYWluID0gJGNhY2hlLnBkcE1haW47XG5cblx0XHRcdFx0dGFyZ2V0Lmh0bWwoZGF0YSk7XG5cblx0XHRcdFx0aWYgKHJlc2V0U2l6ZSl7XG5cdFx0XHRcdFx0dGFyZ2V0LmZpbmQoJ3NlbGVjdC5zaXplLXNlbGVjdCcpLnZhbCgnJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcmVzID0gJChkYXRhKTtcblxuXHRcdFx0XHQvLyB1cGRhdGUgcHJpY2UgZm9yIG1vYmlsZVxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gZW1wdHkgdGhlIG1vYmlsZSBwcmljZSBjb250YWluZXJcblx0XHRcdFx0XHQkKCcucHJpY2UtbW9iaWxlJykuZW1wdHkoKTtcblxuXHRcdFx0XHRcdC8vIGFwcGVuZCBwcm9kdWN0IHByaWNlXG5cdFx0XHRcdFx0cmVzLmZpbmQoJ3NwYW4ucHJvZHVjdC1wcmljZScpLmFwcGVuZFRvKCcucHJpY2UtbW9iaWxlJyk7XG5cdFx0XHRcdFx0cmVzLmZpbmQoJ2Rpdi5kZWJ1dERhdGVzJykuYXBwZW5kVG8oJy5wcmljZS1tb2JpbGUnKTtcblx0XHRcdFx0XHQvLyBwZHAgcHJvbW90aW9uIHRvb2x0aXBzXG5cdFx0XHRcdFx0JCgnLnB0X3Byb2R1Y3QtZGV0YWlscyBhLnRvb2x0aXAnKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0Ly8gVGhlIGNvbnRlbnRzIG9mIHRoZSBoMiBlbGVtZW50IHdpbGwgYmUgdGhlIHRpdGxlIG9mIHRoZSBob3B1cFxuXHRcdFx0XHRcdFx0dmFyIHRleHQgPSAkKHRoaXMpXG5cdFx0XHRcdFx0XHRcdFx0XHQucGFyZW50KClcblx0XHRcdFx0XHRcdFx0XHRcdC5maW5kKCdoMicpXG5cdFx0XHRcdFx0ICAgIFx0XHRcdC50ZXh0KCk7XG5cdFx0XHRcdFx0XHQvLyB0aGUgdG9vbHRpcC1jb250ZW50IGVsZW1lbnQgY29udGFpbnMgdGhlIGRpYWxvZyBib2R5XG5cdFx0XHRcdFx0XHR2YXIgZGxnID0gJCh0aGlzKS5maW5kKCcudG9vbHRpcC1jb250ZW50JykuZGlhbG9nKHtcblx0XHRcdFx0XHRcdFx0ZGlhbG9nQ2xhc3M6ICd0b29sdGlwLXBkcC1wcm9tbycsXG5cdFx0XHRcdFx0XHRcdGF1dG9PcGVuOiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0bW9kYWw6IHRydWUsXG5cdFx0XHRcdFx0XHRcdHRpdGxlOiB0ZXh0LFxuXHRcdFx0XHRcdFx0XHQgb3BlbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0JCgnLnVpLXdpZGdldC1vdmVybGF5JykuYmluZCgnY2xpY2snLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdCQoJy50b29sdGlwLXBkcC1wcm9tbycpLmRpYWxvZygnY2xvc2UnKTtcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHQvLyBzaG93IHRoZSBob3B1cCB3aGVuIHRoZSBsaW5rIGlzIGNsaWNrZWRcblx0XHRcdFx0XHRcdCQodGhpcykub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGRsZy5kaWFsb2coXCJvcGVuXCIpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKGUubWVzc2FnZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwYXJlbnQuYmVmb3JlKHJlcy5maW5kKCd1bC5zd2F0Y2hlcycpKTtcblx0XHRcdFx0cGFyZW50LnJlbW92ZSgpO1xuXHRcdFx0XHR2YXIgZGVzYyA9ICQoJyNzbWFsbC1kZXNjcmlwdGlvbicpO1xuXHRcdFx0XHR2YXIgZGV0YWlsRGVzYyA9ICQoJyNzbWFsbC1kZXRhaWxzJyk7XG5cdFx0XHRcdGlmKGRlc2MgIT0gbnVsbCl7XG5cdFx0XHRcdFx0ZGVzYy5lbXB0eSgpO1xuXHRcdFx0XHRcdHJlcy5maW5kKCcuZGVzY3JpcHRpb24taGVhZGluZywgLnNob3J0LWxlZnQsIC5zaG9ydC1yaWdodCcpLmFwcGVuZFRvKGRlc2MpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGRldGFpbERlc2MgIT0gbnVsbCl7XG5cdFx0XHRcdFx0ZGV0YWlsRGVzYy5lbXB0eSgpO1xuXHRcdFx0XHRcdHJlcy5maW5kKCcjZGV0YWlsLWxvbmdEZXNjJykuYXBwZW5kVG8oZGV0YWlsRGVzYyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgbmV3SWQgPSByZXMuZmluZCgnaW5wdXRbbmFtZT1waWRdJykudmFsKCk7XG5cdFx0XHRcdGlucHV0SWQudmFsKG5ld0lkKTtcblx0XHRcdFx0Ly8gQ29weSB2YXJpYXRpb24gYXR0cmlidXRlcyBvdGhlciB0aGFuIHRoZSBjdXJyZW50IG9uZSBmcm9tIHRoZVxuXHRcdFx0XHQvLyByZXR1cm5lZCBIVE1MIGludG8gdGhlIGN1cnJlbnQgcGFnZSByZXBsYWNpbmcgdGhlIGNvcnJlc3BvbmRpbmdcblx0XHRcdFx0Ly8gZWxlbWVudC4gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHVwZGF0ZSByZWZlcmVuY2VzIGZvciB0aG9zZVxuXHRcdFx0XHQvLyB2YXJpYXRpb25zIHJlZmxlY3QgdGhlIGNoYW5nZSB0byB0aGlzIHZhcmlhdGlvbiAoZS5nLiBjaGFuZ2luZ1xuXHRcdFx0XHQvLyB0aGUgc2l6ZSBkb2Vzbid0IHJldmVydCB0aGUgY29sb3IpXG5cdFx0XHRcdHZhciBhdHRyaWJ1dGVzID0gcmVzLmZpbmQoJ2xpLmF0dHJpYnV0ZScpLnRvQXJyYXkoKTtcblx0XHRcdFx0dmFyIGN1cnJlbnQgPSBjb250YWluZXIuZmluZCgnbGkuYXR0cmlidXRlJykudG9BcnJheSgpO1xuXHRcdFx0XHR2YXIgc2tpcCA9IGN1cnJlbnQuaW5kZXhPZihhdHRyaWJ1dGVDb250YWluZXJbMF0pO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGN1cnJlbnQubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGkgPT0gc2tpcCkgY29udGludWU7XG5cdFx0XHRcdFx0dmFyIGN1ciA9ICQoY3VycmVudFtpXSk7XG5cdFx0XHRcdFx0Y3VyLmJlZm9yZShhdHRyaWJ1dGVzW2ldKTtcblx0XHRcdFx0XHRjdXIucmVtb3ZlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiBSdW4gcmVwbGFjZUltYWdlcyBhbmQgcmVwbGFjZUNvbnRlbnQgaW4gcGFyYWxsZWwgdmlhIGFcblx0XHRcdFx0XHRuaWZ0eSB0cmljayB3LyBzZXRUaW1lb3V0ICovXG5cdFx0XHRcdGlmIChpc0NvbG9yKSB7XG5cdFx0XHRcdFx0aWYoUmVzb3VyY2VzLkNMT1VEX1pPT01fRU5BQkxFRCl7XG5cdFx0XHRcdFx0XHRyZXBsYWNlQ2xvdWRab29tSW1hZ2VzKHBkcE1haW4pO1xuXHRcdFx0XHRcdFx0cmVwbGFjZUNvbnRlbnQoKTtcblx0XHRcdFx0XHRcdGZ1bGxTY3JlZW5JbWFnZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNle1xuXHRcdFx0XHRcdFx0Ly8gbm90ZSBzY2VuZTcgZnVuY3Rpb25hbGl0eSBkb2VzIG5vdCBhY3R1YWxseSB1c2UgdGhpc1xuXHRcdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpe3JlcGxhY2VJbWFnZXMocGRwTWFpbik7fSwgMSk7XG5cdFx0XHRcdFx0XHRzZXRUaW1lb3V0KHJlcGxhY2VDb250ZW50LCAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiBGSVhNRTogVGhpcyBpcyBhIGxvbmctcnVubmluZyBtZXRob2QgdGhhdCB3YXMgYmxvY2tpbmdcblx0XHRcdFx0XHRpbWFnZSByZXBsYWNlbWVudC4gRmluZCBvdXQgd2h5IGFuZCBtYWtlIGl0IGJldHRlci4gKi9cblx0XHRcdFx0c2V0VGltZW91dChpbml0aWFsaXplRXZlbnRzLCAxKTtcblxuXHRcdFx0XHRhcHAucHJvZHVjdC5pbml0QWRkVGhpcygpO1xuXHRcdFx0XHRhcHAucHJvZHVjdC5pbml0QWRkVG9DYXJ0KCk7XG5cblx0XHRcdFx0YmF6emFydm9pY2VDbGVhckhvcHVwKCk7XG5cblx0XHRcdFx0dmFyIHByb2R1Y3RTZXRJdGVtID0gY29udGFpbmVyLmNsb3Nlc3QoJy5wcm9kdWN0LXNldC1pdGVtJyk7XG5cblx0XHRcdFx0aWYgKHByb2R1Y3RTZXRJdGVtLmxlbmd0aCA+IDApIHtcblxuXHRcdFx0XHRcdGlmKHdpbmRvdy5pbm5lcldpZHRoIDwgNDgwKXtcblx0XHRcdFx0XHRcdHZhciBwcm9kdWN0VGh1bWJuYWlscyA9IHByb2R1Y3RTZXRJdGVtLmZpbmQoJy5wcm9kdWN0LXNldC1pbWFnZSBpbWcnKTtcblx0XHRcdFx0XHRcdHZhciBuZXdUaHVtYm5haWwgPSBwcm9kdWN0U2V0SXRlbS5maW5kKCcuc3dhdGNoZXMuQ29sb3IgLnNlbGVjdGVkJykuYXR0cignZGF0YS1waW1hZ2UnKTtcblx0XHRcdFx0XHRcdHByb2R1Y3RUaHVtYm5haWxzLmF0dHIoJ3NyYycsIG5ld1RodW1ibmFpbCk7XG5cdFx0XHRcdFx0XHRwcm9kdWN0U2V0SXRlbS5maW5kKFwiLnNlbGVjdC1xdWFudGl0eVwiKS50cmlnZ2VyKFwiY2hhbmdlXCIpO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0dmFyIHByb2R1Y3RUaHVtYm5haWxzID0gcmVzLmZpbmQoJy5wcm9kdWN0LXRodW1ibmFpbHMgaW1nJyk7XG5cdFx0XHRcdFx0XHRpZiAocHJvZHVjdFRodW1ibmFpbHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgbmV3VGh1bWJuYWlsID0gcHJvZHVjdFRodW1ibmFpbHMuZXEoMCkuYXR0cignc3JjJykucmVwbGFjZSgnL0NfJywnL05fJykucmVwbGFjZSgncHJvZHVjdFRodW1iJywgJ3Byb2R1Y3QyeDInKTtcblx0XHRcdFx0XHRcdFx0cHJvZHVjdFNldEl0ZW0uZmluZCgnLnByb2R1Y3QtdGh1bWJuYWlsJykuYXR0cignc3JjJywgbmV3VGh1bWJuYWlsKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgb2xkUXVhbnRpdHlTZWxlY3QgPSBwcm9kdWN0U2V0SXRlbS5maW5kKCcuc2VsZWN0LXF1YW50aXR5Jyk7XG5cdFx0XHRcdFx0b2xkUXVhbnRpdHlTZWxlY3QuYmVmb3JlKHJlcy5maW5kKCdzZWxlY3Quc2VsZWN0LXF1YW50aXR5JykpO1xuXHRcdFx0XHRcdG9sZFF1YW50aXR5U2VsZWN0LnJlbW92ZSgpO1xuXG5cdFx0XHRcdFx0dmFyIG9sZEF2YWlsYWJpbGl0eSA9IHByb2R1Y3RTZXRJdGVtLmZpbmQoJy5hdmFpbGFiaWxpdHktbWVzc2FnaW5nJyk7XG5cdFx0XHRcdFx0b2xkQXZhaWxhYmlsaXR5LmJlZm9yZShyZXMuZmluZCgnLmF2YWlsYWJpbGl0eS1tZXNzYWdpbmcnKSk7XG5cdFx0XHRcdFx0b2xkQXZhaWxhYmlsaXR5LnJlbW92ZSgpO1xuXG5cdFx0XHRcdFx0dmFyIG9sZFBpZCA9IHByb2R1Y3RTZXRJdGVtLmZpbmQoJ2lucHV0W25hbWU9cGlkXScpO1xuXHRcdFx0XHRcdG9sZFBpZC5iZWZvcmUocmVzLmZpbmQoJ2lucHV0W25hbWU9cGlkXScpKTtcblx0XHRcdFx0XHRvbGRQaWQucmVtb3ZlKCk7XG5cblx0XHRcdFx0XHRpZiAoY29udGFpbmVyLmZpbmQoJ3NlbGVjdC5zaXplLXNlbGVjdCcpLnZhbCgpKSB7XG5cdFx0XHRcdFx0XHRwcm9kdWN0U2V0SXRlbS5yZW1vdmVBdHRyKCdpbnZhbGlkJylcblx0XHRcdFx0XHRcdFx0XHQuZmluZCgnYnV0dG9uLmFkZC10by1jYXJ0Jylcblx0XHRcdFx0XHRcdFx0XHQucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcblxuXHRcdFx0XHRcdFx0aWYgKGNvbnRhaW5lci5jbG9zZXN0KCcucHJvZHVjdC1zZXQnKS5maW5kKCcucHJvZHVjdC1zZXQtaXRlbVtpbnZhbGlkXScpLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdCQoJyNhZGQtYWxsLXRvLWNhcnQnKS5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cblx0XHRcdFx0YXBwLnRvb2x0aXBzLmluaXQoKTtcblxuXHRcdFx0XHQvLyBmb3IgdGhlIGUtZ2lmdCBjYXJkIG9uIFBEUFxuXHRcdFx0XHRpZigkY2FjaGUucGRwRm9ybS5maW5kKCcuZ2lmdC1jYXJkLWluZm8nKS5sZW5ndGgpe1xuXHRcdFx0XHRcdGFwcC52YWxpZGF0b3IuaW5pdEZvcm0oJ2Zvcm0ucGRwRm9ybScpO1xuXHRcdFx0XHRcdGFwcC51dGlsLmxpbWl0Q2hhcmFjdGVycygpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHR5cGVvZiBGQiAhPSAndW5kZWZpbmVkJyAmJiAnWEZCTUwnIGluIEZCICYmICdwYXJzZScgaW4gRkIuWEZCTUwpIHtcblx0XHRcdFx0XHQkKCdmYlxcXFw6bGlrZScpLmF0dHIoJ2hyZWYnLG5ld0hyZWYpO1xuXHRcdFx0XHRcdEZCLlhGQk1MLnBhcnNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gcmVsb2FkIHRoZSBiYXphYXIgdm9pY2UgcmF0aW5ncyBwYW5lXG5cdFx0XHRcdGlmICgkKCcjQlZDdXN0b21lclJhdGluZ3MnKS5sZW5ndGggPiAwICYmIHR5cGVvZiAkQlYgIT0gXCJ1bmRlZmluZWRcIiAmJiBcInVpXCIgaW4gJEJWKSB7XG5cdFx0XHRcdFx0JEJWLnVpKFwicnJcIiwgXCJzaG93X3Jldmlld3NcIiwgY29uZmlnRGF0YSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZWxvYWQgU2hvcFJ1bm5lciBjb250ZW50XG5cdFx0XHRcdGlmICh0eXBlb2Yoc3JfdXBkYXRlTWVzc2FnZXMpID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRzcl91cGRhdGVNZXNzYWdlcygpO1xuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHQvL1RydWUgRml0XG5cdFx0XHRcdGlmICh0eXBlb2YgdGZjICE9PSAndW5kZWZpbmVkJyl7XG5cdFx0XHRcdFx0dGZjLmNhbGN1bGF0ZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0pOyAvLyBlbmQgb2YgYWpheCBsb2FkXG5cblx0fSk7IC8vIGVuZCBvZiBwZHAgc3dhdGNoIGNsaWNrIGhhbmRsZXJcblxuXG5cdC8vbG9jYXRvckluaXQoKTtcblxuXHRDbG91ZFpvb20ucXVpY2tTdGFydCgpO1xuXG5cdC8vbW9ub2dyYW1taW5nIGV2ZW50c1xuXHQkY2FjaGUubW9ub2dyYW1zdHlsZXRpbGVzLmNsaWNrKG1vbm9ncmFtU3R5bGVUaWxlQ2xpY2spO1xuXHQkY2FjaGUubW9ub2dyYW1kb3Rzb3B0aW9ucy5jbGljayhkb3RzT3B0aW9uQ2xpY2spO1xuXHQkY2FjaGUubW9ub2dyYW1jb2xvcnMuY2xpY2sobW9ub2dyYW1Db2xvckNsaWNrKTtcblx0JGNhY2hlLm1vbm9ncmFtdGV4dGlucHV0Y2xlYXIuY2xpY2sodGV4dElucHV0Q2xlYXJDbGljayk7XG5cbn0vL2VuZCBpbml0aWFsaXplRXZlbnRzXG5cbmZ1bmN0aW9uIGluaXRpYWxpemVEb20oKXtcblx0aWYoJGNhY2hlLm1vbm9ncmFtY29udGFpbmVyLmxlbmd0aCA+IDApe1xuXHRcdCRjYWNoZS5tb25vZ3JhbWNvbnRhaW5lci5kYXRhKCdpbWFnZU9wdGlvbnMnLHt9KTtcblx0XHQkY2FjaGUubW9ub2dyYW1jb250YWluZXIuZGF0YSgnaW1hZ2VPcHRpb25zJylbJyRkb3RzJ10gPSAwO1xuXHRcdCRjYWNoZS5tb25vZ3JhbWNvbnRhaW5lci5maW5kKCcubW9ub2dyYW0tZm9udC1zZWxlY3QnKS5lbXB0eSgpO1xuXHRcdCRjYWNoZS5tb25vZ3JhbWNvbnRhaW5lci5maW5kKCcubW9ub2dyYW0tdGV4dC1pbnB1dC1ib2R5JykuZW1wdHkoKTtcblx0XHQkY2FjaGUubW9ub2dyYW1jb250YWluZXIuZmluZCgnLm1vbm9ncmFtLXN5bWJvbC1saXN0JykuZW1wdHkoKTtcblx0XHQkY2FjaGUuZm9udHRpbGViYXNlLnJlbW92ZUNsYXNzKCdtb25vZ3JhbS1mb250LWJhc2UgdmlzdWFsbHktaGlkZGVuJykuYWRkQ2xhc3MoJ21vbm9ncmFtLWZvbnQnKTtcblx0XHQkY2FjaGUuc3ltYm9sYmFzZS5yZW1vdmVDbGFzcygnbW9ub2dyYW0tc3ltYm9sLWJhc2UgdmlzdWFsbHktaGlkZGVuJykuYWRkQ2xhc3MoJ21vbm9ncmFtLXN5bWJvbCcpO1xuXG5cdFx0aWYod2luZG93LmlubmVyV2lkdGggPD0gNDgwKXtcblx0XHRcdCQoJy5wcm9kdWN0LWFkZC10by1jYXJ0JykuYXBwZW5kVG8oJy5wcm9kdWN0LWNvbC0xJyk7XG5cdFx0fWVsc2V7XG5cdFx0XHQkKCcucHJvZHVjdC1hZGQtdG8tY2FydCcpLmFwcGVuZFRvKCcjcHJvZHVjdC1jb250ZW50Jyk7XG5cdFx0XHQkKCcucHJvZHVjdC1hY3Rpb25zJykuYXBwZW5kVG8oJyNwcm9kdWN0LWNvbnRlbnQnKTtcblx0XHR9XG5cdH1cblxufVxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcbiAgICBpbnZlbnRvcnkgPSByZXF1aXJlKCcuLycpO1xuXG52YXIgbmV3TGluZSA9ICdcXG4nO1xudmFyIHBkcFN0b3JlVGVtcGxhdGUgPSBmdW5jdGlvbiAoc3RvcmUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICAnPGxpIGNsYXNzPVwic3RvcmUtbGlzdC1pdGVtICcgKyAoc3RvcmUuc3RvcmVJZCA9PT0gVXNlci5zdG9yZUlkID8gJyBzZWxlY3RlZCcgOiAnJykgKyAnXCI+JyxcbiAgICAgICAgJyAgICA8ZGl2IGNsYXNzPVwic3RvcmUtYWRkcmVzc1wiPicgKyBzdG9yZS5hZGRyZXNzMSArICcsICcgKyBzdG9yZS5jaXR5ICsgJyAnICsgc3RvcmUuc3RhdGVDb2RlICtcbiAgICAgICAgJyAnICsgc3RvcmUucG9zdGFsQ29kZSArICc8L2Rpdj4nLFxuICAgICAgICAnICAgIDxkaXYgY2xhc3M9XCJzdG9yZS1zdGF0dXNcIiBkYXRhLXN0YXR1cz1cIicgKyBzdG9yZS5zdGF0dXNjbGFzcyArICdcIj4nICsgc3RvcmUuc3RhdHVzICsgJzwvZGl2PicsXG4gICAgICAgICc8L2xpPidcbiAgICBdLmpvaW4obmV3TGluZSk7XG59O1xudmFyIHBkcFN0b3Jlc0xpc3RpbmdUZW1wbGF0ZSA9IGZ1bmN0aW9uIChzdG9yZXMpIHtcbiAgICBpZiAoc3RvcmVzICYmIHN0b3Jlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwic3RvcmUtbGlzdC1wZHAtY29udGFpbmVyXCI+JyxcbiAgICAgICAgICAgIChzdG9yZXMubGVuZ3RoID4gMSA/ICcgICAgPGEgY2xhc3M9XCJzdG9yZXMtdG9nZ2xlIGNvbGxhcHNlZFwiIGhyZWY9XCIjXCI+JyArIFJlc291cmNlcy5TRUVfTU9SRSArICc8L2E+JyA6ICcnKSxcbiAgICAgICAgICAgICcgICAgPHVsIGNsYXNzPVwic3RvcmUtbGlzdC1wZHBcIj4nLFxuICAgICAgICAgICAgXy5tYXAoc3RvcmVzLCBwZHBTdG9yZVRlbXBsYXRlKS5qb2luKG5ld0xpbmUpLFxuICAgICAgICAgICAgJyAgICA8L3VsPicsXG4gICAgICAgICAgICAnPC9kaXY+J1xuICAgICAgICBdLmpvaW4obmV3TGluZSk7XG4gICAgfVxufTtcblxudmFyIHN0b3Jlc0xpc3RpbmcgPSBmdW5jdGlvbiAoc3RvcmVzKSB7XG4gICAgLy8gbGlzdCBhbGwgc3RvcmVzIG9uIFBEUCBwYWdlXG4gICAgaWYgKCQoJy5zZWxlY3RlZC1zdG9yZS1pbmZvJykubGVuZ3RoKSB7XG4gICAgICAgICQoJy5wZHBfbG9jYXRvcl9idXR0b24nKS5jc3MoJ2hlaWdodCcsICcnKTtcbiAgICAgICAgJCgnLnNlbGVjdGVkLXN0b3JlLWluZm8nKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0b3Jlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3RvcmVzW2ldLnN0b3JlSWQgPT09IFVzZXIuc3RvcmVJZCkge1xuICAgICAgICAgICAgJCgnI3N0b3JlcGlja3VwJykudmFsKCd0cnVlJyk7XG4gICAgICAgICAgICAkKCcjc3RvcmVpZCcpLnZhbChVc2VyLnN0b3JlSWQpO1xuICAgICAgICAgICAgJCgnLnBkcF9sb2NhdG9yX2J1dHRvbicpLmNzcygnaGVpZ2h0JywgJzYwcHgnKTtcbiAgICAgICAgICAgICQoJy5wZHBfbG9jYXRvcl9idXR0b24nKS5hcHBlbmQoIFsnPGRpdiBjbGFzcz1cInNlbGVjdGVkLXN0b3JlLWluZm9cIj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnICAgIDxzcGFuIGNsYXNzPVwic2VsZWN0ZWQtc3RvcmUtbXNnXCI+JyArIFJlc291cmNlcy5TVE9SRV9QSUNLVVBfU0VMRUNURURTSE9QICsgJzwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnICAgIDxzcGFuIGNsYXNzPVwic2VsZWN0ZWQtc3RvcmUtYWRkcmVzc1wiPicgKyBzdG9yZXNbaV0ubmFtZSArICc8L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyAgICA8c3BhbiBjbGFzcz1cImNoYW5nZS1zdG9yZS1tc2dcIj4nICsgUmVzb3VyY2VzLlNUT1JFX1BJQ0tVUF9DSEFOR0UgKyAnPC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLmpvaW4obmV3TGluZSkpO1xuICAgICAgICB9XG4gICAgfVxuXG59O1xuXG52YXIgcHJvZHVjdEludmVudG9yeSA9IHtcbiAgICBzZXRQcmVmZXJyZWRTdG9yZTogZnVuY3Rpb24gKHN0b3JlSWQpIHtcbiAgICBcdHZhciBzZWxmID0gdGhpcztcbiAgICBcdHZhciBpc0NhcnRQYWdlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnB0X2NhcnQnKTtcbiAgICAgICAgVXNlci5zdG9yZUlkID0gc3RvcmVJZDtcblxuICAgICAgICBpZiAoaXNDYXJ0UGFnZSkge1xuICAgICAgICAgICAgdmFyIGl0ZW1Sb3cgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2FydC1yb3dbZGF0YS1waWQ9XCInK3NlbGYucGlkKydcIl0nKTtcblxuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICB1cmw6IFVybHMuc2V0U3RvcmVQaWNrdXAsXG4gICAgICAgICAgICAgICAgdHlwZTogJ0dFVCcsXG4gICAgICAgICAgICAgICAgZGF0YToge3BsaWQ6IGl0ZW1Sb3cuZGF0YXNldC51dWlkLCBzdG9yZWlkOiBzdG9yZUlkLCBzdG9yZXBpY2t1cDogJ3RydWUnfVxuICAgICAgICAgICAgfSk7XG5cdFx0fVxuXG5cbiAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgIHVybDogVXJscy5zZXRQcmVmZXJyZWRTdG9yZSxcbiAgICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICAgIGRhdGE6IHtzdG9yZUlkOiBzdG9yZUlkfVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIHByb2R1Y3RTZWxlY3RTdG9yZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwaWQgPSB0aGlzLnBpZDtcbiAgICAgICAgaW52ZW50b3J5LmdldFN0b3Jlc0ludmVudG9yeSh0aGlzLnBpZCkudGhlbihmdW5jdGlvbiAoc3RvcmVzKSB7XG5cbiAgICAgICAgICAgIGludmVudG9yeS5zZWxlY3RTdG9yZURpYWxvZyh7XG4gICAgICAgICAgICAgICAgcGlkOiBwaWQsXG4gICAgICAgICAgICAgICAgcGlja3VwQ29udGVudDogVXNlci5waWNrdXBDb250ZW50LFxuICAgICAgICAgICAgICAgIHN0b3Jlczogc3RvcmVzLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkU3RvcmVJZDogVXNlci5zdG9yZUlkLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkU3RvcmVUZXh0OiBSZXNvdXJjZXMuUFJFRkVSUkVEX1NUT1JFLFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlQ2FsbGJhY2s6IHN0b3Jlc0xpc3RpbmcsXG4gICAgICAgICAgICAgICAgc2VsZWN0U3RvcmVDYWxsYmFjazogc2VsZi5zZXRQcmVmZXJyZWRTdG9yZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmRvbmUoKTtcbiAgICB9LFxuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgVXNlci5zdG9yZUlkID0gJyc7XG4gICAgICAgIFVzZXIuemlwID0gJyc7XG4gICAgICAgIFVzZXIucGlja3VwQ29udGVudCA9ICcnO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMucHJvZHVjdGluZm8gPSAnJztcbiAgICAgICAgdGhpcy5waWQgPSAkKCdpbnB1dFtuYW1lPVwicGlkXCJdJykudmFsKCk7XG5cbiAgICAgICAgdmFyIHByb2R1Y3RDb2xvciA9ICQoJy5zd2F0Y2hlcy5Db2xvciAuc2VsZWN0ZWQgLnRpdGxlJykubGVuZ3RoID8gJCgnLnN3YXRjaGVzLkNvbG9yIC5zZWxlY3RlZCAudGl0bGUnKVswXS5pbm5lclRleHQgOiAnJztcbiAgICAgICAgdmFyIHByb2R1Y3RQcmljZSA9ICQoJy5wcmljZS1zYWxlcycpLmxlbmd0aCA/ICQoJy5wcmljZS1zYWxlcycpWzBdLmlubmVyVGV4dCA6ICcnO1xuICAgICAgICB2YXIgcHJvZHVjdFF0eSA9ICQoJ3NlbGVjdFtuYW1lPVwiUXVhbnRpdHlcIl0nKS5sZW5ndGggPyAkKCdzZWxlY3RbbmFtZT1cIlF1YW50aXR5XCJdJylbMF0udmFsdWUgOiAnJztcblxuICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgZGF0YVR5cGU6ICdodG1sJyxcbiAgICAgICAgICAgIHVybDogdXRpbC5hcHBlbmRQYXJhbXNUb1VybChVcmxzLmdldFByb2R1Y3RJbmZvLCB7XG4gICAgICAgICAgICAgICAgcGlkOiB0aGlzLnBpZCxcbiAgICAgICAgICAgICAgICBwcm9kdWN0Q29sb3I6IHByb2R1Y3RDb2xvcixcbiAgICAgICAgICAgICAgICBwcm9kdWN0UHJpY2U6IHByb2R1Y3RQcmljZSxcbiAgICAgICAgICAgICAgICBwcm9kdWN0UXR5OiBwcm9kdWN0UXR5XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIC8vJCgnLnN0b3JlLXByb2R1Y3QtaW5mbycpLmFwcGVuZChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgVXNlci5waWNrdXBDb250ZW50ID0gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCl7XG4gICAgICAgICAgICAkKCcucGRwX2xvY2F0b3JfYnV0dG9uJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgLy8gU2hvdyBlcnJvciBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgICAgICBpZiAoJGNhY2hlLnBkcE1haW4uZmluZChcIi5wZHBfbG9jYXRvcl9lcnJvclwiKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICRjYWNoZS5wZHBNYWluLmZpbmQoXCIucGRwX2xvY2F0b3JfZXJyb3JcIikuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYucHJvZHVjdFNlbGVjdFN0b3JlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgMSk7XG5cbiAgICB9XG59O1xudmFyIG1haW5JbWFnZSA9IHtcblx0aW5pdCA6IGZ1bmN0aW9uKCl7XG5cdFx0dmFyIGlzUXVpY2tWaWV3ID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyICRxdmNvbnRhaW5lciA9ICQoJyNxdWljay12aWV3LWRpYWxvZycpO1xuXHRcdFx0cmV0dXJuICgkcXZjb250YWluZXIubGVuZ3RoPjApO1xuXHRcdH0pKCk7XG5cdFx0aWYgKCFpc1F1aWNrVmlldykge1xuXHRcdFx0dmFyIGhhbmRsZUltZ0xvYWQgPSBmdW5jdGlvbihlLCAkaW1nKSB7XG5cdFx0XHRcdGlmICghJGltZykgJGltZyA9ICQodGhpcyk7XG5cdFx0XHRcdCRpbWcuY3NzKCdtYXJnaW4tdG9wJywgKCRpbWcuaGVpZ2h0KCkgLyAyKSAqIC0xICsgJ3B4Jyk7XG5cdFx0XHRcdCRpbWcuc2hvdygpO1xuXHRcdFx0fTtcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCl7XG5cdFx0XHRcdC8vIGNoZWNrIGZvciBubyBpbWFnZVxuXHRcdFx0XHQkY2FjaGUucGRwTWFpbi5maW5kKCcucHJvZHVjdC1wcmltYXJ5LWltYWdlJykuZWFjaChmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHZhciAkZGl2ID0gJCh0aGlzKTtcblx0XHRcdFx0XHRtYWluSW1hZ2Uubm9JbWFnZUhhbmRsZXIoJGRpdi5maW5kKCdpbWcnKS5ub3QoJy5mdWxsc2NyZWVuLXpvb20taWNvbicpLCBmdW5jdGlvbihpbWcpe1xuXHRcdFx0XHRcdFx0dmFyICRpbWcgPSAkKGltZyk7XG5cdFx0XHRcdFx0XHR2YXIgJGRpdiA9ICQoaW1nKS5jbG9zZXN0KCcucHJvZHVjdC1wcmltYXJ5LWltYWdlJyk7XG5cdFx0XHRcdFx0XHQkaW1nLnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0aWYoJGRpdi5jaGlsZHJlbigpLmxlbmd0aCA9PSAwKXtcblx0XHRcdFx0XHRcdFx0JGRpdi5hZGRDbGFzcygnbm8taW1hZ2UnKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRpZigkZGl2LmNoaWxkcmVuKCkubGVuZ3RoID09IDApe1xuXHRcdFx0XHRcdFx0JGRpdi5hZGRDbGFzcygnbm8taW1hZ2UnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSwgMzAwMCk7XG5cdFx0fVxuXHRcdGVsc2V7XG5cdFx0XHQvLyBpbiBxdWljayB2aWV3XG5cdFx0XHQkY2FjaGUucGRwTWFpbi5maW5kKCcucHJvZHVjdC1wcmltYXJ5LWltYWdlIGltZycpLm5vdCgnLmZ1bGxzY3JlZS16b29tLWljb24nKS5lYWNoKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdG1haW5JbWFnZS5ub0ltYWdlSGFuZGxlcih0aGlzKTtcblx0XHRcdH0pO1xuXG5cdFx0fTtcblx0fSxcblx0bm9JbWFnZUhhbmRsZXIgOiBmdW5jdGlvbihpbWcsIGVycm9ySGFuZGxlcikge1xuXHRcdHZhciAkaW1nID0gJChpbWcpO1xuXHRcdCRpbWcub24oJ2Vycm9yJywgZnVuY3Rpb24oKXtcblx0XHRcdGlmKGVycm9ySGFuZGxlcil7XG5cdFx0XHRcdGVycm9ySGFuZGxlcih0aGlzKTtcblx0XHRcdH1cblx0XHRcdGVsc2V7XG5cdFx0XHRcdG1haW5JbWFnZS5ub0ltYWdlKHRoaXMpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdC8vIHJlbG9hZCBpbWFnZSBpbiBjYXNlIHdlIG1pc3NlZCB0aGUgZXJyb3IgZXZlbnRcblx0XHR2YXIgc3JjID0gJGltZy5hdHRyKCdzcmMnKTtcblx0XHQvLyRpbWcuYXR0cignc3JjJywgJycpOyAvLyB0aGlzIGxpbmUgY3Jhc2hlcyBpT1MgNi4wXG5cdFx0aWYoUmVzb3VyY2VzICYmIFJlc291cmNlcy5CTEFOS19JTUFHRV9VUkwpe1xuXHRcdFx0JGltZy5hdHRyKCdzcmMnLCBSZXNvdXJjZXMuQkxBTktfSU1BR0VfVVJMKTtcblx0XHR9XG5cdFx0JGltZy5hdHRyKCdzcmMnLCBzcmMpO1xuXHR9LFxuXHRub0ltYWdlIDogZnVuY3Rpb24oaW1nKSB7XG5cdFx0aWYoUmVzb3VyY2VzICYmIFJlc291cmNlcy5OT19JTUFHRV9VUkwpe1xuXHRcdFx0dmFyICRpbWcgPSAkKGltZyk7XG5cdFx0XHQkaW1nLmF0dHIoJ2RhdGEtZmFpbGVkLXNyYycsICRpbWcuYXR0cignc3JjJykpO1xuXHRcdFx0JGltZy5hdHRyKCdzcmMnLCBSZXNvdXJjZXMuTk9fSU1BR0VfVVJMKTtcblx0XHR9XG5cdH1cblxufVxuXG5mdW5jdGlvbiBkb1VwZGF0ZUltYWdlcygpe1xuXG5cdGlmKHZhbGlkYXRlSW1hZ2VPcHRpb25zKCkpe1xuXG5cdFx0YXBwLm1vbm9ncmFtLmluaXQoKTtcblxuXHRcdHZhciBxcyA9IGdldFF1ZXJ5U3RyaW5nKCk7XG5cblx0XHR2YXIgYmFzZUltYWdlOy8vID0gXCJodHRwOi8va2F0ZXNwYWRlLnNjZW5lNy5jb20vaXMvaW1hZ2UvS2F0ZVNwYWRlUmVuZGVyP3NyYz1pcntLYXRlU3BhZGVSZW5kZXIvezB9P29iaj1GTE9XL01OR1JNJmRlY2FsJnNyYz1pc3tLYXRlU3BhZGUvbW9ub19rc255P3sxfX0mc2hhcnA9MSZyZXM9MTUwJnJlc01vZGU9c2hhcnAyfSYkcHJvZHVjdFRodW1ibmFpbCRcIjtcblxuXHRcdHN3aXRjaCgkY2FjaGUuc2VsZWN0ZWRTdHlsZUNvbmZpZy5wZXJzb25hbGl6YXRpb25UeXBlKXtcblx0XHRcdGNhc2UgXCJNb25vZ3JhbW1pbmdcIjpcblx0XHRcdFx0YmFzZUltYWdlID0gUmVzb3VyY2VzLk1PTk9HUkFNTUlOR19NT05PR1JBTV9CQVNFX1VSTDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwiRW5ncmF2aW5nXCI6XG5cdFx0XHRcdGJhc2VJbWFnZSA9IFJlc291cmNlcy5NT05PR1JBTU1JTkdfRU5HUkFWSU5HX0JBU0VfVVJMO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGJhc2VJbWFnZSA9IFJlc291cmNlcy5NT05PR1JBTU1JTkdfTU9OT0dSQU1fQkFTRV9VUkw7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXG5cdFx0JCgnLnByb2R1Y3QtdGh1bWJuYWlscyAudGh1bWInKS5lYWNoKGZ1bmN0aW9uKGluZGV4KXtcblx0XHRcdHZhciAkdGhpcyA9ICQodGhpcyk7XG5cdFx0XHR2YXIgJGxpbmsgPSAkdGhpcy5maW5kKCdhJyk7XG5cdFx0XHR2YXIgJGltZyA9ICRsaW5rLmZpbmQoJ2ltZycpO1xuXG5cblx0XHRcdHZhciBiYXNlSW1hZ2VVcmwgPSAkbGluay5hdHRyKCd0aHVtYm5haWwtZGF0YScpLFxuXHRcdFx0XHR1cmxCYXNlID0gYmFzZUltYWdlVXJsLnNwbGl0KCc/JylbMF07XG5cblx0XHRcdC8vIElmIGltYWdlIGlzIGEgbW9ub2dyYW0gaW1hZ2UsIHJldHVybiByZW5kZXJlZCBtb25vZ3JhbSBVUkxcblx0XHRcdGlmICh1cmxCYXNlLmluZGV4T2YoXCJfUlwiKSA9PSB1cmxCYXNlLmxlbmd0aC0yKSB7XG5cdFx0XHRcdHZhciBzcGxpdEJhc2UgPSB1cmxCYXNlLnNwbGl0KCcvJyk7XG5cblx0XHRcdFx0Ly9nZXQgdGhlIGltYWdlIGNvZGUge3NrdX1fe3N0eWxlfVxuXHRcdFx0XHR2YXIgYXNzZXROYW1lID0gc3BsaXRCYXNlW3NwbGl0QmFzZS5sZW5ndGggLSAxXTtcblxuXHRcdFx0XHRhc3NldE5hbWUgPSBhc3NldE5hbWUucmVwbGFjZSgvX1IkLywgJycpO1xuXG5cblx0XHRcdFx0dmFyIG5ld1RodW1ibmFpbCA9IGJhc2VJbWFnZS5mb3JtYXQoYXNzZXROYW1lLHFzKTtcblxuXHRcdFx0XHR2YXIgem9vbUltZyA9IG5ld1RodW1ibmFpbC5yZXBsYWNlKFwiJHByb2R1Y3RUaHVtYm5haWwkXCIsIFwiJGZ1bGxzaXplJFwiKTtcblxuXHRcdFx0XHQkbGluay5hdHRyKCdocmVmJyx6b29tSW1nKTtcblxuXHRcdFx0XHQkaW1nLmF0dHIoJ3NyYycsbmV3VGh1bWJuYWlsKTtcblxuXHRcdFx0XHQvL21vbm9ncmFtLWRpc3BsYXlfbW9ub2dyYW0tcHJldmlldy1pbWFnZVxuXHRcdFx0XHRpZihpbmRleCA9PT0gMCl7XG5cdFx0XHRcdFx0dmFyIGNhcnRJbWFnZSA9IG5ld1RodW1ibmFpbC5yZXBsYWNlKFwiJHByb2R1Y3RUaHVtYm5haWwkXCIsXCIkc2hvcHBpbmdDYXJ0JFwiKVxuXHRcdFx0XHRcdCRjYWNoZS5tb25vZ3JhbWZvcm1maWVsZHMuZmluZChcImlucHV0W25hbWU9J21vbm9ncmFtLWRpc3BsYXlfbW9ub2dyYW0tdGh1bWItaW1hZ2UnXVwiKS52YWwoY2FydEltYWdlKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblxuXG5cdFx0fSk7XG5cblxuXHRcdC8vIGdldCB0aGUgaW5zdGFuY2Ugb2YgQ2xvdWRab29tXG5cdFx0dmFyIGN6ID0gJChcImltZy5wcmltYXJ5LWltYWdlLmNsb3Vkem9vbVwiKS5kYXRhKFwiQ2xvdWRab29tXCIpO1xuXG5cdFx0Ly8gR2V0IHNlbGVjdGVkIGltYWdlIHNyY1xuXHRcdHZhciAkc2VsZWN0ZWRUaHVtYiA9ICRjYWNoZS5wcm9kdWN0VGh1bWJuYWlsVGlsZXMuZmlsdGVyKCcuc2VsZWN0ZWQnKTtcblx0XHR2YXIgc3JjID0gJHNlbGVjdGVkVGh1bWIuZmluZCgnaW1nJykuYXR0cignc3JjJyk7XG5cblx0XHQvLyBMb2FkIGEgbmV3IHNtYWxsIGltYWdlIGFuZCB6b29tIGltYWdlIGludG8gaXQ6XG5cdFx0dmFyIHNtYWxsSW1nID0gc3JjLnJlcGxhY2UoXCIkcHJvZHVjdFRodW1ibmFpbCRcIiwgXCIkbGFyZ2UkXCIpO1xuXHRcdHZhciB6b29tSW1nID0gc21hbGxJbWcucmVwbGFjZShcIiRsYXJnZSRcIiwgXCIkZnVsbHNpemUkXCIpO1xuXG5cdFx0Ly9yZXBsYWNlIHRoZSB0aHVtYm5haWwgaW4gc2xpZGVyIHdpdGggbGFyZ2UgaW1hZ2UgQnVnOiBSUi03MTdcblx0XHQkc2VsZWN0ZWRUaHVtYi5maW5kKCdpbWcnKS5hdHRyKCdzcmMnLCBzbWFsbEltZylcblxuXHRcdC8vIExvYWQgbmV3IGltYWdlcyBpbnRvIENsb3VkWm9vbSBpbnN0YW5jZVxuXHRcdGN6LmxvYWRJbWFnZShzbWFsbEltZywgem9vbUltZyk7XG5cblxuXG5cdFx0c3dpdGNoKCRjYWNoZS5zZWxlY3RlZFN0eWxlQ29uZmlnLnBlcnNvbmFsaXphdGlvblR5cGUpe1xuXHRcdFx0Y2FzZSBcIk1vbm9ncmFtbWluZ1wiOlxuXHRcdFx0XHRiYXNlSW1hZ2UgPSBSZXNvdXJjZXMuTU9OT0dSQU1NSU5HX1BSRVZJRVdfQkFTRV9VUkw7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcIkVuZ3JhdmluZ1wiOlxuXHRcdFx0XHRiYXNlSW1hZ2UgPSBSZXNvdXJjZXMuRU5HUkFWSU5HX1BSRVZJRVdfQkFTRV9VUkw7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0YmFzZUltYWdlID0gUmVzb3VyY2VzLk1PTk9HUkFNTUlOR19QUkVWSUVXX0JBU0VfVVJMO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdFx0dmFyIHByZXZpZXdVUkwgPSBiYXNlSW1hZ2UuZm9ybWF0KHFzKTtcblx0XHQkY2FjaGUubW9ub2dyYW1mb3JtZmllbGRzLmZpbmQoXCJpbnB1dFtuYW1lPSdtb25vZ3JhbS1kaXNwbGF5X21vbm9ncmFtLXByZXZpZXctaW1hZ2UnXVwiKS52YWwocHJldmlld1VSTCk7XG5cdH1cbn1cblxuXG5mdW5jdGlvbiBzdG9yZUxvY2F0ZSgpIHtcblx0dmFyIGxvY2F0ZVppcCA9ICQoXCIucGRwX2xvY2F0b3JfaW5wdXRcIik7XG5cdGlmIChsb2NhdGVaaXAubGVuZ3RoID4gMCAmJiBsb2NhdGVaaXAudmFsaWQoKSkge1xuXHRcdHZhciByZXN1bHRzID0gJChcIi5wZHBfbG9jYXRvcl9yZXN1bHRzXCIpO1xuXHRcdHZhciByYWRpdXNEcm9wZG93biA9ICQoXCIucGRwX2xvY2F0b3JfcmFkaXVzXCIpO1xuXHRcdHZhciBub3RGb3VuZEVycm9yID0gJChcIi5wZHBfbG9jYXRvcl9ub3Rmb3VuZFwiKTtcblxuXHRcdC8vIFNob3cgbG9hZGluZyBnaWYgYW5kIGhpZGUgZXJyb3JzXG5cdFx0cmVzdWx0cy5lbXB0eSgpLmFkZENsYXNzKFwibG9hZGluZ1wiKTtcblx0XHRub3RGb3VuZEVycm9yLmhpZGUoKTtcblxuXHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XCJtYXhfcmFkaXVzXCIgOiByYWRpdXNEcm9wZG93bi52YWwoKSxcblx0XHRcdFwiemlwXCIgOiAkKFwiLnBkcF9sb2NhdG9yX2lucHV0XCIpLnZhbCgpLFxuXHRcdFx0XCJ2YXJpYXRpb25faWRcIiA6ICQoXCIjcGlkXCIpLnZhbCgpXG5cdFx0fTtcblxuXHRcdC8vIExvYWQgbG9jYXRlIHJlc3VsdHNcblx0XHRyZXN1bHRzLmxvYWQoVXJscy5Mb2NhdGVTdG9yZXMsIGRhdGEsIGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIFJlbW92ZSBsb2FkaW5nIGdpZlxuXHRcdFx0cmVzdWx0cy5yZW1vdmVDbGFzcyhcImxvYWRpbmdcIik7XG5cdFx0XHQvLyBJZiBsb2NhdG9yIHJhZGl1cyB3YXMgYXV0b21hdGljYWxseSBpbmNyZWFzZWQgZHVlIHRvIGxhY2sgb2YgcmVzdWx0cywgY2hhbmdlIGRyb3Bkb3duIHRvIG5ldyByYWRpdXNcblx0XHRcdHZhciBwcmV2aWV3ID0gcmVzdWx0cy5maW5kKFwiLnBkcF9sb2NhdG9yX3ByZXZpZXdcIik7XG5cdFx0XHRpZiAocHJldmlldy5oYXNDbGFzcyhcInJhZGl1c0luY3JlYXNlZFwiKSB8fCBwcmV2aWV3Lmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdHZhciBuZXdSYWRpdXNTZWxlY3Rpb24gPSBwcmV2aWV3LmRhdGEoXCJyYWRpdXNcIik7XG5cdFx0XHRcdGlmICghbmV3UmFkaXVzU2VsZWN0aW9uKSB7XG5cdFx0XHRcdFx0bmV3UmFkaXVzU2VsZWN0aW9uID0gcmFkaXVzRHJvcGRvd24uZmluZChcIm9wdGlvblwiKS5sZW5ndGggLSAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdG5ld1JhZGl1c1NlbGVjdGlvbiA9IHJhZGl1c0Ryb3Bkb3duLmZpbmQoXCJvcHRpb25bdmFsdWU9XCIrbmV3UmFkaXVzU2VsZWN0aW9uK1wiXVwiKS5pbmRleCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJhZGl1c0Ryb3Bkb3duLmRhdGEoXCJzdXBwcmVzc1wiLCB0cnVlKS5wcm9wKFwic2VsZWN0ZWRJbmRleFwiLCBuZXdSYWRpdXNTZWxlY3Rpb24pLnRyaWdnZXIoXCJjaGFuZ2VcIik7XG5cdFx0XHR9XG5cdFx0XHQvLyBTaG93IG5vdCBmb3VuZCBlcnJvciBpZiB0aGVyZSBhcmUgbm8gcmVzdWx0c1xuXHRcdFx0aWYgKHJlc3VsdHMuZmluZChcIi5wZHBfbG9jYXRvcl9wcmV2aWV3XCIpLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdG5vdEZvdW5kRXJyb3Iuc2hvdygpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59XG5cbi8vVXNlIGRhdGEgZnJvbSBzd2F0Y2ggaHJlZiB0byBkaXNwbGF5IGltYWdlXG5mdW5jdGlvbiBmdWxsU2NyZWVuSW1hZ2UoKXtcblx0dmFyIHN3YXRjaGVzID0gJCgnLnN3YXRjaGVzIGxpLnNlbGVjdGVkIGEnKTtcblx0dmFyIHNlbGVjdGVkVmFyaWF0aW9uID0gJCgnLnN3YXRjaGVzIGxpLnNlbGVjdGVkIGEnKS5hdHRyKCdocmVmJyk7XG5cblx0aWYoc3dhdGNoZXMubGVuZ3RoID49IDEgJiYgc2VsZWN0ZWRWYXJpYXRpb24pe1xuXHRcdHZhciBmdWxsU2NyZWVuWm9vbUxpbmsgPSAkKCcjZnVsbHNjcmVlbi16b29tLWhvcHVwJyk7XG5cdFx0dmFyIHNlbGVjdGVkVmFyaWF0aW9uID0gc2VsZWN0ZWRWYXJpYXRpb24ucmVwbGFjZShcIlByb2R1Y3QtVmFyaWF0aW9uXCIsIFwiUHJvZHVjdC1HZXRGdWxsU2NyZWVuSW1hZ2VcIik7XG5cdFx0ZnVsbFNjcmVlblpvb21MaW5rLmF0dHIoJ2hyZWYnLCBzZWxlY3RlZFZhcmlhdGlvbik7XG5cdH1cbn1cblxuJChmdW5jdGlvbigpIHtcblx0dmFyIG1vYmlsZUljb24gPSAkKCcjbW9iaWxlLXpvb20taWNvbicpO1xuXHR2YXIgcGRwTWFpbiA9ICQoJyNwZHBNYWluJyk7XG5cblx0XHRpZihwZHBNYWluLmxlbmd0aCA+PSAxKXtcblx0XHRcdGZ1bGxTY3JlZW5JbWFnZSgpO1xuXG5cdFx0XHR2YXIgaXNHaWZ0Q2FyZCA9ICQoJyNpc0dpZnRDYXJkJykubGVuZ3RoO1xuXHRcdFx0aWYoaXNHaWZ0Q2FyZCl7XG5cdFx0XHRcdCQoJyNmdWxsc2NyZWVuLXpvb20taG9wdXAnKS5hZGRDbGFzcygndmlzdWFsbHktaGlkZGVuJyk7XG5cdFx0XHR9XG5cblx0XHRcdCQoJ2JvZHknKS5vbignY2xpY2snLCcjZnVsbHNjcmVlbi16b29tLWhvcHVwJyxmdW5jdGlvbihlKXtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRcdC8vIENyZWF0ZSBEaWFsb2dcblx0XHRcdFx0dmFyIGRsZyA9IGFwcC5kaWFsb2cuY3JlYXRlKHtvcHRpb25zIDoge1xuXHRcdFx0XHRcdHdpZHRoOiA4OTUsXG5cdFx0XHRcdFx0ZGlhbG9nQ2xhc3M6IFwiZnVsbFNjcmVlblwiXG5cdFx0XHRcdH19KTtcblxuXHRcdFx0XHR2YXIgcGFyYW1zID0ge307XG5cblxuXHRcdFx0XHQvL1BvdGVudGlhbGx5IGFkZCBtb25vZ3JhbW1pbmcgb3B0aW9uIHBhcmFtZXRlcnNcblx0XHRcdFx0dmFyICRtb25vZ3JhbW1pbmdDb250YWluZXIgPSBwZHBNYWluLmZpbmQoJy5tb25vZ3JhbS1jb250YWluZXInKTtcblxuXHRcdFx0XHRpZigkbW9ub2dyYW1taW5nQ29udGFpbmVyLmxlbmd0aCl7XG5cblx0XHRcdFx0XHR2YXIgaW1nT3B0aW9ucyA9ICRtb25vZ3JhbW1pbmdDb250YWluZXIuZGF0YSgnaW1hZ2VPcHRpb25zJyk7XG5cdFx0XHRcdFx0aWYoJG1vbm9ncmFtbWluZ0NvbnRhaW5lci5maW5kKCd1bC5tb25vZ3JhbS1zdHlsZXMgbGkubW9ub2dyYW0tc3R5bGUtdGlsZS5zZWxlY3RlZCcpLmxlbmd0aCAhPSAwKXtcblx0XHRcdFx0XHRcdHZhclx0cGVyc29uYWxpemF0aW9uVHlwZSA9ICRtb25vZ3JhbW1pbmdDb250YWluZXIuZmluZCgndWwubW9ub2dyYW0tc3R5bGVzIGxpLm1vbm9ncmFtLXN0eWxlLXRpbGUuc2VsZWN0ZWQnKS5hdHRyKCdkYXRhLXN0eWxlLWNvbmZpZycpLnBlcnNvbmFsaXphdGlvblR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciB2YWxpZCA9IChpbWdPcHRpb25zWyckZnR5cGUnXSAhPSBudWxsICYmXG5cdFx0XHRcdFx0XHRpbWdPcHRpb25zWyckZnN0eWxlJ10gIT0gIG51bGwgJiZcblx0XHRcdFx0XHRcdGltZ09wdGlvbnNbJyRkb3RzJ10gIT0gbnVsbCAmJlxuXHRcdFx0XHRcdFx0KGltZ09wdGlvbnNbJyRjaHIxJ10gIT0gbnVsbCB8fCBpbWdPcHRpb25zWyckY2hyMiddICE9IG51bGwgfHwgaW1nT3B0aW9uc1snJGNocjMnXSAhPSBudWxsKSk7XG5cblx0XHRcdFx0XHRpZigkbW9ub2dyYW1taW5nQ29udGFpbmVyLmZpbmQoJ2xpLm1vbm9ncmFtLWNvbG9yLXN3YXRjaCcpLmxlbmd0aCl7XG5cdFx0XHRcdFx0XHR2YWxpZCA9IHZhbGlkICYmIGltZ09wdGlvbnNbJyRjb2xvciddICE9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYodmFsaWQpe1xuXG5cdFx0XHRcdFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKGltZ09wdGlvbnMpLFxuXHRcdFx0XHRcdFx0XHRuZXdJbWdPcHRpb25zID0ge307XG5cblx0XHRcdFx0XHRcdC8vYWRkIHRoZSBwcmVmaXggdG8gbWFrZSBpdCBlYXN5IG9uIHRoZSBzZXJ2ZXJzaWRlIHRvIGdyYWIgYWxsIG9mIHRoZSByaWdodCBwYXJhbWV0ZXJzXG5cdFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7aSsrKXtcblx0XHRcdFx0XHRcdFx0dmFyIGtleSA9IFwiaW1nT3B0aW9uX1wiK2tleXNbaV07XG5cblx0XHRcdFx0XHRcdFx0bmV3SW1nT3B0aW9uc1trZXldID0gaW1nT3B0aW9uc1trZXlzW2ldXTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0bmV3SW1nT3B0aW9uc1tcInBlcnNvbmFsaXphdGlvblR5cGVcIl0gPSBwZXJzb25hbGl6YXRpb25UeXBlO1xuXG5cdFx0XHRcdFx0XHRwYXJhbXMgPSBuZXdJbWdPcHRpb25zO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cblx0XHRcdFx0dmFyIHVybCA9IGFwcC51dGlsLmFwcGVuZFBhcmFtc1RvVXJsKCQodGhpcykuYXR0cihcImhyZWZcIikscGFyYW1zKTtcblx0XHRcdFx0Ly9pZiBVUkwgaXMgYnVpbHQgb24gbW9ub2dyYW0gcGFnZSwgaXQgaXMgaW5jb21wbGV0ZSBhbmQgY2Fubm90IGJlIHJlbmRlcmVkXG5cdFx0XHRcdGlmKHVybC5pbmRleE9mKCdzaXplJykgPCAwKXtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0JC5hamF4KHtcblx0XHRcdFx0XHR1cmw6dXJsLFxuXHRcdFx0XHRcdHRhcmdldDpkbGcsXG5cdFx0XHRcdFx0Y2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdFx0ZGxnLmRpYWxvZyhcIm9wZW5cIik7XG5cblx0XHRcdFx0XHRcdHZhciBkaWFsb2dDb250YWluZXIgPSAkKCcjZGlhbG9nLWNvbnRhaW5lcicpO1xuXHRcdFx0XHRcdFx0dmFyIHByb2R1Y3RJbWFnZSA9IGRpYWxvZ0NvbnRhaW5lci5maW5kKCQoJy5wcm9kdWN0LXByaW1hcnktaW1hZ2UgaW1nJykpO1xuXHRcdFx0XHRcdFx0dmFyIGRvd25sb2FkTGluayA9ICQoJyNmdWxsc2NyZWVuLWRvd25sb2FkIGEnKTtcblx0XHRcdFx0XHRcdGRpYWxvZ0NvbnRhaW5lci5maW5kKCQoJy51aS1kaWFsb2ctdGl0bGViYXItY2xvc2UnKS5hZGRDbGFzcygnZnVsbHNjcmVlbi16b29tLWNsb3NlJykpO1xuXG5cdFx0XHRcdFx0XHR2YXIgcmVwbGFjZVN0ciA9IFwiJHM3ZnVsbHNpemUkXCI7XG5cdFx0XHRcdFx0XHRpZigkbW9ub2dyYW1taW5nQ29udGFpbmVyLmxlbmd0aCl7XG5cdFx0XHRcdFx0XHRcdHJlcGxhY2VTdHIgPSBcIiRwcm9kdWN0VGh1bWJuYWlsJFwiO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQkKFwiLnRodW1iIGFcIikuY2xpY2soZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdHZhciBpbWFnZVNyYyA9ICQodGhpcykuYXR0cignaHJlZicpO1xuXG5cdFx0XHRcdFx0XHRcdHZhciBmdWxsU2NyZWVuSW1nID0gaW1hZ2VTcmMucmVwbGFjZShyZXBsYWNlU3RyLCBcIiRmdWxsc2NyZWVuJFwiKTtcblx0XHRcdFx0XHRcdFx0cHJvZHVjdEltYWdlLmF0dHIoJ3NyYycsIGZ1bGxTY3JlZW5JbWcpO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFwcGVuZCBTY2VuZTcgcGFyYW0gZm9yY2UgZG93bmxvYWRcblx0XHRcdFx0XHRcdFx0ZnVsbFNjcmVlbkltZyArPSAnJmRvd25sb2FkJztcblx0XHRcdFx0XHRcdFx0ZG93bmxvYWRMaW5rLmF0dHIoJ2hyZWYnLCBmdWxsU2NyZWVuSW1nKTtcblx0XHRcdFx0XHRcdFx0JChlLnRhcmdldCkuY2xvc2VzdChcImxpXCIpLmFkZENsYXNzKFwic2VsZWN0ZWRcIikuc2libGluZ3MoKS5yZW1vdmVDbGFzcyhcInNlbGVjdGVkXCIpO1xuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdHZhciAkbGlzdCA9IGRpYWxvZ0NvbnRhaW5lci5maW5kKCd1bCcpO1xuXHRcdFx0XHRcdFx0JGxpc3QuamNhcm91c2VsKHtcblx0XHRcdFx0XHRcdFx0YXV0bzogMCxcblx0XHRcdFx0XHRcdFx0dmVydGljYWw6dHJ1ZSxcblx0XHRcdFx0XHRcdFx0c2Nyb2xsOjFcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0dmFyIG5leHQgPSBkaWFsb2dDb250YWluZXIuZmluZCgnI25leHQnKTtcblx0XHRcdFx0XHRcdHZhciBwcmV2ID0gZGlhbG9nQ29udGFpbmVyLmZpbmQoJyNwcmV2Jyk7XG5cdFx0XHRcdFx0XHRpZiAoJCgnLmZ1bGxTY3JlZW4nKS5maW5kKCcjdGh1bWJuYWlsLWNhcm91c2VsIGxpJykubGVuZ3RoIDwgNSkge1xuXHRcdFx0XHRcdFx0XHRuZXh0LmhpZGUoKTtcblx0XHRcdFx0XHRcdFx0cHJldi5oaWRlKCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQkKCcjdGh1bWJuYWlscyAuamNhcm91c2VsLXByZXYnKS5jc3MoXCJjc3NUZXh0XCIsIFwiZGlzcGxheTogYmxvY2sgIWltcG9ydGFudDtcIik7XG5cdFx0XHRcdFx0XHRcdCQoJyN0aHVtYm5haWxzIC5qY2Fyb3VzZWwtbmV4dCcpLmNzcyhcImNzc1RleHRcIiwgXCJkaXNwbGF5OiBibG9jayAhaW1wb3J0YW50O1wiKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dmFyICRmaXJzdCA9ICQoJ2xpOmZpcnN0JywgJGxpc3QpLFxuXHRcdFx0XHRcdFx0XHQkbGFzdCA9ICQoJ2xpOmxhc3QnLCAkbGlzdCk7XG5cblx0XHRcdFx0XHRcdG5leHQuY2xpY2soZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdFx0dmFyICRuZXh0LCAkc2VsZWN0ZWQgPSBkaWFsb2dDb250YWluZXIuZmluZCgoXCIuc2VsZWN0ZWRcIikpO1xuXHRcdFx0XHRcdFx0ICAgICRuZXh0ID0gJHNlbGVjdGVkLm5leHQoJ2xpJykubGVuZ3RoID8gJHNlbGVjdGVkLm5leHQoJ2xpJykgOiAkZmlyc3Q7XG5cdFx0XHRcdFx0XHQgICAgJHNlbGVjdGVkLnJlbW92ZUNsYXNzKFwic2VsZWN0ZWRcIik7XG5cdFx0XHRcdFx0XHQgICAgJG5leHQuYWRkQ2xhc3MoJ3NlbGVjdGVkJyk7XG5cblx0XHRcdFx0XHRcdCAgICB2YXIgdXJsID0gJG5leHQuZmluZCgnYScpLmF0dHIoXCJocmVmXCIpO1xuXG5cdFx0XHRcdFx0XHQgICAgaWYoJG1vbm9ncmFtbWluZ0NvbnRhaW5lci5sZW5ndGgpe1xuXHRcdFx0XHRcdFx0ICAgIFx0dXJsID0gdXJsLnJlcGxhY2UocmVwbGFjZVN0cixcIiRmdWxsc2NyZWVuJFwiKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHByb2R1Y3RJbWFnZS5hdHRyKCdzcmMnLCB1cmwpO1xuXHRcdFx0XHRcdFx0XHRkb3dubG9hZExpbmsuYXR0cignaHJlZicsIHVybCk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCRsYXN0Lmhhc0NsYXNzKCdzZWxlY3RlZCcpKSB7XG5cdFx0XHRcdFx0XHRcdFx0JChcIi5qY2Fyb3VzZWwtbmV4dFwiKS50cmlnZ2VyKCBcImNsaWNrXCIgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdHByZXYuY2xpY2soZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgJHByZXYsICRzZWxlY3RlZCA9IGRpYWxvZ0NvbnRhaW5lci5maW5kKChcIi5zZWxlY3RlZFwiKSk7XG5cdFx0XHRcdFx0XHQgICAgJHByZXYgPSAkc2VsZWN0ZWQucHJldignbGknKS5sZW5ndGggPyAkc2VsZWN0ZWQucHJldignbGknKSA6ICRsYXN0O1xuXHRcdFx0XHRcdFx0ICAgICRzZWxlY3RlZC5yZW1vdmVDbGFzcyhcInNlbGVjdGVkXCIpO1xuXHRcdFx0XHRcdFx0ICAgICRwcmV2LmFkZENsYXNzKCdzZWxlY3RlZCcpO1xuXG5cdFx0XHRcdFx0XHQgICAgdmFyIHVybCA9ICRwcmV2LmZpbmQoJ2EnKS5hdHRyKFwiaHJlZlwiKTtcblxuXHRcdFx0XHRcdFx0ICAgIGlmKCRtb25vZ3JhbW1pbmdDb250YWluZXIubGVuZ3RoKXtcblx0XHRcdFx0XHRcdCAgICBcdHVybCA9IHVybC5yZXBsYWNlKHJlcGxhY2VTdHIsXCIkZnVsbHNjcmVlbiRcIik7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRwcm9kdWN0SW1hZ2UuYXR0cignc3JjJywgdXJsKTtcblx0XHRcdFx0XHRcdFx0ZG93bmxvYWRMaW5rLmF0dHIoJ2hyZWYnLCB1cmwpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICgkZmlyc3QuaGFzQ2xhc3MoJ3NlbGVjdGVkJykpIHtcblx0XHRcdFx0XHRcdFx0XHQkKFwiLmpjYXJvdXNlbC1wcmV2XCIpLnRyaWdnZXIoIFwiY2xpY2tcIiApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0dmFyIHBkcE1haW5DYXJvdXNlbCA9ICQoJyNwZHBNYWluICN0aHVtYm5haWwtY2Fyb3VzZWwgLnNlbGVjdGVkJyk7XG5cdFx0XHRcdFx0XHRpZiAocGRwTWFpbkNhcm91c2VsLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgc2VsZWN0ZWRJbmRleCA9IHBkcE1haW5DYXJvdXNlbC5pbmRleCgpO1xuXHRcdFx0XHRcdFx0XHR2YXIgY29ycmVzcG9uZGluZ0ZTWm9vbUltYWdlID0gJGxpc3QuZmluZCgnbGknKS5lcShzZWxlY3RlZEluZGV4KS5maW5kKCdhJyk7XG5cdFx0XHRcdFx0XHRcdGlmIChjb3JyZXNwb25kaW5nRlNab29tSW1hZ2UubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29ycmVzcG9uZGluZ0ZTWm9vbUltYWdlLmNsaWNrKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmICgkKFwiaHRtbFwiKS5pcygnLnRvdWNoJykpIHtcblx0XHRcdFx0bW9iaWxlSWNvbi5zaG93KCk7XG5cdFx0XHRcdHZhciBvdmVybGF5VGltZU91dCA9IFJlc291cmNlcy5aT09NX09WRVJMQVlfVElNRU9VVDtcblx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpe1xuXHRcdFx0XHRcdG1vYmlsZUljb24uZmFkZU91dChcIjEwMDBcIik7XG5cdFx0XHRcdH0sIG92ZXJsYXlUaW1lT3V0KTtcblx0XHRcdH1cblxuXHRcdFx0JGNhY2hlLnBkcE1haW4ub24oJ2NsaWNrJywgJyNtb2JpbGUtZnVsbHNjcmVlbicsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR2YXIgaW1nVVJMID0gJCgnLnRodW1iLnNsaWNrLWN1cnJlbnQgYScpLmF0dHIoJ2hyZWYnKTtcblx0XHRcdFx0dmFyIG1vZGFsY29udGFpbmVyID0gJCgnI21vYmlsZS1mdWxsc2NyZWVuLW1vZGFsJyk7XG5cdFx0XHRcdHZhciBpbWcgPSAgJCgnPGltZy8+Jyk7XG5cdFx0XHRcdGltZ1swXS5zcmMgPSBpbWdVUkw7XG5cblx0XHRcdFx0bW9kYWxjb250YWluZXIuZW1wdHkoKTtcblx0XHRcdFx0bW9kYWxjb250YWluZXIuYXBwZW5kKGltZylcblxuXHRcdFx0XHR2YXIgZGxnID0gJCgnI21vYmlsZS1mdWxsc2NyZWVuLW1vZGFsJykuZGlhbG9nKHtcblx0XHRcdFx0XHR3aWR0aDogJCgnI21haW4nKS53aWR0aCgpLFxuXHRcdFx0XHRcdG1pbkhlaWdodDogNzUwLFxuXHRcdFx0XHRcdHBvc2l0aW9uOiB7IG15OiBcImxlZnQgdG9wXCIsIGF0OiBcInRvcFwiLCBvZjogd2luZG93IH0sXG5cdFx0XHRcdFx0ZGlhbG9nQ2xhc3M6ICdtb2JpbGUtZnVsbHNjcmVlbi1tb2RhbCdcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0ZGxnLmRpYWxvZygnb3BlbicpO1xuXG5cdFx0XHRcdHZhciBjekluc3RhbmNlID0gbmV3IENsb3VkWm9vbShtb2RhbGNvbnRhaW5lci5maW5kKCdpbWcnKS5lcSgwKSwge1xuXHRcdFx0XHRcdGF1dG9JbnNpZGU6IDc0MCxcblx0XHRcdFx0XHR6b29tU2l6ZU1vZGU6ICdsZW5zJ1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRkbGcub2ZmKCkub24oIFwiZGlhbG9nY2xvc2VcIiwgZnVuY3Rpb24oIGV2ZW50LCB1aSApIHtcblx0XHRcdFx0XHRkbGcuZGlhbG9nKCdkZXN0cm95Jyk7XG5cdFx0XHRcdFx0Y3pJbnN0YW5jZS5kZXN0cm95KCk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHR9KTtcblx0XHRcdCQoJyNtYWluJykub24oJ2NsaWNrJywgJy50aHVtYi5zbGljay1zbGlkZS5zbGljay1jdXJyZW50JywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB3aWR0aCA9ICQoJyNtYWluJykud2lkdGgoKTtcblx0XHRcdFx0aWYgKHdpZHRoIDw9IDQ4MCkge1xuXHRcdFx0XHRcdCQoJyNtb2JpbGUtZnVsbHNjcmVlbicpLmNsaWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0fVxuXG59KTtcblxuJGNhY2hlLnBkcE1haW4uZmluZCgnLnByb2R1Y3QtcHJpbWFyeS1pbWFnZSBpbWcnKS5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24oZSl7XG5cdGlmICghJChcImh0bWxcIikuaXMoJy50b3VjaCcpKSB7XG5cdFx0dmFyIHBkcE1haW4gPSAkKCcjcGRwTWFpbicpO1xuXHRcdGlmKHBkcE1haW4ubGVuZ3RoKXtcblx0XHRcdCQoJyN6b29tLXRpcCcpLnNob3coKS5jc3MoeydsZWZ0JzogZS5wYWdlWCArIDIwLCAndG9wJzogZS5wYWdlWSAtIDIwIC0gcGRwTWFpbi5vZmZzZXQoKS50b3B9KTtcblx0XHR9XG5cdH1cbn0pLm9uKCdtb3VzZWxlYXZlJywgZnVuY3Rpb24oKXtcblx0JCgnI3pvb20tdGlwJykuaGlkZSgpO1xufSkub24oJ2NsaWNrJywgZnVuY3Rpb24oZSl7XG5cdHZhciAkc2VsZiA9ICQodGhpcykuY3NzKCdjdXJzb3InLCAnd2FpdCcpO1xuXHR2YXIgJHpvb21lZEN0ciA9ICQoJyN6b29tZWQtaW1hZ2UnKTtcblx0dmFyIGltZ1NyYyA9ICRzZWxmLmRhdGEoJ2JpZycpO1xuXHR2YXIgaW1nID0gbmV3IEltYWdlKCk7XG5cdGltZy5vbmxvYWQ9ZnVuY3Rpb24oKXtcblx0XHQvLyRzZWxmLnJlbW92ZUF0dHIoJ3N0eWxlJyk7XG5cdFx0JHNlbGYuY3NzKCdjdXJzb3InLCcnKTtcblx0XHQkem9vbWVkQ3RyLmZhZGVJbigyMDApO1xuXHRcdGlmICgkKFwiaHRtbFwiKS5pcygnLnRvdWNoJykpIHtcblx0XHRcdGNlbnRlclpvb20oKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0em9vbUludGVyYWN0aW9uKGUpO1xuXHRcdH1cblx0fTtcblx0aW1nLnNyYz1pbWdTcmM7XG5cdCR6b29tZWRDdHIuZmluZCgnaW1nJykuYXR0cignc3JjJywgaW1nU3JjKTtcbn0pO1xuXG4vLyAgIHpvb20gaW50ZXJhY3Rpb25cbmZ1bmN0aW9uIHpvb21JbnRlcmFjdGlvbihldmVudCl7XG5cdHZhciAkY29udGFpbmVyID0gJCgnI3pvb21lZC1pbWFnZScpO1xuXHR2YXIgJGltYWdlID0gJGNvbnRhaW5lci5maW5kKCdpbWcnKTtcblx0dmFyIGNvbnRhaW5lcl93aWQgPSAkY29udGFpbmVyLndpZHRoKCk7XG5cdHZhciBjb250YWluZXJfaGVpID0gJGNvbnRhaW5lci5oZWlnaHQoKTtcblx0dmFyIGltYWdlX3dpZCA9ICRpbWFnZS53aWR0aCgpO1xuXHR2YXIgaW1hZ2VfaGVpID0gJGltYWdlLmhlaWdodCgpO1xuXHR2YXIgb2Zmc2V0ID0gJGNvbnRhaW5lci5vZmZzZXQoKTtcblx0dmFyIG1hc2tXaWR0aCAgPSAkKFwiI3pvb21lZC1pbWFnZVwiKS53aWR0aCgpO1xuXHR2YXIgbWFza0hlaWdodCA9ICQoXCIjem9vbWVkLWltYWdlXCIpLmhlaWdodCgpO1xuXHR2YXIgeDEseTEseDIseTI7XG5cblxuXHRpZihjb250YWluZXJfd2lkIDwgaW1hZ2Vfd2lkKSB7XG5cdFx0dmFyIHdpZF9kaWZmID0gaW1hZ2Vfd2lkIC0gY29udGFpbmVyX3dpZDtcblx0XHR2YXIgbmV3X2xlZnQgPSAtKHdpZF9kaWZmLzIpO1xuXG5cdFx0JGltYWdlLmNzcyh7XG5cdFx0XHRsZWZ0OiBuZXdfbGVmdFxuXHRcdH0pO1xuXHRcdHgxID0gMipuZXdfbGVmdDtcblx0XHR4MiA9IDA7XG5cblx0fSBlbHNlIHtcblx0XHR2YXIgbmV3X2xlZnQgPSAoY29udGFpbmVyX3dpZCAtIGltYWdlX3dpZCkvMjtcblxuXHRcdCRpbWFnZS5jc3Moe1xuXHRcdFx0bGVmdDogbmV3X2xlZnRcblx0XHR9KTtcblxuXHRcdHgxID0gMDtcblx0XHR4MiA9IDIqbmV3X2xlZnQ7XG5cdH1cblxuXHRpZihjb250YWluZXJfaGVpIDwgaW1hZ2VfaGVpKSB7XG5cdFx0dmFyIGhlaV9kaWZmID0gKGltYWdlX2hlaSAtIGNvbnRhaW5lcl9oZWkpL2NvbnRhaW5lcl9oZWk7XG5cdFx0dmFyIG5ld190b3AgPSAwIC0gKChldmVudC5wYWdlWSAtIG9mZnNldC50b3ApICogaGVpX2RpZmYpIDtcblxuXHRcdCRpbWFnZS5jc3Moe1xuXHRcdFx0dG9wOiBuZXdfdG9wXG5cdFx0fSk7XG5cdFx0Ly8gMTA4IGlzIHRoZSBoZWlnaHQgb2YgdGhlIGhlYWRlclxuXHRcdHkxID0gLSggaW1hZ2VfaGVpLzIgKyAxMDgpO1xuXHRcdHkyID0gMTA4O1xuXHR9XG5cblx0JCgnI3pvb21lZC1pbWFnZSBpbWcnKS5kcmFnZ2FibGUoeyBjb250YWlubWVudDogW3gxLHkxLHgyLHkyXSwgc2Nyb2xsOiBmYWxzZX0pO1xufVxuXG5mdW5jdGlvbiBjZW50ZXJab29tKCkge1xuXHR2YXIgJGNvbnRhaW5lciA9ICQoJyN6b29tZWQtaW1hZ2UnKSxcblx0XHQkaW1hZ2UgPSAkY29udGFpbmVyLmZpbmQoJ2ltZycpLFxuXHRcdGNvbnRhaW5lcl93aWQgPSAkY29udGFpbmVyLmhlaWdodCgpLFxuXHRcdGNvbnRhaW5lcl9oZWkgPSAkY29udGFpbmVyLndpZHRoKCksXG5cdFx0aW1hZ2Vfd2lkID0gJGltYWdlLndpZHRoKCksXG5cdFx0aW1hZ2VfaGVpID0gJGltYWdlLmhlaWdodCgpO1xuXG5cdGlmKGNvbnRhaW5lcl93aWQgPCBpbWFnZV93aWQpIHtcblx0XHR2YXIgd2lkX2RpZmYgPSAoaW1hZ2Vfd2lkIC0gY29udGFpbmVyX3dpZCkvY29udGFpbmVyX3dpZDtcblx0XHR2YXIgbmV3X2xlZnQgPSAwIC0gKDEgKiB3aWRfZGlmZikgLSAoY29udGFpbmVyX3dpZC8yKTtcblx0XHQkaW1hZ2UuY3NzKHtcblx0XHRcdGxlZnQ6IG5ld19sZWZ0XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0JGltYWdlLmNzcyh7XG5cdFx0XHRsZWZ0OiAwIC0gKGltYWdlX3dpZC8yKVxuXHRcdH0pO1xuXHR9XG5cblx0JGltYWdlLmNzcyh7XG5cdFx0J3RvcCc6ICcwcHgnXG5cdH0pO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlQ29udGVudCgpIHtcblx0dmFyICR1cGRhdGVDb250ZW50Q3RyID0gJGNhY2hlLnBkcE1haW4uZmluZChcIiN1cGRhdGVUYWJzXCIpLFxuXHRcdCRvbGRUYWJzID0gJHVwZGF0ZUNvbnRlbnRDdHIuZmluZCgnLnRhYi1jb250ZW50JyksXG5cdFx0aXNRdWlja1ZpZXcgPSAoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgJHF2Y29udGFpbmVyID0gJCgnI3F1aWNrLXZpZXctZGlhbG9nJyk7XG5cdFx0XHRyZXR1cm4gKCRxdmNvbnRhaW5lci5sZW5ndGg+MCk7XG5cdFx0fSkoKTtcblxuXHRpZigkdXBkYXRlQ29udGVudEN0ci5sZW5ndGggPiAwKSB7XG5cdFx0JC5lYWNoKCRvbGRUYWJzLCBmdW5jdGlvbihpbmRleCwgb2xkVGFiKSB7XG5cdFx0XHR2YXIgJG9sZFRhYiA9ICQob2xkVGFiKSxcblx0XHRcdCRvbGRUYWJJZCA9ICRvbGRUYWIuYXR0cignaWQnKSxcblx0XHRcdCRuZXdUYWIgPSAnJyxcblx0XHRcdG5ld0NvbnRlbnQgPSAnJztcblxuXHRcdFx0aWYoJG9sZFRhYklkKXtcblx0XHRcdFx0JG5ld1RhYiA9ICR1cGRhdGVDb250ZW50Q3RyLmZpbmQoJ1tkYXRhLXJlbD0nKyAkb2xkVGFiSWQgKyddJyk7XG5cdFx0XHRcdG5ld0NvbnRlbnQgPSAkbmV3VGFiLmh0bWwoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCRuZXdUYWIgIT0gJycgJiYgJG5ld1RhYi5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdCRvbGRUYWIuZW1wdHkoKS5odG1sKG5ld0NvbnRlbnQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdCR1cGRhdGVDb250ZW50Q3RyLnJlbW92ZSgpO1xuXG5cdFx0dmFyIHZlcnRpY2FsID0gdHJ1ZVxuXG5cdFx0JCgnI3RodW1ibmFpbC1jYXJvdXNlbCcpLmpjYXJvdXNlbCh7XG5cdFx0XHRhdXRvOiAwLFxuXHRcdFx0dmVydGljYWw6dmVydGljYWwsXG5cdFx0XHRzY3JvbGw6MVxuXHRcdH0pO1xuXHRcdCQoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcGRwTWFpbiA9ICQoJyNwZHBNYWluJyk7XG5cdFx0XHR2YXIgaXNjTmV4dCA9IHBkcE1haW4uZmluZCgkKCcuamNhcm91c2VsLW5leHQnKSkuaXMoJzpoaWRkZW4nKTtcblx0XHRcdHZhciBpc2NQcmV2ID0gcGRwTWFpbi5maW5kKCQoJy5qY2Fyb3VzZWwtcHJldicpKS5pcygnOmhpZGRlbicpO1xuXHRcdFx0dmFyIGNhcm91c2VsQ2xpcCA9IHBkcE1haW4uZmluZCgnLmpjYXJvdXNlbC1jbGlwJyk7XG5cblx0XHRcdGlmKGlzY05leHQgJiYgaXNjUHJldil7XG5cdFx0XHRcdGNhcm91c2VsQ2xpcC5jc3MoeydtYXJnaW4tdG9wJzogJzAnfSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0aWYgKCQoJyNwZHBNYWluJykuZmluZCgnI3RodW1ibmFpbHMgbGknKS5sZW5ndGggPD0gNCkge1xuXHRcdFx0JCgnI3RodW1ibmFpbHMgLmpjYXJvdXNlbC1wcmV2JykuaGlkZSgpO1xuXHRcdFx0JCgnI3RodW1ibmFpbHMgLmpjYXJvdXNlbC1uZXh0JykuaGlkZSgpO1xuXG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VDbG91ZFpvb21JbWFnZXMocGRwTWFpbikge1xuXHR2YXIgbmV3SW1hZ2VzID0gJChcIiN1cGRhdGUtaW1hZ2VzXCIpO1xuXHR2YXIgaW1hZ2VDb250YWluZXIgPSBwZHBNYWluLmZpbmQoXCIucHJvZHVjdC1jb2wtMTpmaXJzdFwiKTtcblxuXHRpbWFnZUNvbnRhaW5lci5odG1sKG5ld0ltYWdlcy5odG1sKCkpO1xuXHRuZXdJbWFnZXMucmVtb3ZlKCk7XG5cdGFwcC5wcm9kdWN0LmluaXRNb2JpbGVQRFBDYXJvdXNlbCgpO1xuXG5cdHZhciBpc1F1aWNrVmlldyA9IChmdW5jdGlvbigpIHtcblx0XHR2YXIgJHF2Y29udGFpbmVyID0gJCgnI3F1aWNrLXZpZXctZGlhbG9nJyk7XG5cdFx0cmV0dXJuICgkcXZjb250YWluZXIubGVuZ3RoPjApO1xuXHR9KSgpO1xuXG5cdGlmICghaXNRdWlja1ZpZXcpe1xuXHRcdC8vIFJlIGhvb2tcblx0XHRDbG91ZFpvb20ucXVpY2tTdGFydCgpO1xuXHR9XG5cdGVsc2V7XG5cdFx0YXBwLnF1aWNrVmlldy5pbml0UXVpY2tWaWV3Q2Fyb3VzZWwoKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZXBsYWNlSW1hZ2VzKHBkcE1haW4pIHtcblx0dmFyICR1cGRhdGVJbWFnZXNDdHIgPSBwZHBNYWluLmZpbmQoXCIjdXBkYXRlLWltYWdlc1wiKSxcblx0XHQkbWFpbkltYWdlQ3RyID0gcGRwTWFpbi5maW5kKFwiLnByb2R1Y3QtaW1hZ2UtY29udGFpbmVyOmZpcnN0XCIpLFxuXHRcdHRodW1ibmFpbHMgPSBwZHBNYWluLmZpbmQoJy5wcm9kdWN0LXRodW1ibmFpbHM6Zmlyc3QnKSxcblx0XHRuZXdUaHVtYm5haWxzID0gJHVwZGF0ZUltYWdlc0N0ci5maW5kKCcucHJvZHVjdC10aHVtYm5haWxzJyksXG5cdFx0bmV3TWFpbkltYWdlcyA9ICR1cGRhdGVJbWFnZXNDdHIuZmluZCgnLnByb2R1Y3QtaW1hZ2UtY29udGFpbmVyJyksXG5cdFx0Y3VycmVudFBvcyA9IE51bWJlcigkbWFpbkltYWdlQ3RyLmZpbmQoJ2xpLmN1cnJlbnQnKS5hdHRyKCdqY2Fyb3VzZWxpbmRleCcpKS0xIHx8IDAsXG5cdFx0aXNRdWlja1ZpZXcgPSAoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgJHF2Y29udGFpbmVyID0gJCgnI3F1aWNrLXZpZXctZGlhbG9nJyk7XG5cdFx0XHRyZXR1cm4gKCRxdmNvbnRhaW5lci5sZW5ndGg+MCk7XG5cdFx0fSkoKTtcblxuXG5cdCRtYWluSW1hZ2VDdHIucmVwbGFjZVdpdGgobmV3TWFpbkltYWdlcyk7XG5cdCR1cGRhdGVJbWFnZXNDdHIucmVtb3ZlKCk7XG5cbn1cblxuLy9Vc2UgZm9yIEFKQVggUmVxdWVzdHMgLSBDaGVja3MgYW5kIGNsb3NlcyBhbnkgQmF6emFyVm9pY2UgSG9wdXAgRG9tIEVsZW1lbnRzXG5mdW5jdGlvbiBiYXp6YXJ2b2ljZUNsZWFySG9wdXAoKXtcblx0dHJ5e1xuXHRcdHZhciBidlJlYWRDbG9zZUJ0biA9ICQoJyN1aS1kaWFsb2ctdGl0bGUtUmV2Q29udGFpbmVyJykubmV4dCgnLnVpLWRpYWxvZy10aXRsZWJhci1jbG9zZScpO1xuXHRcdHZhciBidlN1Ym1pdENsb3NlQnRuID0gJCgnI3VpLWRpYWxvZy10aXRsZS1CVlN1Ym1pc3Npb25Db250YWluZXInKS5uZXh0KCcudWktZGlhbG9nLXRpdGxlYmFyLWNsb3NlJyk7XG5cblx0XHRpZihidlJlYWRDbG9zZUJ0bi5pcygnOnZpc2libGUnKSlcblx0XHRcdGJ2UmVhZENsb3NlQnRuLnRyaWdnZXIoJ2NsaWNrJyk7XG5cblx0XHRpZihidlN1Ym1pdENsb3NlQnRuLmlzKCc6dmlzaWJsZScpKVxuXHRcdFx0YnZTdWJtaXRDbG9zZUJ0bi50cmlnZ2VyKCdjbGljaycpO1xuXHR9IGNhdGNoKGUpIHtcblx0XHQvL2Vycm9yXG5cdH1cbn1cblxuLypGdW5jdGlvbnMgZm9yIE1vbm9ncmFtbWluZyovXG5mdW5jdGlvbiB2YWxpZGF0ZUZvcm1GaWVsZHMoKXtcblx0dmFyIHZhbGlkID0gdHJ1ZTtcblx0aWYgKCQoJy5tb25vZ3JhbS1jb250YWluZXInKS5sZW5ndGggPT09IDApIHtcblx0XHRyZXR1cm4gdmFsaWQ7XG5cdH1cblxuXHRpZigoJGNhY2hlLnNlbGVjdGVkU3R5bGVDb25maWcubWluQ2hhciA9PSAkY2FjaGUuc2VsZWN0ZWRTdHlsZUNvbmZpZy5tYXhDaGFyKSAmJiAkY2FjaGUuc2VsZWN0ZWRTdHlsZUNvbmZpZy5tYXhDaGFyIDw9IDMpe1xuXHRcdGZvcih2YXIgaSA9IDE7IGkgPD0gJGNhY2hlLnNlbGVjdGVkU3R5bGVDb25maWcubWF4Q2hhcjsgaSsrKXtcblx0XHRcdHZhciAkZWxlID0gJGNhY2hlLm1vbm9ncmFtZm9ybWZpZWxkcy5maW5kKCdpbnB1dFtuYW1lPVwibW9ub2dyYW1fQ0hBUicgKyBpICsgJ1wiXScpO1xuXG5cdFx0XHRpZighJGVsZS52YWwoKSl7XG5cdFx0XHRcdHZhbGlkID0gZmFsc2U7XG5cdFx0XHRcdHNldEVycm9yTWVzc2FnZSgkZWxlKTtcblxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0fWVsc2V7XG5cdFx0Ly8gaWYgd2UgaGF2ZSBhIFwid29yZFwiIHR5cGUsIG1ha2Ugc3VyZSB3ZSBoYXZlIGF0IGxlYXN0IDEgY2hhcmFjdGVyXG5cdFx0aWYoJGNhY2hlLnNlbGVjdGVkU3R5bGVDb25maWcubWF4Q2hhciA+IDMpe1xuXHRcdFx0dmFyICRlbGUgPSAkY2FjaGUubW9ub2dyYW1mb3JtZmllbGRzLmZpbmQoJ2lucHV0W25hbWU9XCJtb25vZ3JhbV9DSEFSMVwiXScpO1xuXHRcdFx0aWYoISRlbGUudmFsKCkpe1xuXHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xuXHRcdFx0XHRzZXRFcnJvck1lc3NhZ2UoJGVsZSk7XG5cdFx0XHR9XG5cdFx0Ly8gZWxzZSwgd2UgaGF2ZSBhIHJhbmdlIG9mIGNoYXJhY3RlcnMsIHNvIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGVyZVxuXHRcdC8vIGlzIGF0IGxlYXN0IDEgZmllbGQgcG9wdWxhdGVkXG5cdFx0fWVsc2V7XG5cdFx0XHR2YXIgY291bnQgPSAwO1xuXG5cdFx0XHRmb3IodmFyIGkgPSAxOyBpIDw9ICRjYWNoZS5zZWxlY3RlZFN0eWxlQ29uZmlnLm1heENoYXI7IGkrKylcblx0XHRcdHtcblx0XHRcdFx0dmFyICRlbGUgPSAkY2FjaGUubW9ub2dyYW1mb3JtZmllbGRzLmZpbmQoJ2lucHV0W25hbWU9XCJtb25vZ3JhbV9DSEFSJyArIGkgKyAnXCJdJyk7XG5cblx0XHRcdFx0aWYoICRlbGUudmFsKCkgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiggY291bnQgPCAkY2FjaGUuc2VsZWN0ZWRTdHlsZUNvbmZpZy5taW5DaGFyIHx8IGNvdW50ID4gJGNhY2hlLnNlbGVjdGVkU3R5bGVDb25maWcubWF4Q2hhciApXG5cdFx0XHR7XG5cdFx0XHRcdHZhbGlkID0gZmFsc2U7XG5cdFx0XHRcdHZhciAkZWxlID0gJGNhY2hlLm1vbm9ncmFtZm9ybWZpZWxkcy5maW5kKCdpbnB1dFtuYW1lPVwibW9ub2dyYW1fQ0hBUjFcIl0nKTtcblx0XHRcdFx0Ly8gc2hvdyB0aGUgZXJyb3IgbWVzc2FnZVxuXHRcdFx0XHRzZXRFcnJvck1lc3NhZ2UoJGVsZSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdHZhbGlkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHZhbGlkO1xufVxuZnVuY3Rpb24gc2V0RXJyb3JNZXNzYWdlKCRlbGUpe1xuXHQvLyBzZXQgYW4gZXJyb3IgY2xhc3Mgb24gJGVsZSwgd2UgaGF2ZSBvbmUgd2l0aCB0aGUgcmVkIGJvcmRlclxuXHQvLyBzaG93IHRoZSBlcnJvciBtZXNzYWdlXG5cdCQoJy5tb25vZ3JhbS10ZXh0LWlucHV0LXdyYXBwZXIgaW5wdXQnKS5hZGRDbGFzcygnZXJyb3InKTtcblx0JCgnLm1vbm9ncmFtLXRleHQtbWlzc2luZy1pbnB1dC1lcnJvcicpLnNob3coKTtcbn1cbmZ1bmN0aW9uIGNsZWFyRXJyb3JNZXNzYWdlcygpe1xuXHQkKCcubW9ub2dyYW0tdGV4dC1pbnB1dC13cmFwcGVyIGlucHV0JykucmVtb3ZlQ2xhc3MoJ2Vycm9yJyk7XG5cdCQoJy5tb25vZ3JhbS10ZXh0LWlucHV0LWVycm9yJykuaGlkZSgpO1xufVxuXG5mdW5jdGlvbiBtb25vZ3JhbVJlc2V0KCkge1xuICAgIHZhciBtb25vQ29udGFpbmVyID0gJCgnLm1vbm9ncmFtLWNvbnRhaW5lcicpO1xuICAgIGlmIChtb25vQ29udGFpbmVyLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvL3JlbW92ZSB0aGUgY2hhcmFjdGVyc1xuICAgICAgICAkKCcubW9ub2dyYW0tdGV4dC1pbnB1dC1maWVsZCcpLnZhbCgnJykudHJpZ2dlcihcImtleXVwXCIpLnJlbW92ZUNsYXNzKFwiZXJyb3JcIik7XG4gICAgICAgICQoXCIubW9ub2dyYW0tdGV4dC1pbnB1dC1lcnJvclwiKS5oaWRlKCk7XG5cbiAgICAgICAgLy8gaGlkZSB0aGUgYm90dG9tIGNvbnRhaW5lcnNcbiAgICAgICAgJGNhY2hlLm1vbm9ncmFtY29udGFpbmVyLmZpbmQoJy5tb25vZ3JhbS1zZWN0aW9uJykuYWRkQ2xhc3MoJ2luYWN0aXZlLXNlY3Rpb24nKTtcbiAgICAgICAgJGNhY2hlLm1vbm9ncmFtY29udGFpbmVyLmZpbmQoJy5tb25vZ3JhbS1vcHRpb25zLWJvZHknKS5zbGlkZVVwKCk7XG4gICAgICAgICRjYWNoZS5tb25vZ3JhbWNvbnRhaW5lci5maW5kKCcubW9ub2dyYW0tY29sb3JzLXNlY3Rpb24tYm9keScpLnNsaWRlVXAoKTtcbiAgICAgICAgJGNhY2hlLm1vbm9ncmFtY29udGFpbmVyLmZpbmQoJy5tb25vZ3JhbS1zZWN0aW9uLXRpdGxlLCAubW9ub2dyYW0tdG9nZ2xlLWljb24nKS5hZGRDbGFzcygnaW5hY3RpdmUnKTtcbiAgICAgICAgJGNhY2hlLm1vbm9ncmFtY29udGFpbmVyLmZpbmQoJy5tb25vZ3JhbS1zZWN0aW9uLXRpdGxlIC5jb2xvci1uYW1lJykuYWRkQ2xhc3MoJ3Zpc3VhbGx5LWhpZGRlbicpO1xuICAgICAgICAkY2FjaGUucGRwTWFpbi5maW5kKCcucHJvZHVjdC1hZGQtdG8tY2FydCAuYXZhaWxhYmlsaXR5IC52YWx1ZScpLmh0bWwoXCJcIik7XG5cbiAgICAgICAgLy8gYWRqdXN0ICdjaG9vc2UgYSBzdHlsZScgc2VjdGlvblxuICAgICAgICAkY2FjaGUubW9ub2dyYW1zdHlsZXRpbGVzLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgICAkY2FjaGUubW9ub2dyYW1jb250YWluZXIuZmluZCgnLm1vbm9ncmFtLXNlY3Rpb24nKS5maXJzdCgpLnJlbW92ZUNsYXNzKCdpbmFjdGl2ZS1zZWN0aW9uJyk7XG4gICAgICAgICRjYWNoZS5tb25vZ3JhbWNvbnRhaW5lci5maW5kKCcubW9ub2dyYW0tc2VjdGlvbi10aXRsZScpLmZpcnN0KCkucmVtb3ZlQ2xhc3MoJ2luYWN0aXZlJyk7XG4gICAgICAgICRjYWNoZS5tb25vZ3JhbWNvbnRhaW5lci5maW5kKCcubW9ub2dyYW0tdG9nZ2xlLWljb24nKS5maXJzdCgpLnJlbW92ZUNsYXNzKCdpbmFjdGl2ZScpO1xuXG4gICAgICAgIC8vIGRpc2FibGUgdGhlIGEyYyBidXR0b25cbiAgICAgICAgJCgnYnV0dG9uI2FkZC10by1jYXJ0JykuYXR0cihcImRpc2FibGVkXCIsIFwiZGlzYWJsZWRcIik7XG5cbiAgICAgICAgLy8gdW5iaW5kIGNsaWNrIGV2ZW50cyBmb3Igc2xpZGUgVXAvRG93blxuICAgICAgICAkY2FjaGUubW9ub2dyYW1jb250YWluZXIuZmluZCgnLm1vbm9ncmFtLXNlY3Rpb24tdG9nZ2xlIHNwYW4nKS5vZmYoJ2NsaWNrJyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBtb25vZ3JhbVN0eWxlVGlsZUNsaWNrKGUpe1xuXHR2YXIgJHRoaXMgPSAkY2FjaGUubW9ub2dyYW1zdHlsZXMuZmluZChlLnRhcmdldCkuY2xvc2VzdCgnbGkubW9ub2dyYW0tc3R5bGUtdGlsZScpO1xuXG5cdGlmKCR0aGlzLmhhc0NsYXNzKCdzZWxlY3RlZCcpKXtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBkbyBjaGFuZ2VzIGZvciB0aGUgdGlsZXMgYW5kIHN0eWxlIHNlbGVjdGlvblxuXHQkY2FjaGUubW9ub2dyYW1zdHlsZXRpbGVzLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xuXHQkdGhpcy5hZGRDbGFzcygnc2VsZWN0ZWQnKTtcblxuXG5cblx0dmFyIHN0eWxlQ29uZmlnID0gJHRoaXMuZGF0YSgnc3R5bGUtY29uZmlnJyk7XG5cdCRjYWNoZS5zZWxlY3RlZFN0eWxlQ29uZmlnID0gc3R5bGVDb25maWc7XG5cblx0LyoqXG5cdCAqIHNldHVwIGZvbnRzXG5cdCAqL1xuXHQkY2FjaGUubW9ub2dyYW1mb250c2VsZWN0LmVtcHR5KCk7XG5cdHZhciBmb250Q29uZmlnO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlQ29uZmlnLmF2YWlsYWJsZUZvbnRzLmxlbmd0aDsgaSsrKXtcblx0XHRmb250Q29uZmlnID0gc3R5bGVDb25maWcuYXZhaWxhYmxlRm9udHNbaV07XG5cdFx0Y3JlYXRlRm9udFRpbGUoZm9udENvbmZpZyxpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBzZXR1cCBjaGFyYWN0ZXJzXG5cdCAqL1xuXHQvLyBzZXR1cCB0aXRsZVxuXHR2YXIgY2hhcmFjdGVyc1RpdGxlO1xuXHRpZihzdHlsZUNvbmZpZy5taW5DaGFyICE9IHN0eWxlQ29uZmlnLm1heENoYXIpe1xuXHRcdGNoYXJhY3RlcnNUaXRsZSA9IFwidHlwZSBpbiBcIiArIHN0eWxlQ29uZmlnLm1pbkNoYXIgKyBcIiAtIFwiICsgc3R5bGVDb25maWcubWF4Q2hhciArIFwiIGNoYXJhY3RlcnNcIlxuXHR9ZWxzZXtcblxuXHRcdGNoYXJhY3RlcnNUaXRsZSA9IFwidHlwZSBpbiBcIiArIHN0eWxlQ29uZmlnLm1heENoYXIgKyBcIiBjaGFyYWN0ZXJcIjtcblxuXHRcdGlmKHN0eWxlQ29uZmlnLm1heENoYXIgIT09IDEpe1xuXHRcdFx0Y2hhcmFjdGVyc1RpdGxlICs9IFwic1wiO1xuXHRcdH1cblx0fVxuXHQkY2FjaGUubW9ub2dyYW10ZXh0dGl0bGUudGV4dChjaGFyYWN0ZXJzVGl0bGUpO1xuXG5cblx0Ly8gc2F2ZSBvZmYgZXhpc3RpbmcgY2hhcmFjdGVyc1xuXHQvLyBvbmx5IHNhdmUgaWYgd2UgYXJlbid0IHN3aXRjaGluZyBmcm9tIGEgd29yZFxuXHRpZigkY2FjaGUubW9ub2dyYW1jb250YWluZXIuZGF0YSgnaW5wdXRUeXBlJykgIT09ICd3b3JkJyl7XG5cdFx0dmFyIGV4aXN0aW5nQ2hhcmFjdGVycyA9IHt9O1xuXHRcdCRjYWNoZS5tb25vZ3JhbXRleHRpbnB1dGJvZHkuZmluZCgnaW5wdXQnKS5lYWNoKGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgJHRoaXMgID0gJCh0aGlzKSxcblx0XHRcdFx0cG9zaXRpb24gPSAkdGhpcy5kYXRhKCdwb3NpdGlvbicpO1xuXG5cdFx0XHRpZihwb3NpdGlvbil7XG5cdFx0XHRcdHZhciBvID0ge1widmFsXCI6JHRoaXMudmFsKCksXG5cdFx0XHRcdFx0XHRcImlzU3ltYm9sXCI6JHRoaXMuaGFzQ2xhc3MoJ2ZvbnQtc3ltYm9sJyksXG5cdFx0XHRcdFx0XHRcInN5bWJvbENvbmZpZ1wiOiR0aGlzLmRhdGEoJ3N5bWJvbC1jb25maWcnKVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0ZXhpc3RpbmdDaGFyYWN0ZXJzW3Bvc2l0aW9uXSA9IG87XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXG5cdCRjYWNoZS5tb25vZ3JhbXRleHRpbnB1dGJvZHkuZW1wdHkoKTtcblxuXHQvKipcblx0ICogc2V0dXAgaW5wdXQgZmllbGRzXG5cdCAqL1xuXHRpZihzdHlsZUNvbmZpZy5tYXhDaGFyIDw9Myl7XG5cdFx0JGNhY2hlLm1vbm9ncmFtY29udGFpbmVyLmRhdGEoJ2lucHV0VHlwZScsJ2NoYXInKTtcblxuXHRcdHZhciAkdGV4dElucHV0O1xuXHRcdHZhciAkaGlkZGVuQ2hhcklucHV0cyA9ICRjYWNoZS5tb25vZ3JhbWZvcm1maWVsZHMuZmluZChcImlucHV0W25hbWVePSdtb25vZ3JhbV9DSEFSJ11cIik7XG5cblx0XHRmb3IodmFyIGkgPSAxOyBpIDw9IDM7aSsrICl7XG5cdFx0XHRpZihpIDw9IHN0eWxlQ29uZmlnLm1heENoYXIpe1xuXHRcdFx0XHQvLyBjcmVhdGUgaW5wdXRcblx0XHRcdFx0JHRleHRJbnB1dCA9IGNyZWF0ZVRleHRJbnB1dChzdHlsZUNvbmZpZyxpKTtcblx0XHRcdH1cblx0XHRcdCRjYWNoZS5tb25vZ3JhbWNvbnRhaW5lci5kYXRhKCdpbWFnZU9wdGlvbnMnKVsnJGNocicraV0gPSBcIlwiO1xuXHRcdH1cblx0XHQkY2FjaGUubW9ub2dyYW10ZXh0aW5wdXRjbGVhci5wYXJlbnQoKS5yZW1vdmVDbGFzcygnd29yZCcpO1xuXG5cdFx0Ly8gaWYgdmFsdWVzIGFyZSBwcmVzZW50IGZvciBDSEFSIGlucHV0cyB0aGF0IGV4Y2VlZCB0aGUgbWF4Q2hhclxuXHRcdC8vIGNvdW50LCBzZXQgdGhvc2UgdmFsdWVzIHRvIGVtcHR5O1xuXHRcdCQuZWFjaCgkaGlkZGVuQ2hhcklucHV0cywgZnVuY3Rpb24gKGksZWwpIHtcblx0XHRcdGlmIChpID49IHN0eWxlQ29uZmlnLm1heENoYXIpIHtcblx0XHRcdFx0JChlbCkudmFsKCcnKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHQvLyBidWlsZCBiaWcgdGV4dCBmaWVsZFxuXHR9ZWxzZXtcblxuXHRcdCRjYWNoZS5tb25vZ3JhbWNvbnRhaW5lci5kYXRhKCdpbnB1dFR5cGUnLCd3b3JkJyk7XG5cblx0XHRjcmVhdGVXb3JkSW5wdXQoc3R5bGVDb25maWcpO1xuXHRcdCRjYWNoZS5tb25vZ3JhbXRleHRpbnB1dGNsZWFyLnBhcmVudCgpLmFkZENsYXNzKCd3b3JkJyk7XG5cdH1cblx0Ly8gc2hvdy9oaWRlIHRoZSAnZmlyc3QvbGFzdC9taWRkbGUnIHRleHRcblx0JGNhY2hlLm1vbm9ncmFtdGV4dGlucHV0Y29udGFpbmVyLmZpbmQoJy50cmFkaXRpb25hbC1jYXB0aW9uJykudG9nZ2xlKCRjYWNoZS5zZWxlY3RlZFN0eWxlQ29uZmlnLnRyYWRpdGlvbmFsKTtcblx0JGNhY2hlLm1vbm9ncmFtdGV4dGlucHV0Y29udGFpbmVyLnRvZ2dsZUNsYXNzKCd0cmFkaXRpb25hbCcsJGNhY2hlLnNlbGVjdGVkU3R5bGVDb25maWcudHJhZGl0aW9uYWwpO1xuXG5cdC8vIGNsZWFyIG91dCBleGlzdGluZyBmaWVsZCBkYXRhXG5cdCRjYWNoZS5tb25vZ3JhbWZvcm1maWVsZHMuZmluZCgnaW5wdXRbbmFtZV49XCJDSEFSXCJdJykudmFsKFwiXCIpO1xuXG5cdC8vIHJlcG9wdWxhdGUgY2hhcmFjdGVyc1xuXHQvLyBvbmx5IHJlcG9wdWxhdGUgaWYgdGhlIGlucHV0VHlwZSB3ZSdyZSBkZWFsaW5nIHdpdGggaW5kaXZpZHVhbCBpbnB1dFxuXHQvLyBmaWVsZHNcblx0Ly8gYW5kIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGEgc3R5bGUgdGhhdCBoYWQgY2hhcmFjdGVycyBpbnB1dFxuXHRpZigkY2FjaGUubW9ub2dyYW1jb250YWluZXIuZGF0YSgnaW5wdXRUeXBlJykgPT09ICdjaGFyJyAmJiBleGlzdGluZ0NoYXJhY3RlcnMpe1xuXHRcdHZhciAkaW5wdXRzID0gJGNhY2hlLm1vbm9ncmFtdGV4dGlucHV0Ym9keS5maW5kKCdpbnB1dCcpO1xuXHRcdCQuZWFjaChPYmplY3Qua2V5cyhleGlzdGluZ0NoYXJhY3RlcnMpLGZ1bmN0aW9uKGksY2hhcil7XG5cblx0XHRcdC8vIGRvZXMgdGhlIHBvc2l0aW9uIG1hdGNoP1xuXHRcdFx0dmFyICRpbnB1dCA9ICRpbnB1dHMuZmlsdGVyKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHJldHVybiAkKHRoaXMpLmRhdGEoJ3Bvc2l0aW9uJykgPT09IGNoYXI7XG5cdFx0XHR9KS5maXJzdCgpO1xuXG5cdFx0XHQvLyBpZiBzbywgc2V0IHRoZSBuZXcgdmFsdWVcblx0XHRcdGlmKCRpbnB1dC5sZW5ndGgpe1xuXHRcdFx0XHR2YXIgZXhpc3RpbmdDaGFyYWN0ZXIgPSBleGlzdGluZ0NoYXJhY3RlcnNbY2hhcl0sXG5cdFx0XHRcdFx0Y2hhciA9IGV4aXN0aW5nQ2hhcmFjdGVyLnZhbCxcblx0XHRcdFx0XHRzN1ZhbCA9IGNoYXI7XG5cblxuXHRcdFx0XHQvLyBpcyB0aGlzIGEgc3ltYm9sLCBhbmQgZG9lcyB0aGUgc3R5bGUgc3VwcG9ydCB0aGlzIHN5bWJvbD9cblx0XHRcdFx0aWYoZXhpc3RpbmdDaGFyYWN0ZXIuaXNTeW1ib2wpe1xuXG5cdFx0XHRcdFx0Ly8gbG9vcCBvdmVyIGFsbCB0aGUgYXZhaWxhYmxlIGNvbmZpZ3MgYW5kIHNlZSBpZiB3ZSBjYW5cblx0XHRcdFx0XHQvLyBmaW5kIGEgbWF0Y2hcblx0XHRcdFx0XHR2YXIgaXNTeW1ib2xBdmFpbGFibGUgPSBmYWxzZTtcblx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgJGNhY2hlLnNlbGVjdGVkU3R5bGVDb25maWcuYXZhaWxhYmxlU3ltYm9scy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdFx0XHR2YXIgY29uZmlnID0gJGNhY2hlLnNlbGVjdGVkU3R5bGVDb25maWcuYXZhaWxhYmxlU3ltYm9sc1tpXTtcblxuXHRcdFx0XHRcdFx0aWYoY29uZmlnLmNoYXJhY3RlciA9PT0gZXhpc3RpbmdDaGFyYWN0ZXIuc3ltYm9sQ29uZmlnLmNoYXJhY3Rlcil7XG5cdFx0XHRcdFx0XHRcdGlzU3ltYm9sQXZhaWxhYmxlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKGlzU3ltYm9sQXZhaWxhYmxlKXtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYoaXNTeW1ib2xBdmFpbGFibGUpe1xuXHRcdFx0XHRcdFx0JGlucHV0LmFkZENsYXNzKCdmb250LXN5bWJvbCcpO1xuXHRcdFx0XHRcdFx0JGlucHV0LmRhdGEoJ3N5bWJvbC1jb25maWcnLGV4aXN0aW5nQ2hhcmFjdGVyLnN5bWJvbENvbmZpZyk7XG5cdFx0XHRcdFx0XHRzN1ZhbCA9IGV4aXN0aW5nQ2hhcmFjdGVyLnN5bWJvbENvbmZpZy5zY2VuZTdDb2RlO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0Y2hhciA9IFwiXCI7XG5cdFx0XHRcdFx0XHRzN1ZhbCA9IFwiXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0JGlucHV0LnZhbChjaGFyKTtcblx0XHRcdFx0JGNhY2hlLm1vbm9ncmFtY29udGFpbmVyLmRhdGEoJ2ltYWdlT3B0aW9ucycpWyRpbnB1dC5kYXRhKCdwb3NpdGlvbicpXSA9IHM3VmFsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIHNldHVwIHN5bWJvbHNcblx0ICovXG5cdHZhciBhdmFpbGFibGVTeW1ib2xzID0gc3R5bGVDb25maWcuYXZhaWxhYmxlU3ltYm9scztcblx0JGNhY2hlLm1vbm9ncmFtc3ltYm9sbGlzdC5lbXB0eSgpO1xuXHRpZihhdmFpbGFibGVTeW1ib2xzICYmIGF2YWlsYWJsZVN5bWJvbHMubGVuZ3RoID4gMCl7XG5cdFx0dmFyIHN5bWJvbENvbmZpZztcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYXZhaWxhYmxlU3ltYm9scy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRzeW1ib2xDb25maWcgPSBhdmFpbGFibGVTeW1ib2xzW2ldO1xuXHRcdFx0aWYoc3ltYm9sQ29uZmlnLmZvbnRDb2RlKXtcblx0XHRcdFx0Y3JlYXRlU3ltYm9sKHN5bWJvbENvbmZpZyxpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQkY2FjaGUubW9ub2dyYW1zeW1ib2xzZWxlY3Rpb25jb250YWluZXIuc2hvdygpO1xuXHR9ZWxzZXtcblxuXHRcdCRjYWNoZS5tb25vZ3JhbXN5bWJvbHNlbGVjdGlvbmNvbnRhaW5lci5oaWRlKCk7XG5cblx0XHQvLyBUT0RPLU1PTk86IGVtcHR5IG91dCBhbnkgc2VsZWN0ZWQgc3ltYm9sc1xuXG5cdH1cblxuXG5cdC8qKlxuXHQgKiBzZXR1cCBkb3RzXG5cdCAqL1xuXHRpZighc3R5bGVDb25maWcuZG90c0FsbG93ZWQpe1xuXHRcdC8vIHNldCBkb3RzIGhpZGRlbiBpbnB1dCB2YWx1ZSBmb3IgZm9ybSBzdWJtaXNzaW9uXG5cdFx0JGNhY2hlLm1vbm9ncmFtZm9ybWZpZWxkcy5maW5kKFwiaW5wdXRbbmFtZT1tb25vZ3JhbV9ET1RTXVwiKS52YWwoJ04nKTtcblxuXHRcdC8vIHNldCBpbWFnZSB2YWx1ZXNcblx0XHQkY2FjaGUubW9ub2dyYW1jb250YWluZXIuZGF0YSgnaW1hZ2VPcHRpb25zJylbJyRkb3RzJ10gPSAwO1xuXG5cdFx0Ly8gaGlkZSBkb3RzIHNlY3Rpb25cblx0XHQkY2FjaGUubW9ub2dyYW1kb3RzY29udGFpbmVyLnNsaWRlVXAoKTtcblxuXHR9ZWxzZXtcblx0XHQkY2FjaGUubW9ub2dyYW1kb3RzY29udGFpbmVyLmZpbmQoJy5kb3RzLXRpdGxlJykudG9nZ2xlQ2xhc3MoJ3RyYWRpdGlvbmFsJywkY2FjaGUuc2VsZWN0ZWRTdHlsZUNvbmZpZy50cmFkaXRpb25hbCk7XG5cdFx0JGNhY2hlLm1vbm9ncmFtaW5nb3B0aW9uc2NvbnRhaW5lci5maW5kKCcubW9ub2dyYW0tdGV4dC1pbnB1dC1lcnJvcicpLnRvZ2dsZUNsYXNzKCd0cmFkaXRpb25hbCcsJGNhY2hlLnNlbGVjdGVkU3R5bGVDb25maWcudHJhZGl0aW9uYWwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERvIGluaXRpYWwgc2V0dXAgY2xpY2sgZXZlbnRzXG5cdCAqL1xuXHQkY2FjaGUubW9ub2dyYW1mb250c2VsZWN0LmZpbmQoJ2xpLm1vbm9ncmFtLWZvbnQnKS5maXJzdCgpLmNsaWNrKCk7XG5cdGlmKCRjYWNoZS5tb25vZ3JhbWNvbG9ycy5sZW5ndGgpe1xuXHRcdCRjYWNoZS5tb25vZ3JhbWNvbG9ycy5maXJzdCgpLmNsaWNrKCk7XG5cdH1cblxuXHQvLyBTZXQgc3R5bGUgdmFsdWVzIGZvciBmb3JtIHN1Ym1pc3Npb25cblx0JGNhY2hlLm1vbm9ncmFtZm9ybWZpZWxkcy5maW5kKFwiaW5wdXRbbmFtZT0nbW9ub2dyYW1fVFJBRElUSU9OQUwnXVwiKS52YWwoc3R5bGVDb25maWcudHJhZGl0aW9uYWwgPyBcIllcIiA6IFwiTlwiKTtcblx0JGNhY2hlLm1vbm9ncmFtZm9ybWZpZWxkcy5maW5kKFwiaW5wdXRbbmFtZT0nbW9ub2dyYW1fU0laRSddXCIpLnZhbChzdHlsZUNvbmZpZy5mb250U2l6ZSk7XG5cdCRjYWNoZS5tb25vZ3JhbWZvcm1maWVsZHMuZmluZChcImlucHV0W25hbWU9J21vbm9ncmFtX0FMVF9TSVpFJ11cIikudmFsKHN0eWxlQ29uZmlnLmZvbnRBbHRTaXplKTtcblx0JGNhY2hlLm1vbm9ncmFtZm9ybWZpZWxkcy5maW5kKFwiaW5wdXRbbmFtZT0nbW9ub2dyYW1fU1RZTEUnXVwiKS52YWwoc3R5bGVDb25maWcuc3R5bGVOYW1lKTtcblx0JGNhY2hlLm1vbm9ncmFtZm9ybWZpZWxkcy5maW5kKFwiaW5wdXRbbmFtZT0nbW9ub2dyYW0tZGlzcGxheV9tb25vZ3JhbS1zdHlsZS1uYW1lJ11cIikudmFsKHN0eWxlQ29uZmlnLnN0eWxlTmFtZSk7XG5cdCRjYWNoZS5tb25vZ3JhbWZvcm1maWVsZHMuZmluZChcImlucHV0W25hbWU9J3BlcnNvbmFsaXphdGlvbi10eXBlJ11cIikudmFsKHN0eWxlQ29uZmlnLnBlcnNvbmFsaXphdGlvblR5cGUpO1xuXG5cblx0Ly8gc2V0IGltYWdlIHZhbHVlc1xuXHQkY2FjaGUubW9ub2dyYW1jb250YWluZXIuZGF0YSgnaW1hZ2VPcHRpb25zJylbJyRmdHlwZSddID0gc3R5bGVDb25maWcuc3R5bGVJRDtcblx0aWYoJGNhY2hlLm1vbm9ncmFtY29sb3JzLmxlbmd0aCl7XG5cdFx0JGNhY2hlLm1vbm9ncmFtY29udGFpbmVyLmRhdGEoJ2ltYWdlT3B0aW9ucycpWyckY29sb3InXSA9ICRjYWNoZS5tb25vZ3JhbWNvbG9ycy5maWx0ZXIoJ2xpLnNlbGVjdGVkJykuZGF0YSgnY29sb3ItY29uZmlnJykuczdDb2RlO1xuXHR9XG5cblx0Ly8gc2hvdyB0aGUgYm90dG9tIGNvbnRhaW5lcnNcblx0JGNhY2hlLm1vbm9ncmFtY29udGFpbmVyLmZpbmQoJy5tb25vZ3JhbS1zZWN0aW9uJykucmVtb3ZlQ2xhc3MoJ2luYWN0aXZlLXNlY3Rpb24nKTtcblx0JGNhY2hlLm1vbm9ncmFtY29udGFpbmVyLmZpbmQoJy5tb25vZ3JhbS1vcHRpb25zLWJvZHknKS5zbGlkZURvd24oKTtcblx0JGNhY2hlLm1vbm9ncmFtY29udGFpbmVyLmZpbmQoJy5tb25vZ3JhbS1jb2xvcnMtc2VjdGlvbi1ib2R5Jykuc2xpZGVEb3duKCk7XG5cdCRjYWNoZS5tb25vZ3JhbWNvbnRhaW5lci5maW5kKCcubW9ub2dyYW0tc2VjdGlvbi10aXRsZSwgLm1vbm9ncmFtLXRvZ2dsZS1pY29uJykucmVtb3ZlQ2xhc3MoJ2luYWN0aXZlJyk7XG5cdCRjYWNoZS5tb25vZ3JhbWNvbnRhaW5lci5maW5kKCcubW9ub2dyYW0tc2VjdGlvbi10aXRsZSAuY29sb3ItbmFtZScpLnJlbW92ZUNsYXNzKCd2aXN1YWxseS1oaWRkZW4nKTtcblx0JGNhY2hlLnBkcE1haW4uZmluZCgnLnByb2R1Y3QtYWRkLXRvLWNhcnQgLmF2YWlsYWJpbGl0eSAudmFsdWUnKS5odG1sKFwiXCIpO1xuXG5cdCRjYWNoZS5tb25vZ3JhbXRleHRpbnB1dGNvbnRhaW5lci5maW5kKCdpbnB1dCcpLmZpcnN0KCkuZm9jdXMoKTtcblxuXHR1cGRhdGVJbWFnZXMoKTtcblx0Ly8gZW5hYmxlIHRoZSBhMmMgYnV0dG9uXG5cdHZhciB0aXRsZSA9ICQoJ2J1dHRvbiNhZGQtdG8tY2FydCcpLmF0dHIoJ3JlbCcpO1xuXHQvLyQoJ2J1dHRvbiNhZGQtdG8tY2FydCcpLmF0dHIoJ3RpdGxlJyx0aXRsZSkucmVtb3ZlQXR0cihcImRpc2FibGVkXCIpO1xuXHQkKCcubW9ub2dyYW0tdGV4dC1taXNzaW5nLWlucHV0LWVycm9yJykuaGlkZSgpO1xuXG5cdGlmKCEkY2FjaGUubW9ub2dyYW1jb250YWluZXIuZmluZCgnLm1vbm9ncmFtLXNlY3Rpb24tdG9nZ2xlIHNwYW4nKS5oYXNDbGFzcygnZW5hYmxlZCcpKSB7XG5cdFx0JGNhY2hlLm1vbm9ncmFtY29udGFpbmVyLmZpbmQoJy5tb25vZ3JhbS1zZWN0aW9uLXRvZ2dsZSBzcGFuJykuY2xpY2sobW9ub2dyYW1TZWN0aW9uVG9nZ2xlQ2xpY2spO1xuXHR9XG59XG5cbmZ1bmN0aW9uIG1vbm9ncmFtU2VjdGlvblRvZ2dsZUNsaWNrKGUpe1xuXHR2YXIgJG1vbm9ncmFtc2VjdGlvbmNvbnRhaW5lciA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJ2Rpdi5tb25vZ3JhbS1zZWN0aW9uJyk7XG5cdCRtb25vZ3JhbXNlY3Rpb25jb250YWluZXIudG9nZ2xlQ2xhc3MoJ2luYWN0aXZlLXNlY3Rpb24nKTtcblx0JG1vbm9ncmFtc2VjdGlvbmNvbnRhaW5lci5maW5kKCcubW9ub2dyYW0tc2VjdGlvbi1ib2R5Jykuc2xpZGVUb2dnbGUoKTtcblx0JG1vbm9ncmFtc2VjdGlvbmNvbnRhaW5lci5maW5kKCcubW9ub2dyYW0tc2VjdGlvbi10aXRsZScpLnRvZ2dsZUNsYXNzKCdpbmFjdGl2ZScpO1xuXHQkbW9ub2dyYW1zZWN0aW9uY29udGFpbmVyLmZpbmQoJy5tb25vZ3JhbS10b2dnbGUtaWNvbicpLnRvZ2dsZUNsYXNzKCdpbmFjdGl2ZScpO1xuXHQkbW9ub2dyYW1zZWN0aW9uY29udGFpbmVyLmZpbmQoJy5tb25vZ3JhbS10b2dnbGUtaWNvbicpLmFkZENsYXNzKCdlbmFibGVkJyk7XG5cdCRtb25vZ3JhbXNlY3Rpb25jb250YWluZXIuZmluZCgnLm1vbm9ncmFtLXNlY3Rpb24tdGl0bGUgLmNvbG9yLW5hbWUnKS50b2dnbGVDbGFzcygndmlzdWFsbHktaGlkZGVuJyk7XG59XG5cbmZ1bmN0aW9uIG1vbm9ncmFtRm9udENsaWNrKGUpe1xuXHR2YXIgJHRoaXMgPSAkKGUudGFyZ2V0KS5jbG9zZXN0KCdsaS5tb25vZ3JhbS1mb250Jyk7XG5cblx0aWYoJHRoaXMuaGFzQ2xhc3MoJ3NlbGVjdGVkJykpe1xuXHRcdHJldHVybjtcblx0fVxuXG5cdCRjYWNoZS5tb25vZ3JhbWZvbnRzZWxlY3QuZmluZCgnbGkubW9ub2dyYW0tZm9udCcpLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xuXHQkdGhpcy5hZGRDbGFzcygnc2VsZWN0ZWQnKTtcblx0dmFyIGZvbnREYXRhID0gJHRoaXMuZGF0YSgnZm9udC1jb25maWcnKTtcblx0dmFyICRpbnB1dHMgPSAkY2FjaGUubW9ub2dyYW10ZXh0aW5wdXRib2R5LmZpbmQoJ2lucHV0Jykubm90KCcuZm9udC1zeW1ib2wnKTtcblx0JGlucHV0cy5jc3MoJ2ZvbnQtZmFtaWx5Jyxmb250RGF0YS5mb250U3R5bGUpO1xuXG5cdCRpbnB1dHMudG9nZ2xlQ2xhc3MoJ21vbm9ncmFtLXRleHQtaW5wdXQtZmllbGQtYm9sZCcsZm9udERhdGEuYm9sZCk7XG5cblx0JGlucHV0cy50b2dnbGVDbGFzcygnbW9ub2dyYW0tdGV4dC1pbnB1dC1maWVsZC1pdGFsaWMnLGZvbnREYXRhLml0YWxpYyk7XG5cblx0Ly8gc2V0IGZvbnQgZmllbGQgdmFsdWVzIGZvciBmb3JtIHN1Ym1pc3Npb25cblx0JGNhY2hlLm1vbm9ncmFtZm9ybWZpZWxkcy5maW5kKFwiaW5wdXRbbmFtZT0nbW9ub2dyYW1fRk9OVCddXCIpLnZhbChmb250RGF0YS5yYWRpYWxGb250KTtcblx0JGNhY2hlLm1vbm9ncmFtZm9ybWZpZWxkcy5maW5kKFwiaW5wdXRbbmFtZT0nbW9ub2dyYW1fQk9MRCddXCIpLnZhbChmb250RGF0YS5ib2xkID8gXCJZXCIgOiBcIk5cIik7XG5cdCRjYWNoZS5tb25vZ3JhbWZvcm1maWVsZHMuZmluZChcImlucHV0W25hbWU9J21vbm9ncmFtX0lUQUxJQyddXCIpLnZhbChmb250RGF0YS5pdGFsaWMgPyBcIllcIiA6IFwiTlwiKTtcblxuXHQvLyBzZXQgaW1hZ2UgdmFyc1xuXHQkY2FjaGUubW9ub2dyYW1jb250YWluZXIuZGF0YSgnaW1hZ2VPcHRpb25zJylbJyRmc3R5bGUnXSA9IGZvbnREYXRhLmZvbnROYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0dXBkYXRlSW1hZ2VzKCk7XG59XG5cbmZ1bmN0aW9uIG1vbm9ncmFtQ29sb3JDbGljayhlKXtcblx0dmFyICR0aGlzID0gJChlLnRhcmdldCkuY2xvc2VzdCgnbGkubW9ub2dyYW0tY29sb3Itc3dhdGNoJyk7XG5cblx0aWYoJHRoaXMuaGFzQ2xhc3MoJ3NlbGVjdGVkJykpe1xuXHRcdHJldHVybjtcblx0fVxuXG5cdCRjYWNoZS5tb25vZ3JhbWNvbG9ycy5yZW1vdmVDbGFzcygnc2VsZWN0ZWQnKTtcblx0JHRoaXMuYWRkQ2xhc3MoJ3NlbGVjdGVkJyk7XG5cblx0dmFyIGNvbG9yQ29uZmlnID0gJHRoaXMuZGF0YSgnY29sb3ItY29uZmlnJylcblxuXHQkY2FjaGUubW9ub2dyYW1jb250YWluZXIuZGF0YSgnaW1hZ2VPcHRpb25zJylbJyRjb2xvciddID0gY29sb3JDb25maWcuczdDb2RlO1xuXG5cdCRjYWNoZS5tb25vZ3JhbWZvcm1maWVsZHMuZmluZChcImlucHV0W25hbWU9J21vbm9ncmFtX0NPTE9SJ11cIikudmFsKGNvbG9yQ29uZmlnLnJhZGlhbENvZGUpO1xuXHQkY2FjaGUubW9ub2dyYW1mb3JtZmllbGRzLmZpbmQoXCJpbnB1dFtuYW1lPSdtb25vZ3JhbS1kaXNwbGF5X21vbm9ncmFtLWNvbG9yLW5hbWUnXVwiKS52YWwoY29sb3JDb25maWcuY29sb3JOYW1lKTtcblxuXHQkY2FjaGUubW9ub2dyYW1jb250YWluZXIuZmluZCgnLm1vbm9ncmFtLXNlY3Rpb24tdGl0bGUgLmNvbG9yLW5hbWUnKS50ZXh0KGNvbG9yQ29uZmlnLmNvbG9yTmFtZSk7XG5cblx0dXBkYXRlSW1hZ2VzKCk7XG5cbn1cblxuZnVuY3Rpb24gdGV4dElucHV0Rm9jdXMoZSl7XG5cdHZhciAkdGhpcyA9ICQoZS50YXJnZXQpO1xuXHQkY2FjaGUubW9ub2dyYW10ZXh0aW5wdXRib2R5LmZpbmQoJ2lucHV0JykucmVtb3ZlQ2xhc3MoJ2ZvY3VzZWQnKTtcblx0JHRoaXMuYWRkQ2xhc3MoJ2ZvY3VzZWQnKTtcblx0JGNhY2hlLmZvY3VzZWRpbnB1dCA9ICR0aGlzO1xuXG5cdHZhciBkaXNhYmxlRG91YmxlV2lkZVN5bWJvbHMgPSBmYWxzZTtcblxuXHRpZigkY2FjaGUubW9ub2dyYW1zeW1ib2xsaXN0LmZpbmQoJ2xpLm1vbm9ncmFtLXN5bWJvbC5kb3VibGUtd2lkZS5zZWxlY3RlZCcpLmxlbmd0aCA+IDApe1xuXHRcdGRpc2FibGVEb3VibGVXaWRlU3ltYm9scyA9IHRydWU7XG5cdFx0aWYoJHRoaXMuaGFzQ2xhc3MoJ2ZvbnQtc3ltYm9sJykpe1xuXHRcdFx0dmFyIHN5bWJvbENvbmZpZyA9ICR0aGlzLmRhdGEoJ3N5bWJvbC1jb25maWcnKTtcblx0XHRcdGlmKHN5bWJvbENvbmZpZy53aWR0aCA9PSAyICl7XG5cdFx0XHRcdGRpc2FibGVEb3VibGVXaWRlU3ltYm9scyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdCRjYWNoZS5tb25vZ3JhbXN5bWJvbGxpc3QuZmluZCgnbGkubW9ub2dyYW0tc3ltYm9sLmRvdWJsZS13aWRlJykudG9nZ2xlQ2xhc3MoJ3Vuc2VsZWN0YWJsZS1kb3VibGUtd2lkZS1zeW1ib2wnLCBkaXNhYmxlRG91YmxlV2lkZVN5bWJvbHMpO1xufVxuXG5mdW5jdGlvbiB0ZXh0SW5wdXRCbHVyKGUpe1xuXHQkKGUudGFyZ2V0KS5yZW1vdmVDbGFzcygnZm9jdXNlZCcpO1xuXHQkKCcubW9ub2dyYW0tdGV4dC1taXNzaW5nLWlucHV0LWVycm9yJykuaGlkZSgpO1xufVxuXG5mdW5jdGlvbiB0ZXh0SW5wdXRLZXlVcChlKXtcblx0dmFyICR0aGlzID0gJChlLnRhcmdldCksXG5cdFx0dmFsID0gJHRoaXMudmFsKCksXG5cdFx0dXBkYXRlQ2hhcmFjdGVyID0gZmFsc2UsXG5cdFx0dmFsSXNWYWxpZCA9IGZhbHNlO1xuXG5cdC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gdXBwZXIgb3IgbG93ZXJjYXNlIHRoaXNcblx0aWYodmFsKXtcblx0XHRzd2l0Y2goJGNhY2hlLnNlbGVjdGVkU3R5bGVDb25maWcubW9ub2dyYW1taW5nRm9udENhc2Upe1xuXHRcdFx0Y2FzZSBcImZvcmNlVXBwZXJcIjpcblx0XHRcdFx0dmFsID0gdmFsLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwiZm9yY2VMb3dlclwiOlxuXHRcdFx0XHR2YWwgPSB2YWwudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblxuXHR2YWxJc1ZhbGlkID0gJGNhY2hlLnNlbGVjdGVkU3R5bGVDb25maWcuY2hhcmFjdGVyc0xpc3QuaW5kZXhPZih2YWwpID4gLTE7XG5cblx0Ly8gaWYgdGhlIGZpZWxkIHdhcyBhIHN5bWJvbCwgYW5kIHdlIGRlbGV0ZWQgaXQsIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZVxuXHQvLyBzeW1ib2wgZGF0YSBhbmQgcmVhcHBseSB0aGUgb2xkIGZvbnRzXG5cdC8vIGFsc28sIHVwZGF0ZWQgdGhlIHNlbGVjdGVkIHN5bWJvbHMgYW5kIHRoZSBpbnB1dHRlZCBjaGFyYWN0ZXJzXG5cdGlmKCAkdGhpcy5oYXNDbGFzcyhcImZvbnQtc3ltYm9sXCIpICYmIHZhbCA9PT0gXCJcIil7XG5cblx0XHR2YXIgc3ltYm9sQ29uZmlnID0gJHRoaXMuZGF0YSgnc3ltYm9sLWNvbmZpZycpO1xuXHRcdGlmKHN5bWJvbENvbmZpZy53aWR0aCA9PSAyKXtcblx0XHRcdCRjYWNoZS5tb25vZ3JhbXN5bWJvbGxpc3QuZmluZCgnbGkubW9ub2dyYW0tc3ltYm9sLmRvdWJsZS13aWRlJykudG9nZ2xlQ2xhc3MoJ3Vuc2VsZWN0YWJsZS1kb3VibGUtd2lkZS1zeW1ib2wnLCBmYWxzZSk7XG5cdFx0fVxuXG5cdFx0c2V0SW5wdXRCYWNrVG9Ob3JtYWwoJHRoaXMpO1xuXG5cdFx0dXBkYXRlQ2hhcmFjdGVyID0gdHJ1ZTtcblxuXHQvLyBpZiB0aGUgZmllbGQgaXMgTk9UIGEgc3ltYm9sLCBvciBpdCBpcyBhIHN5bWJvbCBhbmQgc29tZW9uZVxuXHQvLyBoaWdobGlnaHRlZCBhbmQgY2hhbmdlZCBpdFxuXHR9ZWxzZSBpZiggISR0aGlzLmhhc0NsYXNzKCdmb250LXN5bWJvbCcpIHx8ICR0aGlzLmhhc0NsYXNzKFwiZm9udC1zeW1ib2xcIikgJiYgdmFsSXNWYWxpZCl7XG5cblx0XHQvLyBpZiBpdCB3YXMgYSBoaWdobGlnaHQgYW5kIGNoYW5nZT8gc3dpdGNoIGlucHV0IGZpZWxkIGJhY2sgdG9cblx0XHQvLyBiZWluZyBub3JtYWxcblx0XHRpZigkdGhpcy5oYXNDbGFzcyhcImZvbnQtc3ltYm9sXCIpICYmIHZhbElzVmFsaWQpe1xuXHRcdFx0c2V0SW5wdXRCYWNrVG9Ob3JtYWwoJHRoaXMpO1xuXHRcdH1cblxuXHRcdGlmKCRjYWNoZS5zZWxlY3RlZFN0eWxlQ29uZmlnLm1pbkNoYXIgIT09ICRjYWNoZS5zZWxlY3RlZFN0eWxlQ29uZmlnLm1heENoYXIpe1xuXHRcdFx0dmFsSXNWYWxpZCA9IHZhbElzVmFsaWQgfHwgJHRoaXMudmFsKCkgPT09IFwiXCI7XG5cdFx0fVxuXG5cdFx0aWYoIXZhbElzVmFsaWQpe1xuXHRcdFx0dmFsID0gXCJcIjtcblx0XHR9ZWxzZSBpZiAoKGUua2V5ICYmIGUua2V5Lmxlbmd0aCA9PSAxKSB8fCAoYXBwLmlzTW9iaWxlVXNlckFnZW50ICYmIHZhbElzVmFsaWQpKXtcblx0XHRcdCR0aGlzLmNsb3Nlc3QoJ2RpdicpLm5leHQoKS5maW5kKCdpbnB1dCcpLmZvY3VzKCk7XG5cdFx0fVxuXG5cdFx0JHRoaXMudG9nZ2xlQ2xhc3MoJ2Vycm9yJywhdmFsSXNWYWxpZCk7XG5cdFx0JCgnLm1vbm9ncmFtLXRleHQtaW52YWxpZC1pbnB1dC1lcnJvcicpLnRvZ2dsZSghdmFsSXNWYWxpZCk7XG5cblx0XHR1cGRhdGVDaGFyYWN0ZXIgPSB0cnVlO1xuXHR9XG5cblx0aWYodXBkYXRlQ2hhcmFjdGVyKXtcblx0XHQkdGhpcy52YWwodmFsKTtcblxuXHRcdCRjYWNoZS5tb25vZ3JhbWNvbnRhaW5lci5kYXRhKCdpbWFnZU9wdGlvbnMnKVskdGhpcy5kYXRhKCdwb3NpdGlvbicpXSA9IHZhbDtcblxuXHRcdCRjYWNoZS5tb25vZ3JhbWZvcm1maWVsZHMuZmluZChcImlucHV0W25hbWU9J21vbm9ncmFtX0NIQVJcIiArICR0aGlzLmRhdGEoJ2luZGV4JykgKyBcIiddXCIpLnZhbCh2YWwpO1xuXG5cdFx0JGNhY2hlLm1vbm9ncmFtY29udGFpbmVyLmRhdGEoJ2ltYWdlT3B0aW9ucycpWyckY2hhcnMnXSA9IE9iamVjdC5rZXlzKCRjYWNoZS5tb25vZ3JhbWNvbnRhaW5lci5kYXRhKCdpbWFnZU9wdGlvbnMnKSkuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pe1xuXHRcdFx0cmV0dXJuIGl0ZW0uaW5kZXhPZignJGNocicpID09PSAwO1xuXHRcdH0pLmxlbmd0aDtcblx0fVxuXG5cdHVwZGF0ZUltYWdlcygpO1xuICAgIHZhbGlkYXRlTW9ub2dyYW1JbnB1dFZhbHVlcygpO1xufVxuXG5mdW5jdGlvbiBzZXRJbnB1dEJhY2tUb05vcm1hbCgkaW5wdXRGaWVsZCl7XG5cdHZhciAkc2VsZWN0ZWRGb250ID0gJGNhY2hlLm1vbm9ncmFtZm9udHNlbGVjdC5maW5kKCdsaS5tb25vZ3JhbS1mb250LnNlbGVjdGVkJyksXG5cdGZvbnREYXRhID0gJHNlbGVjdGVkRm9udC5kYXRhKCdmb250LWNvbmZpZycpO1xuXG5cdCRpbnB1dEZpZWxkLmNzcygnZm9udC1mYW1pbHknLGZvbnREYXRhLmZvbnRTdHlsZSk7XG5cdCRpbnB1dEZpZWxkLnRvZ2dsZUNsYXNzKCdtb25vZ3JhbS10ZXh0LWlucHV0LWZpZWxkLWJvbGQnLGZvbnREYXRhLmJvbGQpO1xuXHQkaW5wdXRGaWVsZC50b2dnbGVDbGFzcygnbW9ub2dyYW0tdGV4dC1pbnB1dC1maWVsZC1pdGFsaWMnLGZvbnREYXRhLml0YWxpYyk7XG5cblx0JGlucHV0RmllbGQucmVtb3ZlQ2xhc3MoXCJmb250LXN5bWJvbFwiKTtcblxuXHR1cGRhdGVTeW1ib2xzU2VsZWN0ZWQoKTtcbn1cblxuZnVuY3Rpb24gd29yZElucHV0S2V5VXAoZSl7XG5cdHZhciAkdGhpcyA9ICQoZS50YXJnZXQpLFxuXHRcdHZhbCA9ICR0aGlzLnZhbCgpLnNwbGl0KCcnKSxcblx0XHR2YWxpZCA9IHRydWU7XG5cblx0Zm9yKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKyl7XG5cdFx0dmFsaWQgPSB2YWxpZCAmJiAkY2FjaGUuc2VsZWN0ZWRTdHlsZUNvbmZpZy5jaGFyYWN0ZXJzTGlzdC5pbmRleE9mKHZhbFtpXSkgPiAtMTtcblx0fVxuXG5cdGlmKCRjYWNoZS5zZWxlY3RlZFN0eWxlQ29uZmlnLm1pbkNoYXIgIT09ICRjYWNoZS5zZWxlY3RlZFN0eWxlQ29uZmlnLm1heENoYXIpe1xuXHRcdHZhbGlkID0gdmFsaWQgfHwgJHRoaXMudmFsKCkgPT09IFwiXCI7XG5cdH1cblxuXHRpZighdmFsaWQpe1xuXHRcdHZhbCA9IFwiXCI7XG5cdH1cblxuXHR2YXIgbWF4Q2hhcnMgPSAkY2FjaGUuc2VsZWN0ZWRTdHlsZUNvbmZpZy5tYXhDaGFyO1xuXG5cdGZvcih2YXIgaSA9IDE7aSA8PSBtYXhDaGFyczsgaSsrKXtcblx0XHRkZWxldGUgJGNhY2hlLm1vbm9ncmFtY29udGFpbmVyLmRhdGEoJ2ltYWdlT3B0aW9ucycpWyckY2hyJytpXTtcblx0XHQkY2FjaGUubW9ub2dyYW1mb3JtZmllbGRzLmZpbmQoJ2lucHV0W25hbWU9XCJtb25vZ3JhbV9DSEFSJytpKydcIl0nKS52YWwoXCJcIik7XG5cdH1cblxuXHR2YXIgaW5kZXgsXG5cdFx0d29yZExlbmd0aCA9IHZhbC5sZW5ndGgsXG5cdFx0bGV0dGVyO1xuXHRmb3IodmFyIGkgPSAxOyBpIDw9IG1heENoYXJzOyBpKyspe1xuXHRcdGluZGV4ID0gaS0xO1xuXHRcdGlmKGluZGV4IDwgd29yZExlbmd0aCl7XG5cdFx0XHRsZXR0ZXIgPSB2YWxbaW5kZXhdO1xuXHRcdH1lbHNle1xuXHRcdFx0bGV0dGVyID0gXCJcIjtcblx0XHR9XG5cblx0XHQkY2FjaGUubW9ub2dyYW1jb250YWluZXIuZGF0YSgnaW1hZ2VPcHRpb25zJylbJyRjaHInK2ldID0gbGV0dGVyO1xuXHRcdCRjYWNoZS5tb25vZ3JhbWZvcm1maWVsZHMuZmluZCgnaW5wdXRbbmFtZT1cIm1vbm9ncmFtX0NIQVInK2krJ1wiXScpLnZhbChsZXR0ZXIpO1xuXHR9XG5cblxuXHQkY2FjaGUubW9ub2dyYW1jb250YWluZXIuZGF0YSgnaW1hZ2VPcHRpb25zJylbJyRjaGFycyddID0gd29yZExlbmd0aDtcblxuXHR1cGRhdGVJbWFnZXMoKTtcblxuXHQkdGhpcy50b2dnbGVDbGFzcygnZXJyb3InLCF2YWxpZCk7XG5cdCQoJy5tb25vZ3JhbS10ZXh0LWludmFsaWQtaW5wdXQtZXJyb3InKS50b2dnbGUoIXZhbGlkKTtcbiAgICB2YWxpZGF0ZU1vbm9ncmFtSW5wdXRWYWx1ZXMoKTtcbn1cblxuZnVuY3Rpb24gc3ltYm9sQ2xpY2soZSl7XG5cblx0aWYoJGNhY2hlLmZvY3VzZWRpbnB1dCA9PSBudWxsKXsgcmV0dXJuOyB9XG5cblx0JGNhY2hlLmZvY3VzZWRpbnB1dC5mb2N1cygpO1xuXG5cdHZhciAkdGhpcyA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJ2xpLm1vbm9ncmFtLXN5bWJvbCcpO1xuXG5cdGlmKCR0aGlzLmhhc0NsYXNzKCd1bnNlbGVjdGFibGUtZG91YmxlLXdpZGUtc3ltYm9sJykpeyByZXR1cm47IH1cblxuXHQkdGhpcy5hZGRDbGFzcygnc2VsZWN0ZWQnKTtcblxuXHR2YXIgc3ltYm9sQ29uZmlnID0gJHRoaXMuZGF0YSgnc3ltYm9sLWNvbmZpZycpO1xuXG5cdC8vIGNsZWFyIG91dCBvbGQgZm9udC1mYW1pbHkgYW5kIHVzZSB0aGUgc3ltYm9sIGZvbnQgZmFtaWx5XG5cdCRjYWNoZS5mb2N1c2VkaW5wdXQucmVtb3ZlQXR0cignc3R5bGUnKTtcblx0JGNhY2hlLmZvY3VzZWRpbnB1dC5hZGRDbGFzcygnZm9udC1zeW1ib2wnKTtcblx0JGNhY2hlLmZvY3VzZWRpbnB1dC5yZW1vdmVDbGFzcygnbW9ub2dyYW0tdGV4dC1pbnB1dC1maWVsZC1pdGFsaWMgbW9ub2dyYW0tdGV4dC1pbnB1dC1maWVsZC1ib2xkIGVycm9yJyk7XG5cblx0Ly8gYWRkIHRoZSBzeW1ib2xcblx0dmFyIHZhbCA9ICQoJzxkaXY+JykuaHRtbChzeW1ib2xDb25maWcuZm9udENvZGUpLnRleHQoKTtcblx0JGNhY2hlLmZvY3VzZWRpbnB1dC52YWwodmFsKTtcblx0JGNhY2hlLmZvY3VzZWRpbnB1dC5kYXRhKCdzeW1ib2wtY29uZmlnJyxzeW1ib2xDb25maWcpO1xuXG5cdC8vIGNsZWFyIGVycm9yIG1lc3NhZ2luZ1xuXHQkKCcubW9ub2dyYW0tdGV4dC1pbnZhbGlkLWlucHV0LWVycm9yJykuaGlkZSgpO1xuXHQkY2FjaGUuZm9jdXNlZGlucHV0LnJlbW92ZUNsYXNzKCdlcnJvcicpO1xuXG5cdC8vIHNldCB0aGUgaW1hZ2Ugb3B0aW9ucyBmb3IgdXNlIGluIHJlLXJlbmRlcmluZyB0aGUgaW1hZ2VzXG5cdCRjYWNoZS5tb25vZ3JhbWNvbnRhaW5lci5kYXRhKCdpbWFnZU9wdGlvbnMnKVskY2FjaGUuZm9jdXNlZGlucHV0LmRhdGEoJ3Bvc2l0aW9uJyldID0gc3ltYm9sQ29uZmlnLnNjZW5lN0NvZGU7XG5cblx0dmFyIGluZGV4ID0gJGNhY2hlLmZvY3VzZWRpbnB1dC5kYXRhKCdpbmRleCcpO1xuXG5cdCRjYWNoZS5tb25vZ3JhbWZvcm1maWVsZHMuZmluZChcImlucHV0W25hbWU9J21vbm9ncmFtX0NIQVJcIiArIGluZGV4ICsgXCInXVwiKS52YWwoc3ltYm9sQ29uZmlnLnJhZGlhbENvZGUpO1xuXG5cdHVwZGF0ZVN5bWJvbHNTZWxlY3RlZCgpO1xuXG5cdGlmKGluZGV4ICE9PSAkY2FjaGUuc2VsZWN0ZWRTdHlsZUNvbmZpZy5tYXhDaGFyKXtcblx0XHRpZihzeW1ib2xDb25maWcud2lkdGggPT0gMil7XG5cdFx0XHQkY2FjaGUubW9ub2dyYW1zeW1ib2xsaXN0LmZpbmQoJ2xpLm1vbm9ncmFtLXN5bWJvbC5kb3VibGUtd2lkZScpLnRvZ2dsZUNsYXNzKCd1bnNlbGVjdGFibGUtZG91YmxlLXdpZGUtc3ltYm9sJywgdHJ1ZSk7XG5cdFx0fVxuXHRcdCRjYWNoZS5mb2N1c2VkaW5wdXQuY2xvc2VzdCgnZGl2JykubmV4dCgpLmZpbmQoJ2lucHV0JykuZm9jdXMoKTtcblx0fVxuXG5cblx0dXBkYXRlSW1hZ2VzKCk7XG5cdHZhbGlkYXRlTW9ub2dyYW1JbnB1dFZhbHVlcygpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTeW1ib2xzU2VsZWN0ZWQoKXtcblx0dmFyICRzeW1ib2xzID0gJGNhY2hlLm1vbm9ncmFtc3ltYm9sbGlzdC5maW5kKCdsaS5tb25vZ3JhbS1zeW1ib2wnKTtcblxuXHQkc3ltYm9scy5lYWNoKGZ1bmN0aW9uKCl7XG5cdFx0dmFyIGN1cnJlbnRTeW1ib2xDb25maWcgPSAkKHRoaXMpLmRhdGEoJ3N5bWJvbC1jb25maWcnKSxcblx0XHRcdHN5bWJvbENvdW50ID0gMDtcblxuXHRcdCRjYWNoZS5tb25vZ3JhbXRleHRpbnB1dGJvZHkuZmluZCgnaW5wdXQnKS5lYWNoKGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgJGZpZWxkID0gJCh0aGlzKTtcblxuXHRcdFx0aWYoJGZpZWxkLmhhc0NsYXNzKCdmb250LXN5bWJvbCcpKXtcblx0XHRcdFx0dmFyIGZpZWxkU3ltYm9sQ29uZmlnID0gJGZpZWxkLmRhdGEoJ3N5bWJvbC1jb25maWcnKTtcblxuXHRcdFx0XHRpZihmaWVsZFN5bWJvbENvbmZpZy5jaGFyYWN0ZXIgPT09IGN1cnJlbnRTeW1ib2xDb25maWcuY2hhcmFjdGVyKXtcblx0XHRcdFx0XHRzeW1ib2xDb3VudCsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZihzeW1ib2xDb3VudCA9PT0gMCl7XG5cdFx0XHQkc3ltYm9scy5lYWNoKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHZhciAkdGhpcyA9ICQodGhpcyksXG5cdFx0XHRcdFx0ZGF0YSA9ICR0aGlzLmRhdGEoJ3N5bWJvbC1jb25maWcnKTtcblxuXHRcdFx0XHRpZihjdXJyZW50U3ltYm9sQ29uZmlnLmNoYXJhY3RlciA9PT0gZGF0YS5jaGFyYWN0ZXIpe1xuXHRcdFx0XHRcdCR0aGlzLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIGRvdHNPcHRpb25DbGljayhlKXtcblx0dmFyICR0aGlzID0gJChlLnRhcmdldCkuY2xvc2VzdCgnbGkuZG90cy1vcHRpb24nKTtcblxuXHRpZigkdGhpcy5oYXNDbGFzcygnc2VsZWN0ZWQnKSl7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0JGNhY2hlLm1vbm9ncmFtZG90c29wdGlvbnMucmVtb3ZlQ2xhc3MoJ3NlbGVjdGVkJyk7XG5cdCR0aGlzLmFkZENsYXNzKCdzZWxlY3RlZCcpO1xuXG5cdC8vIHNldCBkb3RzIGhpZGRlbiBpbnB1dCB2YWx1ZSBmb3IgZm9ybSBzdWJtaXNzaW9uXG5cdCRjYWNoZS5tb25vZ3JhbWZvcm1maWVsZHMuZmluZChcImlucHV0W25hbWU9bW9ub2dyYW1fRE9UU11cIikudmFsKCR0aGlzLmRhdGEoJ3ZhbHVlJykgPyBcIllcIiA6IFwiTlwiKTtcblxuXHQvLyBzZXQgaW1hZ2UgdmFsdWVzXG5cdCRjYWNoZS5tb25vZ3JhbWNvbnRhaW5lci5kYXRhKCdpbWFnZU9wdGlvbnMnKVsnJGRvdHMnXSA9ICR0aGlzLmRhdGEoJ3ZhbHVlJykgPyAxIDogMDtcblxuXHR1cGRhdGVJbWFnZXMoKTtcbn1cblxuZnVuY3Rpb24gdGV4dElucHV0Q2xlYXJDbGljayhlKXtcbiAgICAvLyBkaXNhYmxlIHRoZSBhMmMgYnV0dG9uXG4gICAgdmFyIHRpdGxlID0gJCgnYnV0dG9uI2FkZC10by1jYXJ0JykuYXR0cigncmVsJyk7XG4gICAgJCgnYnV0dG9uI2FkZC10by1jYXJ0JykuYXR0cigndGl0bGUnLCQoJ2J1dHRvbiNhZGQtdG8tY2FydCcpLmF0dHIoJ3JlbCcpKS5hdHRyKFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZFwiKTtcblx0JGNhY2hlLm1vbm9ncmFtdGV4dGlucHV0Ym9keS5maW5kKFwiaW5wdXRcIikudmFsKFwiXCIpO1xuXHQkY2FjaGUubW9ub2dyYW10ZXh0aW5wdXRib2R5LmZpbmQoJ2lucHV0JykucmVtb3ZlQ2xhc3MoJ2ZvbnQtc3ltYm9sJyk7XG5cdCRjYWNoZS5tb25vZ3JhbXN5bWJvbGxpc3QuZmluZCgnbGkubW9ub2dyYW0tc3ltYm9sJykucmVtb3ZlQ2xhc3MoJ3NlbGVjdGVkIHVuc2VsZWN0YWJsZS1kb3VibGUtd2lkZS1zeW1ib2wnKTtcblx0JGNhY2hlLm1vbm9ncmFtZm9ybWZpZWxkcy5maW5kKFwiaW5wdXRbbmFtZV49J21vbm9ncmFtX0NIQVJcIikudmFsKFwiXCIpO1xuXG5cdHZhciBpbWFnZU9wdGlvbnMgPSAkY2FjaGUubW9ub2dyYW1jb250YWluZXIuZGF0YSgnaW1hZ2VPcHRpb25zJyk7XG5cdHZhciBrZXlzID0gT2JqZWN0LmtleXMoaW1hZ2VPcHRpb25zKTtcblx0Zm9yKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspe1xuXHRcdHZhciBrZXkgPSBrZXlzW2ldO1xuXHRcdGlmKGtleS5pbmRleE9mKCckY2hyJykgPT09IDApe1xuXHRcdFx0aW1hZ2VPcHRpb25zW2tleV0gPSBcIlwiO1xuXHRcdH1cblx0fVxuXHQkY2FjaGUubW9ub2dyYW1jb250YWluZXIuZGF0YSgnaW1hZ2VPcHRpb25zJyxpbWFnZU9wdGlvbnMpO1xuXHR1cGRhdGVTeW1ib2xzU2VsZWN0ZWQoKTtcblx0dXBkYXRlSW1hZ2VzKCk7XG5cdGNsZWFyRXJyb3JNZXNzYWdlcygpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGb250VGlsZShmb250LGkpe1xuXHQvKipcblx0ICogPGxpIGNsYXNzPVwibW9ub2dyYW0tZm9udFwiPiA8c3BhbiBjbGFzcz1cImZvbnQtbmFtZVwiPjwvc3Bhbj4gPC9saT5cblx0ICovXG5cdHZhciAkZm9udCA9ICRjYWNoZS5mb250dGlsZWJhc2UuY2xvbmUoKTtcblx0JGZvbnQuZmluZCgnLmZvbnQtbmFtZScpLnRleHQoZm9udC5mb250TmFtZSk7XG5cdCRmb250LmZpbmQoJy5mb250LW5hbWUnKS5jc3MoXCJmb250LWZhbWlseVwiLGZvbnQuZm9udFN0eWxlKTtcblxuXHRpZihmb250LmJvbGQpe1xuXHRcdCRmb250LmZpbmQoJy5mb250LW5hbWUnKS5hZGRDbGFzcyhcIm1vbm9ncmFtLWZvbnQtc3R5bGUtYm9sZFwiKTtcblx0fVxuXG5cdGlmKGZvbnQuaXRhbGljKXtcblx0XHQkZm9udC5maW5kKCcuZm9udC1uYW1lJykuYWRkQ2xhc3MoXCJtb25vZ3JhbS1mb250LXN0eWxlLWl0YWxpY1wiKTtcblx0fVxuXG5cdCRmb250LmRhdGEoJ2ZvbnQtY29uZmlnJyxmb250KTtcblxuXHRpZihpID09PTApe1xuXHRcdCRmb250LmFkZENsYXNzKCdmaXJzdC1tb25vZ3JhbS1mb250Jyk7XG5cdH1cblxuXHQkZm9udC5jbGljayhtb25vZ3JhbUZvbnRDbGljayk7XG5cblx0JGNhY2hlLm1vbm9ncmFtZm9udHNlbGVjdC5hcHBlbmQoJGZvbnQpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0SW5wdXQoc3R5bGVDb25maWcsaSl7XG5cdHZhciAkdGV4dElucHV0ID0gJGNhY2hlLm1vbm9ncmFtaW5wdXRiYXNlLmNsb25lKCksXG5cdFx0JGlucHV0ID0gJHRleHRJbnB1dC5maW5kKCdpbnB1dCcpO1xuXG5cdGlmKCRjYWNoZS5tb25vZ3JhbWZvbnRzZWxlY3QuZmluZCgnLm1vbm9ncmFtLWZvbnQuc2VsZWN0ZWQnKS5sZW5ndGggPT09IDEpe1xuXHRcdCRpbnB1dC5jc3MoJ2ZvbnQtZmFtaWx5JywkY2FjaGUubW9ub2dyYW1mb250c2VsZWN0LmZpbmQoJy5tb25vZ3JhbS1mb250LnNlbGVjdGVkJykuZGF0YSgnZm9udC1jb25maWcnKS5mb250U3R5bGUpO1xuXHR9XG5cblx0JGlucHV0LmRhdGEoJ3Bvc2l0aW9uJywnJGNocicraSk7XG5cblx0JGlucHV0LmRhdGEoJ2luZGV4JyxpKTtcblxuXHRpZihpID09PSAyICYmIHN0eWxlQ29uZmlnLnRyYWRpdGlvbmFsKXtcblx0XHQkaW5wdXQuYWRkQ2xhc3MoJ21vbm9ncmFtLXRleHQtaW5wdXQtZmllbGQtdHJhZGl0aW9uYWwtbWlkZGxlJylcblx0fVxuXG5cdGlmKHN0eWxlQ29uZmlnLm1heENoYXIgPT09IDEpe1xuXHRcdCRpbnB1dC5hZGRDbGFzcygnbW9ub2dyYW0tdGV4dC1pbnB1dC1maWVsZC1zaW5nbGUnKTtcblx0fWVsc2UgaWYoc3R5bGVDb25maWcubWF4Q2hhciA9PT0gMil7XG5cdFx0JGlucHV0LmFkZENsYXNzKCdtb25vZ3JhbS10ZXh0LWlucHV0LWZpZWxkLWRvdWJsZScpO1xuXHR9XG5cblx0c3dpdGNoKHN0eWxlQ29uZmlnLm1vbm9ncmFtbWluZ0ZvbnRDYXNlKXtcblx0XHRjYXNlIFwiZm9yY2VVcHBlclwiOlxuXHRcdFx0JGlucHV0LmFkZENsYXNzKFwibW9ub2dyYW0tZm9udC1jYXNlLXVwcGVyXCIpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIFwiZm9yY2VMb3dlclwiOlxuXHRcdFx0JGlucHV0LmFkZENsYXNzKFwibW9ub2dyYW0tZm9udC1jYXNlLWxvd2VyXCIpO1xuXHRcdFx0YnJlYWs7XG5cdH1cblxuXHQkaW5wdXQuZm9jdXModGV4dElucHV0Rm9jdXMpO1xuXHQkaW5wdXQuYmx1cih0ZXh0SW5wdXRCbHVyKTtcblx0JGlucHV0LmtleXVwKHRleHRJbnB1dEtleVVwKTtcblxuXHQkY2FjaGUubW9ub2dyYW10ZXh0aW5wdXRib2R5LmFwcGVuZCgkdGV4dElucHV0KTtcblxuXHRyZXR1cm4gJHRleHRJbnB1dDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlV29yZElucHV0KHN0eWxlQ29uZmlnKXtcblx0dmFyICR0ZXh0SW5wdXQgPSAkY2FjaGUubW9ub2dyYW1pbnB1dGJhc2UuY2xvbmUoKSxcblx0JGlucHV0ID0gJHRleHRJbnB1dC5maW5kKCdpbnB1dCcpO1xuXG5cdGlmKCRjYWNoZS5tb25vZ3JhbWZvbnRzZWxlY3QuZmluZCgnLm1vbm9ncmFtLWZvbnQuc2VsZWN0ZWQnKS5sZW5ndGggPT09IDEpe1xuXHRcdCRpbnB1dC5jc3MoJ2ZvbnQtZmFtaWx5JywkY2FjaGUubW9ub2dyYW1mb250c2VsZWN0LmZpbmQoJy5tb25vZ3JhbS1mb250LnNlbGVjdGVkJykuZGF0YSgnZm9udC1jb25maWcnKS5mb250U3R5bGUpO1xuXHR9XG5cblx0JGlucHV0LmF0dHIoJ21heGxlbmd0aCcsc3R5bGVDb25maWcubWF4Q2hhcik7XG5cblx0JGlucHV0LmFkZENsYXNzKCdtb25vZ3JhbS13b3JkLWlucHV0LWZpZWxkJyk7XG5cblx0JGlucHV0LmZvY3VzKHRleHRJbnB1dEZvY3VzKTtcblx0JGlucHV0LmJsdXIodGV4dElucHV0Qmx1cik7XG5cdCRpbnB1dC5rZXl1cCh3b3JkSW5wdXRLZXlVcCk7XG5cblx0JGNhY2hlLm1vbm9ncmFtdGV4dGlucHV0Ym9keS5hcHBlbmQoJHRleHRJbnB1dCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN5bWJvbChzeW1ib2xDb25maWcsaSl7XG5cdC8qKlxuXHQgKiA8bGkgY2xhc3M9XCJtb25vZ3JhbS1zeW1ib2xcIj4gPGRpdiBjbGFzcz1cIm1vbm9ncmFtLXN5bWJvbC1maWVsZFxuXHQgKiBmb250LXN5bWJvbFwiLz4gPC9saT5cblx0ICovXG5cdHZhciAkc3ltYm9sID0gJGNhY2hlLnN5bWJvbGJhc2UuY2xvbmUoKTtcblx0Ly8gYWRkIEFEQSBsYWJlbCBhdHRyc1xuXHQkc3ltYm9sLmF0dHIoJ2FyaWEtbGFiZWwnLCBzeW1ib2xDb25maWcuY2hhcmFjdGVyKVxuXHQkc3ltYm9sLmZpbmQoJ2RpdicpLmF0dHIoJ2FyaWEtbGFiZWwnLCBzeW1ib2xDb25maWcuY2hhcmFjdGVyKVxuXHQkc3ltYm9sLmZpbmQoJ2RpdicpLmh0bWwoc3ltYm9sQ29uZmlnLmZvbnRDb2RlKTtcblx0JHN5bWJvbC5kYXRhKCdzeW1ib2wtY29uZmlnJyxzeW1ib2xDb25maWcpO1xuXG5cdGlmKHN5bWJvbENvbmZpZy53aWR0aCA9PT0gMil7XG5cdFx0JHN5bWJvbC5hZGRDbGFzcyhcImRvdWJsZS13aWRlXCIpO1xuXHR9XG5cdGlmKHN5bWJvbENvbmZpZy5mb250U2l6ZSl7XG5cdFx0JHN5bWJvbC5maW5kKCdkaXYnKS5jc3MoJ2ZvbnQtc2l6ZScsc3ltYm9sQ29uZmlnLmZvbnRTaXplKTtcblx0fVxuXG5cdCRzeW1ib2wuY2xpY2soc3ltYm9sQ2xpY2spXG5cblx0JGNhY2hlLm1vbm9ncmFtc3ltYm9sbGlzdC5hcHBlbmQoJHN5bWJvbCk7XG59XG5cblxuZnVuY3Rpb24gdXBkYXRlSW1hZ2VzKCl7XG5cdGlmKCRjYWNoZS5pbWFnZXNUaW1lb3V0KXtcblx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCRjYWNoZS5pbWFnZXNUaW1lb3V0KTtcblx0fVxuXHQkY2FjaGUuaW1hZ2VzVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGRvVXBkYXRlSW1hZ2VzLDUwMCk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTW9ub2dyYW1JbnB1dFZhbHVlcygpe1xuXG5cdHZhciBtb25vZ3JhbVRleHRJbnB1dFZhbGlkID0gZmFsc2U7XG5cdC8vJCgnLm1vbm9ncmFtLXRleHQtaW5wdXQtYm9keScpLmZpbmQoJ21vbm9ncmFtLXRleHQtaW5wdXQtZmllbGQnKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgIHZhciBtb25vZ3JhbVRleHRJbnB1dHMgPSAkKCcubW9ub2dyYW0tdGV4dC1pbnB1dC1maWVsZCcpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpPCBtb25vZ3JhbVRleHRJbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCQobW9ub2dyYW1UZXh0SW5wdXRzW2ldKS52YWwoKS50cmltKCkgIT0gJycpIHtcbiAgICAgICAgXHRtb25vZ3JhbVRleHRJbnB1dFZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9pZiBhbGwgaW5wdXRzIGFyZSBmaWxsZWQgb3V0LCBlbmFibGUgQWRkIFRvIENhcnQgYnV0dG9uXG4gICAgaWYgKG1vbm9ncmFtVGV4dElucHV0VmFsaWQpIHtcbiAgICAgICAgdmFyIHRpdGxlID0gJCgnYnV0dG9uI2FkZC10by1jYXJ0JykuYXR0cigncmVsJyk7XG4gICAgICAgICQoJ2J1dHRvbiNhZGQtdG8tY2FydCcpLmF0dHIoJ3RpdGxlJyx0aXRsZSkucmVtb3ZlQXR0cihcImRpc2FibGVkXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRpc2FibGUgdGhlIGEyYyBidXR0b25cbiAgICAgICAgJCgnYnV0dG9uI2FkZC10by1jYXJ0JykuYXR0cihcImRpc2FibGVkXCIsIFwiZGlzYWJsZWRcIik7XG4gICAgfVxufVxuXG5cbmZ1bmN0aW9uIGdldFF1ZXJ5U3RyaW5nKCl7XG5cdHZhciBpbWdPcHRpb25zID0gJGNhY2hlLm1vbm9ncmFtY29udGFpbmVyLmRhdGEoJ2ltYWdlT3B0aW9ucycpLFxuXHRcdGtleXMgPSBPYmplY3Qua2V5cyhpbWdPcHRpb25zKSxcblx0XHRxcyA9IFtdLFxuXHRcdGtleTtcblxuXHRmb3IodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKyl7XG5cdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRxcy5wdXNoKGtleSArIFwiPVwiICsgaW1nT3B0aW9uc1trZXldKTtcblx0fVxuXG5cdHJldHVybiBxcy5qb2luKFwiJlwiKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVJbWFnZU9wdGlvbnMoKXtcblx0dmFyIGltZ09wdGlvbnMgPSAkY2FjaGUubW9ub2dyYW1jb250YWluZXIuZGF0YSgnaW1hZ2VPcHRpb25zJyk7XG5cblx0dmFyIHZhbGlkID0gKGltZ09wdGlvbnNbJyRmdHlwZSddICE9IG51bGwgJiZcblx0XHRpbWdPcHRpb25zWyckZnN0eWxlJ10gIT0gIG51bGwgJiZcblx0XHRpbWdPcHRpb25zWyckZG90cyddICE9IG51bGwgJiZcblx0XHQoaW1nT3B0aW9uc1snJGNocjEnXSAhPSBudWxsIHx8IGltZ09wdGlvbnNbJyRjaHIyJ10gIT0gbnVsbCB8fCBpbWdPcHRpb25zWyckY2hyMyddICE9IG51bGwpKTtcblxuXHRpZigkY2FjaGUubW9ub2dyYW1jb2xvcnMubGVuZ3RoKXtcblx0XHR2YWxpZCA9IHZhbGlkICYmIGltZ09wdGlvbnNbJyRjb2xvciddICE9IG51bGw7XG5cdH1cblxuXHRyZXR1cm4gdmFsaWQ7XG59XG5cbmZ1bmN0aW9uIHJlc2V0TW9ub2dyYW1taW5nUGFnZSgpe1xuXHR0ZXh0SW5wdXRDbGVhckNsaWNrKCk7XG5cdCRjYWNoZS5tb25vZ3JhbXN0eWxldGlsZXMucmVtb3ZlQ2xhc3MoJ3NlbGVjdGVkJyk7XG5cblx0Ly8gaGlkZSB0aGUgYm90dG9tIGNvbnRhaW5lcnNcblx0JGNhY2hlLm1vbm9ncmFtY29udGFpbmVyLmZpbmQoJy5tb25vZ3JhbS1vcHRpb25zLWJvZHknKS5zbGlkZVVwKCk7XG5cdCRjYWNoZS5tb25vZ3JhbWNvbnRhaW5lci5maW5kKCcubW9ub2dyYW0tY29sb3JzLXNlY3Rpb24tYm9keScpLnNsaWRlVXAoKTtcblx0JGNhY2hlLm1vbm9ncmFtY29udGFpbmVyLmZpbmQoJy5tb25vZ3JhbS1zZWN0aW9uLXRpdGxlLCAubW9ub2dyYW0tdG9nZ2xlLWljb24nKS5hZGRDbGFzcygnaW5hY3RpdmUnKTtcblx0JGNhY2hlLm1vbm9ncmFtY29udGFpbmVyLmZpbmQoJy5tb25vZ3JhbS1zZWN0aW9uLXRpdGxlIC5jb2xvci1uYW1lJykuYWRkQ2xhc3MoJ3Zpc3VhbGx5LWhpZGRlbicpO1xuXG5cdC8vIGRpc2FibGUgdGhlIGEyYyBidXR0b25cblx0JCgnYnV0dG9uI2FkZC10by1jYXJ0JykuYXR0cihcImRpc2FibGVkXCIsXCJkaXNhYmxlZFwiKTtcblx0JCgnLm1vbm9ncmFtLXRleHQtbWlzc2luZy1pbnB1dC1lcnJvcicpLnNob3coKTtcbn1cblxuZnVuY3Rpb24gc2V0QWRkVG9DYXJ0SGFuZGxlcihlKSB7XG5cdGUucHJldmVudERlZmF1bHQoKTtcblx0aWYgKCF2YWxpZGF0ZUZvcm1GaWVsZHMoKSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciBmb3JtID0gJCh0aGlzKS5jbG9zZXN0KCdmb3JtJyk7XG5cdHZhciBxdHkgPSBmb3JtLmZpbmQoXCJzZWxlY3RbbmFtZT0nUXVhbnRpdHknXVwiKTtcblx0dmFyIGlzU3ViSXRlbSA9ICQodGhpcykuaGFzQ2xhc3MoXCJzdWItcHJvZHVjdC1pdGVtXCIpO1xuXHRpZihxdHkubGVuZ3RoID09PSAwIHx8IGlzTmFOKHF0eS52YWwoKSkgfHwgcGFyc2VJbnQocXR5LnZhbCgpLCAxMCkgPT09IDApIHtcblx0XHRxdHkudmFsKFwiMVwiKTtcblx0fVxuXG5cdC8vIGZvciBnaWZ0IHJlZ2lzdHJ5XG5cdHZhciBpdGVtaWQgPSAkKHRoaXMpLmRhdGEoJ2l0ZW1pZCcpO1xuXHRpZihpdGVtaWQpe1xuXHRcdCQoJ2lucHV0W25hbWU9aXRlbWlkXScpLnZhbChpdGVtaWQpO1xuXHR9XG5cdHZhciBxdHllbGVtID0gJCh0aGlzKS5kYXRhKCdxdHllbGVtJyk7XG5cdGlmKHF0eWVsZW0pe1xuXHRcdHF0eWVsZW0gPSAkKCdzZWxlY3RbbmFtZT0nICsgcXR5ZWxlbSArICddJykuZmlyc3QoKTtcblx0XHRpZihxdHllbGVtKXtcblx0XHRcdCQoJ2lucHV0W25hbWU9UXVhbnRpdHldJykudmFsKHF0eWVsZW0udmFsKCkpO1xuXHRcdH1cblx0fVxuXG5cdHZhciBwZHBNYWluID0gKCRjYWNoZSA/ICRjYWNoZS5wZHBNYWluIDogbnVsbCk7XG5cblx0dmFyIGRhdGEgPSBmb3JtLnNlcmlhbGl6ZSgpO1xuXG5cdGFwcC5jYXJ0LnVwZGF0ZShkYXRhICsgJyZmbHlvdXQ9dHJ1ZScsIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHRcdHJlc2V0TW9ub2dyYW1taW5nUGFnZSgpO1xuXHRcdGlmIChyZXNwb25zZS5lcnJvciA9PSAnb3V0X29mX3N0b2NrJykge1xuXHRcdFx0dmFyIG91dG9mc3RvY2ttZXNzYWdlID0gKHR5cGVvZiBrYXRlc3BhZGUgIT0gJ3VuZGVmaW5lZCcpID8gUmVzb3VyY2VzLlBST0RVQ1RfT1VUX09GX1NUT0NLX0ZMWU9VVCA6IFJlc291cmNlcy5LU1NfUFJPRFVDVF9PVVRfT0ZfU1RPQ0tfRkxZT1VUO1xuXHRcdFx0YXBwLm1pbmljYXJ0LmZseW91dChyZXNwb25zZSxwZHBNYWluLG51bGwsb3V0b2ZzdG9ja21lc3NhZ2UpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHQvLyByZWZyZXNoIHRoZSBxdWFudGl0eSBhbmQgY2hlY2sgZm9yIHB1cmNoYXNlIGxpbWl0XG5cdFx0aWYodHlwZW9mIGthdGVzcGFkZSAhPSAndW5kZWZpbmVkJyl7IC8vIGZvciBub3cgb25seSBlbmFibGUgb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGthdGUgc3BhZGUgYW5kIGthdGUgc2FsZVxuXHRcdFx0YXBwLnByb2R1Y3QudXBkYXRlUXVhbnRpdHkoe2NoZWNrUHVyY2hhc2VMaW1pdDp0cnVlfSk7XG5cdFx0fVxuXHRcdHZhciBtaW5pQ2FydFYyID0gJChcIi5taW5pLWNhcnQtcmVmcmVzaC52MlwiKTtcblx0XHRpZiAobWluaUNhcnRWMi5sZW5ndGggPT0gMCkge1xuXHRcdFx0YXBwLm1pbmljYXJ0LmZseW91dChyZXNwb25zZSwgcGRwTWFpbiwgZm9ybS5maW5kKFwiI2FkZC10by1jYXJ0XCIpKTtcblx0XHR9XG5cblx0XHQvLyB1cGRhdGUgdGhlIG1pbmljYXJ0LCBidXQgZG9uJ3Qgc2hvdyBpdFxuXHRcdHZhciB1cmwgPSBhcHAudXRpbC5hamF4VXJsKGFwcC51cmxzLm1pbmljYXJ0KTtcblx0XHQkLnBvc3QodXJsLCBudWxsLCBmdW5jdGlvbihyZXNwb25zZSkge1xuXHRcdFx0aWYgKG1pbmlDYXJ0VjIubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRhcHAubWluaWNhcnQuc2hvdyhyZXNwb25zZSk7XG5cdFx0XHRcdC8vIHNob3cgQURERUQhIG9uIHRoZSBhZGQgdG8gY2FydCBidXR0b24gZm9yIDIgc2Vjb25kc1xuXHRcdFx0XHR2YXIgYTJjID0gZm9ybS5maW5kKCcjYWRkLXRvLWNhcnQnKTtcblx0XHRcdFx0aWYgKCFhMmMuZGF0YSgndGV4dCcpKSB7XG5cdFx0XHRcdFx0YTJjLmRhdGEoJ3RleHQnLCBhMmMudGV4dCgpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhMmMudGV4dChSZXNvdXJjZXMuUFJPRFVDVF9BRERFRCk7XG5cdFx0XHRcdGlmICgkY2FjaGUuYWRkZWRUaW1lcikge1xuXHRcdFx0XHRcdGNsZWFyVGltZW91dCgkY2FjaGUuYWRkZWRUaW1lcik7XG5cdFx0XHRcdH1cblx0XHRcdFx0JGNhY2hlLmFkZGVkVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0YTJjLnRleHQoYTJjLmRhdGEoJ3RleHQnKSk7XG5cdFx0XHRcdFx0YTJjLmRhdGEoJ3RleHQnLCBudWxsKTtcblx0XHRcdFx0fSwgMjAwMCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0YXBwLm1pbmljYXJ0LnVwZGF0ZShyZXNwb25zZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fSk7XG5cblx0aWYgKHR5cGVvZiBkYXRhTGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRkYXRhTGF5ZXIucHVzaChhcHAuZGF0YWxheWVyLmdldEV2ZW50KFwiZXZlbnRcIiwgXCJhZGRUb0NhcnRcIikpO1xuXHRcdC8vIGRhdGFMYXllci5wdXNoKHsgXCJldmVudFwiIDogXCJhZGRUb0NhcnRcIn0pO1xuXHRcdHZhciB0cmFuc2FjdGlvblByb2R1Y3RzID0gW107XG5cdFx0dmFyIGRsUGlkLCBkbFNrdSwgZGxQcm9kdWN0TmFtZSwgZGxDYXRlZ29yeUlELCBkbFByaWNlLCBkbFF1YW50aXR5O1xuXHRcdGlmICh0eXBlb2YgY21Qcm9kdWN0TmFtZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0ZGxQcm9kdWN0TmFtZSA9IGNtUHJvZHVjdE5hbWU7XG5cdFx0XHRkbENhdGVnb3J5SUQgPSBjbUNhdGVnb3J5SUQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBkbFByb2R1Y3ROYW1lID0gZm9ybS5hdHRyKFwiZGF0YS1wbmFtZVwiKTtcblx0XHRcdHZhciBkbENhdGVnb3J5SUQgPSBmb3JtLmF0dHIoXCJkYXRhLXBjYXRcIik7XG5cdFx0fVxuXG5cdFx0XHRkbFNrdSA9ICQoXCIjcGlkXCIpLnZhbCgpO1xuXHRcdFx0ZGxQaWQgPSAkKCcjcHJvZHVjdC1jb250ZW50JykuZmluZCgnZGl2W2RhdGEtbWFzdGVyXScpLmF0dHIoJ2RhdGEtbWFzdGVyJyk7XG5cdFx0XHQvLyBkbFByb2R1Y3ROYW1lIHNldCBwcmV2aW91c2x5XG5cdFx0XHQvLyBkbENhdGVnb3J5SUQgc2V0IHByZXZpb3VzbHlcblx0XHRcdGRsUHJpY2UgPSAoJC50cmltKCQoXCIucHJpY2Utc2FsZXNcIikuaHRtbCgpLnRyaW0oKSkucmVwbGFjZShcIiRcIiwgXCJcIikpO1xuXHRcdFx0ZGxRdWFudGl0eSA9IHBhcnNlSW50KHF0eS52YWwoKSwgMTApO1xuXG5cdFx0dHJhbnNhY3Rpb25Qcm9kdWN0cy5wdXNoKHsgXCJza3VcIiA6IGRsU2t1LCBcInBpZFwiIDogZGxQaWQsIFwibmFtZVwiIDogZGxQcm9kdWN0TmFtZSwgXCJjYXRlZ29yeVwiIDogZGxDYXRlZ29yeUlELCBcInByaWNlXCIgOiBkbFByaWNlLCBcInF1YW50aXR5XCIgOmRsUXVhbnRpdHkgfSk7XG5cblx0XHRkYXRhTGF5ZXIucHVzaChhcHAuZGF0YWxheWVyLmdldEV2ZW50KFwidHJhbnNhY3Rpb25Qcm9kdWN0c1wiLCB0cmFuc2FjdGlvblByb2R1Y3RzKSk7XG5cdFx0Ly8gZGF0YUxheWVyLnB1c2goe1widHJhbnNhY3Rpb25Qcm9kdWN0c1wiIDogdHJhbnNhY3Rpb25Qcm9kdWN0cyB9KTtcblx0fVxufVxuLypFbmQgTW9ub2dyYW1taW5nIGZ1bmN0aW9ucyovXG5cblxubWFpbkltYWdlLmluaXQoKTtcbmluaXRpYWxpemVFdmVudHMoKTtcbmluaXRpYWxpemVEb20oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwcm9kdWN0SW52ZW50b3J5O1xubW9kdWxlLmV4cG9ydHMubW9ub2dyYW1SZXNldCA9IG1vbm9ncmFtUmVzZXQ7XG5tb2R1bGUuZXhwb3J0cy5mdWxsU2NyZWVuSW1hZ2UgPSBmdWxsU2NyZWVuSW1hZ2U7XG5tb2R1bGUuZXhwb3J0cy52YWxpZGF0ZUZvcm1GaWVsZHMgPSB2YWxpZGF0ZUZvcm1GaWVsZHM7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBpbnZlbnRvcnkgPSByZXF1aXJlKCcuLycpO1xudmFyIFRQcm9taXNlID0gcmVxdWlyZSgncHJvbWlzZScpO1xuXG52YXIgc2hpcHBpbmdJbnZlbnRvcnkgPSB7XG5cbiAgICBzaGlwSW5zdGVhZDogZnVuY3Rpb24odXVpZCkge1xuICAgICAgICBUUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICB1cmw6IFVybHMuc2V0U3RvcmVQaWNrdXAsXG4gICAgICAgICAgICAgICAgdHlwZTogJ0dFVCcsXG4gICAgICAgICAgICAgICAgZGF0YTogeyBwbGlkOiB1dWlkLCBzdG9yZWlkOiAnJywgc3RvcmVwaWNrdXA6ICdmYWxzZSd9XG4gICAgICAgICAgICB9KVxuICAgICAgICApLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgb3BlbkVkaXRTdG9yZURpYWxvZzogZnVuY3Rpb24oJHNoaXBtZW50Q29udGFpbmVyKSB7XG4gICAgICAgIHZhciAkY29sb3JFbCA9ICRzaGlwbWVudENvbnRhaW5lci5maW5kKCdkaXZbZGF0YS1hdHRyaWJ1dGU9XCJjb2xvclwiXSAudmFsdWUnKTtcbiAgICAgICAgdmFyICRwcmljZUVsID0gJHNoaXBtZW50Q29udGFpbmVyLmZpbmQoJy5taW5pLXByb2R1Y3QtcHJpY2UtdG90YWwnKTtcbiAgICAgICAgdmFyICRxdHlFbCA9ICRzaGlwbWVudENvbnRhaW5lci5maW5kKCcubWluaS1wcm9kdWN0LXF1YW50aXR5Jyk7XG5cbiAgICAgICAgdmFyIHNoaXBtZW50RGF0YSA9ICRzaGlwbWVudENvbnRhaW5lci5kYXRhKCk7XG4gICAgICAgIHZhciBwaWQgPSAgc2hpcG1lbnREYXRhLnBpZDtcbiAgICAgICAgdmFyIHV1aWQgPSBzaGlwbWVudERhdGEudXVpZDtcbiAgICAgICAgdmFyIHNlbGVjdGVkU3RvcmUgPSBzaGlwbWVudERhdGEuc3RvcmVJZDtcbiAgICAgICAgdmFyIG5ld1NlbGVjdGVkU3RvcmVJZCA9ICcnO1xuICAgICAgICB2YXIgcHJvZHVjdENvbG9yID0gKCRjb2xvckVsLmxlbmd0aCA+IDApID8gJGNvbG9yRWwudGV4dCgpLnRyaW0oKSA6ICcnO1xuICAgICAgICB2YXIgcHJvZHVjdFByaWNlID0gKCRwcmljZUVsLmxlbmd0aCA+IDApID8gJHByaWNlRWwudGV4dCgpLnRyaW0oKSA6ICcnO1xuICAgICAgICB2YXIgcHJvZHVjdFF0eSA9ICAoJHF0eUVsLmxlbmd0aCA+IDApID8gICRxdHlFbC50ZXh0KCkudHJpbSgpIDogJyc7XG5cbiAgICAgICAgVFByb21pc2UucmVzb2x2ZShcbiAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdodG1sJyxcbiAgICAgICAgICAgICAgICB1cmw6IHV0aWwuYXBwZW5kUGFyYW1zVG9VcmwoVXJscy5nZXRQcm9kdWN0SW5mbywge1xuICAgICAgICAgICAgICAgICAgICBwaWQ6IHBpZCxcbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjdENvbG9yOiBwcm9kdWN0Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHByb2R1Y3RQcmljZTogcHJvZHVjdFByaWNlLFxuICAgICAgICAgICAgICAgICAgICBwcm9kdWN0UXR5OiBwcm9kdWN0UXR5XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgaW52ZW50b3J5LnNlbGVjdFN0b3JlRGlhbG9nKHtcbiAgICAgICAgICAgICAgICBwaWQ6IHBpZCxcbiAgICAgICAgICAgICAgICBwaWNrdXBDb250ZW50OiByZXNwb25zZSxcbiAgICAgICAgICAgICAgICBzdG9yZXM6IFtdLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkU3RvcmVJZDogc2VsZWN0ZWRTdG9yZSxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFN0b3JlVGV4dDogUmVzb3VyY2VzLlNFTEVDVEVEX1NUT1JFLFxuICAgICAgICAgICAgICAgIHNlbGVjdFN0b3JlQ2FsbGJhY2s6IGZ1bmN0aW9uKHN0b3JlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0ZWRTdG9yZUlkID0gc3RvcmVJZDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1NlbGVjdGVkU3RvcmVJZCAhPT0gJycgJiYgbmV3U2VsZWN0ZWRTdG9yZUlkICE9PSBzZWxlY3RlZFN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBUUHJvbWlzZS5yZXNvbHZlKCQuYWpheCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBVcmxzLnNldFN0b3JlUGlja3VwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdHRVQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxpZDogdXVpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVpZDogbmV3U2VsZWN0ZWRTdG9yZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZXBpY2t1cDogJ3RydWUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICQoZG9jdW1lbnQpLm9uKCdjbGljaycsICcuanMtc2hpcHBpbmctc2hpcC1pbnN0ZWFkJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdmFyIHV1aWQgPSAkKHRoaXMpLmRhdGEoJ3V1aWQnKTtcbiAgICAgICAgICAgIHNlbGYuc2hpcEluc3RlYWQodXVpZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICQoZG9jdW1lbnQpLm9uKCdjbGljaycsICcuanMtc2hpcHBpbmctZWRpdC1zdG9yZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHZhciAkc2hpcG1lbnRDb250YWluZXIgPSAkKHRoaXMpO1xuICAgICAgICAgICAgc2VsZi5vcGVuRWRpdFN0b3JlRGlhbG9nKCRzaGlwbWVudENvbnRhaW5lcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc2hpcHBpbmdJbnZlbnRvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2hlY2tzIHRoZSBUTFMgYW5kIGRpc3BsYXlzIGEgd2FybmluZyBpZiBhcHByb3ByaWF0ZVxuICogQGZ1bmN0aW9uIGdldFVzZXJBZ2VudCBDaGVja3MgdGhlIFRMUyBhbmQgZGlzcGxheXMgYSB3YXJuaW5nIGlmIGFwcHJvcHJpYXRlXG4gKiovXG5mdW5jdGlvbiBnZXRVc2VyQWdlbnQoKSB7XG4gICAgLy8gVXNlIGFuIGV4dGVybmFsIHNlcnZpY2UgdG8gY2hlY2sgdGhlIFRMUyBvZiB0aGUgYnJvd3NlclxuICAgIC8vIE5PVEU6IHRoaXMgaW1wbGVtZW50YXRpb24gdXNlcyBodHRwczovL3d3dy5ob3dzbXlzc2wuY29tXG4gICAgLy8gICAgIHlvdSBtYXkgYWxzbyB3aXNoIHRvIGNvbnNpZGVyIHRoZSBBUEkgYXZhaWxhYmxlIGF0IGh0dHBzOi8vd3d3LnNzbGxhYnMuY29tL3Byb2plY3RzL3NzbGxhYnMtYXBpcy9pbmRleC5odG1sXG4gICAgdmFyIHVybCA9ICdodHRwczovL3d3dy5ob3dzbXlzc2wuY29tL2EvY2hlY2snO1xuICAgIHZhciBjb29raWVOYW1lID0gJ2R3X1RMU1dhcm5pbmcnO1xuICAgIHZhciBjb29raWVWYWx1ZSA9IGdldENvb2tpZShjb29raWVOYW1lKTtcblxuICAgIC8vIFRlc3QgdG8gc2VlIGlmIHRoaXMgYnJvd3NlciBoYXMgYWxyZWFkeSBiZWVuIGZsYWdnZWQgYnkgbG9va2luZyBhdCBpdHMgY29va2llc1xuICAgIGlmICghY29va2llVmFsdWUpIHtcbiAgICAgICAgZ2V0VExTKHVybCwgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzaG93V2FybmluZyhtZXNzYWdlWzBdKTtcblxuICAgICAgICAgICAgICAgIC8vIHRoZSBicm93c2VyIGlzIGJhZCAtIHNldCB0aGUgY29va2llIHRvIHRydWUgKGZvciAxNSBtaW51dGVzKVxuICAgICAgICAgICAgICAgIHNldENvb2tpZShjb29raWVOYW1lLCAndHJ1ZScsIDE1KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZWxzZSB0aGUgYnJvd3NlciBpcyBnb29kLCBzZXQgdGhlIGNvb2tpZSB0byBmYWxzZSAoZm9yIDMwIGRheXMpIHNvIHdlIGRvbid0IGNoZWNrIGFnYWluXG4gICAgICAgICAgICAgICAgc2V0Q29va2llKGNvb2tpZU5hbWUsICdmYWxzZScsIDYwICogMjQgKiAzMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29va2llVmFsdWUgPT09ICd0cnVlJykge1xuICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IGtub3cgdGhhdCB0aGlzIGlzIGFuIGludmFsaWQgYnJvd3Nlciwgc2hvdyB0aGUgd2FybmluZ1xuICAgICAgICBzaG93V2FybmluZyhSZXNvdXJjZXMuVExTX1dBUk5JTkcpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDYWxscyBvdXQgdG8gdGhlIFRMUyBzZXJ2aWNlIGFuZCBjYWxscyB0aGUgY2FsbGJhY2sgd2l0aCBhIG1lc3NhZ2UgKGlmIG5lY2Vzc2FyeSlcbiAqIEBmdW5jdGlvbiBnZXRUTFNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVVJMIG9mIGV4dGVybmFsIFRMUy1jaGVja2luZyBBUElcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gZnVuY3Rpb24gdG8gY2FsbCB3aXRoIHJlc3BvbnNlXG4gKiovXG5mdW5jdGlvbiBnZXRUTFModXJsLCBjYWxsYmFjaykge1xuICAgIHZhciBtZXNzYWdlID0gW107XG5cbiAgICAvLyBGaXJzdCwgc2VlIGlmIHRoZSBicm93c2VyIGlzIGFtb25nIHRoZSBzdXNwZWN0IGJyb3dzZXJzIHRvIHNlZSBpZiBhIFRMUyBjaGVjayBpcyBuZWNlc3NhcnlcbiAgICB2YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICAgIC8qKiBUaGlzIGxpc3QgZGVyaXZlZCBmcm9tIGh0dHBzOi8vd3d3LnNzbGxhYnMuY29tL3NzbHRlc3QvY2xpZW50cy5odG1sICoqL1xuICAgIHZhciBiYWRCcm93c2VycyA9IFsnTVNJRSA2LjAnLCdNU0lFIDcuMCcsJ01TSUUgOC4wJywnTVNJRSA5LjAnLCdNU0lFIDEwLjAnLFxuICAgICAgICAgICAgICAgICAgICAgICAnQW5kcm9pZCAyLjMuNycsICdBbmRyb2lkIDQuMC40JywgJ0FuZHJvaWQgNC4xLjEnLCAnQW5kcm9pZCA0LjIuMicsICdBbmRyb2lkIDQuMycsXG4gICAgICAgICAgICAgICAgICAgICAgICdTYWZhcmkgNS4xLjkgLyBPUyBYIDEwLjYuOCcsICdTYWZhcmkgNi4wLjQgLyBPUyBYIDEwLjguNCAnXTtcbiAgICBmdW5jdGlvbiBjaGVja1RMU0xldmVsKGRhdGEpIHtcbiAgICAgICAgLy8gSWYgd2UgY2FuIGRldGVybWluZSB0aGUgVExTIGxldmVsLCBjaGVjayB0byBzZWUgaWYgaXQncyBsZXNzIHRoYW4gMS4yXG4gICAgICAgIGlmIChwYXJzZUZsb2F0KGRhdGEudGxzX3ZlcnNpb24uc3BsaXQoJyAnKVsxXSkgPCAxLjEpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UucHVzaChSZXNvdXJjZXMuVExTX1dBUk5JTkcpO1xuICAgICAgICAgICAgY2FsbGJhY2sobWVzc2FnZSk7XG5cbiAgICAgICAgICAgIC8vSWYgeW91IHdhbnQgdG8gdHJhY2sgc3RhdGlzdGljcyBvbiBiYWQgVExTIGhpdHMsIGluY2x1ZGUgdGhpcyBjYWxsXG4gICAgICAgICAgICAkLmFqYXgoe3VybDogVXJscy5UTFNCYWRUTFN9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcG9ydEJhZEJyb3dzZXIgKCkge1xuICAgICAgICAvLyBJZiB0aGUgVExTIGxldmVsIGNhbm5vdCBiZSBkZXRlcm1pbmVkIGp1c3QgcmVwb3J0IHRoYXQgdGhpcyBicm93c2VyIGlzIHN1c3BlY3RcbiAgICAgICAgbWVzc2FnZS5wdXNoKFJlc291cmNlcy5UTFNfV0FSTklORyk7XG4gICAgICAgIGNhbGxiYWNrKG1lc3NhZ2UpO1xuXG4gICAgICAgIC8vSWYgeW91IHdhbnQgdG8gdHJhY2sgc3RhdGlzdGljcyBvbiBkZXByZWNhdGVkIGJyb3dzZXJzLCBpbmNsdWRlIHRoaXMgY2FsbFxuICAgICAgICAkLmFqYXgoe3VybDogVXJscy5UTFNCYWRCcm93c2VyfSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYWRCcm93c2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodXNlckFnZW50Lm1hdGNoKGJhZEJyb3dzZXJzW2ldKSkge1xuICAgICAgICAgICAgLy8gSXQncyBhIHN1c3BlY3QgYnJvd3NlciwgbGV0J3Mgc2VlIHdoYXQgaXQncyBUTFMgbGV2ZWwgaXNcbiAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgIH0pLmRvbmUoY2hlY2tUTFNMZXZlbCkuZmFpbChyZXBvcnRCYWRCcm93c2VyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEZvciB0ZXN0aW5nIHB1cnBvc2VzLCB1bmNvbW1lbnQgdGhpcyBibG9ja1xuICAgICAgICBtZXNzYWdlLnB1c2goUmVzb3VyY2VzLlRMU19XQVJOSU5HKTtcbiAgICAqKi9cbiAgICBjYWxsYmFjayhtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb24gc2hvd1dhcm5pbmcgdHVybnMgb24gdGhlIGJyb3dzZXItY29tcGF0aWJpbGl0eS1hbGVydCBhbmQgc2V0cyB0aGUgbWVzc2FnZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gdGhlIG1lc3NhZ2UgdGhhdCB3aWxsIGJlIHNob3duIHVwb24gZGV0ZWN0aW9uIG9mIGEgYmFkIGJyb3dzZXJcbiAqKi9cbmZ1bmN0aW9uIHNob3dXYXJuaW5nKG1lc3NhZ2UpIHtcbiAgICAkKCc8ZGl2Lz4nKS5hZGRDbGFzcygnYnJvd3Nlci1jb21wYXRpYmlsaXR5LWFsZXJ0JykuYXBwZW5kKCQoJzxwLz4nKS5hZGRDbGFzcygnYnJvd3Nlci1lcnJvcicpLmh0bWwobWVzc2FnZSkpLmFwcGVuZFRvKCcjYnJvd3Nlci1jaGVjaycpO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvbiBnZXRDb29raWVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGNvb2tpZSBuYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB2YWx1ZSAtIHRoZSB2YWx1ZSBvZiB0aGUgY29va2llIGlmIGZvdW5kLCBudWxsIG90aGVyd2lzZVxuICoqL1xuZnVuY3Rpb24gZ2V0Q29va2llKGtleSkge1xuICAgIHZhciBjb29raWVzID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7Jyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29raWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0b2tlbnMgPSBjb29raWVzW2ldLnNwbGl0KCc9Jyk7XG4gICAgICAgIHZhciBjb29raWVLZXkgPSB0b2tlbnNbMF0udHJpbSgpO1xuICAgICAgICBpZiAoY29va2llS2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbnNbMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvbiBzZXRDb29raWVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGNvb2tpZSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgY29va2llIHZhbHVlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG1pbnV0ZXMgLSBUaGUgbnVtYmVyIG9mIG1pbnV0ZXMgdG8gZXhwaXJlIHRoZSBjb29raWVcbiAqKi9cbmZ1bmN0aW9uIHNldENvb2tpZSAoa2V5LCB2YWx1ZSwgbWludXRlcykge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcbiAgICBkYXRlLnNldFRpbWUoZGF0ZSArIChtaW51dGVzICogNjAgKiAxMDAwKSk7XG5cbiAgICBkb2N1bWVudC5jb29raWUgPSBrZXkgKyAnPScgKyB2YWx1ZSArICc7IGV4cGlyZXM9JyArIGRhdGUudG9HTVRTdHJpbmcoKSArICc7IHBhdGg9Lyc7XG59XG5cbi8qKlxuICogRXhwb3J0IHRoZSBnZXRVc2VyQWdlbnQgZnVuY3Rpb25cbiAqL1xuXG5leHBvcnRzLmdldFVzZXJBZ2VudCA9IGdldFVzZXJBZ2VudDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvbiBJbml0aWFsaXplcyB0aGUgdG9vbHRpcC1jb250ZW50IGFuZCBsYXlvdXRcbiAqL1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICQoZG9jdW1lbnQpLnRvb2x0aXAoe1xuICAgICAgICBpdGVtczogJy50b29sdGlwJyxcbiAgICAgICAgdHJhY2s6IHRydWUsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICBteTogXCJsZWZ0KzMwIGNlbnRlclwiLFxuICAgICAgICAgICAgYXQ6IFwicmlnaHQgY2VudGVyXCIsXG4gICAgICAgICAgICBjb2xsaXNpb246IFwiZmxpcGZpdFwiLFxuICAgICAgICAgICAgdXNpbmc6IGZ1bmN0aW9uKCBwb3NpdGlvbiwgZmVlZGJhY2sgKSB7XG4gICAgICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcbiAgICAgICAgICAgICAgICAvLyBzZXQgdXAgdG9vbHRpcCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICR0aGlzLmNzcyggcG9zaXRpb24gKTtcbiAgICAgICAgICAgICAgICAvLyBhZGQgZXh0cmEgY2xhc3MgdG8gZGV0ZXJtaW5lIHRvb2x0aXAncyBob3Jpem9udGFsIHBvc2l0aW9uKGxlZnQgb3IgcmlnaHQpXG4gICAgICAgICAgICAgICAgdmFyIGhvcml6b250YWxQb3MgPSAnaG9yaXpvbnRhbC1wb3MtJyArIGZlZWRiYWNrLmhvcml6b250YWw7XG4gICAgICAgICAgICAgICAgJHRoaXMuZmluZCgnLnVpLXRvb2x0aXAtY29udGVudCcpLmFkZENsYXNzKGhvcml6b250YWxQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb250ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5maW5kKCcudG9vbHRpcC1jb250ZW50JykuaHRtbCgpO1xuICAgICAgICB9LFxuICAgICAgICBvcGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgXHQkKCcudWktdG9vbHRpcC1jb250ZW50JykuYWZ0ZXIoKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIH0pO31cbiAgICB9KTtcblxuICAgICQoJy50b29sdGlwJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuXG4gICAgJCgnLnNoYXJlLWxpbmsnKS5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciB0YXJnZXQgPSAkKHRoaXMpLmRhdGEoJ3RhcmdldCcpO1xuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgICQodGFyZ2V0KS50b2dnbGVDbGFzcygnYWN0aXZlJyk7XG4gICAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG52YXIgdXRpbCA9IHtcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gYXBwZW5kcyB0aGUgcGFyYW1ldGVyIHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIHZhbHVlIHRvIHRoZSBnaXZlbiB1cmwgYW5kIHJldHVybnMgdGhlIGNoYW5nZWQgdXJsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCB0aGUgdXJsIHRvIHdoaWNoIHRoZSBwYXJhbWV0ZXIgd2lsbCBiZSBhZGRlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgdGhlIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICAgKi9cbiAgICBhcHBlbmRQYXJhbVRvVVJMOiBmdW5jdGlvbiAodXJsLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAvLyBxdWl0IGlmIHRoZSBwYXJhbSBhbHJlYWR5IGV4aXN0c1xuICAgIFx0aWYgKG5hbWUuaW5kZXhPZignc291cmNlJykgPT0gLTEgJiYgdXJsLmluZGV4T2YobmFtZSArICc9JykgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSB1cmwuaW5kZXhPZignPycpICE9PSAtMSA/ICcmJyA6ICc/JztcbiAgICAgICAgcmV0dXJuIHVybCArIHNlcGFyYXRvciArIG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgIH0sXG5cbiAgICBnZXRVcmkgOiBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgYTtcbiAgICAgICAgaWYgKG8udGFnTmFtZSAmJiAkKG8pLmF0dHIoXCJocmVmXCIpKSB7XG4gICAgICAgICAgICBhID0gbztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICAgICAgYS5ocmVmID0gbztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXRoUGFydHMgPSAnJztcbiAgICAgICAgaWYgKGEucGF0aG5hbWUpIHtcbiAgICAgICAgICAgIHBhdGhQYXJ0cyA9IGEucGF0aG5hbWUuc3BsaXQoJy8nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvdG9jb2wgOiBhLnByb3RvY29sLCAvL2h0dHA6XG4gICAgICAgICAgICBob3N0IDogYS5ob3N0LCAvL3d3dy5teWV4YW1wbGUuY29tXG4gICAgICAgICAgICBob3N0bmFtZSA6IGEuaG9zdG5hbWUsIC8vd3d3Lm15ZXhhbXBsZS5jb20nXG4gICAgICAgICAgICBwb3J0IDogYS5wb3J0LCAvLzo4MFxuICAgICAgICAgICAgcGF0aCA6IGEucGF0aG5hbWUsIC8vIC9zdWIxL3N1YjJcbiAgICAgICAgICAgIHF1ZXJ5IDogYS5zZWFyY2gsIC8vID9wYXJhbTE9dmFsMSZwYXJhbTI9dmFsMlxuICAgICAgICAgICAgcXVlcnlQYXJhbXMgOiBhLnNlYXJjaC5sZW5ndGggPiAxID8gdXRpbC5nZXRRdWVyeVN0cmluZ1BhcmFtcyhhLnNlYXJjaC5zdWJzdHIoMSkpIDoge30sXG4gICAgICAgICAgICBoYXNoIDogYS5oYXNoLCAvLyAjT1U4MTIsNTE1MFxuICAgICAgICAgICAgdXJsIDogYS5wcm90b2NvbCsgXCIvL1wiICsgYS5ob3N0ICsgYS5wYXRobmFtZSxcbiAgICAgICAgICAgIHVybFdpdGhRdWVyeSA6IGEucHJvdG9jb2wrIFwiLy9cIiArIGEuaG9zdCArIGEucG9ydCArIGEucGF0aG5hbWUgKyBhLnNlYXJjaCxcbiAgICAgICAgICAgIHBhZ2UgOiBwYXRoUGFydHMubGVuZ3RoID4gMCA/IHBhdGhQYXJ0c1twYXRoUGFydHMubGVuZ3RoLTFdIDogJycgLy8gc3ViMlxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gcmVtb3ZlIHRoZSBwYXJhbWV0ZXIgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBnaXZlbiB1cmwgYW5kIHJldHVybnMgdGhlIGNoYW5nZWQgdXJsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCB0aGUgdXJsIGZyb20gd2hpY2ggdGhlIHBhcmFtZXRlciB3aWxsIGJlIHJlbW92ZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiBwYXJhbWV0ZXIgdGhhdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB1cmxcbiAgICAgKi9cbiAgICByZW1vdmVQYXJhbUZyb21VUkw6IGZ1bmN0aW9uICh1cmwsIG5hbWUpIHtcbiAgICAgICAgaWYgKHVybC5pbmRleE9mKCc/JykgPT09IC0xIHx8IHVybC5pbmRleE9mKG5hbWUgKyAnPScpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFzaDtcbiAgICAgICAgdmFyIHBhcmFtcztcbiAgICAgICAgdmFyIGRvbWFpbiA9IHVybC5zcGxpdCgnPycpWzBdO1xuICAgICAgICB2YXIgcGFyYW1VcmwgPSB1cmwuc3BsaXQoJz8nKVsxXTtcbiAgICAgICAgdmFyIG5ld1BhcmFtcyA9IFtdO1xuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIGhhc2ggYXQgdGhlIGVuZCwgc3RvcmUgdGhlIGhhc2hcbiAgICAgICAgaWYgKHBhcmFtVXJsLmluZGV4T2YoJyMnKSA+IC0xKSB7XG4gICAgICAgICAgICBoYXNoID0gcGFyYW1Vcmwuc3BsaXQoJyMnKVsxXSB8fCAnJztcbiAgICAgICAgICAgIHBhcmFtVXJsID0gcGFyYW1Vcmwuc3BsaXQoJyMnKVswXTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMgPSBwYXJhbVVybC5zcGxpdCgnJicpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gcHV0IGJhY2sgcGFyYW0gdG8gbmV3UGFyYW1zIGFycmF5IGlmIGl0IGlzIG5vdCB0aGUgb25lIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgICAgIGlmIChwYXJhbXNbaV0uc3BsaXQoJz0nKVswXSAhPT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIG5ld1BhcmFtcy5wdXNoKHBhcmFtc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbWFpbiArICc/JyArIG5ld1BhcmFtcy5qb2luKCcmJykgKyAoaGFzaCA/ICcjJyArIGhhc2ggOiAnJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBhcHBlbmRzIHRoZSBwYXJhbWV0ZXJzIHRvIHRoZSBnaXZlbiB1cmwgYW5kIHJldHVybnMgdGhlIGNoYW5nZWQgdXJsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCB0aGUgdXJsIHRvIHdoaWNoIHRoZSBwYXJhbWV0ZXJzIHdpbGwgYmUgYWRkZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICovXG4gICAgYXBwZW5kUGFyYW1zVG9Vcmw6IGZ1bmN0aW9uICh1cmwsIHBhcmFtcykge1xuICAgICAgICB2YXIgX3VybCA9IHVybDtcbiAgICAgICAgXy5lYWNoKHBhcmFtcywgZnVuY3Rpb24gKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgICAgICBfdXJsID0gdGhpcy5hcHBlbmRQYXJhbVRvVVJMKF91cmwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIF91cmw7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gZXh0cmFjdCB0aGUgcXVlcnkgc3RyaW5nIGZyb20gVVJMXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCB0aGUgdXJsIHRvIGV4dHJhIHF1ZXJ5IHN0cmluZyBmcm9tXG4gICAgICoqL1xuICAgIGdldFF1ZXJ5U3RyaW5nOiBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHZhciBxcztcbiAgICAgICAgaWYgKCFfLmlzU3RyaW5nKHVybCkpIHsgcmV0dXJuOyB9XG4gICAgICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICBhLmhyZWYgPSB1cmw7XG4gICAgICAgIGlmIChhLnNlYXJjaCkge1xuICAgICAgICAgICAgcXMgPSBhLnNlYXJjaC5zdWJzdHIoMSk7IC8vIHJlbW92ZSB0aGUgbGVhZGluZyA/XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHFzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9XG4gICAgICogQHBhcmFtIHtTdHJpbmd9XG4gICAgICovXG4gICAgZWxlbWVudEluVmlld3BvcnQ6IGZ1bmN0aW9uIChlbCwgb2Zmc2V0VG9Ub3ApIHtcbiAgICAgICAgdmFyIHRvcCA9IGVsLm9mZnNldFRvcCxcbiAgICAgICAgICAgIGxlZnQgPSBlbC5vZmZzZXRMZWZ0LFxuICAgICAgICAgICAgd2lkdGggPSBlbC5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IGVsLm9mZnNldEhlaWdodDtcblxuICAgICAgICB3aGlsZSAoZWwub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICBlbCA9IGVsLm9mZnNldFBhcmVudDtcbiAgICAgICAgICAgIHRvcCArPSBlbC5vZmZzZXRUb3A7XG4gICAgICAgICAgICBsZWZ0ICs9IGVsLm9mZnNldExlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mKG9mZnNldFRvVG9wKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvcCAtPSBvZmZzZXRUb1RvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aW5kb3cucGFnZVhPZmZzZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgdG9wIDwgKHdpbmRvdy5wYWdlWU9mZnNldCArIHdpbmRvdy5pbm5lckhlaWdodCkgJiZcbiAgICAgICAgICAgICAgICBsZWZ0IDwgKHdpbmRvdy5wYWdlWE9mZnNldCArIHdpbmRvdy5pbm5lcldpZHRoKSAmJlxuICAgICAgICAgICAgICAgICh0b3AgKyBoZWlnaHQpID4gd2luZG93LnBhZ2VZT2Zmc2V0ICYmXG4gICAgICAgICAgICAgICAgKGxlZnQgKyB3aWR0aCkgPiB3aW5kb3cucGFnZVhPZmZzZXRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9jdW1lbnQuY29tcGF0TW9kZSA9PT0gJ0NTUzFDb21wYXQnKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHRvcCA8ICh3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCArIHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KSAmJlxuICAgICAgICAgICAgICAgIGxlZnQgPCAod2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0ICsgd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCkgJiZcbiAgICAgICAgICAgICAgICAodG9wICsgaGVpZ2h0KSA+IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wICYmXG4gICAgICAgICAgICAgICAgKGxlZnQgKyB3aWR0aCkgPiB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIEFwcGVuZHMgdGhlIHBhcmFtZXRlciAnZm9ybWF0PWFqYXgnIHRvIGEgZ2l2ZW4gcGF0aFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRoZSByZWxhdGl2ZSBwYXRoXG4gICAgICovXG4gICAgYWpheFVybDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZW5kUGFyYW1Ub1VSTChwYXRoLCAnZm9ybWF0JywgJ2FqYXgnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICAgICAqL1xuICAgIHRvQWJzb2x1dGVVcmw6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgaWYgKHVybC5pbmRleE9mKCdodHRwJykgIT09IDAgJiYgdXJsLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICAgICAgICB1cmwgPSAnLycgKyB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBMb2FkcyBjc3MgZHluYW1pY2FsbHkgZnJvbSBnaXZlbiB1cmxzXG4gICAgICogQHBhcmFtIHtBcnJheX0gdXJscyBBcnJheSBvZiB1cmxzIGZyb20gd2hpY2ggY3NzIHdpbGwgYmUgZHluYW1pY2FsbHkgbG9hZGVkLlxuICAgICAqL1xuICAgIGxvYWREeW5hbWljQ3NzOiBmdW5jdGlvbiAodXJscykge1xuICAgICAgICB2YXIgaSwgbGVuID0gdXJscy5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5sb2FkZWRDc3NGaWxlcy5wdXNoKHRoaXMubG9hZENzc0ZpbGUodXJsc1tpXSkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBMb2FkcyBjc3MgZmlsZSBkeW5hbWljYWxseSBmcm9tIGdpdmVuIHVybFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIHVybCBmcm9tIHdoaWNoIGNzcyBmaWxlIHdpbGwgYmUgZHluYW1pY2FsbHkgbG9hZGVkLlxuICAgICAqL1xuICAgIGxvYWRDc3NGaWxlOiBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHJldHVybiAkKCc8bGluay8+JykuYXBwZW5kVG8oJCgnaGVhZCcpKS5hdHRyKHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0L2NzcycsXG4gICAgICAgICAgICByZWw6ICdzdHlsZXNoZWV0J1xuICAgICAgICB9KS5hdHRyKCdocmVmJywgdXJsKTsgLy8gZm9yIGkuZS4gPDksIGhyZWYgbXVzdCBiZSBhZGRlZCBhZnRlciBsaW5rIGhhcyBiZWVuIGFwcGVuZGVkIHRvIGhlYWRcbiAgICB9LFxuICAgIC8vIGFycmF5IHRvIGtlZXAgdHJhY2sgb2YgdGhlIGR5bmFtaWNhbGx5IGxvYWRlZCBDU1MgZmlsZXNcbiAgICBsb2FkZWRDc3NGaWxlczogW10sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyBhbGwgY3NzIGZpbGVzIHdoaWNoIHdlcmUgZHluYW1pY2FsbHkgbG9hZGVkXG4gICAgICovXG4gICAgY2xlYXJEeW5hbWljQ3NzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5sb2FkZWRDc3NGaWxlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgwID4gaS0tKSB7XG4gICAgICAgICAgICAkKHRoaXMubG9hZGVkQ3NzRmlsZXNbaV0pLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZGVkQ3NzRmlsZXMgPSBbXTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBFeHRyYWN0cyBhbGwgcGFyYW1ldGVycyBmcm9tIGEgZ2l2ZW4gcXVlcnkgc3RyaW5nIGludG8gYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHFzIFRoZSBxdWVyeSBzdHJpbmcgZnJvbSB3aGljaCB0aGUgcGFyYW1ldGVycyB3aWxsIGJlIGV4dHJhY3RlZFxuICAgICAqL1xuICAgIGdldFF1ZXJ5U3RyaW5nUGFyYW1zOiBmdW5jdGlvbiAocXMpIHtcbiAgICAgICAgaWYgKCFxcyB8fCBxcy5sZW5ndGggPT09IDApIHsgcmV0dXJuIHt9OyB9XG4gICAgICAgIHZhciBwYXJhbXMgPSB7fSxcbiAgICAgICAgICAgIHVuZXNjYXBlZFFTID0gZGVjb2RlVVJJQ29tcG9uZW50KHFzKTtcbiAgICAgICAgLy8gVXNlIHRoZSBTdHJpbmc6OnJlcGxhY2UgbWV0aG9kIHRvIGl0ZXJhdGUgb3ZlciBlYWNoXG4gICAgICAgIC8vIG5hbWUtdmFsdWUgcGFpciBpbiB0aGUgc3RyaW5nLlxuICAgICAgICB1bmVzY2FwZWRRUy5yZXBsYWNlKG5ldyBSZWdFeHAoJyhbXj89Jl0rKSg9KFteJl0qKSk/JywgJ2cnKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgkMCwgJDEsICQyLCAkMykge1xuICAgICAgICAgICAgICAgIHBhcmFtc1skMV0gPSAkMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9LFxuXG4gICAgZmlsbEFkZHJlc3NGaWVsZHM6IGZ1bmN0aW9uIChhZGRyZXNzLCAkZm9ybSkge1xuICAgICAgICBmb3IgKHZhciBmaWVsZCBpbiBhZGRyZXNzKSB7XG4gICAgICAgICAgICBpZiAoZmllbGQgPT09ICdJRCcgfHwgZmllbGQgPT09ICdVVUlEJyB8fCBmaWVsZCA9PT0gJ2tleScpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHRoZSBrZXkgaW4gYWRkcmVzcyBvYmplY3QgZW5kcyB3aXRoICdDb2RlJywgcmVtb3ZlIHRoYXQgc3VmZml4XG4gICAgICAgICAgICAkZm9ybS5maW5kKCdbbmFtZSQ9XCInICsgZmllbGQucmVwbGFjZSgnQ29kZScsICcnKSArICdcIl0nKS52YWwoYWRkcmVzc1tmaWVsZF0pLmJsdXIoKTtcbiAgICAgICAgICAgIGlmIChmaWVsZCA9PT0gJ3Bvc3RhbENvZGUnKSB7XG4gICAgICAgICAgICAgICAgJGZvcm0uZmluZCgnaW5wdXQucG9zdGFsJykuYXR0cigndmFsdWUnLCBhZGRyZXNzW2ZpZWxkXSkuYmx1cigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBzdGF0ZSBmaWVsZHNcbiAgICAgICAgICAgIGlmIChmaWVsZCA9PT0gJ2NvdW50cnlDb2RlJykge1xuICAgICAgICAgICAgXHQkZm9ybS5maW5kKCdbbmFtZSQ9XCJjb3VudHJ5XCJdJykudmFsKGFkZHJlc3MuY291bnRyeUNvZGUudG9VcHBlckNhc2UoKSkuYmx1cigpO1xuICAgICAgICAgICAgICAgIC8vIHJldHJpZ2dlciBzdGF0ZSBzZWxlY3Rpb24gYWZ0ZXIgY291bnRyeSBoYXMgY2hhbmdlZFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgcmVzdWx0cyBpbiBkdXBsaWNhdGlvbiBvZiB0aGUgc3RhdGUgY29kZSwgYnV0IGlzIGEgbmVjZXNzYXJ5IGV2aWxcbiAgICAgICAgICAgICAgICAvLyBmb3Igbm93IGJlY2F1c2Ugc29tZXRpbWVzIGNvdW50cnlDb2RlIGNvbWVzIGFmdGVyIHN0YXRlQ29kZVxuICAgICAgICAgICAgICAgICRmb3JtLmZpbmQoJ1tuYW1lJD1cInN0YXRlXCJdJykudmFsKGFkZHJlc3Muc3RhdGVDb2RlKS5ibHVyKCk7XG4gICAgICAgICAgICAgICAgJGZvcm0uZmluZCgnW25hbWUkPVwiemlwXCJdJykudmFsKGFkZHJlc3MucG9zdGFsQ29kZSkuYmx1cigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHV0aWwuc2VsZWN0VW5mbG9hdCgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIFVwZGF0ZXMgdGhlIG51bWJlciBvZiB0aGUgcmVtYWluaW5nIGNoYXJhY3RlclxuICAgICAqIGJhc2VkIG9uIHRoZSBjaGFyYWN0ZXIgbGltaXQgaW4gYSB0ZXh0IGFyZWFcbiAgICAgKi9cbiAgICBsaW1pdENoYXJhY3RlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJCgnZm9ybScpLmZpbmQoJ3RleHRhcmVhW2RhdGEtY2hhcmFjdGVyLWxpbWl0XScpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNoYXJhY3RlckxpbWl0ID0gJCh0aGlzKS5kYXRhKCdjaGFyYWN0ZXItbGltaXQnKTtcbiAgICAgICAgICAgIHZhciBjaGFyQ291bnRIdG1sID0gU3RyaW5nLmZvcm1hdChSZXNvdXJjZXMuQ0hBUl9MSU1JVF9NU0csXG4gICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiY2hhci1yZW1haW4tY291bnRcIj4nICsgY2hhcmFjdGVyTGltaXQgKyAnPC9zcGFuPicsXG4gICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiY2hhci1hbGxvd2VkLWNvdW50XCI+JyArIGNoYXJhY3RlckxpbWl0ICsgJzwvc3Bhbj4nKTtcbiAgICAgICAgICAgIHZhciBjaGFyQ291bnRDb250YWluZXIgPSAkKHRoaXMpLm5leHQoJ2Rpdi5jaGFyLWNvdW50Jyk7XG4gICAgICAgICAgICBpZiAoY2hhckNvdW50Q29udGFpbmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNoYXJDb3VudENvbnRhaW5lciA9ICQoJzxkaXYgY2xhc3M9XCJjaGFyLWNvdW50XCIvPicpLmluc2VydEFmdGVyKCQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhckNvdW50Q29udGFpbmVyLmh0bWwoY2hhckNvdW50SHRtbCk7XG4gICAgICAgICAgICAvLyB0cmlnZ2VyIHRoZSBrZXlkb3duIGV2ZW50IHNvIHRoYXQgYW55IGV4aXN0aW5nIGNoYXJhY3RlciBkYXRhIGlzIGNhbGN1bGF0ZWRcbiAgICAgICAgICAgICQodGhpcykuY2hhbmdlKCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIEJpbmRzIHRoZSBvbmNsaWNrLWV2ZW50IHRvIGEgZGVsZXRlIGJ1dHRvbiBvbiBhIGdpdmVuIGNvbnRhaW5lcixcbiAgICAgKiB3aGljaCBvcGVucyBhIGNvbmZpcm1hdGlvbiBib3ggd2l0aCBhIGdpdmVuIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29udGFpbmVyIFRoZSBuYW1lIG9mIGVsZW1lbnQgdG8gd2hpY2ggdGhlIGZ1bmN0aW9uIHdpbGwgYmUgYmluZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRoZSB3aWxsIGJlIHNob3duIHVwb24gYSBjbGlja1xuICAgICAqL1xuICAgIHNldERlbGV0ZUNvbmZpcm1hdGlvbjogZnVuY3Rpb24gKGNvbnRhaW5lciwgbWVzc2FnZSkge1xuICAgICAgICAkKGNvbnRhaW5lcikub24oJ2NsaWNrJywgJy5kZWxldGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LmNvbmZpcm0obWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIFNjcm9sbHMgYSBicm93c2VyIHdpbmRvdyB0byBhIGdpdmVuIHggcG9pbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gVGhlIHggY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIHNjcm9sbEJyb3dzZXI6IGZ1bmN0aW9uICh4TG9jYXRpb24pIHtcbiAgICAgICAgJCgnaHRtbCwgYm9keScpLmFuaW1hdGUoe3Njcm9sbFRvcDogeExvY2F0aW9ufSwgNTAwKTtcbiAgICB9LFxuXG4gICAgaXNNb2JpbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1vYmlsZUFnZW50SGFzaCA9IFsnbW9iaWxlJywgJ3RhYmxldCcsICdwaG9uZScsICdpcGFkJywgJ2lwb2QnLCAnYW5kcm9pZCcsICdibGFja2JlcnJ5JywgJ3dpbmRvd3MgY2UnLCAnb3BlcmEgbWluaScsICdwYWxtJ107XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB2YXIgaXNNb2JpbGUgPSBmYWxzZTtcbiAgICAgICAgdmFyIHVzZXJBZ2VudCA9IChuYXZpZ2F0b3IudXNlckFnZW50KS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIHdoaWxlIChtb2JpbGVBZ2VudEhhc2hbaWR4XSAmJiAhaXNNb2JpbGUpIHtcbiAgICAgICAgICAgIGlzTW9iaWxlID0gKHVzZXJBZ2VudC5pbmRleE9mKG1vYmlsZUFnZW50SGFzaFtpZHhdKSA+PSAwKTtcbiAgICAgICAgICAgIGlkeCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc01vYmlsZTtcbiAgICB9LFxuICAgIFxuICAgIGlzVG91Y2hTdXBwb3J0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgfHwgKG5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzID4gMCk7XG4gICAgfSxcbiAgICBcbiAgICBnZXRWaWV3cG9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdyA9IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMCk7XG4gICAgICAgIHJldHVybiB3O1xuICAgIH0sXG5cbiAgICBjaGFuZ2VTdGF0ZUZpZWxkIDogZnVuY3Rpb24oY291bnRyeSwgZm9ybSwgc3RhdGVFbXB0eU9wdGlvbkh0bWwpIHtcbiAgICAgICAgdmFyIHN0YXRlRWxlbWVudHMgPSB7XG4gICAgICAgICAgICBjb250YWluZXI6IGZvcm0uZmluZCgnLnN0YXRlLWZpZWxkLWNvbnRhaW5lcicpXG4gICAgICAgIH07XG4gICAgICAgIHN0YXRlRWxlbWVudHMubGFiZWwgPSBzdGF0ZUVsZW1lbnRzLmNvbnRhaW5lci5maW5kKCdsYWJlbCAudGV4dC1pbnB1dC1sYWJlbCcpO1xuICAgICAgICBzdGF0ZUVsZW1lbnRzLmlucHV0ID0gc3RhdGVFbGVtZW50cy5jb250YWluZXIuZmluZCgnc2VsZWN0Jyk7XG5cbiAgICAgICAgdmFyIHN0YXRlSW50bEVsZW1lbnRzID0ge1xuICAgICAgICAgICAgY29udGFpbmVyOiBmb3JtLmZpbmQoJy5zdGF0ZS1maWVsZC1pbnRsLWNvbnRhaW5lcicpXG4gICAgICAgIH07XG4gICAgICAgIHN0YXRlSW50bEVsZW1lbnRzLmxhYmVsID0gc3RhdGVJbnRsRWxlbWVudHMuY29udGFpbmVyLmZpbmQoJ2xhYmVsIC50ZXh0LWlucHV0LWxhYmVsJyk7XG4gICAgICAgIHN0YXRlSW50bEVsZW1lbnRzLmlucHV0ID0gc3RhdGVJbnRsRWxlbWVudHMuY29udGFpbmVyLmZpbmQoJ2lucHV0Jyk7XG5cbiAgICAgICAgdmFyIGZpZWxkSWRCYWsgPSAnc3RhdGUtaWQtYmFrJztcbiAgICAgICAgdmFyIGZpZWxkSWQgPSBmb3JtLmZpbmQoXCJpbnB1dFtuYW1lJD0nX3N0YXRlJ10sIHNlbGVjdFtuYW1lJD0nX3N0YXRlJ11cIikuYXR0cignaWQnKTtcbiAgICAgICAgdmFyIHppcFJvdyA9IGZvcm0uZmluZCgnLmZvcm0tcm93LnppcC1yb3cnKTtcbiAgICAgICAgdmFyIHppcExhYmVsID0gemlwUm93LmZpbmQoJy50ZXh0LWlucHV0LWxhYmVsJyk7XG4gICAgICAgIHZhciB6aXBJbnB1dCA9IHppcFJvdy5maW5kKCdpbnB1dCcpO1xuICAgICAgICB2YXIgY291bnRyaWVzID0gd2luZG93LkNvdW50cmllcyB8fCB3aW5kb3cuY291bnRyaWVzO1xuICAgICAgICB2YXIgY291bnRyeUNvbmZpZyA9IGNvdW50cmllc1tjb3VudHJ5XTtcblxuICAgICAgICBpZiAoY291bnRyeSA9PT0gJycgfHwgY291bnRyeSA9PT0gJ1VTJyB8fCBjb3VudHJ5ID09PSAnQ0EnKSB7XG4gICAgICAgICAgICBzaG93U3RhdGVFbGVtZW50cyhzdGF0ZUVsZW1lbnRzLCB0cnVlKTtcbiAgICAgICAgICAgIGhpZGVTdGF0ZUVsZW1lbnRzKHN0YXRlSW50bEVsZW1lbnRzKTtcbiAgICAgICAgICAgIHV0aWwudG9nZ2xlUGhvbmVNYXNrKGZvcm0sIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlkZVN0YXRlRWxlbWVudHMoc3RhdGVFbGVtZW50cyk7XG4gICAgICAgICAgICBzaG93U3RhdGVFbGVtZW50cyhzdGF0ZUludGxFbGVtZW50cywgZmFsc2UpO1xuICAgICAgICAgICAgdXRpbC50b2dnbGVQaG9uZU1hc2soZm9ybSwgZmFsc2UpO1xuICAgICAgICAgICAgLyokKCcjZHdmcm1fc2luZ2xlc2hpcHBpbmdfc2hpcHBpbmdBZGRyZXNzX2FkZHJlc3NGaWVsZHNfc3RhdGVzX3N0YXRlJykucGFyZW50KCkuY3NzKFwiZGlzcGxheVwiLFwibm9uZVwiKTtcbiAgICBcdFx0JCgnI2R3ZnJtX3NpbmdsZXNoaXBwaW5nX3NoaXBwaW5nQWRkcmVzc19hZGRyZXNzRmllbGRzX3N0YXRlc19zdGF0ZSBvcHRpb25bdmFsdWU9XCJPVEhFUlwiXScpLnByb3AoJ3NlbGVjdGVkJywgdHJ1ZSk7XG4gICAgXHRcdFxuICAgIFx0XHQkKCcjZHdmcm1fYmlsbGluZ19iaWxsaW5nQWRkcmVzc19hZGRyZXNzRmllbGRzX3N0YXRlc19zdGF0ZScpLnBhcmVudCgpLmNzcyhcImRpc3BsYXlcIixcIm5vbmVcIik7XG4gICAgIFx0XHQkKCcjZHdmcm1fYmlsbGluZ19iaWxsaW5nQWRkcmVzc19hZGRyZXNzRmllbGRzX3N0YXRlc19zdGF0ZSBvcHRpb25bdmFsdWU9XCJPVEhFUlwiXScpLnByb3AoJ3NlbGVjdGVkJywgdHJ1ZSk7Ki9cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb3VudHJ5Q29uZmlnICYmIGNvdW50cnlDb25maWcuemlwbGFiZWwpIHtcbiAgICAgICAgICAgIHppcExhYmVsLmh0bWwoY291bnRyeUNvbmZpZy56aXBsYWJlbCk7XG4gICAgICAgICAgICB6aXBJbnB1dC5hdHRyKCdwbGFjZWhvbGRlcicsIGNvdW50cnlDb25maWcuemlwbGFiZWwpXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzaG93U3RhdGVFbGVtZW50cyhzdGF0ZUVsZW1lbnRzLCByZXF1aXJlZCkge1xuICAgICAgICAgICAgdmFyIHN0YXRlVmFsID0gc3RhdGVFbGVtZW50cy5pbnB1dC52YWwoKTtcblxuICAgICAgICAgICAgc3RhdGVFbGVtZW50cy5jb250YWluZXIucmVtb3ZlQ2xhc3MoJ3Zpc3VhbGx5LWhpZGRlbicpXG4gICAgICAgICAgICAgICAgLmNzcyh7IGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snIH0pO1xuICAgICAgICAgICAgc3RhdGVFbGVtZW50cy5pbnB1dC5hdHRyKHtcbiAgICAgICAgICAgICAgICBpZDogZmllbGRJZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBmaWVsZElkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0YXRlRWxlbWVudHMubGFiZWwuYXR0cignZm9yJywgZmllbGRJZCk7XG5cbiAgICAgICAgICAgIGlmIChyZXF1aXJlZCkge1xuICAgICAgICAgICAgICAgIHN0YXRlRWxlbWVudHMuaW5wdXQuYWRkQ2xhc3MoJ3JlcXVpcmVkJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlRWxlbWVudHMuaW5wdXQucmVtb3ZlQ2xhc3MoJ3JlcXVpcmVkJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb3VudHJ5Q29uZmlnKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVFbGVtZW50cy5sYWJlbC5odG1sKGNvdW50cnlDb25maWcucmVnaW9uTGFiZWwgfHwgY291bnRyeUNvbmZpZy5sYWJlbCk7XG4gICAgICAgICAgICAgICAgc3RhdGVFbGVtZW50cy5pbnB1dC5hdHRyKCdwbGFjZWhvbGRlcicsIGNvdW50cnlDb25maWcucmVnaW9uTGFiZWwgfHwgY291bnRyeUNvbmZpZy5sYWJlbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIV8uaXNFbXB0eShjb3VudHJ5Q29uZmlnLnJlZ2lvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWdpb25PcHRpb25zSHRtbCA9IHN0YXRlRW1wdHlPcHRpb25IdG1sO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByZWdpb24gaW4gY291bnRyeUNvbmZpZy5yZWdpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVnaW9uTGFiZWwgPSBjb3VudHJ5Q29uZmlnLnJlZ2lvbnNbcmVnaW9uXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbk9wdGlvbnNIdG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiJyArIHJlZ2lvbiArICdcIiBjbGFzcz1cInNlbGVjdC1vcHRpb25cIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgbGFiZWw9XCInICsgcmVnaW9uTGFiZWwgKyAnXCI+JyArIHJlZ2lvbkxhYmVsICsgJzwvb3B0aW9uPic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdGVFbGVtZW50cy5pbnB1dC5odG1sKHJlZ2lvbk9wdGlvbnNIdG1sKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlVmFsICYmIHN0YXRlRWxlbWVudHMuaW5wdXQuZmluZCgnb3B0aW9uW3ZhbHVlPScgKyBzdGF0ZVZhbCArICddJykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVFbGVtZW50cy5pbnB1dC52YWwoc3RhdGVWYWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGVFbGVtZW50cy5pbnB1dC5yZW1vdmVDbGFzcygnZXJyb3IgdmFsaWQnKS5uZXh0KCdzcGFuLmVycm9yJykucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBoaWRlU3RhdGVFbGVtZW50cyhzdGF0ZUVsZW1lbnRzKSB7XG4gICAgICAgICAgICBzdGF0ZUVsZW1lbnRzLmNvbnRhaW5lci5hZGRDbGFzcygndmlzdWFsbHktaGlkZGVuJylcbiAgICAgICAgICAgICAgICAuY3NzKHsgZGlzcGxheTogJ25vbmUnIH0pO1xuICAgICAgICAgICAgc3RhdGVFbGVtZW50cy5sYWJlbC5hdHRyKCdmb3InLCBmaWVsZElkQmFrKTtcbiAgICAgICAgICAgIHN0YXRlRWxlbWVudHMuaW5wdXQucmVtb3ZlQ2xhc3MoJ3JlcXVpcmVkJylcbiAgICAgICAgICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBmaWVsZElkQmFrLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBmaWVsZElkQmFrXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3RVbmZsb2F0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgYSBmb3JtYXQgZm9yIHRoZSBwaG9uZSBudW1iZXIgd2hlbiBydW5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gXHRvYmogXHRmb3JtXG4gICAgICogQHBhcmFtIFx0Ym9vbCBcdG1hc2tcbiAgICAgKiBAdmFyIFx0b2JqIFx0cGhvbmVcbiAgICAgKiBAcmV0dXJuIFx0Vk9JRFxuICAgICAqL1xuICAgIHRvZ2dsZVBob25lTWFzayA6IGZ1bmN0aW9uIChmb3JtLCBtYXNrKSB7XG4gICAgICAgIHZhciBwaG9uZSA9IGZvcm0uZmluZCgnaW5wdXQucGhvbmUnKTtcbiAgICAgICAgaWYgKHBob25lLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYobWFzaykge1xuICAgICAgICAgICAgICAgIHBob25lLm1hc2soXCIoMDAwKSAwMDAtMDAwMFwiLCB7IHdhdGNoSW5wdXRzOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGhvbmUudW5tYXNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuIFxuICAgIGluaXRaaXBTZXJ2aWNlIDogZnVuY3Rpb24gKGZvcm0pIHtcbiAgICAgICAgLy8gUHJlcG9wdWxhdGUgY2l0eSBmb3IgY2hlY2tvdXQgcmVkZXNpZ25cbiAgICAgICAgaWYgKGZvcm0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGNvdW50cnkgPSBmb3JtLmZpbmQoXCJzZWxlY3RbbmFtZSQ9J19jb3VudHJ5J11cIik7XG4gICAgICAgICAgICB2YXIgcG9zdGFsQ29kZSA9IGZvcm0uZmluZChcImlucHV0W25hbWUkPSdfemlwJ10sIGlucHV0W25hbWUkPSdfcG9zdGFsJ11cIik7XG4gICAgICAgICAgICB2YXIgY2l0eSA9IGZvcm0uZmluZChcImlucHV0W25hbWUkPSdfY2l0eSddXCIpO1xuICAgICAgICAgICAgdmFyIHN0YXRlQ29kZSA9IGZvcm0uZmluZChcInNlbGVjdFtpZCQ9J19zdGF0ZSddXCIpO1xuXG4gICAgICAgICAgICBwb3N0YWxDb2RlLm9uKCdibHVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50cnkubGVuZ3RoID4gMCAmJiAoY291bnRyeS52YWwoKSA9PT0gJ1VTJyB8fCBjb3VudHJ5LnZhbCgpID09PSAnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHppcCA9ICQodGhpcykudmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgcHJlcG9wdWxhdGUgaWYgaGF2ZSBhIGZ1bGwgemlwXG4gICAgICAgICAgICAgICAgICAgIGlmICh6aXAubGVuZ3RoID49IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBVcmxzLmdldENpdHlTdGF0ZUZyb21aaXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd6aXAnOiB6aXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5kb25lKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5jaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaXR5LnZhbChjYXBpdGFsaXplV29yZHMoZGF0YS5jaXR5KSkuYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2l0eS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb2RlLnZhbChkYXRhLnN0YXRlKS5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvZGUudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIFN1Ym1pdCBhIGZvcm0gdmlhIGFqYXggKG9ubHkgaWYgaXQgaXMgdmFsaWQpIGFuZCBhbGxvdyBmb3IgYSBjYWxsIGJhY2tcbiAgICBmb3Jtc3VibWl0IDogZnVuY3Rpb24oZm9ybSwgYnRuLCB0eXBlLCBjYWxsYmFjayl7XG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiBmb3JtIGlzIHZhbGlkXG4gICAgICAgIGlmICghZm9ybS52YWxpZCgpKSByZXR1cm47XG4gICAgICAgIC8vIElmIHZhbGlkLCBzZW5kIHRoZSBmb3JtIHZpYSBhamF4XG4gICAgICAgIC8vIERhdGEgdG8gc2VuZCB0byB0aGUganF1ZXJ5IGNhbGxcbiAgICAgICAgdmFyIHVybCA9IGFwcC51dGlsLmFwcGVuZFBhcmFtVG9VUkwoZm9ybS5hdHRyKCdhY3Rpb24nKSwgXCJmb3JtYXRcIiwgXCJhamF4XCIpO1xuICAgICAgICAvLyBDb2xsZWN0IHRoZSByZXF1aXJlZCBmb3JtIGZpZWxkc1xuICAgICAgICB2YXIgZGF0YSA9IGZvcm0uc2VyaWFsaXplKCk7XG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgd2hhdCB0eXBlIG9mIGNhbGwgdGhpcyBpcyAoZnJvbSB0aGUgYnV0dG9uKVxuICAgICAgICBkYXRhICs9IFwiJlwiICsgYnRuLmF0dHIoXCJuYW1lXCIpICsgXCI9XCIgKyBidG4uYXR0cihcInZhbHVlXCIpO1xuICAgICAgICAvLyBtYWtlIHRoZSBzZXJ2ZXIgY2FsbFxuICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgdXJsIDogdXJsLFxuICAgICAgICAgICAgZGF0YSA6IGRhdGEsXG4gICAgICAgICAgICB0eXBlOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGRhdGFUeXBlOiB0eXBlIHx8IFwiaHRtbFwiXG4gICAgICAgIH0pXG4gICAgICAgIC5kb25lKGZ1bmN0aW9uKGUsIHRleHRTdGF0dXMpe1xuICAgICAgICAgICAgaWYoIWNhbGxiYWNrKSByZXR1cm47XG4gICAgICAgICAgICBjYWxsYmFjayhlLCB0ZXh0U3RhdHVzKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmZhaWwoZnVuY3Rpb24gKGUsIHRleHRTdGF0dXMpIHtcbiAgICAgICAgICAgIGlmKHRleHRTdGF0dXMgPT09IFwicGFyc2VyZXJyb3JcIikge1xuICAgICAgICAgICAgICAgIGFsZXJ0KHRleHRTdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgc2VsZWN0VW5mbG9hdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJCgnLnB0X2NoZWNrb3V0IHNlbGVjdCcpLmVhY2goZnVuY3Rpb24gKGksIGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCQoZWwpLnZhbCgpICYmICQoZWwpLnZhbCgpLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgJChlbCkucGFyZW50KCkuYWRkQ2xhc3MoJ3VuZmxvYXQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwxMDApO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHRoZSB1c2VyIGhhcyBzdG9wcGVkIHJlc2l6aW5nIHRoZSBzY3JlZW4uXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIHtGdW5jdGlvbn0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGV4ZWN1dGUuXG4gICAgICovXG4gICAgc21hcnRSZXNpemU6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgdGltZW91dDtcblxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICB9LFxufTtcblxuZnVuY3Rpb24gY2FwaXRhbGl6ZVdvcmRzKHN0cikge1xuICAgIHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFxcYikoW2EtekEtWl0pL2csXG4gICAgICAgIGZ1bmN0aW9uKGZpcnN0TGV0dGVyKXtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdExldHRlci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1dGlsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbmFQaG9uZSA9IC9eXFwoPyhbMi05XVswLThdWzAtOV0pXFwpP1tcXC1cXC4gXT8oWzItOV1bMC05XXsyfSlcXC0oWzAtOV17NH0pKFxccyp4WzAtOV0rKT8kLztcbnZhciByZWdleCA9IHtcbiAgICBwaG9uZToge1xuICAgICAgICB1czogbmFQaG9uZSxcbiAgICAgICAgY2E6IG5hUGhvbmUsXG4gICAgICAgIGZyOiAvXjBbMS02XXsxfSgoWzAtOV17Mn0pezR9KXwoKFxcc1swLTldezJ9KXs0fSl8KCgtWzAtOV17Mn0pezR9KSQvLFxuICAgICAgICBpdDogL14oKFswLTldezIsNH0pKFstXFxzXFwvXXswLDF9KShbMC05XXs0LDh9KSk/JC8sXG4gICAgICAgIGpwOiAvXigwXFxkezEsNH0tID8pP1xcZHsxLDR9LVxcZHs0fSQvLFxuICAgICAgICBjbjogLy4qLyxcbiAgICAgICAgZ2I6IC9eKChcXCg/MFxcZHs0fVxcKT9cXHM/XFxkezN9XFxzP1xcZHszfSl8KFxcKD8wXFxkezN9XFwpP1xccz9cXGR7M31cXHM/XFxkezR9KXwoXFwoPzBcXGR7Mn1cXCk/XFxzP1xcZHs0fVxccz9cXGR7NH0pKShcXHM/XFwjKFxcZHs0fXxcXGR7M30pKT8kLyxcbiAgICAgICAgZXh0ZW5zaW9uOiAvKFxccyp4WzAtOV0rKS9cbiAgICB9LFxuICAgIGVtYWlsIDogL15bXFx3ListXStAW1xcdy4tXStcXC5bXFx3XXsyLDZ9JC8sXG4gICAgcG9zdGFsOiB7XG4gICAgICAgIHVzOiAvXig/ITB7M30pWzAtOV17NX0oLT9cXGR7NH0pPyQvLFxuICAgICAgICBjYTogL15bQUJDRUdISktMTU5QUlNUVlhZXXsxfVxcZHsxfVtBLVpdezF9ICpcXGR7MX1bQS1aXXsxfVxcZHsxfSQvaSxcbiAgICAgICAgLyogXG4gICAgICAgIFx0Q09NTUVOVElORyBPVVQgVEhFIENPVU5UUklFUyBCRUxPVyBTSU5DRSBUSEVTRSBSRUdVTEFSIEVYUFJFU1NJT05TIFxuICAgICAgICBcdEFSRSBDVVJSRU5UTFkgTk9UIEJFSU5HIFVTRUQuXG4gICAgICAgIGZyOiAvXihGLSk/KCgyW0F8Ql0pfFswLTldezJ9KVswLTldezN9JC8sXG4gICAgICAgIGl0OiAvXihbMC05XSl7NX0kLyxcbiAgICAgICAganA6IC9eKFswLTldKXszfVstXShbMC05XSl7NH0kLyxcbiAgICAgICAgY246IC9eKFswLTldKXs2fSQvLFxuICAgICAgICAqL1xuICAgICAgICBnYjogL14oW0EtUFItVVdZWjAtOV1bQS1ISy1ZMC05XVtBRUhNTlBSVFZYWTAtOV0/W0FCRUhNTlBSVldYWTAtOV0/IHsxLDJ9WzAtOV1bQUJELUhKTE4tVVctWl17Mn18R0lSIDBBQSkkL1xuICAgIH0sXG4gICAgbm90Q0M6IC9eKD8hKChbMC05IC1dKXsxMywxOX0pKS4qJC8sXG4gICAgY2hhcl9yYW5nZSA6IC9eW1xcdTAwMjAtXFx1MDA3RVxcdTAwQkYtXFx1MDBGRl0qJC8sXG4gICAganVzdF9kaWdpdHM6IC9bXlxcZF0vZ1xufTtcbi8vIGdsb2JhbCBmb3JtIHZhbGlkYXRvciBzZXR0aW5nc1xudmFyIHNldHRpbmdzID0ge1xuICAgIGVycm9yQ2xhc3M6ICdlcnJvcicsXG4gICAgZXJyb3JFbGVtZW50OiAnc3BhbicsXG4gICAgb25rZXl1cDogZmFsc2UsXG4gICAgb25mb2N1c291dDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrYWJsZShlbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGZvcm1hdHRlciA9IHtcblx0XHRwaG9uZTogZm9ybWF0UGhvbmVcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAZGVzY3JpcHRpb24gVmFsaWRhdGVzIGEgZ2l2ZW4gcGhvbmUgbnVtYmVyIGFnYWluc3QgdGhlIGNvdW50cmllcyBwaG9uZSByZWdleFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSBwaG9uZSBudW1iZXIgd2hpY2ggd2lsbCBiZSB2YWxpZGF0ZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbCBUaGUgaW5wdXQgZmllbGRcbiAqL1xudmFyIHZhbGlkYXRlUGhvbmUgPSBmdW5jdGlvbiAodmFsdWUsIGVsKSB7XG4gICAgdmFyIGNvdW50cnkgPSAkKGVsKS5jbG9zZXN0KCdmb3JtJykuZmluZCgnLmNvdW50cnknKTtcblx0aWYgKGNvdW50cnkudmFsKCkgPT0gJ1VTJyB8fCBjb3VudHJ5LnZhbCgpID09ICdDQScpIHtcblx0ICAgIGlmIChjb3VudHJ5Lmxlbmd0aCA9PT0gMCB8fCBjb3VudHJ5LnZhbCgpLmxlbmd0aCA9PT0gMCB8fCAhcmVnZXgucGhvbmVbY291bnRyeS52YWwoKS50b0xvd2VyQ2FzZSgpXSkge1xuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHRcblx0ICAgIHZhciByZ3ggPSByZWdleC5waG9uZVtjb3VudHJ5LnZhbCgpLnRvTG93ZXJDYXNlKCldO1xuXHQgICAgdmFyIGlzT3B0aW9uYWwgPSB0aGlzLm9wdGlvbmFsKGVsKTtcblx0ICAgIHZhciBpc1ZhbGlkID0gcmd4LnRlc3QoJC50cmltKHZhbHVlKSk7XG5cdH1cblx0ZWxzZSB7XG4gICAgICAgIHZhciBpc09wdGlvbmFsID0gdHJ1ZTtcblx0fVxuXHQgICAgXG4gICAgcmV0dXJuIGlzT3B0aW9uYWwgfHwgaXNWYWxpZDtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAZGVzY3JpcHRpb24gRm9ybWF0cyBhIHBob25lIG51bWJlciB0byBhIG1hdGNoIGEgdmFsaWQgcmVnZXhcbiAqIEBwYXJhbSB7T2JqZWN0fSBUaGUgSlF1ZXJ5IG9iamVjdCBob2xkaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBwaG9uZSBudW1iZXIgaW5wdXQgZmllbGQgdG8gYmUgZm9ybWF0dGVkLlxuICovXG5mdW5jdGlvbiBmb3JtYXRQaG9uZSAoZSwgc2VsZlRyaWdnZXJlZCkge1xuXHRpZiAoc2VsZlRyaWdnZXJlZCkge1xuXHRcdHJldHVybiBmYWxzZTsgLy8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuXHR9XG4gXHR2YXIgJHBob25lID0gJCh0aGlzKSxcblx0bnVtYmVyID0gJHBob25lLnZhbCgpLnRvTG93ZXJDYXNlKCksXG5cdGRpZ2l0cyA9IG51bWJlci5yZXBsYWNlKHJlZ2V4Lmp1c3RfZGlnaXRzLCBcIlwiKSxcblx0Y291bnRyeSA9ICRwaG9uZS5jbG9zZXN0KCdmb3JtJykuZmluZCgnLmNvdW50cnknKTtcblxuXHQvLyBObyBmb3JtYXR0aW5nIGZvciBub24gVVMgb3IgQ0EgcGhvbmUgbnVtYmVyc1xuXHRpZiAoY291bnRyeS52YWwoKSAhPSAnVVMnICYmIGNvdW50cnkudmFsKCkgIT0gJ0NBJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG4gICAgaWYoKG51bWJlci5sZW5ndGggPiAwKSAmJiAobnVtYmVyLmluZGV4T2YoJy0nKSA9PSAtMSkpIHtcbiAgICAgICAgdmFyIGZvcm1hdHRlZE51bWJlciA9ICcoJztcbiAgICAgICAgZm9ybWF0dGVkTnVtYmVyICs9IGRpZ2l0cy5zdWJzdHIoMCwzKTtcbiAgICAgICAgZm9ybWF0dGVkTnVtYmVyICs9ICcpICc7XG4gICAgICAgIGZvcm1hdHRlZE51bWJlciArPSBkaWdpdHMuc3Vic3RyKDMsMyk7XG4gICAgICAgIGZvcm1hdHRlZE51bWJlciArPSAnLSc7XG4gICAgICAgIGZvcm1hdHRlZE51bWJlciArPSBkaWdpdHMuc3Vic3RyKDYsNCk7XG4gICAgICAgIG51bWJlciA9IGZvcm1hdHRlZE51bWJlcjtcbiAgICAgICAgJHBob25lLnZhbChmb3JtYXR0ZWROdW1iZXIpO1xuICAgIH1cblxuICAgICRwaG9uZS5tYXNrKFwiKDAwMCkgMDAwLTAwMDBcIik7XG5cblx0aWYgKG51bWJlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICRwaG9uZS5wYXJlbnQoKS5hZGRDbGFzcygnZm9jdXNlZCcpO1xuICAgIH1cblxuICAgIGlmIChjb3VudHJ5Lmxlbmd0aCA9PT0gMCB8fCBjb3VudHJ5LnZhbCgpLmxlbmd0aCA9PT0gMCB8fCAhcmVnZXgucGhvbmVbY291bnRyeS52YWwoKS50b0xvd2VyQ2FzZSgpXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcmd4ID0gcmVnZXgucGhvbmVbY291bnRyeS52YWwoKS50b0xvd2VyQ2FzZSgpXTtcbiAgICB2YXIgaXNWYWxpZCA9IHJneC50ZXN0KCQudHJpbShudW1iZXIpKTtcblxuICAgIGlmIChpc1ZhbGlkID09IGZhbHNlKSB7XG4gICAgICAgICRwaG9uZS5wYXJlbnQoKS5yZW1vdmVDbGFzcygnZm9jdXNlZCcpO1xuICAgIH1cblx0JHBob25lLnRyaWdnZXIoJ2NoYW5nZScsIFt0cnVlXSk7IC8vIHZhbGlkYXRvciBmdW5jdGlvbiBtdXN0IHJ1biBhZnRlciB0aGUgdmFsdWUgY2hhbmdlc1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uIFZhbGlkYXRlcyBhIGdpdmVuIGVtYWlsIGFkZHJlc3MuXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIHBob25lIG51bWJlciB3aGljaCB3aWxsIGJlIHZhbGlkYXRlZFxuICogQHBhcmFtIHtTdHJpbmd9IGVsIFRoZSBpbnB1dCBmaWVsZFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUVtYWlsKHZhbHVlLCBlbCkge1xuXHR2YXIgaXNPcHRpb25hbCA9IHRoaXMub3B0aW9uYWwoZWwpO1xuXHR2YXIgaXNWYWxpZCA9IHJlZ2V4LmVtYWlsLnRlc3QoJC50cmltKHZhbHVlKSk7XG5cdHJldHVybiBpc09wdGlvbmFsIHx8IGlzVmFsaWQ7IFxufSBcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvbiBWYWxpZGF0ZXMgYSBnaXZlbiBwb3N0YWwgY29kZSBhZ2FpbnN0IHRoZSBhbGwgY291bnRyaWVzIHBvc3RhbCByZWd1bGFyIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIHBvc3RhbCBjb2RlIHdoaWNoIHdpbGwgYmUgdmFsaWRhdGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gZWwgVGhlIGlucHV0IGZpZWxkXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQWxsUG9zdGFsKHZhbHVlLCBlbCkge1xuICAgIHZhciBpc1ZhbGlkID0gZmFsc2U7XG4gICAgdmFyIGlzT3B0aW9uYWwgPSB0aGlzLm9wdGlvbmFsKGVsKTtcblxuICAgIGZvcih2YXIgY291bnRyeSBpbiByZWdleC5wb3N0YWwpIHtcbiAgICAgICAgaWYocmVnZXgucG9zdGFsW2NvdW50cnldLnRlc3QoJC50cmltKHZhbHVlKSkgPT0gdHJ1ZSl7XG4gICAgICAgIFx0aXNWYWxpZCA9IHRydWU7XG4gICAgICAgIFx0cmV0dXJuIGlzT3B0aW9uYWwgfHwgaXNWYWxpZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXNPcHRpb25hbCB8fCBpc1ZhbGlkO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uIFZhbGlkYXRlcyBhIGdpdmVuIHBvc3RhbCBjb2RlIGFnYWluc3QgdGhlIGNvdW50cnkncyBwb3N0YWwgcmVndWxhciBleHByZXNzaW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSBwb3N0YWwgY29kZSB3aGljaCB3aWxsIGJlIHZhbGlkYXRlZFxuICogQHBhcmFtIHtTdHJpbmd9IGVsIFRoZSBpbnB1dCBmaWVsZFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVBvc3RhbCh2YWx1ZSwgZWwpIHtcbiAgICB2YXIgJGNvdW50cnkgPSAkKGVsKS5jbG9zZXN0KCdmaWVsZHNldCcpLmZpbmQoJy5pbnB1dC1zZWxlY3QuY291bnRyeScpO1xuXG4gICAgaWYgKHZhbHVlLmxlbmd0aCA8IDQpIHtyZXR1cm4gZmFsc2U7fVxuIFxuICAgIGlmKCRjb3VudHJ5Lmxlbmd0aCA9PT0gMCB8fCAkY291bnRyeS52YWwoKS5sZW5ndGggPT09IDAgfHwgIXJlZ2V4LnBvc3RhbFskY291bnRyeS52YWwoKS50b0xvd2VyQ2FzZSgpXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHJneCA9IHJlZ2V4LnBvc3RhbFskY291bnRyeS52YWwoKS50b0xvd2VyQ2FzZSgpXTtcbiAgICB2YXIgaXNWYWxpZCA9IHJneC50ZXN0KCQudHJpbSh2YWx1ZSkpO1xuXG4gICAgcmV0dXJuIGlzVmFsaWQ7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAZGVzY3JpcHRpb24gVmFsaWRhdGVzIHRoYXQgYSBjcmVkaXQgY2FyZCBvd25lciBpcyBub3QgYSBDcmVkaXQgY2FyZCBudW1iZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgb3duZXIgZmllbGQgd2hpY2ggd2lsbCBiZSB2YWxpZGF0ZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbCBUaGUgaW5wdXQgZmllbGRcbiAqL1xudmFyIHZhbGlkYXRlT3duZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgaXNWYWxpZCA9IHJlZ2V4Lm5vdENDLnRlc3QoJC50cmltKHZhbHVlKSk7XG4gICAgcmV0dXJuIGlzVmFsaWQ7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uIFZhbGlkYXRlcyBhIHJlY2lwaWVudCBjb25maXJtYXRpb24gZW1haWwgbWF0Y2hlcyByZWNpcGllbnQgZW1haWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgcmVjaXBpZW50IGNvbmZpcm1hdGlvbiBlbWFpbCB3aGljaCB3aWxsIGJlIHZhbGlkYXRlZFxuICogQHBhcmFtIHtTdHJpbmd9IGVsIFRoZSBpbnB1dCBmaWVsZFxuICovXG5mdW5jdGlvbiByZWNpcGllbnRFbWFpbENvbmZpcm0odmFsdWUsIGVsKSB7XG4gICAgdmFyIGlzT3B0aW9uYWwgPSB0aGlzLm9wdGlvbmFsKGVsKTtcbiAgICB2YXIgcmVjaXBpZW50RW1haWwgPSAkKCdpbnB1dFtuYW1lPVwidmdjUmVjaXBpZW50RW1haWxcIl0nKTtcbiAgICB2YXIgaXNWYWxpZCA9ICggcmVnZXguZW1haWwudGVzdCgkLnRyaW0odmFsdWUpKSAmJiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSByZWNpcGllbnRFbWFpbC52YWwoKS50b0xvd2VyQ2FzZSgpICk7XG4gICAgcmV0dXJuIGlzT3B0aW9uYWwgfHwgaXNWYWxpZDtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVHaWZ0TXNnKHZhbHVlLCBlbCkge1xuICAgIHZhciBpc09wdGlvbmFsID0gdGhpcy5vcHRpb25hbChlbCk7XG4gICAgdmFyIGlzVmFsaWQgPSAoIHJlZ2V4LmNoYXJfcmFuZ2UudGVzdCgkLnRyaW0odmFsdWUpKSApO1xuICAgIHJldHVybiBpc09wdGlvbmFsIHx8IGlzVmFsaWQ7XG59XG5cbmZ1bmN0aW9uIGNvbmZpcm1QYXNzd29yZCh2YWx1ZSwgZWwpIHtcbiAgICB2YXIgaXNPcHRpb25hbCA9IHRoaXMub3B0aW9uYWwoZWwpO1xuICAgIHZhciBmb3JtID0gJChlbCkuY2xvc2VzdCgnZm9ybScpO1xuICAgIHZhciBwYXNzd29yZEZpZWxkID0gZm9ybS5maW5kKCdpbnB1dC5wYXNzd29yZCcpO1xuICAgIHZhciBpc1ZhbGlkID0gZmFsc2U7XG4gICAgaWYocGFzc3dvcmRGaWVsZC5sZW5ndGggPiAwKSBpc1ZhbGlkID0gKHZhbHVlID09IHBhc3N3b3JkRmllbGQudmFsKCkpO1xuICAgIHJldHVybiBpc09wdGlvbmFsIHx8IGlzVmFsaWQ7XG59XG5cbnZhciB2YWxpZGF0ZUdpZnRSZWdpc3RyeUV2ZW50RGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyBcblx0XHQvLyBHZXQgZGF0ZSBmcm9tIGZvcm0gZmllbGQgaW5wdXRcblx0dmFyIG1vbnRoID0gcGFyc2VJbnQodmFsdWUuc3Vic3RyaW5nKDAsIDIpKTtcblx0dmFyIGRheSA9IHBhcnNlSW50KHZhbHVlLnN1YnN0cmluZyg1LCA3KSk7XG5cdHZhciB5ZWFyID0gcGFyc2VJbnQoXCIyMFwiK3BhcnNlSW50KHZhbHVlLnN1YnN0cmluZygxMCwgMTIpKSk7XG5cdFx0Ly8gQ3JlYXRlIG5ldyBkYXRlIG9iamVjdFxuXHR2YXIgZXZlbnREYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGgtMSwgZGF5KTtcblx0dmFyIGN1cnJlbnREYXRlID0gbmV3IERhdGUoKTtcblx0XHQvLyBNYWtlIHN1cmUgZXZlbnQgZGF0ZSBpcyBwYXN0IGN1cnJlbnQgZGF0ZVxuXHRpZih2YWx1ZS5sZW5ndGggPT0gMTIgJiYgKGV2ZW50RGF0ZSA+PSBjdXJyZW50RGF0ZSkpIHtcblx0XHQkKCcjZHdmcm1fZ2lmdHJlZ2lzdHJ5X2V2ZW50X2RhdGUnKS52YWwobW9udGggKyAnIC8gJyArIGRheSArICcgLyAnICsgeWVhcik7IFxuXHRcdHJldHVybiB0cnVlO1xuXHR9IFxuXHRlbHNlIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbmZ1bmN0aW9uIGNvbXBhcmVQYXNzd29yZCh2YWx1ZSkge1xuICAgIHJldHVybiAkKCcuaW5wdXQtdGV4dC5wYXNzd29yZCcpLnZhbCgpID09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNDKHZhbHVlLCBlbCkge1xuXHQvL2lmIGNjIG51bWJlciBoYXMgKiBpbiBpdCwgaXQgaXMgYSBzYXZlZCBjYXJkIGFuZCBkb2VzIG5vdCBuZWVkIHRvIGJlIHZhbGlkYXRlZFxuXHRpZih2YWx1ZS5pbmRleE9mKCcqKioqJykgPT0gLTEpe1xuXHQgICAgdmFyIGlzT3B0aW9uYWwgPSB0aGlzLm9wdGlvbmFsKGVsKTtcblx0ICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxzKy9nLCAnJyk7XG5cdCAgICBpZiAodmFsdWUubGVuZ3RoIDwgMTMpIHtcblx0ICAgICAgICByZXR1cm4gaXNPcHRpb25hbCB8fCBmYWxzZTtcblx0ICAgIH1cblx0ICAgIGlmICgvXig1WzEtNV18MlsyLTddWzAtOV0pLy50ZXN0KHZhbHVlKSB8fCAvXjQvLnRlc3QodmFsdWUpIHx8IC9eM1s0N10vLnRlc3QodmFsdWUpIHx8IC9eNig/OjAxMXw1fDRbNC05XSkvLnRlc3QodmFsdWUpKSB7XG5cdCAgICAgICAgcmV0dXJuIGlzT3B0aW9uYWwgfHwgbHVobi52ZXJpZnkodmFsdWUpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gaXNPcHRpb25hbCB8fCBmYWxzZTtcblx0ICAgIH1cblx0fWVsc2V7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVNaXNzaW5nQ0NFeHBpcmF0aW9uRGF0ZSAodmFsdWUpIHtcbiAgICB2YXIgeWVhckRhdGEgPSAgdmFsdWUuc3Vic3RyKDQsIDMpO1xuICAgIHZhciBtb250aERhdGEgPSB2YWx1ZS5zdWJzdHIoMCwgMik7XG4gICAgeWVhckRhdGEgPSAnMjAnK3BhcnNlSW50KHllYXJEYXRhKTtcbiAgICBpZiAoeWVhckRhdGEubGVuZ3RoID09IDQgJiYgcGFyc2VJbnQobW9udGhEYXRhKSA+IDAgJiYgcGFyc2VJbnQobW9udGhEYXRhKSA8IDEzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG59XG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDQ0V4cGlyYXRpb25EYXRlICh2YWx1ZSkge1xuICAgIHZhciB5ZWFyRGF0YSA9ICB2YWx1ZS5zdWJzdHIoNCwgMyk7XG4gICAgdmFyIG1vbnRoRGF0YSA9IHZhbHVlLnN1YnN0cigwLCAyKTtcbiAgICB2YXIgY3VycmVudFllYXIgPSAgbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuICAgIHZhciBjdXJyZW50TW9udGggPSBuZXcgRGF0ZSgpLmdldE1vbnRoKCkrMTtcbiAgICB2YXIgYWxsb3dZZWFyID0gY3VycmVudFllYXIgKyA5O1xuICAgIHllYXJEYXRhID0gJzIwJytwYXJzZUludCh5ZWFyRGF0YSk7XG4gICAgaWYgKCAoeWVhckRhdGEgPT0gY3VycmVudFllYXIgJiYgbW9udGhEYXRhID49IGN1cnJlbnRNb250aCkgfHwgKHllYXJEYXRhIDw9IGFsbG93WWVhciAmJiB5ZWFyRGF0YSA+IGN1cnJlbnRZZWFyKSApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxufVxuXG52YXIgbHVobiA9IHtcbiAgICB2ZXJpZnk6IGZ1bmN0aW9uKGRpZ2l0cykge1xuICAgICAgICB2YXIgc3VtID0gdGhpcy5zdW0oZGlnaXRzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHN1bSA+IDAgJiYgc3VtICUgMTAgPT09IDA7XG4gICAgfSxcbiAgICBzdW06IGZ1bmN0aW9uKGRpZ2l0cywgZXZlbikge1xuICAgICAgICB2YXIgc3VtID0gMCxcbiAgICAgICAgICBkaWdpdCA9IDAsXG4gICAgICAgICAgaSA9IGRpZ2l0cy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgZGlnaXQgPSBOdW1iZXIoZGlnaXRzW2ldKTtcbiAgICAgICAgICAgIHN1bSArPSAoZXZlbiA9ICFldmVuKSA/IHRoaXMuY29tcHV0ZWRbZGlnaXRdIDogZGlnaXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IFswLCAyLCA0LCA2LCA4LCAxLCAzLCA1LCA3LCA5XVxufTtcblxuLyoqXG4gKiBBZGQgcGFzc3dvcmQgY29tcGFyaXNzb24gbWV0aG9kIHRvIGpRdWVyeSB2YWxpZGF0aW9uIHBsdWdpbi5cbiAqIFRleHQgZmllbGRzIG11c3QgaGF2ZSAnY3JlZGl0Y2FyZCcgY3NzIGNsYXNzIHRvIGJlIHZhbGlkYXRlZCBhcyBlbWFpbFxuICovXG4kLnZhbGlkYXRvci5hZGRNZXRob2QoXCJwYXNzd29yZGNvbmZpcm1cIiwgY29tcGFyZVBhc3N3b3JkLCBSZXNvdXJjZXMuVkFMSURBVEVfSU5WQUxJRF9QQVNTTUFUQ0gpO1xuXG4vKipcbiAqIEFkZCBjcmVkaXQgY2FyZCBleHBpcmF0aW9uIGRhdGUgdmFsaWRhdGlvbiBtZXRob2QgdG8galF1ZXJ5IHZhbGlkYXRpb24gcGx1Z2luLlxuICogVGV4dCBmaWVsZHMgbXVzdCBoYXZlICdjcmVkaXRjYXJkJyBjc3MgY2xhc3MgdG8gYmUgdmFsaWRhdGVkIGFzIGVtYWlsXG4gKi9cbiQudmFsaWRhdG9yLmFkZE1ldGhvZChcImNjLW1pc3NpbmctZXhwaXJhdGlvblwiLCB2YWxpZGF0ZU1pc3NpbmdDQ0V4cGlyYXRpb25EYXRlLCBSZXNvdXJjZXMuTUlTU0lOR19FWFBJUkFUSU9OKTtcblxuLyoqXG4gKiBBZGQgY3JlZGl0IGNhcmQgZXhwaXJhdGlvbiBkYXRlIHZhbGlkYXRpb24gbWV0aG9kIHRvIGpRdWVyeSB2YWxpZGF0aW9uIHBsdWdpbi5cbiAqIFRleHQgZmllbGRzIG11c3QgaGF2ZSAnY3JlZGl0Y2FyZCcgY3NzIGNsYXNzIHRvIGJlIHZhbGlkYXRlZCBhcyBlbWFpbFxuICovXG4kLnZhbGlkYXRvci5hZGRNZXRob2QoXCJjYy12YWxpZC1leHBpcmF0aW9uXCIsIHZhbGlkYXRlQ0NFeHBpcmF0aW9uRGF0ZSwgUmVzb3VyY2VzLklOVkFMSURfRVhQSVJBVElPTik7XG5cbi8qKlxuICogQWRkIGNyZWRpdCBjYXJkIHZhbGlkYXRpb24gbWV0aG9kIHRvIGpRdWVyeSB2YWxpZGF0aW9uIHBsdWdpbi5cbiAqIFRleHQgZmllbGRzIG11c3QgaGF2ZSAnY3JlZGl0Y2FyZCcgY3NzIGNsYXNzIHRvIGJlIHZhbGlkYXRlZCBhcyBlbWFpbFxuICovXG4kLnZhbGlkYXRvci5hZGRNZXRob2QoXCJjcmVkaXQtY2FyZC1udW1iZXJcIiwgdmFsaWRhdGVDQywgUmVzb3VyY2VzLlZBTElEQVRFX05VTUJFUik7XG5cbi8qKlxuICogdmFsaWRhdGVHaWZ0UmVnaXN0cnlFdmVudERhdGUgdmVyaWZpZXMgdGhlIGZpcnN0IHR3byBkaWdpdHMgYXJlIHRoZSBtb250aCwgdGhlIHRoaXJkIGFuZCBmb3VydGggZGlnaXQgaXMgYSBkYXlcbiAqL1xuJC52YWxpZGF0b3IuYWRkTWV0aG9kKCdkYXRlbm90aGlkZGVuJywgdmFsaWRhdGVHaWZ0UmVnaXN0cnlFdmVudERhdGUsIFJlc291cmNlcy5WQUxJREFURV9EQVRFKTtcblxuLyoqXG4gKiBBZGQgZW1haWwgYWRkcmVzcyB2YWxpZGF0aW9uIG1ldGhvZCB0byBqUXVlcnkgdmFsaWRhdGlvbiBwbHVnaW4uXG4gKiBUZXh0IGZpZWxkcyBtdXN0IGhhdmUgJ2VtYWlsJyBjc3MgY2xhc3MgdG8gYmUgdmFsaWRhdGVkIGFzIGVtYWlsIFxuICovXG4kLnZhbGlkYXRvci5hZGRNZXRob2QoXCJlbWFpbFwiLCB2YWxpZGF0ZUVtYWlsLCBSZXNvdXJjZXMuSU5WQUxJRF9FTUFJTCk7XG5cbi8qKlxuICogQWRkIHBvc3RhbCBjb2RlIHZhbGlkYXRpb24gbWV0aG9kIHRvIGpRdWVyeSB2YWxpZGF0aW9uIHBsdWdpbi5cbiAqIFRleHQgZmllbGRzIG11c3QgaGF2ZSAncG9zdGFsQWxsJyBjc3MgY2xhc3MgdG8gYmUgdmFsaWRhdGVkIGFzIHBvc3RhbCBjb2RlXG4gKi9cbiQudmFsaWRhdG9yLmFkZE1ldGhvZChcInBvc3RhbEFsbFwiLCB2YWxpZGF0ZUFsbFBvc3RhbCwgUmVzb3VyY2VzLklOVkFMSURfUE9TVEFMKTtcblxuLyoqXG4gKiBBZGQgcG9zdGFsIGNvZGUgdmFsaWRhdGlvbiBtZXRob2QgdG8galF1ZXJ5IHZhbGlkYXRpb24gcGx1Z2luLlxuICogVGV4dCBmaWVsZHMgbXVzdCBoYXZlICdwb3N0YWwnIGNzcyBjbGFzcyB0byBiZSB2YWxpZGF0ZWQgYXMgcG9zdGFsIGNvZGVcbiAqL1xuJC52YWxpZGF0b3IuYWRkTWV0aG9kKFwicG9zdGFsXCIsIHZhbGlkYXRlUG9zdGFsLCBSZXNvdXJjZXMuSU5WQUxJRF9QT1NUQUwpO1xuXG4vKipcbiAqIEFkZCBwaG9uZSB2YWxpZGF0aW9uIG1ldGhvZCB0byBqUXVlcnkgdmFsaWRhdGlvbiBwbHVnaW4uXG4gKiBUZXh0IGZpZWxkcyBtdXN0IGhhdmUgJ3Bob25lJyBjc3MgY2xhc3MgdG8gYmUgdmFsaWRhdGVkIGFzIHBob25lXG4gKi9cbiQudmFsaWRhdG9yLmFkZE1ldGhvZCgncGhvbmUnLCB2YWxpZGF0ZVBob25lLCBSZXNvdXJjZXMuSU5WQUxJRF9QSE9ORSk7XG5cbi8qKlxuICogQWRkIENDT3duZXIgdmFsaWRhdGlvbiBtZXRob2QgdG8galF1ZXJ5IHZhbGlkYXRpb24gcGx1Z2luLlxuICogVGV4dCBmaWVsZHMgbXVzdCBoYXZlICdvd25lcicgY3NzIGNsYXNzIHRvIGJlIHZhbGlkYXRlZCBhcyBub3QgYSBjcmVkaXQgY2FyZFxuICovXG4kLnZhbGlkYXRvci5hZGRNZXRob2QoJ293bmVyJywgdmFsaWRhdGVPd25lciwgUmVzb3VyY2VzLklOVkFMSURfT1dORVIpO1xuXG4vKipcbiAqIEFkZCBnaWZ0IGNlcnQgYW1vdW50IHZhbGlkYXRpb24gbWV0aG9kIHRvIGpRdWVyeSB2YWxpZGF0aW9uIHBsdWdpbi5cbiAqIFRleHQgZmllbGRzIG11c3QgaGF2ZSAnZ2lmdC1jZXJ0LWFtb250JyBjc3MgY2xhc3MgdG8gYmUgdmFsaWRhdGVkXG4gKi9cbiQudmFsaWRhdG9yLmFkZE1ldGhvZCgnZ2lmdC1jZXJ0LWFtb3VudCcsIGZ1bmN0aW9uICh2YWx1ZSwgZWwpIHtcbiAgICB2YXIgaXNPcHRpb25hbCA9IHRoaXMub3B0aW9uYWwoZWwpO1xuICAgIHZhciBpc1ZhbGlkID0gKCFpc05hTih2YWx1ZSkpICYmIChwYXJzZUZsb2F0KHZhbHVlKSA+PSA1KSAmJiAocGFyc2VGbG9hdCh2YWx1ZSkgPD0gNTAwMCk7XG4gICAgcmV0dXJuIGlzT3B0aW9uYWwgfHwgaXNWYWxpZDtcbn0sIFJlc291cmNlcy5HSUZUX0NFUlRfQU1PVU5UX0lOVkFMSUQpO1xuXG4vKipcbiAqIEFkZCBnaWZ0IG1lc3NhZ2UgdmFsaWRhdGlvblxuICovXG4kLnZhbGlkYXRvci5hZGRNZXRob2QoJ2dpZnQtbWVzc2FnZS1jaGFycycsIHZhbGlkYXRlR2lmdE1zZywgUmVzb3VyY2VzLlZBTElEQVRFX0NIQVJSQU5HRSk7XG5cbi8qKlxuICogQWRkIHBvc2l0aXZlIG51bWJlciB2YWxpZGF0aW9uIG1ldGhvZCB0byBqUXVlcnkgdmFsaWRhdGlvbiBwbHVnaW4uXG4gKiBUZXh0IGZpZWxkcyBtdXN0IGhhdmUgJ3Bvc2l0aXZlbnVtYmVyJyBjc3MgY2xhc3MgdG8gYmUgdmFsaWRhdGVkIGFzIHBvc2l0aXZlbnVtYmVyXG4gKi9cbiQudmFsaWRhdG9yLmFkZE1ldGhvZCgncG9zaXRpdmVudW1iZXInLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoJC50cmltKHZhbHVlKS5sZW5ndGggPT09IDApIHsgcmV0dXJuIHRydWU7IH1cbiAgICByZXR1cm4gKCFpc05hTih2YWx1ZSkgJiYgTnVtYmVyKHZhbHVlKSA+PSAwKTtcbn0sICcnKTsgLy8gJycgc2hvdWxkIGJlIHJlcGxhY2VkIHdpdGggZXJyb3IgbWVzc2FnZSBpZiBuZWVkZWRcblxuJC52YWxpZGF0b3IuYWRkTWV0aG9kKFwicmVjaXBpZW50LWVtYWlsLWNvbmZpcm1cIiwgcmVjaXBpZW50RW1haWxDb25maXJtLCBSZXNvdXJjZXMuVkFMSURBVEVfSU5WQUxJRF9FTUFJTE1BVENIKTtcblxuLyoqXG4gKiBBZGQgcGFzc3dvcmQgY29uZmlybSB2YWxpZGF0aW9uIG1ldGhvZCB0byBqUXVlcnkgdmFsaWRhdGlvbiBwbHVnaW4uXG4gKiBUZXh0IGZpZWxkcyBtdXN0IGhhdmUgJ3Bhc3N3b3JkY29uZmlybScgY3NzIGNsYXNzIHRvIGJlIHZhbGlkYXRlZCBhcyBwYXNzd29yZFxuICovXG4kLnZhbGlkYXRvci5hZGRNZXRob2QoXCJwYXNzd29yZGNvbmZpcm1cIiwgY29uZmlybVBhc3N3b3JkLCBSZXNvdXJjZXMuSU5WQUxJRF9QQVNTV09SRE1BVENIKTtcblxuJC5leHRlbmQoJC52YWxpZGF0b3IubWVzc2FnZXMsIHtcbiAgICByZXF1aXJlZDogUmVzb3VyY2VzLlZBTElEQVRFX1JFUVVJUkVELFxuICAgIHJlbW90ZTogUmVzb3VyY2VzLlZBTElEQVRFX1JFTU9URSxcbiAgICBlbWFpbDogUmVzb3VyY2VzLlZBTElEQVRFX0VNQUlMLFxuICAgIHVybDogUmVzb3VyY2VzLlZBTElEQVRFX1VSTCxcbiAgICBkYXRlOiBSZXNvdXJjZXMuVkFMSURBVEVfREFURSxcbiAgICBkYXRlSVNPOiBSZXNvdXJjZXMuVkFMSURBVEVfREFURUlTTyxcbiAgICBudW1iZXI6IFJlc291cmNlcy5WQUxJREFURV9OVU1CRVIsXG4gICAgZGlnaXRzOiBSZXNvdXJjZXMuVkFMSURBVEVfRElHSVRTLFxuICAgIGNyZWRpdGNhcmQ6IFJlc291cmNlcy5WQUxJREFURV9DUkVESVRDQVJELFxuICAgIGVxdWFsVG86IFJlc291cmNlcy5WQUxJREFURV9FUVVBTFRPLFxuICAgIG1heGxlbmd0aDogJC52YWxpZGF0b3IuZm9ybWF0KFJlc291cmNlcy5WQUxJREFURV9NQVhMRU5HVEgpLFxuICAgIG1pbmxlbmd0aDogJC52YWxpZGF0b3IuZm9ybWF0KFJlc291cmNlcy5WQUxJREFURV9NSU5MRU5HVEgpLFxuICAgIHJhbmdlbGVuZ3RoOiAkLnZhbGlkYXRvci5mb3JtYXQoUmVzb3VyY2VzLlZBTElEQVRFX1JBTkdFTEVOR1RIKSxcbiAgICByYW5nZTogJC52YWxpZGF0b3IuZm9ybWF0KFJlc291cmNlcy5WQUxJREFURV9SQU5HRSksXG4gICAgbWF4OiAkLnZhbGlkYXRvci5mb3JtYXQoUmVzb3VyY2VzLlZBTElEQVRFX01BWCksXG4gICAgbWluOiAkLnZhbGlkYXRvci5mb3JtYXQoUmVzb3VyY2VzLlZBTElEQVRFX01JTilcbn0pO1xuXG52YXIgdmFsaWRhdG9yID0ge1xuICAgIHJlZ2V4OiByZWdleCxcbiAgICBzZXR0aW5nczogc2V0dGluZ3MsXG4gICAgZm9ybWF0dGVyOiBmb3JtYXR0ZXIsXG4gICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICQoJ2Zvcm06bm90KC5zdXBwcmVzcyknKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3JtcyBoYXZpbmcgcmVxdWlyZWQgaW5wdXQgZmllbGRzIHdpdGggZGF0YS1yZXF1aXJlZC10ZXh0PScnIGF0dHJpYnV0ZSwgY3JlYXRlIGN1c3RvbWl6ZWQgZXJyb3IgbWVzc2FnZXMgZm9yIGNsaWVudHNpZGUgZm9ybSB2YWxpZGF0aW9uXG4gICAgICAgICAgICBpZiAoJCh0aGlzKS5maW5kKCdpbnB1dFtkYXRhLXJlcXVpcmVkLXRleHRdLnJlcXVpcmVkLCBzZWxlY3RbZGF0YS1yZXF1aXJlZC10ZXh0XS5yZXF1aXJlZCcpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyBtZXNzYWdlcyBvYmplY3QgZm9yIHZhbGlkYXRlIHNldHRpbmdzXG4gICAgICAgICAgICAgICAgc2VsZi5zZXR0aW5ncy5tZXNzYWdlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAvLyBMb29wIHRocnUgZWFjaCByZXF1aXJlZCBmaWVsZCB0byBleHRyYWN0IHRoZSBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgJCh0aGlzKS5maW5kKCdpbnB1dFtkYXRhLXJlcXVpcmVkLXRleHRdLnJlcXVpcmVkJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXR0aW5ncy5tZXNzYWdlc1sgJCh0aGlzKS5hdHRyKCdpZCcpIF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAncmVxdWlyZWQnOiAkKHRoaXMpLmRhdGEoJ3JlcXVpcmVkLXRleHQnKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkKHRoaXMpLnZhbGlkYXRlKHNlbGYuc2V0dGluZ3MpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGluaXRGb3JtOiBmdW5jdGlvbiAoZiwgc2V0dGluZ3MpIHtcbiAgICAgICAgJChmKS52YWxpZGF0ZShzZXR0aW5ncyAhPSBudWxsID8gc2V0dGluZ3MgOiB0aGlzLnNldHRpbmdzKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkYXRvcjtcbiJdfQ==
